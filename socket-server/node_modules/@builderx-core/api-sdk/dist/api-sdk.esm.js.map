{"version":3,"file":"api-sdk.esm.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/apiService.ts","../src/realtimeIO.ts","../src/helper.ts","../src/config.ts","../src/apiSdk.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import axiosService, { AxiosInstance } from \"axios\";\nimport get from \"lodash.get\";\n\nexport default class ApiService {\n  API_URL!: string;\n  authToken: string | undefined;\n  axios!: AxiosInstance;\n\n  createService(authToken: string | undefined, API_URL: string): void {\n    this.API_URL = API_URL;\n    const headers: any = {};\n    if (authToken) {\n      headers[\"X-BuilderX-Auth-Token\"] = authToken;\n      this.authToken = authToken;\n    }\n    try {\n      this.axios = axiosService.create({\n        baseURL: this.API_URL,\n        headers: headers,\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  get = (\n    endPoint: string,\n    params?: { [key: string]: any },\n    config?: { [key: string]: any }\n  ): Promise<any> => {\n    return new Promise((resolve, reject) => {\n      if (!this.axios) {\n        reject(\"Couldn't create service\");\n      }\n      this.axios\n        .get(endPoint, {\n          params,\n          ...config,\n        })\n        .then(response => {\n          resolve(response);\n        })\n        .catch(error => {\n          reject(error);\n        });\n    });\n  };\n\n  getOne = (endPoint: string, key: string, config?: { [key: string]: any }) => {\n    return new Promise((resolve, reject) => {\n      if (!this.axios) {\n        reject(new Error(\"Couldn't create service\"));\n      }\n      this.axios\n        .get(`${endPoint}/${key}`, config)\n        .then(response => {\n          resolve(response);\n        })\n        .catch(error => {\n          reject(error);\n        });\n    });\n  };\n\n  post = (\n    endPoint: string,\n    params?: { [key: string]: any },\n    config?: { [key: string]: any }\n  ) => {\n    return new Promise((resolve, reject) => {\n      if (!this.axios) {\n        reject(new Error(\"Couldn't create service\"));\n      }\n      this.axios\n        .post(endPoint, params, {\n          ...config,\n        })\n        .then(response => {\n          resolve(response);\n        })\n        .catch(error => {\n          if (get(error, \"response.status\") === 401) {\n            reject(error);\n          }\n          reject(error);\n        });\n    });\n  };\n\n  put = (\n    endPoint: string,\n    params?: { [key: string]: any },\n    config?: { [key: string]: any }\n  ) => {\n    return new Promise((resolve, reject) => {\n      if (!this.axios) {\n        reject(new Error(\"Couldn't create service\"));\n      }\n      this.axios\n        .put(endPoint, params, {\n          ...config,\n        })\n        .then(response => {\n          resolve(response);\n        })\n        .catch(error => {\n          reject(error);\n        });\n    });\n  };\n\n  patch = (\n    endPoint: string,\n    params?: { [key: string]: any },\n    config?: { [key: string]: any }\n  ) => {\n    return new Promise((resolve, reject) => {\n      if (!this.axios) {\n        reject(new Error(\"Couldn't create service\"));\n      }\n      this.axios\n        .patch(endPoint, params, {\n          ...config,\n        })\n        .then(response => {\n          resolve(response);\n        })\n        .catch(error => {\n          reject(error);\n        });\n    });\n  };\n\n  delete = (endPoint: string, config?: { [key: string]: any }) => {\n    return new Promise((resolve, reject) => {\n      if (!this.axios) {\n        reject(new Error(\"Couldn't create service\"));\n      }\n      this.axios\n        .delete(endPoint, {\n          ...config,\n        })\n        .then(response => {\n          resolve(response);\n        })\n        .catch(error => {\n          reject(error);\n        });\n    });\n  };\n}\n","import axios from \"axios\";\n\nexport default class RealtimeIO {\n  static ioInstance: any;\n\n  url: string;\n  config: any;\n  headers: any;\n  eventListenersMap: Map<string, Array<any>> = new Map();\n\n  public static connect(url: string, config: any, headers: any): RealtimeIO {\n    let instance: RealtimeIO;\n    if (RealtimeIO.ioInstance) {\n      instance = RealtimeIO.ioInstance;\n    } else {\n      instance = new RealtimeIO(url, config, headers);\n      axios\n        .post(url, config, headers)\n        .then(response => {\n          instance.emit(\"connect\", response);\n          instance.poll();\n        })\n        .catch(Error => {\n          instance.emit(\"connection-failed\", Error);\n          instance.poll();\n        });\n    }\n    return instance;\n  }\n\n  constructor(url: string, config: any, headers: any) {\n    this.url = url;\n    this.config = config;\n    this.headers = headers;\n  }\n\n  private poll() {\n    axios\n      .post(this.url, this.config, this.headers)\n      .then(response => {\n        this.emit(\"poll\", response);\n        setTimeout(() => {\n          this.poll();\n        }, 10000);\n      })\n      .catch(() => {\n        this.emit(\"connection-failed\");\n        setTimeout(() => {\n          this.poll();\n        }, 20000);\n      });\n  }\n\n  emit(property: string, data?: any) {\n    const arrayOfListener: any = this.eventListenersMap.get(property);\n    if (arrayOfListener) {\n      arrayOfListener.forEach((listner: any) => {\n        if (listner) {\n          listner(data);\n        }\n      });\n    }\n  }\n\n  on(property: string, listener: any) {\n    const existingArrOfListeners = this.eventListenersMap.get(property);\n    if (existingArrOfListeners) {\n      existingArrOfListeners.push(listener);\n    } else {\n      this.eventListenersMap.set(property, [listener]);\n    }\n  }\n}\n","import get from \"lodash.get\";\n\nconst transformResponse = (response: any) => {\n  return {\n    data: response.data ? response.data : { ...response },\n    message: response.message ? response.message : \"Successfull\",\n    status: response.status,\n    headers: response.headers ? response.headers : {},\n  };\n};\n\nconst errorHandler = (error: any, resolve: any, reject: any) => {\n  const responseStatus = get(error, \"response.status\");\n  if (responseStatus && responseStatus === 401) {\n    resolve(false);\n  } else {\n    reject(error);\n  }\n};\n\nconst transformShareability = (response: any) => {\n  return {\n    data: response.data\n      ? response.data.data\n        ? response.data.data\n        : response.data\n      : { ...response },\n    message: response.data.message ? response.data.message : \"Successfull\",\n    status: response.status,\n    headers: response.headers ? response.headers : {},\n  };\n};\n\nexport { transformResponse, transformShareability, errorHandler };\n","import jsCookie from \"js-cookie\";\n\nexport default {\n  env: \"local\",\n  baseUrl: \"https://pre-cloud.builderx.io/api/\",\n  accessToken: jsCookie.get(\"access-token\"),\n  googleFontsUrl: \"https://www.googleapis.com/webfonts/v1/webfonts?key=\",\n  localFontsUrl: \"http://localhost:8979\",\n};\n","import ApiService from \"./apiService\";\nimport RealtimeIO from \"./realtimeIO\";\nimport axios from \"axios\";\nimport APIResponse, {\n  Auth,\n  Project,\n  ProjectShareability,\n  File,\n  User,\n  FileContent,\n  Team,\n} from \"./interfaces\";\nimport {\n  errorHandler,\n  transformResponse,\n  transformShareability,\n} from \"./helper\";\nimport defaultConfig from \"./config\";\n\ninterface Config {\n  env?: string;\n  baseUrl?: string;\n  accessToken?: string;\n  googleFontsUrl?: string;\n  localFontsUrl?: string;\n}\n\nclass ApiSdk {\n  apiService: ApiService = new ApiService();\n  config: Config = {\n    ...defaultConfig,\n  };\n\n  init(config: Config): void {\n    this.config = { ...this.config, ...config };\n    this.apiService.createService(\n      this.config.accessToken,\n      this.config.baseUrl || defaultConfig.baseUrl\n    ); // TODO: INstead of passing multiple params, pass `this` (instance of ApiSdk) to apiService\n  }\n\n  async auth(): Promise<APIResponse<Auth>> {\n    return new Promise(async (resolve, reject) => {\n      try {\n        if (this.apiService) {\n          const response = await this.apiService.get(`get-my-id`);\n          if (response.data.id) {\n            const result = transformResponse(response);\n            resolve(result);\n          } else {\n            reject(\"Not Authenticated\");\n          }\n        }\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  project = {\n    get: async (\n      projectId: string,\n      connectionId?: string\n    ): Promise<APIResponse<Project>> => {\n      return new Promise(async (resolve, reject) => {\n        try {\n          if (this.apiService) {\n            const response = await this.apiService.get(\n              `projects/${projectId}`,\n              { connectionId: connectionId }\n            );\n            const result = transformResponse(response);\n            resolve(result);\n          }\n        } catch (error) {\n          errorHandler(error, resolve, reject);\n        }\n      });\n    },\n    post: async (name: string): Promise<APIResponse<Project>> => {\n      return new Promise(async (resolve, reject) => {\n        try {\n          if (this.apiService) {\n            const response = await this.apiService.post(\n              \"projects\",\n              { name },\n              { headers: { \"content-type\": \"application/json\" } }\n            );\n            const result = transformResponse(response);\n            resolve(result);\n          }\n        } catch (error) {\n          errorHandler(error, resolve, reject);\n        }\n      });\n    },\n    update: async (\n      projectId: string,\n      key: string,\n      value: any\n    ): Promise<APIResponse<Project>> => {\n      return new Promise(async (resolve, reject) => {\n        try {\n          if (this.apiService) {\n            const response = await this.apiService.put(\n              `projects/${projectId}`,\n              { [key]: value }\n            );\n            const result = transformResponse(response);\n            resolve(result);\n          }\n        } catch (error) {\n          errorHandler(error, resolve, reject);\n        }\n      });\n    },\n    clone: async (\n      projectId: string,\n      params?: { [key: string]: any }\n    ): Promise<any> => {\n      return new Promise(async (resolve, reject) => {\n        try {\n          if (this.apiService) {\n            const response = await this.apiService.get(\n              `/project-clone/${projectId}`,\n              params\n            );\n            const result = transformResponse(response);\n            resolve(result);\n          }\n        } catch (error) {\n          errorHandler(error, resolve, reject);\n        }\n      });\n    },\n    shareability: async (\n      project_id: string,\n      type: string,\n      access: string,\n      email?: string,\n      mode?: string\n    ): Promise<APIResponse<ProjectShareability>> => {\n      return new Promise(async (resolve, reject) => {\n        try {\n          if (this.apiService) {\n            const response = await this.apiService.post(\n              \"projects-shareability\",\n              { project_id, type, access, email, mode }\n            );\n            const result = transformShareability(response);\n            resolve(result);\n          }\n        } catch (error) {\n          errorHandler(error, resolve, reject);\n        }\n      });\n    },\n  };\n\n  files = {\n    get: async (\n      name: string = \"\",\n      projectId?: string\n    ): Promise<APIResponse<File>> => {\n      return new Promise(async (resolve, reject) => {\n        try {\n          if (this.apiService) {\n            const response = await this.apiService.get(\"files\", {\n              name,\n              projectId,\n            });\n            const result = transformShareability(response);\n            resolve(result);\n          }\n        } catch (error) {\n          errorHandler(error, resolve, reject);\n        }\n      });\n    },\n    delete: async (\n      dbFileId: string,\n      connectionId: string = \"\"\n    ): Promise<any> => {\n      return new Promise(async (resolve, reject) => {\n        try {\n          if (this.apiService) {\n            const response = await this.apiService.delete(\n              `files/${dbFileId}?connectionId=${connectionId}`\n            );\n            resolve(response);\n          }\n        } catch (error) {\n          errorHandler(error, resolve, reject);\n        }\n      });\n    },\n    patch: async (dbFileId: string): Promise<any> => {\n      return new Promise(async (resolve, reject) => {\n        try {\n          if (this.apiService) {\n            const response = await this.apiService.patch(`files/${dbFileId}`, {\n              deleted_at: \"1\",\n            });\n            resolve(response);\n          }\n        } catch (error) {\n          errorHandler(error, resolve, reject);\n        }\n      });\n    },\n    exists: async (projectId: string, filePath: string): Promise<any> => {\n      return new Promise(async (resolve, reject) => {\n        try {\n          if (this.apiService) {\n            const response = await this.apiService.get(\n              `get-file-content/${projectId}?fileName=${filePath}`\n            );\n            resolve(response);\n          }\n        } catch (error) {\n          errorHandler(error, resolve, reject);\n        }\n      });\n    },\n  };\n\n  projectLog = {\n    post: async (domainJSON: string): Promise<any> => {\n      return new Promise(async (resolve, reject) => {\n        try {\n          if (this.apiService) {\n            const response = await this.apiService.post(\"projects/log\", {\n              data: JSON.parse(domainJSON),\n            });\n            resolve(response);\n          }\n        } catch (error) {\n          errorHandler(error, resolve, reject);\n        }\n      });\n    },\n  };\n\n  fileContent = {\n    get: async (fileId?: string): Promise<any> => {\n      return new Promise(async (resolve, reject) => {\n        try {\n          if (this.apiService) {\n            const response = await this.apiService.get(\"file-content\", {\n              fileId,\n            });\n            resolve(response);\n          }\n        } catch (error) {\n          errorHandler(error, resolve, reject);\n        }\n      });\n    },\n    post: async (\n      params?: { [key: string]: any },\n      config?: { [key: string]: any }\n    ): Promise<APIResponse<FileContent>> => {\n      return new Promise(async (resolve, reject) => {\n        try {\n          if (this.apiService) {\n            const response = await this.apiService.post(\n              \"file-content\",\n              params,\n              config\n            );\n            const result = transformResponse(response);\n            resolve(result);\n          }\n        } catch (error) {\n          errorHandler(error, resolve, reject);\n        }\n      });\n    },\n  };\n\n  user = {\n    get: async (userId: string): Promise<APIResponse<User>> => {\n      return new Promise(async (resolve, reject) => {\n        try {\n          if (this.apiService) {\n            const response = await this.apiService.get(`users/${userId}`);\n            const result = transformResponse(response);\n            resolve(result);\n          }\n        } catch (error) {\n          errorHandler(error, resolve, reject);\n        }\n      });\n    },\n    patch: async (\n      userId: string,\n      params?: { [key: string]: any },\n      config?: { [key: string]: any }\n    ): Promise<any> => {\n      return new Promise(async (resolve, reject) => {\n        try {\n          if (this.apiService) {\n            const response = await this.apiService.patch(\n              `users/${userId}`,\n              params,\n              config\n            );\n            resolve(response);\n          }\n        } catch (error) {\n          errorHandler(error, resolve, reject);\n        }\n      });\n    },\n  };\n\n  teams = {\n    get: async (\n      teamId: string,\n      params?: { [key: string]: any }\n    ): Promise<APIResponse<Team>> => {\n      return new Promise(async (resolve, reject) => {\n        try {\n          if (this.apiService) {\n            const response = await this.apiService.get(\n              `settings/teams/json/${teamId}`,\n              params\n            );\n            const result = transformResponse(response);\n            resolve(result);\n          }\n        } catch (error) {\n          errorHandler(error, resolve, reject);\n        }\n      });\n    },\n  };\n\n  poll = {\n    connect: (url: string, config: any, headers: any): RealtimeIO => {\n      return RealtimeIO.connect(url, config, headers);\n    },\n  };\n\n  raw = {\n    getBlob: async (\n      path: string,\n      params?: { [key: string]: any }\n    ): Promise<any> => {\n      return new Promise(async (resolve, reject) => {\n        try {\n          const response = await axios.get(path, params);\n          resolve(response);\n        } catch (error) {\n          errorHandler(error, resolve, reject);\n        }\n      });\n    },\n    checkPort: async (portNumber: number): Promise<any> => {\n      return new Promise(async (resolve, reject) => {\n        try {\n          const response = await axios.get(\n            `http://localhost:${portNumber}/checkPort` // TODO: get base url as config in init\n          );\n          resolve(response);\n        } catch (error) {\n          errorHandler(error, resolve, reject);\n        }\n      });\n    },\n  };\n\n  assets = {\n    getFont: async (\n      fontUrl: string,\n      path: string,\n      params?: { [key: string]: any }\n    ): Promise<any> => {\n      return new Promise(async (resolve, reject) => {\n        try {\n          const response = await axios.get(\n            `${fontUrl}getFont?id=` + path,\n            params\n          );\n          resolve(response);\n        } catch (error) {\n          errorHandler(error, resolve, reject);\n        }\n      });\n    },\n    getCloudImage: async (\n      cloudImagePath: string,\n      params?: { [key: string]: any }\n    ): Promise<any> => {\n      return new Promise(async (resolve, reject) => {\n        try {\n          const response = await axios.get(cloudImagePath, params);\n          resolve(response);\n        } catch (error) {\n          errorHandler(error, resolve, reject);\n        }\n      });\n    },\n    getGoogleFonts: async (BUILDERX_FONT_API_KEY: string): Promise<any> => {\n      return new Promise(async (resolve, reject) => {\n        try {\n          const response = await axios.get(\n            this.config.googleFontsUrl + BUILDERX_FONT_API_KEY\n          );\n          resolve(response);\n        } catch (error) {\n          errorHandler(error, resolve, reject);\n        }\n      });\n    },\n    fetchLocalFonts: async (): Promise<any> => {\n      return new Promise(async (resolve, reject) => {\n        try {\n          const response = await axios.get(\n            this.config.localFontsUrl || defaultConfig.localFontsUrl\n          );\n          resolve(response);\n        } catch (error) {\n          errorHandler(error, resolve, reject);\n        }\n      });\n    },\n    uploadAsset: async (\n      projectId: string,\n      filePath: string,\n      data: string | Blob,\n      connectionId: string = \"\",\n      type: \"image\" | \"font\"\n    ): Promise<any> => {\n      return new Promise(async (resolve, reject) => {\n        try {\n          const name = filePath;\n          const fileContentFormData = new FormData();\n          fileContentFormData.append(\"projectId\", projectId);\n          fileContentFormData.append(\"name\", name);\n          fileContentFormData.append(\"connectionId\", connectionId);\n          fileContentFormData.append(\"content\", data);\n          fileContentFormData.append(\"contentType\", type);\n          let headers = { \"content-type\": \"multipart/form-data\" };\n          this.fileContent\n            .post(fileContentFormData, { headers })\n            .then(res => {\n              resolve(res.data.fileId);\n            })\n            .catch(err => {\n              console.error(err, filePath, \"writeFile failed\");\n              reject(err);\n            });\n        } catch (error) {\n          reject(error);\n        }\n      });\n    },\n  };\n}\n\nconst apiSdk = new ApiSdk();\nexport { apiSdk, ApiSdk };\n"],"names":["ApiService","endPoint","params","config","Promise","resolve","reject","axios","get","then","response","error","key","Error","post","put","patch","createService","authToken","API_URL","headers","axiosService","create","baseURL","RealtimeIO","url","Map","connect","instance","ioInstance","emit","poll","setTimeout","property","data","arrayOfListener","eventListenersMap","forEach","listner","on","listener","existingArrOfListeners","push","set","transformResponse","message","status","errorHandler","responseStatus","transformShareability","env","baseUrl","accessToken","jsCookie","googleFontsUrl","localFontsUrl","ApiSdk","defaultConfig","projectId","connectionId","apiService","result","name","update","value","clone","shareability","project_id","type","access","email","mode","dbFileId","deleted_at","exists","filePath","domainJSON","JSON","parse","fileId","userId","teamId","getBlob","path","checkPort","portNumber","getFont","fontUrl","getCloudImage","cloudImagePath","getGoogleFonts","BUILDERX_FONT_API_KEY","fetchLocalFonts","uploadAsset","fileContentFormData","FormData","append","fileContent","res","err","console","init","auth","id","apiSdk"],"mappings":"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"}