'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var lodash = require('lodash');
var path = require('path');
var pascalCase$8 = _interopDefault(require('pascal-case'));
var prettier = _interopDefault(require('prettier/standalone'));
var prettierBabylon = _interopDefault(require('prettier/parser-babylon'));

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var switchHighestNumber = 0;
var mapHighestNumber = 0;
var hasButtonLayer = false;
var generateChildren = function generateChildren(layer, generateChildCallback, extraParams) {
  var childrenCode = '';
  layer.children.forEach(function (child) {
    if (['expressionStatement', 'binaryExpression', 'expression', 'conditionalExpression', 'logicalExpression'].includes(child.type)) {
      childrenCode += "{" + generateChildCallback(child, extraParams) + "\n    }";
    } else if (layer.styleName.indexOf('carousel') !== -1) {
      childrenCode += "<Slide>" + generateChildCallback(child, extraParams) + "</Slide>";
    } else {
      childrenCode += generateChildCallback(child, extraParams) + "\n    ";
    }
  });
  return childrenCode;
};
var addImportToContext = function addImportToContext(context, layerJSON, generateJSLiteralCode) {
  // console.log("Adding imports with json as ", context);
  if (layerJSON["import"].layerName.includes('.')) {
    return;
  }

  if (layerJSON["import"].packageName === '@builderx/icons' || layerJSON["import"].packageName === 'VectorIcons') {
    var currentFamily = getCurrentFamily(layerJSON, generateJSLiteralCode);
    layerJSON["import"].packageName = "react-native-vector-icons/dist/" + currentFamily;
  }

  if (layerJSON["import"].packageName === 'native') {
    layerJSON["import"].packageName = 'react-native';
  }

  if (layerJSON.type === 'symbol') {
    if (context.filePath.indexOf('screens') !== -1) {
      layerJSON["import"].packageName = "../components/" + layerJSON["import"].layerName;
    } else if (context.filePath.indexOf('preview') !== -1) {
      layerJSON["import"].packageName = "./components/" + layerJSON["import"].layerName;
    } else if (context.filePath.indexOf('symbols') !== -1 || context.filePath.indexOf('components') !== -1) {
      layerJSON["import"].packageName = "./" + layerJSON["import"].layerName;
    }
  }

  switch (layerJSON["import"].layerName) {
    case 'MapView':
      layerJSON["import"] = _extends({}, layerJSON["import"], {
        packageName: 'google-map-react',
        layerName: "GoogleMapReact" + (context.mapDuplicate.lastNumber === 1 ? '' : context.mapDuplicate.lastNumber),
        isDefaultImport: true
      });
      break;

    case 'Swiper':
      layerJSON["import"] = _extends({}, layerJSON, {
        packageName: 'pure-react-carousel',
        layerName: 'Carousel'
      });
      context.imports[layerJSON["import"].packageName] = {
        named: ['CarouselProvider', 'Slider as CarouselSlider', 'Slide', 'DotGroup'],
        "default": false,
        cssFile: 'pure-react-carousel/dist/react-carousel.es.css'
      };
      break;

    case 'TabView':
      layerJSON["import"] = _extends({}, layerJSON, {
        packageName: '@material-ui/core',
        layerName: 'AppBar'
      });
      context.imports[layerJSON["import"].packageName] = {
        named: ['Tabs', 'Tab as LabelledTab'],
        "default": false
      };
      break;

    case 'FlatList':
      layerJSON["import"] = _extends({}, layerJSON, {
        packageName: 'react-list',
        layerName: 'ReactList',
        isDefaultImport: true
      });
      break;

    case 'Switch':
      layerJSON["import"] = _extends({}, layerJSON, {
        packageName: '@material-ui/core/Switch',
        layerName: context.switchDuplicate.lastNumber === 1 ? 'MaterialUISwitch' : "MaterialUISwitch" + context.switchDuplicate.lastNumber,
        isDefaultImport: true
      });
      break;

    case 'Slider':
      layerJSON["import"] = _extends({}, layerJSON["import"], {
        packageName: 'material-ui-slider',
        layerName: 'Slider'
      });
      break;

    case 'ActivityIndicator':
      layerJSON["import"] = _extends({}, layerJSON["import"], {
        packageName: '@material-ui/core/CircularProgress',
        layerName: 'CircularProgress',
        isDefaultImport: true
      });
      break;

    case 'TouchableOpacity':
      layerJSON["import"] = _extends({}, layerJSON["import"], {
        packageName: 'react-router-dom',
        layerName: 'Link'
      });
      break;
  }

  if (!context.imports[layerJSON["import"].packageName]) {
    context.imports[layerJSON["import"].packageName] = {
      named: [],
      "default": false
    };
  }

  var contextImportObj = context.imports[layerJSON["import"].packageName];

  if (layerJSON["import"].packageName.indexOf('react-native-vector-icons') !== -1) {
    var _currentFamily = getCurrentFamily(layerJSON, generateJSLiteralCode);

    contextImportObj["default"] = "" + _currentFamily + layerJSON["import"].layerName;
  } else if (layerJSON["import"].isDefaultImport) {
    contextImportObj["default"] = layerJSON["import"].layerName;
  } else {
    if (contextImportObj.named.indexOf(layerJSON["import"].layerName) === -1) {
      contextImportObj.named.push(layerJSON["import"].layerName);
    }
  }
};
var isTabViewSpecificStyleProp = function isTabViewSpecificStyleProp(propName) {
  return ['tabBarStyle', 'indicatorStyle', 'labelStyle', 'tabStyle'].indexOf(propName) !== -1;
};
var escapeTextForJSX = function escapeTextForJSX(text) {
  if (typeof text === 'string') {
    text = text.trim();
    text = lodash.escape(text);
  }

  if (lodash.includes(text, '\n')) {
    text = lodash.replace(text, new RegExp('\n', 'g'), "{\"\\n\"}");
    text = lodash.replace(text, new RegExp('\t', 'g'), "{\"\\t\"}");
  }

  return text;
};
var anyChildIsFlex = function anyChildIsFlex(layer) {
  var hasFlexChild = false;
  layer.children.forEach(function (child) {
    var _child$props$style = child.props.style,
        flex = _child$props$style.flex,
        restStyles = _objectWithoutPropertiesLoose(_child$props$style, ["flex"]);

    if (flex) {
      hasFlexChild = true;
    }
  });
  return hasFlexChild;
};
var jsonHasButtonLayer = function jsonHasButtonLayer(layer, context) {
  layer.children.forEach(function (child) {
    if (lodash.get(child, 'import.layerName', 0) && child["import"].layerName === 'TouchableOpacity') {
      context.buttonDuplicate.exists = true;
      return;
    }

    if (child.children && child.children.length !== 0) {
      jsonHasButtonLayer(child, context);
    }
  });
  return hasButtonLayer;
};
var traverseLayersForStyleName = function traverseLayersForStyleName(layer, context) {
  layer.children.forEach(function (child) {
    if (child.styleName && (child.styleName.startsWith('materialUISwitch') || child.styleName.startsWith('MaterialUISwitch'))) {
      if (typeof child.styleName === 'string') {
        var followedString = child.styleName.substring(16, child.styleName.length);

        if (!isNaN(followedString)) {
          var currentNumber = Number(followedString);

          if (currentNumber > switchHighestNumber) {
            switchHighestNumber = currentNumber;
          } else if (currentNumber === 0) {
            switchHighestNumber++;
          }
        }
      }
    }

    context.switchDuplicate.lastNumber = switchHighestNumber + 1;

    if (child.styleName && (child.styleName.startsWith('googleMapReact') || child.styleName.startsWith('GoogleMapReact'))) {
      if (typeof child.styleName === 'string') {
        var _followedString = child.styleName.substring(14, child.styleName.length);

        if (!isNaN(_followedString)) {
          var _currentNumber = Number(_followedString);

          if (_currentNumber > mapHighestNumber) {
            mapHighestNumber = _currentNumber;
          } else if (_currentNumber === 0) {
            mapHighestNumber++;
          }
        }

        if (child.styleName && (child.styleName === 'googleMapReact' || child.styleName === 'GoogleMapReact')) {
          mapHighestNumber++;
        }
      }
    }

    context.mapDuplicate.lastNumber = mapHighestNumber + 1;

    if (child.styleName && (child.styleName.startsWith('buttonOverlay') || child.styleName.startsWith('ButtonOverlay'))) {
      if (typeof child.styleName === 'string') {
        var _followedString2 = child.styleName.substring(13, child.styleName.length);

        doesNumberExist('buttonOverlay', context.buttonDuplicate.lastNumber, layer, context);
      }
    }
  });
};
var getCurrentFamily = function getCurrentFamily(layerJSON, generateJSLiteralCode) {
  var conditionalStatement = generateJSLiteralCode(layerJSON.props.type);
  var currentFamily = '';
  var families = ['Entypo', 'EvilIcons', 'Feather', 'FontAwesome', 'MaterialIcons', 'MaterialCommunityIcons', 'SimpleLineIcons', 'Octicons', 'Zocial', 'Ionicons'];

  for (var i = 0; i < families.length; i++) {
    if (conditionalStatement.indexOf(families[i]) !== -1) {
      currentFamily = families[i];
      break;
    }
  }

  return currentFamily;
};

var doesNumberExist = function doesNumberExist(category, num, layer, context) {
  layer.children.forEach(function (child) {
    if (typeof child.styleName === 'string') {
      var compareWith = num === 1 ? ("" + category).toLowerCase() : ("" + category + num).toLowerCase();

      if (child.styleName.toLowerCase() === compareWith) {
        context.buttonDuplicate.lastNumber++;
        doesNumberExist(category, context.buttonDuplicate.lastNumber, layer, context);
      }
    }

    if (child.children && child.children.length !== 0) {
      doesNumberExist(category, context.buttonDuplicate.lastNumber, layer, context);
    }
  });
  return;
};
var hasPositionProperty = function hasPositionProperty(layer) {
  var position = lodash.get(layer, 'props.style.position', undefined);
  return position ? true : false;
};
var hasAbsolutePosition = function hasAbsolutePosition(styles) {
  return styles.position === 'absolute';
};
var layerHasAbsoluteChild = function layerHasAbsoluteChild(layer) {
  var hasAbsoluteChild = false;

  for (var i = 0; i < layer.children.length; i++) {
    if (hasPositionProperty(layer.children[i]) && hasAbsolutePosition(layer.children[i].props.style)) {
      hasAbsoluteChild = true;
      break;
    }
  }

  return hasAbsoluteChild;
};
var addFlexValuesForScrollViewChildren = function addFlexValuesForScrollViewChildren(extraParams, json) {
  var parent = lodash.get(extraParams, 'parent', undefined);

  if (parent && parent.type && parent.type.toLowerCase() === 'scrollview') {
    var parentStyles = lodash.get(parent, 'props.style', undefined);

    if (parentStyles && parentStyles.display && parentStyles.display === 'flex') {
      json.props.style = _extends({}, json.props.style, {
        flex: '0 0 auto'
      });
    }
  }
};
var getGradient = function getGradient(gradient, palette) {
  var colors = [];

  if (palette) {
    lodash.forEach(palette, function (data, index) {
      colors.push(data.color);
    });
  } else {
    lodash.forEach(gradient.stops, function (data, index) {
      colors.push(data.stopColor);
    });
  }

  var vector;

  if (gradient.to && gradient.from) {
    vector = {
      x: gradient.to.x - gradient.from.x,
      y: gradient.to.y - gradient.from.y
    };
  } else {
    vector = {
      x: 0,
      y: 2
    };
  }

  var angleRad = Math.atan2(vector.y, vector.x);
  var angleDeg = angleRad * 180 / Math.PI + 90;
  var realLocations = [];

  if (palette) {
    lodash.forEach(palette, function (data, index) {
      realLocations.push(data.pos);
    });
  } else {
    lodash.forEach(gradient.stops, function (data, index) {
      realLocations.push(data.offset);
    });
  }

  var colorStrings = colors.map(function (color, i) {
    return color + " " + Math.round(realLocations[i] * 100) + "%";
  }).join(', ');

  if (gradient.gradientType && gradient.gradientType === 'LinearGradient') {
    return "linear-gradient(" + angleDeg + "deg, " + colorStrings + ")";
  } else if (gradient.gradientType && gradient.gradientType === 'RadialGradient') {
    var dist = Math.sqrt((gradient.to.x - gradient.from.x) * (gradient.to.x - gradient.from.x) + (gradient.to.y - gradient.from.y) * (gradient.to.y - gradient.from.y));
    var maxDist = Math.sqrt((1 - gradient.from.x) * (1 - gradient.from.x) + (1 - gradient.from.y) * (1 - gradient.from.y));
    var radialColorStrings = colors.map(function (color, i) {
      return color + " " + Math.round(realLocations[i] * (dist / maxDist) * 100) + "%";
    }).join(', ');
    return "radial-gradient(circle at " + gradient.from.x * 100 + "% " + gradient.from.y * 100 + "%," + radialColorStrings + ")";
  } else if (gradient.gradientType && gradient.gradientType === 'AngularGradient') {
    return "conic-gradient(" + colorStrings + ")";
  } else {
    return "linear-gradient(" + angleDeg + "deg, " + colorStrings + ")";
  }
};
var getGradientString = function getGradientString(gradient, palette) {
  return getGradient(gradient, palette);
};

var layerNameMap = {
  View: 'div',
  TouchableOpacity: 'div',
  Ellipse: 'svg',
  Icon: 'i',
  Image: 'img',
  ReactList: 'div',
  GoogleMapReact: 'div',
  Path: 'svg',
  ScrollView: 'div',
  Switch: 'div',
  TabView: 'div',
  Text: 'span',
  TextInput: 'input',
  Picker: 'select'
};
var MARGIN_PROPERTIES = ['margin', 'marginBottom', 'marginHorizontal', 'marginLeft', 'marginRight', 'marginTop', 'marginVertical'];
var ROUNDABLE_LAYOUT_PROPERTIES = /*#__PURE__*/['bottom', 'fontSize', 'height', 'left', 'maxHeight', 'maxWidth', 'minHeight', 'minWidth', 'padding', 'paddingBottom', 'paddingHorizontal', 'paddingLeft', 'paddingRight', 'paddingTop', 'paddingVertical', 'right', 'width', 'top'].concat(MARGIN_PROPERTIES);
var ROUNDABLE_TO_TWO_DECIMALS_LAYOUT_PROPERTIES = ['flex'];
 // export { MapStyles } from './MapStyle';

var pascalCase = /*#__PURE__*/require('pascal-case');

var toStyleString = /*#__PURE__*/require('to-style').string;

var flexProperties = ['flex', 'justifyContent', 'alignItems', 'alignSelf', 'flexWrap'];

var LayerCodeGen = /*#__PURE__*/function () {
  function LayerCodeGen() {
    var _this = this;

    this.generateProps = function (json, extraParams) {
      var propsCode = '';

      if (json.props) {
        lodash.forEach(json.props, function (propValue, propName) {
          if (propName === 'onPress') {
            if (typeof propValue === 'string') {
              propsCode = "onClick={" + propValue.replace(/;/g, '') + "}";
            } else {
              // TODO: Handle conditional navigation
              propsCode += '/* Conditional navigation not supported at the moment */';
            } // TODO: check for all callback props

          } else if (lodash.get(json, 'import.layerName').indexOf('GoogleMapReact') !== -1 && propName === 'initialRegion') {
            propName = 'defaultCenter';
            delete propValue.longitude;
            delete propValue.latitudeDelta;
            delete propValue.longitudeDelta;
            Object.assign(propValue, {
              lat: 20.5937,
              lng: 78.9629
            });
            propsCode += propName + "={" + _this.generateJSLiteralCode(propValue, extraParams) + "}";
          } else if (lodash.get(json, 'import.layerName') === 'ReactList' && propName === 'renderItem') {
            propName = 'itemRenderer';
            propsCode += propName + "={({ item, separators }) => " + _this.context.baseCodeGen.generate(propValue, extraParams) + "}";
          } else if (lodash.get(json, 'import.layerName') === 'ReactList' && (propName === 'ListHeaderComponent' || propName === 'ListFooterComponent' || propName === 'ItemSeparatorComponent')) {
            propsCode += propName + "={() => " + _this.context.baseCodeGen.generate(propValue, extraParams) + "}";
          } else if (propName === 'source') {
            propName = 'src';
            propsCode += _this.generateSourcePropCode(path.basename(propValue.uri));
          } else if (!isTabViewSpecificStyleProp(propName) && propName !== 'style' && propName !== 'contentContainerStyle') {
            if (typeof propValue === 'string') {
              propsCode += propName + "=" + _this.generateJSLiteralCode(propValue, extraParams);
            } else {
              var ellipseProps = ['cx', 'cy', 'rx', 'ry'];

              if (ellipseProps.includes(propName)) {
                propValue = lodash.round(propValue);
              }

              propsCode += propName + "={" + _this.generateJSLiteralCode(propValue, extraParams) + "}";
            }
          }

          if (propName === 'style') {
            for (var prop in json.props.style) {
              if (typeof json.props.style[prop] !== 'string' && typeof json.props.style[prop] !== 'number' && prop.indexOf('shadow') === -1 && prop.indexOf('transform') === -1) {
                propsCode += propName + "={{" + prop + ":" + _this.generateJSLiteralCode(json.props.style[prop], extraParams) + "}}";
                delete json.props.style[prop];
              }
            }
          }
        });
      }

      return propsCode;
    };

    this.generateStyle = function (json, extraParams, stylePropName) {
      if (stylePropName === void 0) {
        stylePropName = 'style';
      }

      if (lodash.get(json, 'import.layerName') === 'Picker.Item') {
        return '';
      }

      var style = lodash.get(json, "props." + stylePropName, {});
      var conditionalStyles = {};
      lodash.forEach(style, function (styleValue, styleProperty) {
        if (styleValue && ['expressionStatement', 'binaryExpression', 'expression', 'conditionalExpression', 'logicalExpression'].includes(styleValue.type)) {
          conditionalStyles[styleProperty] = _this.context.baseCodeGen.generate(styleValue, extraParams);
          delete _this.context.styles[json.styleName][styleProperty];
        }
      });

      if (Object.keys(conditionalStyles).length !== 0) {
        var conditionalStyleObjCode = '';
        lodash.forEach(conditionalStyles, function (code, styleProperty) {
          return conditionalStyleObjCode += styleProperty + ": " + code + ",";
        });
        return stylePropName + "={[\n        styles." + json.styleName + (stylePropName !== 'style' ? '_' + stylePropName : '') + ",\n        {\n          " + conditionalStyleObjCode + "\n        }\n      ]}";
      }

      return stylePropName + "={styles." + json.styleName + (stylePropName !== 'style' ? '_' + stylePropName : '') + "}";
    };

    this.generateStyleComponentCode = function (literal, json, extraParams) {
      var code = ''; // let restStyles = {};

      lodash.forEach(literal, function (element, key) {
        // if (element.hasOwnProperty("style")) {
        //   let { flex, ...remainingStyles } = element.style;
        //   restStyles = remainingStyles;
        // }
        if (element.category === 'text' || element.category === 'TextInput') {
          element.style = _extends({
            fontFamily: 'Arial'
          }, element.style);

          var styleCode = _this.generateStyleCode(element.style, extraParams, element.category);

          code += "const " + pascalCase(key) + " = styled." + element.layerName + "`\n" + styleCode + "`;\n\n";
        } else if (element.layerName !== 'ThirdParty' && element.layerName !== 'svg' && element.layerName !== 'Symbol' && element.category !== 'Center' && (element.category !== 'root' || _this.context.filePath.indexOf('symbols') === -1 || _this.context.filePath.indexOf('components') === -1)) {
          var _styleCode = _this.generateStyleCode(element.style, extraParams, element.category, json); // if (
          //   !isEmpty(restStyles) ||
          //   this.context.filePath.indexOf("symbols") !== -1 ||
          //   this.context.filePath.indexOf("components") !== -1
          // ) {
          //   // TODO:Condition can be improved
          //   if (isEmpty(restStyles)) {
          //     // This is the case of empty object and symbol
          //     code += `const ${pascalCase(key)} = styled.${
          //       element.layerName
          //     }\`\``;
          //   } else {
          //     code += `const ${pascalCase(key)} = styled.${
          //       element.layerName
          //     }\`\n${styleCode}\`;\n\n`;
          //   }
          // } else {


          code += "const " + pascalCase(key) + " = styled." + element.layerName + "`\n" + _styleCode + "`\n\n"; // }
        } else if (element.category === 'Center') {
          code += "const " + pascalCase(key) + " = styled." + element.layerName + "`\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  display: flex;\n  flex-direction: column;\n  position: absolute;\n  pointer-events: none;\n\n  ${props=>\n  ((props.horizontal && !props.vertical)\n  ||(!props.horizontal && !props.vertical)) && css `\n      align-items: center;\n  `};\n\n\n  ${props=>\n  ((props.vertical &&!props.horizontal)\n  ||(!props.horizontal&&!props.vertical)) && css `\n      justify-content: center;\n  `};\n  `;\n\n";
        } else if (element.category === 'root' && (_this.context.filePath.indexOf('symbols') !== -1 || _this.context.filePath.indexOf('components') !== -1)) {
          code += "const " + pascalCase(key) + "=styled." + element.layerName + "(\n            " + _this.generateJSLiteralCode(element.style, extraParams, false, element.category) + "\n          );";
        }

        if (_this.context.buttonDuplicate.exists && !_this.context.buttonDuplicate.codeGenerated) {
          code += "const ButtonOverlay" + (_this.context.buttonDuplicate.lastNumber !== 1 ? _this.context.buttonDuplicate.lastNumber : '') + " = styled.button`\n display: block;\n background: none;\n height: 100%;\n width: 100%;\n border:none\n `;";
          _this.context.buttonDuplicate.codeGenerated = true;
          _this.context.buttonDuplicate.exists = false;
        }
      });
      return code;
    };

    this.generateJSLiteralCode = function (literal, extraParams, jsExpression, category) {
      if (jsExpression === void 0) {
        jsExpression = false;
      }

      var code = '';
      var literalType = typeof literal;

      if (literal === null) {
        literalType = literal; // Handle null literal, otherwise it takes type object
      }

      if (Array.isArray(literal)) {
        literalType = 'array';
      }

      switch (literalType) {
        case 'object':
          // TODO:if is not handelled
          if (['expressionStatement', 'binaryExpression', 'expression', 'conditionalExpression', 'logicalExpression'].includes(literal.type)) {
            code = _this.context.baseCodeGen.generate(literal, extraParams);
          } else {
            code = "" + _this.generateJSObjectCode(literal, extraParams, category);
          }

          break;

        case 'array':
          code = "" + _this.generateJSArrayCode(literal, extraParams);
          break;

        case 'boolean':
          code = "" + literal;
          break;

        case 'number':
          code = String(literal); // TODO: consider setValueinInt

          break;

        case 'string':
        default:
          if (jsExpression) {
            code = "" + literal;
          } else {
            code = "\"" + literal + "\"";
          }

      }

      return code;
    };

    this.generateJSObjectCode = function (obj, extraParams, category) {
      var code = '';

      if (obj.hasOwnProperty('shadowOffset')) {
        obj = _extends({}, obj, {
          boxShadow: (obj.shadowOffset.width ? obj.shadowOffset.width : 0) + "px " + (obj.shadowOffset.height ? obj.shadowOffset.height : 0) + "px " + (obj.shadowRadius ? obj.shadowRadius : 0) + "px  " + (obj.shadowOpacity ? obj.shadowOpacity : 0) + "px " + (obj.shadowColor && obj.shadowColor) + " "
        });
        var junk = obj.shadowOffset && delete obj.shadowOffset;
        junk = obj.shadowColor && delete obj.shadowColor;
        junk = obj.shadowOpacity && delete obj.shadowOpacity;
        junk = obj.shadowRadius && delete obj.shadowRadius;
        junk = obj.elevation && delete obj.elevation;
      }

      lodash.forEach(obj, function (value, key) {
        if (value !== undefined) {
          if (key === 'transform') {
            value = "rotate(" + value[0]['rotate'] + ")";
          }

          if (key === 'lineHeight') {
            value = value + 'px';
          } // if (key === "fontSize") {
          //   value = `${value * 0.5}px`;
          // }


          if (ROUNDABLE_LAYOUT_PROPERTIES.includes(key)) {
            if (typeof value === 'number') {
              value = Math.round(value);
            } else if (typeof value === 'string' && value.includes('%')) {
              // For percentage values
              var numValue = parseFloat(value.replace('%', ''));
              numValue = Math.round(numValue * 100) / 100;
              value = numValue + '%';
            }
          } else if (ROUNDABLE_TO_TWO_DECIMALS_LAYOUT_PROPERTIES.includes(key)) {
            if (typeof value === 'number') {
              value = Math.round(value * 100) / 100;
            }
          }

          code += key + ": " + _this.generateJSLiteralCode(value, extraParams) + ",\n      ";
        }
      });
      return "{\n      " + code + "\n    }";
    };

    this.generateJSArrayCode = function (obj, extraParams) {
      var code = '';
      obj.forEach(function (value) {
        code += _this.generateJSLiteralCode(value, extraParams) + ",\n      ";
      });
      return "[\n      " + code + "\n    ]";
    };
  }

  var _proto = LayerCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    return '';
  };

  _proto.generateSourcePropCode = function generateSourcePropCode(imageName, category) {
    // TODO:Confirm from @HimanshuSatija about JS expressions
    var assetsRelativePath = this.config.isPreviewFile ? './assets/images/' : '../assets/images/';

    if (category === 'svgImage') {
      return "" + assetsRelativePath + imageName;
    }

    return "src={require(\"" + assetsRelativePath + imageName + "\")}";
  };

  _proto.generateStyleCode = function generateStyleCode(obj, extraParams, category, json) {
    var flexStyles = lodash.get(obj, 'flex');

    if (category === 'tabView') {
      obj = _extends({}, obj, {
        position: 'absolute'
      });
    }

    if (flexStyles && category !== 'root') {
      var flexDirection = lodash.get(extraParams, 'parent.props.style.flexDirection', undefined);
      var flexValue = obj['flex'];
      var styles = {
        display: 'flex',
        flexDirection: obj.flexDirection ? obj.flexDirection : 'column'
      };

      if (typeof flexValue === 'number' || typeof flexValue === 'string' && flexValue.indexOf(' ') === -1) {
        Object.assign(styles, {
          flex: flexValue + " 1 0%"
        });
      }

      if (flexDirection) {
        switch (flexDirection) {
          case 'row':
            Object.assign(styles, {
              width: '100%'
            });
            break;

          case 'column':
            Object.assign(styles, {
              height: '100%'
            });
            break;
        }
      }

      obj = _extends({}, obj, styles);
    } else if (category === 'root') {
      var _styles = {};

      if (flexStyles) {
        delete obj.flex;
      }

      var res = [];
      Object.keys(obj).forEach(function (key, index) {
        if (flexProperties.includes(key)) {
          res.push(key);
        }
      });
      var hasFlex = res.length !== 0;

      if (obj.hasOwnProperty('backgroundColor') && this.context.filePath.indexOf('preview') === -1 || json && anyChildIsFlex(json.layer) || hasFlex) {
        // Appending styles to root only we have backgroundColor as one of the property
        _styles = {
          height: obj.height ? obj.height : '100vh',
          width: obj.width ? obj.width : '100vw'
        };
        obj = _extends({}, obj, _styles);
      }

      if (obj.hasOwnProperty('flexDirection')) {
        _styles = {
          display: 'flex'
        };
        obj = _extends({}, _styles, obj);
      }

      if (this.context.filePath.indexOf('symbols') !== -1 || this.context.filePath.indexOf('components') !== -1) {
        delete obj.height;
        delete obj.width;
      } else {
        obj = _extends({}, obj, _styles);
      }
    }

    if (obj.hasOwnProperty('shadowOffset')) {
      obj = _extends({}, obj, {
        boxShadow: (obj.shadowOffset.width ? obj.shadowOffset.width : 0) + "px " + (obj.shadowOffset.height ? obj.shadowOffset.height : 0) + "px " + (obj.shadowRadius ? obj.shadowRadius : 0) + "px  " + (obj.shadowOpacity ? obj.shadowOpacity : 0) + "px " + (obj.shadowColor && obj.shadowColor) + " "
      });
      var junk = obj.shadowOffset && delete obj.shadowOffset;
      junk = obj.shadowColor && delete obj.shadowColor;
      junk = obj.shadowOpacity && delete obj.shadowOpacity;
      junk = obj.shadowRadius && delete obj.shadowRadius;
      junk = obj.elevation && delete obj.elevation;
    }

    for (var key in obj) {
      if (typeof obj[key] !== 'string') {
        var passVal = obj[key];

        if (typeof obj[key] === 'number' && ROUNDABLE_LAYOUT_PROPERTIES.includes(key)) {
          passVal = lodash.round(passVal);
        }

        obj[key] = this.generateJSLiteralCode(passVal, extraParams);
      }
    }

    var style = toStyleString(obj);

    if (style === '') {
      return style;
    }

    var styleProperties = style.split(';');
    style = '';
    var length = styleProperties.length;

    for (var i = 0; i < length; i++) {
      if (i === 0 && length > 1) {
        style = style + ("  " + styleProperties[i] + ";\n");
      } else {
        style = style + (" " + styleProperties[i] + ";\n");
      }
    }

    return style;
  };

  _proto.generateSymbolOverrideProps = function generateSymbolOverrideProps(scopeVariables, extraParams) {
    var _this2 = this;

    var code = '';
    lodash.forEach(scopeVariables, function (value, key) {
      if (typeof value === 'string') {
        code += key.replace('this.props.', '') + "=" + _this2.generateJSLiteralCode(value, extraParams);
      } else {
        code += key.replace('this.props.', '') + "={" + _this2.generateJSLiteralCode(value, extraParams) + "}";
      }
    });
    return code;
  };

  return LayerCodeGen;
}();

var DivCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(DivCodeGen, _LayerCodeGen);

  function DivCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = DivCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    var gradient = json.props.style.gradient;

    if (gradient) {
      var gradientString = getGradientString(gradient);
      json.props.style.backgroundImage = gradientString;
      delete json.props.style.backgroundColor;
      delete json.props.gradientImage;
    }

    delete json.props.style.gradient;
    var propsCode = this.generateProps(json, extraParams); // Handling delete opacity in case of gradient(special case for React and not for react native)

    var _json$props$style = json.props.style,
        stylesWithoutOpacity = _objectWithoutPropertiesLoose(_json$props$style, ["opacity"]);

    var smartFlexTransformed = this.context.smartFlexTransformed;
    var layerStyles = '';

    if (smartFlexTransformed && gradient) {
      if (layerHasAbsoluteChild(json)) {
        layerStyles = _extends({}, stylesWithoutOpacity, {
          display: 'flex'
        });
      }
    }

    if (json.children) {
      if (json.children.length === 0) {
        this.context.styles[json.styleName] = {
          style: smartFlexTransformed && gradient ? stylesWithoutOpacity : json.props.style,
          layerName: layerNameMap[json["import"].layerName],
          category: json.type === 'root' ? 'root' : undefined
        };
      } else {
        if (layerHasAbsoluteChild(json)) {
          json.props.style.position = !(hasPositionProperty(json) && hasAbsolutePosition(json.props.style)) ? 'relative' : json.props.style.position;
        }

        this.context.styles[json.styleName] = {
          style: smartFlexTransformed && gradient ? _extends({}, stylesWithoutOpacity, {
            display: 'flex'
          }) : _extends({}, json.props.style, {
            display: 'flex'
          }),
          layerName: layerNameMap[json["import"].layerName],
          category: json.type === 'root' ? 'root' : undefined
        };
      }
    } else {
      this.context.styles[json.styleName] = {
        style: json.props.style,
        layerName: layerNameMap[json["import"].layerName],
        category: json.type === 'root' ? 'root' : undefined
      };
    }

    var _json$props$style2 = json.props.style,
        restStyles = _objectWithoutPropertiesLoose(_json$props$style2, ["flex"]);

    var tag = json.type === 'root' && lodash.isEmpty(restStyles) ? '' : pascalCase$8(json.styleName);

    if (tag === '') {
      this.context.styles[json.styleName].style = {};
    }

    if (json.type === 'root' && (this.context.filePath.indexOf('symbols') !== -1 || this.context.filePath.indexOf('components') !== -1)) {
      return "<" + pascalCase$8(json.styleName) + " {...props} >\n      " + generateChildren(json, this.context.baseCodeGen.generate, {
        parent: json
      }) + "\n      </" + pascalCase$8(json.styleName) + ">";
    } //  else if (
    //   json.type === "root" &&
    //   json.children.length <= 1 &&
    //   this.context.filePath.indexOf("symbols") === -1 &&
    //   this.context.filePath.indexOf("components") === -1
    // ) {
    //   if (json.children.length === 0) {
    //     if (!isEmpty(json.props.style)) {
    //       return `<Container>
    //     ${generateChildren(json, this.context.baseCodeGen.generate, {
    //       parent: json
    //     })}
    //     </Container>`;
    //     }
    //     return `<>
    //   ${generateChildren(json, this.context.baseCodeGen.generate, {
    //     parent: json
    //   })}
    //   </>`;
    //   } else {
    //     this.context.styles[json.styleName].style = {};
    //     return `${generateChildren(json, this.context.baseCodeGen.generate, {
    //       parent: json
    //     })}`;
    //   }
    // } else if (
    //   (this.context.filePath.indexOf("symbols") !== -1 ||
    //     this.context.filePath.indexOf("components") !== -1) &&
    //   json.type === "root" &&
    //   json.children.length > 1
    // ) {
    //   return `<${tag} style={props.style} ${propsCode} >
    //   ${generateChildren(json, this.context.baseCodeGen.generate, {
    //     parent: json
    //   })}
    //   </${tag}>`;
    // }


    return "<" + tag + " " + propsCode + " >\n      " + generateChildren(json, this.context.baseCodeGen.generate, {
      parent: json
    }) + "\n      </" + tag + ">";
  };

  return DivCodeGen;
}(LayerCodeGen);

var CenterCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(CenterCodeGen, _LayerCodeGen);

  function CenterCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = CenterCodeGen.prototype;

  _proto.generateCenterProps = function generateCenterProps(template) {
    if (template.centerVertical && !template.centerHorizontal) {
      return 'vertical';
    } else if (!template.centerVertical && template.centerHorizontal) {
      return 'horizontal';
    }

    return '';
  };

  _proto.generate = function generate(json, extraParams) {
    var propsCode = this.generateCenterProps(json.template);
    this.context.styles = _extends({}, this.context.styles, {
      center: {
        layerName: 'div',
        category: 'Center'
      }
    });
    var layer = extraParams.parent;

    if ((!hasPositionProperty(extraParams.parent) || hasPositionProperty(layer) && !hasAbsolutePosition(layer.props.style)) && !this.context.smartFlexTransformed) {
      this.context.styles[extraParams.parent.styleName].style.position = 'relative';
    }

    delete json.template.centerHorizontal;
    delete json.template.centerVertical;
    return "<Center " + propsCode + ">\n      " + this.context.baseCodeGen.generate(json, extraParams) + "\n    </Center>"; // return this.generateJSLiteralCode({ top: 100 });
  };

  return CenterCodeGen;
}(LayerCodeGen);

var getRandomString = function getRandomString(length) {
  if (length === void 0) {
    length = 6;
  }

  var text = '';
  var possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  text = possible.charAt(Math.floor(Math.random() * 52));

  for (var i = 0; i < length; i++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  }

  return text;
};
function updateWrapperStyleName(json, extraParams) {
  if (json.type === 'row' || json.type === 'column' || json.type === 'stack') {
    var firstChildStyleName = lodash.get(json, 'children.0.styleName', getRandomString(6));
    json.styleName = firstChildStyleName + json.type.charAt(0).toUpperCase() + json.type.slice(1);
  } else if (json.type === 'flexFiller') {
    var siblingsLength = lodash.get(extraParams, 'parent.children.length', 1);
    var previousSiblingStyleName = lodash.get(extraParams, 'parent.children.0.styleName');

    if (previousSiblingStyleName && previousSiblingStyleName !== 'flexFiller') {
      json.styleName = previousSiblingStyleName + 'Filler';
    } else {
      json.styleName = lodash.get(extraParams, "parent.children." + (siblingsLength - 1) + ".styleName", getRandomString(6)) + 'Filler';
    } // const previousSiblingStyleName = get(
    //   extraParams,
    //   "parent.children.0.styleName",
    // );
    // json.styleName = previousSiblingStyleName + "Filler";

  }
}
function isSymbolFile(filePath) {
  // this.context.filePath.indexOf("symbols") === -1 &&
  //     this.context.filePath.indexOf("components") === -1
  return filePath.includes('symbols') || filePath.includes('components');
}
function getRotation(transform) {
  var rotation = 0;

  if (transform) {
    var transformValue = lodash.isArray(transform) ? transform : transform['value'];
    var index = lodash.findIndex(transformValue, function (item) {
      var rotate = lodash.keys(item).indexOf('rotate');
      return rotate !== -1 && !lodash.isNil(item['rotate']);
    });

    if (index > -1) {
      var value = transformValue[index]['rotate'] && transformValue[index]['rotate'].type ? transformValue[index]['rotate'].value : transformValue[index]['rotate'];

      if (value && value.indexOf) {
        if (value.indexOf('rad') > -1) {
          value = parseFloat(value.slice(0, -3));
          rotation = value * 180 / Math.PI;
        } else {
          value = parseFloat(value.slice(0, -3));
          rotation = value;
        }
      }
    }
  }

  return rotation;
}

var FileCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(FileCodeGen, _LayerCodeGen);

  function FileCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;

    _this.isFileComponent = function () {
      if (_this.context.filePath.indexOf('component') !== -1 || _this.context.filePath.indexOf('symbol') !== -1) {
        return true;
      }

      return false;
    };

    _this.context = context;
    return _this;
  }

  var _proto = FileCodeGen.prototype;

  _proto.generateStyleNames = function generateStyleNames(json, extraParams) {
    return this.generateStyleComponentCode(this.context.styles, json, extraParams);
  };

  _proto.generateConditionalVariables = function generateConditionalVariables() {
    var conditionalVariables = '';

    for (var i = 0; i < this.context.conditionals.length; i++) {
      conditionalVariables += "let " + this.context.conditionals[i] + "=true;";
    }

    return conditionalVariables;
  };

  _proto.generateImports = function generateImports() {
    var importsCode = '';
    lodash.forEach(this.context.imports, function (importObj, packageName) {
      var defaultImportCode = '';

      if (importObj["default"]) {
        defaultImportCode = importObj.named.length > 0 ? importObj["default"] + "," : importObj["default"];
      }

      var namedImportsCode = ' ';
      lodash.forEach(importObj.named, function (layerName, index) {
        if (index === 0) {
          namedImportsCode += '{ ';
        }

        if (typeof layerName === 'object') {
          if (layerName.hasOwnProperty('name') && layerName.hasOwnProperty('asName')) {
            namedImportsCode += layerName.name + " as " + layerName.asName + ",";
          }
        } else {
          namedImportsCode += layerName + ", ";
        }

        if (index === importObj.named.length - 1) {
          namedImportsCode += '}';
        }
      });

      if (importObj.named.length > 0 || importObj["default"]) {
        importsCode += "import " + defaultImportCode + " " + namedImportsCode + " from \"" + packageName + "\";";

        if (importObj.cssFile !== undefined) {
          importsCode += "import \"" + importObj.cssFile + "\";";
        }
      }
    });
    return importsCode;
  };

  _proto.generate = function generate(json, extraParams) {
    var _json$layer$props$sty = json.layer.props.style,
        display = _json$layer$props$sty.display,
        flexDirection = _json$layer$props$sty.flexDirection,
        restStyles = _objectWithoutPropertiesLoose(_json$layer$props$sty, ["flex", "display", "flexDirection"]);

    var containerHasDefaultStyles = lodash.isEmpty(restStyles) && (!display || display === 'flex') && (!flexDirection || flexDirection === 'column');

    if (json.smartFlexTransformed) {
      this.context.smartFlexTransformed = true;
    }

    var className = json.path;
    this.context['filePath'] = json.path;
    className = className.substring(className.lastIndexOf('/') + 1, className.lastIndexOf('.'));
    var layersCode;

    if (json.layer.children.length === 0 && containerHasDefaultStyles && !isSymbolFile(this.context.filePath)) {
      layersCode = '<></>';
    } else {
      if (!isSymbolFile(json.path) && containerHasDefaultStyles) {
        if (json.layer.children.length === 1 && json.layer.children[0].type !== 'symbol') {
          json.layer.children[0].type = 'root';
          layersCode = this.context.baseCodeGen.generate(json.layer.children[0], {
            parent: json
          });
        } else if (!anyChildIsFlex(json.layer)) {
          layersCode = "<>" + generateChildren(json.layer, this.context.baseCodeGen.generate, {
            parent: json
          }) + "</>";
        } else {
          layersCode = this.context.baseCodeGen.generate(json.layer, {
            parent: json
          });
        }
      } else if (this.config.isPreviewFile && json.layer.children.length === 1) {
        layersCode = this.context.baseCodeGen.generate(json.layer.children[0], {
          parent: json
        });
      } else {
        layersCode = this.context.baseCodeGen.generate(json.layer, {
          parent: json
        });
      }
    }

    var stylesCode = this.generateStyleNames(json, {
      parent: json
    });
    this.context.buttonDuplicate.exists = false;
    this.context.buttonDuplicate.codeGenerated = false;
    return this.generateImports() + "\n\n    " + (this.context.isPlatformConditional ? "let Platform={OS:\"Web\"}" : '') + ";\n   " + this.generateConditionalVariables() + "\n\n   function " + className + "(props) {\n        " + (this.context.fileHasTabView ? "let value=0;" : '') + "\n        return " + layersCode + ";\n    }\n\n    " + stylesCode + "\n\n    export default " + className;
  };

  return FileCodeGen;
}(LayerCodeGen);

var LiteralCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(LiteralCodeGen, _LayerCodeGen);

  function LiteralCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = LiteralCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    if (lodash.get(json, 'value.type', '') === 'unknown') {
      return 'null';
    } else if (json.value && json.value.type) {
      return this.context.baseCodeGen.generate(json.value, extraParams);
    }

    if (typeof json.value === 'string') {
      if (extraParams && !extraParams.textLiteral) {
        json.value = escapeTextForJSX(json.value);
      } else {
        var newLine = '\\' + 'n';
        json.value = lodash.replace(json.value, new RegExp('\n', 'g'), newLine);
        var tab = '\\' + 't';
        json.value = lodash.replace(json.value, new RegExp('\t', 'g'), tab);
      } // Only replace opening curly braces `{` with `{"{"} and `


      if (extraParams && !extraParams.textLiteral) {
        json.value = json.value.replace(/(\{+)([^"])/g, "{\"$1\"}$2");
      }

      return this.generateJSLiteralCode(json.value, extraParams, extraParams && typeof extraParams.textLiteral === 'boolean' ? !extraParams.textLiteral : false);
    } else {
      //   const errorMessage = `json.value should be string but received ${JSON.stringify(
      //     json.value
      //   )} for ${this.context.filePath}`;
      //   console.error(errorMessage);
      //   this.context.baseCodeGen.ipc.executeCommand("captureErrorForSentry", [
      //     new Error(errorMessage)
      //   ]);
      //   if (json.value.toString) {
      //     json.value = json.value.toString();
      //   } else {
      //     json.value = "";
      //   }
      // } else {
      //   const errorMessage = `json.value should be string but received ${JSON.stringify(
      //     json.value
      //   )} for ${this.context.filePath}`;
      //   console.error(errorMessage);
      //   this.context.baseCodeGen.ipc.executeCommand("captureErrorForSentry", [
      //     new Error(errorMessage)
      //   ]);
      //   json.value = "";
      return this.generateJSLiteralCode(json.value, extraParams, true);
    } // return json.value;

  };

  return LiteralCodeGen;
}(LayerCodeGen);

var pascalCase$1 = /*#__PURE__*/require('pascal-case');

var TextCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(TextCodeGen, _LayerCodeGen);

  function TextCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = TextCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    delete json.props.style.fontPostscriptName;
    this.context.styles[json.styleName] = {
      style: json.props.style,
      layerName: layerNameMap[json["import"].layerName],
      category: 'text'
    };
    console.log("" + generateChildren(json, this.context.baseCodeGen.generate, _extends({}, extraParams, {
      parent: json,
      textLiteral: false
    })), 'hello here &&&&');
    return "<" + pascalCase$1(json.styleName) + " " + this.generateProps(json, extraParams) + ">\n      " + generateChildren(json, this.context.baseCodeGen.generate, _extends({}, extraParams, {
      parent: json,
      textLiteral: false
    })) + "\n    </" + pascalCase$1(json.styleName) + ">";
  };

  return TextCodeGen;
}(LayerCodeGen);

function getRadiusAdjustment(pointsArray, currentIndex, nextIndex, maxRadius) {
  if (!pointsArray[currentIndex] || !pointsArray[nextIndex]) {
    return {
      x: 0,
      y: 0
    };
  }

  var radius = maxRadius > pointsArray[currentIndex].cornerRadius ? pointsArray[currentIndex].cornerRadius : maxRadius;
  var x0 = pointsArray[currentIndex].point.x;
  var y0 = pointsArray[currentIndex].point.y;
  var x1 = pointsArray[nextIndex].point.x;
  var y1 = pointsArray[nextIndex].point.y;

  if (x1 === x0 && y1 === y0) {
    return {
      x: 0,
      y: 0
    };
  } else if (x1 === x0) {
    return {
      x: 0,
      y: y1 > y0 ? radius : -radius
    };
  } else {
    var angle = Math.atan2(y1 - y0, x1 - x0);
    return {
      x: Math.cos(angle) * radius,
      y: Math.sin(angle) * radius
    };
  }
}

function generateSVGPath(pointsArray, strokeWidthOffset, isClosed, viewBox) {
  var generatedPath = '';

  if (!pointsArray) {
    return '';
  }

  var dims = viewBox && viewBox.split ? viewBox.split(' ') : [0, 0, 100, 100];
  var maxRadius = Math.min(dims[2] - dims[0], dims[3] - dims[1]) / 2;
  strokeWidthOffset = strokeWidthOffset <= 1 ? 0 : strokeWidthOffset / 2;
  var initialIndex = 0; // Maintains track of each shape start after combining

  var d1 = {
    x: 0,
    y: 0
  }; // Distance with radius

  for (var i = 0; i < pointsArray.length; i++) {
    if (i === initialIndex) {
      // Moving to initial points with "M"
      var xy0 = pointsArray[i].point;

      if (pointsArray[i].cornerRadius) {
        d1 = getRadiusAdjustment(pointsArray, i, i + 1, maxRadius);
      }

      var x0 = (strokeWidthOffset + xy0.x + d1.x).toFixed(2);
      var y0 = (strokeWidthOffset + xy0.y + d1.y).toFixed(2);
      generatedPath += 'M' + x0 + ' ' + y0 + ' ';
      generatedPath += getNextPathPoint(pointsArray, i, strokeWidthOffset, initialIndex, maxRadius);
    } else if (isFillerCondition(pointsArray[i])) {
      initialIndex = i + 1;

      if (i !== pointsArray.length - 1 && isFillerClosed(pointsArray[i])) {
        generatedPath += 'Z ';
      }
    } else if (i === pointsArray.length - 1 || i !== pointsArray.length - 1 && isFillerCondition(pointsArray[i + 1])) {
      // adding additional point in the end of string
      if (isClosed && pointsArray[i].point.x !== pointsArray[initialIndex].point.x && pointsArray[i].point.y !== pointsArray[initialIndex].point.y) {
        var pointTo = pointsArray[initialIndex].point;
        var radiusPoint = void 0;

        if (pointsArray[i].cornerRadius) {
          d1 = getRadiusAdjustment(pointsArray, i, initialIndex, maxRadius);
          var passedPointIndex = pointsArray[initialIndex + 1] ? initialIndex + 1 : initialIndex;
          var d2 = getRadiusAdjustment(pointsArray, initialIndex, passedPointIndex, maxRadius);
          var px0 = (strokeWidthOffset + pointTo.x + d2.x).toFixed(2);
          var py0 = (strokeWidthOffset + pointTo.y + d2.y).toFixed(2);
          var curveFromX0 = (strokeWidthOffset + pointTo.x - d1.x / 2).toFixed(2);
          var curveFromY0 = (strokeWidthOffset + pointTo.y - d1.y / 2).toFixed(2);
          var curveToX0 = (strokeWidthOffset + pointTo.x + d2.x / 2).toFixed(2);
          var curveToY0 = (strokeWidthOffset + pointTo.y + d2.y / 2).toFixed(2);
          radiusPoint = 'C' + curveFromX0 + ' ' + curveFromY0 + ' ' + curveToX0 + ' ' + curveToY0 + ' ' + px0 + ' ' + py0 + ' ';
        }

        var px = (strokeWidthOffset + pointTo.x - d1.x).toFixed(2);
        var py = (strokeWidthOffset + pointTo.y - d1.y).toFixed(2);
        var curveFromPoint = pointsArray[i].curveFrom;
        var curveFromX = (strokeWidthOffset + curveFromPoint.x).toFixed(2);
        var curveFromY = (strokeWidthOffset + curveFromPoint.y).toFixed(2);
        var curveTo = pointsArray[initialIndex].curveTo;
        var curveToX = (strokeWidthOffset + curveTo.x).toFixed(2);
        var curveToY = (strokeWidthOffset + curveTo.y).toFixed(2);

        if (pointsArray[initialIndex] && pointsArray[initialIndex].hasCurveTo || pointsArray[i].hasCurveFrom) {
          generatedPath += 'C' + curveFromX + ' ' + curveFromY + ' ' + curveToX + ' ' + curveToY + ' ' + px + ' ' + py + ' ' + (radiusPoint || '');
        } else {
          generatedPath += 'L' + px + ' ' + py + ' ' + (radiusPoint || '');
        }
      }
    } else {
      generatedPath += getNextPathPoint(pointsArray, i, strokeWidthOffset, initialIndex, maxRadius);
    }
  }

  if (isClosed) {
    generatedPath += 'Z';
  } // console.log("*** generatedPath", generatedPath);


  return generatedPath;
}

function getNextPathPoint(pointsArray, i, strokeWidthOffset, initialIndex, maxRadius) {
  if (i + 1 >= pointsArray.length) {
    return '';
  }

  var nextPoint = '';
  var pointTo = pointsArray[i + 1].point;
  var d1 = {
    x: 0,
    y: 0
  };
  var radiusPoint;

  if (pointsArray[i].cornerRadius) {
    d1 = getRadiusAdjustment(pointsArray, i, i + 1, maxRadius);
    var passedPointIndex = pointsArray[i + 2] ? i + 2 : initialIndex;
    var d2 = getRadiusAdjustment(pointsArray, i + 1, passedPointIndex, maxRadius);
    var px0 = (strokeWidthOffset + pointTo.x + d2.x).toFixed(2);
    var py0 = (strokeWidthOffset + pointTo.y + d2.y).toFixed(2);
    var curveFromX0 = (strokeWidthOffset + pointTo.x - d1.x / 2).toFixed(2);
    var curveFromY0 = (strokeWidthOffset + pointTo.y - d1.y / 2).toFixed(2);
    var curveToX0 = (strokeWidthOffset + pointTo.x + d2.x / 2).toFixed(2);
    var curveToY0 = (strokeWidthOffset + pointTo.y + d2.y / 2).toFixed(2);
    radiusPoint = 'C' + curveFromX0 + ' ' + curveFromY0 + ' ' + curveToX0 + ' ' + curveToY0 + ' ' + px0 + ' ' + py0 + ' ';
  }

  var px = (strokeWidthOffset + pointTo.x - d1.x).toFixed(2);
  var py = (strokeWidthOffset + pointTo.y - d1.y).toFixed(2);
  var curveFromPoint = pointsArray[i].curveFrom;
  var curveFromX = (strokeWidthOffset + curveFromPoint.x).toFixed(2);
  var curveFromY = (strokeWidthOffset + curveFromPoint.y).toFixed(2);
  var curveTo = pointsArray[i + 1].curveTo;
  var curveToX = (strokeWidthOffset + curveTo.x).toFixed(2);
  var curveToY = (strokeWidthOffset + curveTo.y).toFixed(2);

  if (pointsArray[i + 1] && pointsArray[i + 1].hasCurveTo || pointsArray[i].hasCurveFrom) {
    nextPoint += 'C' + curveFromX + ' ' + curveFromY + ' ' + curveToX + ' ' + curveToY + ' ' + px + ' ' + py + ' ' + (radiusPoint || '');
  } else {
    nextPoint += 'L' + px + ' ' + py + ' ' + (radiusPoint || '');
  }

  return nextPoint;
}

function isFillerCondition(point) {
  return point.cornerRadius === 777 && point.curveMode === 777 || point.cornerRadius === 776 && point.curveMode === 776;
}

function isFillerClosed(point) {
  return point.cornerRadius === 776 && point.curveMode === 776;
}

var pascalCase$2 = /*#__PURE__*/require('pascal-case');

var ImageCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(ImageCodeGen, _LayerCodeGen);

  function ImageCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = ImageCodeGen.prototype;

  _proto.getRandomString = function getRandomString() {
    var text = '';
    var possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    text = possible.charAt(Math.floor(Math.random() * 52));

    for (var i = 0; i < 6; i++) {
      text += possible.charAt(Math.floor(Math.random() * possible.length));
    }

    return text;
  };

  _proto.generateDefs = function generateDefs(json, maskId) {
    var defsCode = '';
    var maskCode = '';
    var maskPathCode = "<path fill=\"white\" d={\"" + generateSVGPath(json.props.mask, 0, true, json.props.viewBox) + "\"}/>"; // const viewBox = json.props.viewBox.split(" ");

    maskCode = "<mask id=\"" + maskId + "\" x={0} y={0}>\n      " + maskPathCode + "\n      </mask>";

    if (maskCode) {
      defsCode = "<defs>\n    " + maskCode + "\n    </defs>";
    }

    return defsCode;
  };

  _proto.generate = function generate(json, extraParams) {
    var flexDirection = lodash.get(extraParams, 'parent.props.style.flexDirection', undefined);

    if (flexDirection) {
      switch (flexDirection) {
        case 'row':
          Object.assign(json.props.style, {
            width: '100%'
          });
          break;

        case 'column':
          Object.assign(json.props.style, {
            height: '100%'
          });
          break;
      }
    }

    if (json.props.mask) {
      var _json$props = json.props,
          viewBox = _json$props.viewBox,
          style = _json$props.style;
      this.context.styles[json.styleName] = {
        style: json.props.style,
        layerName: layerNameMap[json["import"].layerName],
        category: 'svgImage'
      };

      var svgJson = _extends({}, json, {
        props: {
          viewBox: viewBox,
          style: style
        }
      });

      var maskId = this.getRandomString();
      return "<svg " + this.generateProps(svgJson, extraParams) + " style={" + this.generateJSLiteralCode(json.props.style, extraParams) + "}>\n      " + this.generateDefs(json, maskId) + "\n      <image href={require(\"" + this.generateSourcePropCode(path.basename(json.props.source.uri), 'svgImage') + "\")} x={" + json.props.svgDims.x + "} y={" + json.props.svgDims.y + "} width={" + json.props.svgDims.width + "} height={" + json.props.svgDims.height + "} mask={\"url(#" + maskId + ")\"}>\n      " + generateChildren(json, this.context.baseCodeGen.generate, {
        parent: json
      }) + "\n      </image>\n      </svg>";
    }

    if (json.props.hasOwnProperty('resizeMode')) {
      json.props.style = _extends({}, json.props.style, {
        objectFit: json.props['resizeMode']
      });
      delete json.props.resizeMode;
    }

    if (json.children.length !== 0) {
      json["import"].layerName = 'View';

      if (!json.props.style.gradient) {
        var assetsRelativePath = this.config.isPreviewFile ? './assets/images/' : '../assets/images/';
        var pathName = assetsRelativePath + path.basename(json.props.source.uri);
        json.props.style.backgroundImage = "url(${require('" + pathName + "')})";
        json.props.style.backgroundSize = 'cover';

        if (json.props.style.objectFit) {
          delete json.props.style.objectFit;
        }
      }

      delete json.props.source;
    }

    this.context.styles[json.styleName] = {
      style: json.props.style,
      layerName: layerNameMap[json["import"].layerName]
    };
    return "<" + pascalCase$2(json.styleName) + " " + this.generateProps(json, extraParams) + " >\n    " + generateChildren(json, this.context.baseCodeGen.generate, {
      parent: json
    }) + "\n    </" + pascalCase$2(json.styleName) + ">";
  };

  return ImageCodeGen;
}(LayerCodeGen);

var EllipseCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(EllipseCodeGen, _LayerCodeGen);

  function EllipseCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = EllipseCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    json.props.viewBox = json.props.viewBox.split(' ').map(function (v) {
      return Math.round(parseFloat(v) * 100) / 100;
    }).join(' ');
    this.context.styles[json.styleName] = {
      style: json.props.style,
      layerName: layerNameMap[json["import"].layerName]
    };

    var _json$props = json.props,
        viewBox = _json$props.viewBox,
        style = _json$props.style,
        ellipseProps = _objectWithoutPropertiesLoose(_json$props, ["viewBox", "style"]);

    var ellipseJson = _extends({}, json, {
      props: ellipseProps
    });

    var svgJson = _extends({}, json, {
      props: {
        viewBox: viewBox,
        style: style
      }
    });

    return "<svg " + this.generateProps(svgJson, extraParams) + " style={" + this.generateJSLiteralCode(json.props.style, extraParams) + "}>\n    <ellipse " + this.generateProps(ellipseJson, extraParams) + ">\n      " + generateChildren(json, this.context.baseCodeGen.generate, {
      parent: json
    }) + "\n    </ellipse>\n    </svg>";
  };

  return EllipseCodeGen;
}(LayerCodeGen);

var pascalCase$3 = /*#__PURE__*/require('pascal-case');

var ScrollViewCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(ScrollViewCodeGen, _LayerCodeGen);

  function ScrollViewCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = ScrollViewCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    var _extends2;

    // let layerSpecificStyles = "";
    // layerSpecificStyles += `${this.generateStyle(
    //   json,
    //   extraParams,
    //   "contentContainerStyle"
    // )}`;
    var horizontal = json.props.horizontal;
    var scrollDirection = horizontal ? 'overflowX' : 'overflowY';

    var style = _extends((_extends2 = {}, _extends2[scrollDirection] = 'scroll', _extends2), json.props.style, {
      display: 'flex'
    });

    this.context.styles[json.styleName] = {
      style: style,
      layerName: layerNameMap[json["import"].layerName]
    };
    delete json.props.horizontal;
    return "<" + pascalCase$3(json.styleName) + " " + this.generateProps(json, extraParams) + " >\n      " + generateChildren(json, this.context.baseCodeGen.generate, {
      parent: json
    }) + "\n    </" + pascalCase$3(json.styleName) + ">";
  };

  return ScrollViewCodeGen;
}(LayerCodeGen);

var SymbolLayerCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(SymbolLayerCodeGen, _LayerCodeGen);

  function SymbolLayerCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = SymbolLayerCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    this.context.styles[json.styleName] = {
      style: json.props.style,
      layerName: 'Symbol'
    };
    addImportToContext(this.context, json);
    var tagName = json["import"].layerName;
    return "<" + tagName + " " + this.generateProps(json, extraParams) + " style={" + this.generateJSLiteralCode(json.props.style, extraParams) + "} " + this.generateSymbolOverrideProps(json.scopeVariables, extraParams) + ">\n      " + generateChildren(json, this.context.baseCodeGen.generate, {
      parent: json
    }) + "\n    </" + tagName + ">";
  };

  return SymbolLayerCodeGen;
}(LayerCodeGen);

var pascalCase$4 = /*#__PURE__*/require('pascal-case');

var TextInputCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(TextInputCodeGen, _LayerCodeGen);

  function TextInputCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = TextInputCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    delete json.props.style.fontPostscriptName;

    var textInputStyles = _extends({}, json.props.style, {
      background: 'transparent'
    });

    if (!json.props.style.hasOwnProperty('border') && !json.props.style.hasOwnProperty('borderWidth')) {
      textInputStyles = _extends({}, json.props.style, {
        border: 'none',
        background: 'transparent'
      });
    }

    var _json$props = json.props,
        restProps = _objectWithoutPropertiesLoose(_json$props, ["textBreakStrategy", "clearButtonMode", "dataDetector", "keyboardAppearance"]);

    json.props = _extends({}, restProps);
    this.context.styles[json.styleName] = {
      style: textInputStyles,
      layerName: layerNameMap[json["import"].layerName],
      category: 'TextInput'
    };

    if (lodash.includes(json.props.placeholder, '\n')) {
      json.props.placeholder = lodash.replace(json.props.placeholder, new RegExp('\n', 'g'), ' ');
      json.props.placeholder = lodash.replace(json.props.placeholder, new RegExp('\t', 'g'), ' ');
    }

    delete json.props.value;
    var junk = json.props.placeholderTextColor && delete json.props.placeholderTextColor;
    junk = json.props.selectionColor && delete json.props.selectionColor;
    junk = json.props.underlineColorAndroid && delete json.props.underlineColorAndroid;
    junk = json.props.blurOnSubmit && delete json.props.blurOnSubmit;
    junk = json.props.caretHidden && delete json.props.caretHidden;
    junk = json.props.editable && delete json.props.editable;
    junk = json.props.multiline && delete json.props.multiline;
    junk = json.props.secureTextEntry && delete json.props.secureTextEntry;
    junk = json.props.disableFullscreenUI && delete json.props.disableFullscreenUI;
    junk = json.props.clearTextOnFocus && delete json.props.clearTextOnFocus;
    junk = json.props.enablesReturnKeyAutomatically && delete json.props.enablesReturnKeyAutomatically;
    junk = json.props.keyboardType && delete json.props.keyboardType;
    junk = json.props.returnKeyType && delete json.props.returnKeyType;
    junk = json.props.autoCapitalize && delete json.props.autoCapitalize;
    return "<" + pascalCase$4(json.styleName) + " " + this.generateProps(json, extraParams) + ">\n      " + generateChildren(json, this.context.baseCodeGen.generate, {
      parent: json
    }) + "\n    </" + pascalCase$4(json.styleName) + ">";
  };

  return TextInputCodeGen;
}(LayerCodeGen);

var pascalCase$5 = /*#__PURE__*/require('pascal-case');

var ButtonCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(ButtonCodeGen, _LayerCodeGen);

  function ButtonCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;

    _this.getButtonTag = function (json, extraParams) {
      var suffix = _this.context.buttonDuplicate.lastNumber > 1 ? _this.context.buttonDuplicate.lastNumber : '';
      return "<" + pascalCase$5(json.styleName) + ">\n    <ButtonOverlay" + suffix + " " + _this.generateProps(json, extraParams) + " " + (json.navigateTo && json.navigateTo === 'Go Back' ? "onClick = {() => props.history.goBack()}" : '') + ">\n      " + generateChildren(json, _this.context.baseCodeGen.generate, {
        parent: json
      }) + "\n    </ButtonOverlay" + suffix + ">\n    </" + pascalCase$5(json.styleName) + ">";
    };

    _this.context = context;
    return _this;
  }

  var _proto = ButtonCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    var buttonStyles = _extends({}, json.props.style);

    if (!json.props.style.hasOwnProperty('border') && !json.props.style.hasOwnProperty('borderWidth')) {
      buttonStyles = _extends({}, json.props.style, {
        border: 'none'
      });
    }

    this.context.styles[json.styleName] = {
      style: buttonStyles,
      layerName: layerNameMap[json["import"].layerName]
    };

    if (json.navigateTo && json.navigateTo !== 'Go Back') {
      addImportToContext(this.context, json);
    }

    return "" + (json.navigateTo && json.navigateTo !== 'Go Back' ? "<Link to=\"/" + json.navigateTo + "\">\n            " + this.getButtonTag(json, extraParams) + "\n          </Link>" : this.getButtonTag(json, extraParams));
  };

  return ButtonCodeGen;
}(LayerCodeGen);

var PathCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(PathCodeGen, _LayerCodeGen);

  function PathCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = PathCodeGen.prototype;

  _proto.generateDefs = function generateDefs(json) {
    var defsCode = '';
    var gradId, maskId;
    var gradientCode = '';
    var gradient = json.props.style.gradient;
    delete json.props.style.gradient;

    if (gradient && gradient.gradientType === 'LinearGradient') {
      var x1 = gradient.from.x;
      x1 = typeof x1 === 'number' ? x1 * 100 : parseFloat(x1) * 100;
      var y1 = gradient.from.y;
      y1 = typeof y1 === 'number' ? y1 * 100 : parseFloat(y1) * 100;
      var x2 = gradient.to.x;
      x2 = typeof x2 === 'number' ? x2 * 100 : parseFloat(x2) * 100;
      var y2 = gradient.to.y;
      y2 = typeof y2 === 'number' ? y2 * 100 : parseFloat(y2) * 100;
      gradId = getRandomString(6);
      var linearGradProps = "id=\"" + gradId + "\" x1=\"" + x1 + "%\" x2=\"" + x2 + "%\" y1=\"" + y1 + "%\" y2=\"" + y2 + "%\"";
      var stopsCode = '';
      lodash.forEach(gradient.stops, function (stop) {
        if (typeof stop.offset === 'string') {
          stop.offset = parseFloat(stop.offset);
        }

        stopsCode += "<stop offset=\"" + stop.offset.toFixed(2).toString() + "\" stopColor=\"" + stop.stopColor + "\" />";
      });
      gradientCode = "<linearGradient " + linearGradProps + ">\n      " + stopsCode + "\n      </linearGradient>";
    }

    var maskCode = '';

    if (json.props.mask) {
      var maskPathD = generateSVGPath(json.props.mask, 1, true, json.props.viewBox);
      var maskPathCode = "<path d=\"" + maskPathD + "\" fill=\"white\" />";
      var viewBox = ['0', '0', json.rcDims.width + '', json.rcDims.height + ''];

      if (json.props.viewBox) {
        // TODO: We're getting props.viewBox undeifned in some case which should never happen
        viewBox = json.props.viewBox.split(' ');
      }

      maskId = getRandomString(6);
      maskCode = "<mask id=\"" + maskId + "\" x={0} y={0} width={" + parseInt(viewBox[2], 10) + "} height={" + parseInt(viewBox[3], 10) + "}>\n      " + maskPathCode + "\n      </mask>";
    }

    if (gradientCode || maskCode) {
      defsCode = "<defs>\n    " + gradientCode + "\n    " + maskCode + "\n    </defs>";
    }

    return {
      code: defsCode,
      gradId: gradId,
      maskId: maskId
    };
  };

  _proto.generate = function generate(json, extraParams) {
    json.props.viewBox = json.props.viewBox.split(' ').map(function (v) {
      return Math.round(parseFloat(v) * 100) / 100;
    }).join(' ');
    delete json.props.gradientImage;
    this.context.styles[json.styleName] = {
      style: json.props.style,
      layerName: layerNameMap[json["import"].layerName]
    };

    var _json$props = json.props,
        viewBox = _json$props.viewBox,
        style = _json$props.style,
        points = _json$props.points,
        isClosed = _json$props.isClosed,
        pathProps = _objectWithoutPropertiesLoose(_json$props, ["viewBox", "style", "points", "isClosed"]);

    var svgPath = generateSVGPath(points, json.props.strokeWidth || 0, isClosed, viewBox);

    var pathJson = _extends({}, json, {
      props: _extends({}, pathProps, {
        d: svgPath
      })
    });

    var svgJson = _extends({}, json, {
      props: {
        viewBox: viewBox,
        style: style
      }
    });

    var _this$generateDefs = this.generateDefs(json),
        gradId = _this$generateDefs.gradId,
        maskId = _this$generateDefs.maskId,
        defsCode = _this$generateDefs.code;

    if (gradId) {
      pathJson.props.fill = "url(#" + gradId + ")";
    }

    if (maskId) {
      pathJson.props.mask = "url(#" + maskId + ")";
    }

    return "<svg " + this.generateProps(svgJson, extraParams) + " style={" + this.generateJSLiteralCode(json.props.style, extraParams) + "} >\n    " + defsCode + "\n    <path " + this.generateProps(pathJson, extraParams) + ">\n      " + generateChildren(json, this.context.baseCodeGen.generate, {
      parent: json
    }) + "\n    </path>\n    </svg>";
  };

  return PathCodeGen;
}(LayerCodeGen);

var ExpressionStatementCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(ExpressionStatementCodeGen, _LayerCodeGen);

  function ExpressionStatementCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = ExpressionStatementCodeGen.prototype;

  _proto.getCondtionalASTFromJSON = function getCondtionalASTFromJSON(conditionJSON, fileId) {//
  };

  _proto.generate = function generate(json, extraParams) {
    return this.context.baseCodeGen.generate(json.expression, _extends({}, extraParams, {
      textLiteral: true
    }));
  };

  return ExpressionStatementCodeGen;
}(LayerCodeGen);

var BinaryExpressionCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(BinaryExpressionCodeGen, _LayerCodeGen);

  function BinaryExpressionCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = BinaryExpressionCodeGen.prototype;

  _proto.getCondtionalASTFromJSON = function getCondtionalASTFromJSON(conditionJSON, fileId) {//
  };

  _proto.generate = function generate(json, extraParams) {
    // console.log("In binary expression is ", json);
    if (json.left.expression === 'platform') {
      // console.log("Hanji hai expression to binary");
      this.context.isPlatformConditional = true;
    }

    if (extraParams && extraParams.textLiteral) {
      extraParams.textLiteral = false;
    } // addImportToContext(this.context, {
    //   import: {
    //     isDefaultImport: false,
    //     layerName: "Platform",
    //     packageName: "react-native"
    //   }
    // });


    return "\n      " + this.context.baseCodeGen.generate(json.left, extraParams) + "\n        " + json.operator + "\n        " + this.context.baseCodeGen.generate(json.right, extraParams) + "\n      ";
  };

  return BinaryExpressionCodeGen;
}(LayerCodeGen);

var ExpressionCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(ExpressionCodeGen, _LayerCodeGen);

  function ExpressionCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = ExpressionCodeGen.prototype;

  _proto.getCondtionalASTFromJSON = function getCondtionalASTFromJSON(conditionJSON, fileId) {//
  };

  _proto.generate = function generate(json, extraParams) {
    // console.log("In expression code gen with json as ", json);
    var expression = json.expression; // console.log("Expression in expression statement is ", expression);

    if (expression !== 'platform' && expression.indexOf('.') === -1) {
      this.context.conditionals.push(expression);
    }

    if (expression === 'platform') {
      this.context.isPlatformConditional = true; // addImportToContext(this.context, {
      //   import: {
      //     isDefaultImport: false,
      //     layerName: "Platform",
      //     packageName: "react-native"
      //   }
      // });

      expression = 'Platform.OS';
    } // console.log("Context in expression", this.context);


    return this.generateJSLiteralCode(expression, extraParams, true);
  };

  return ExpressionCodeGen;
}(LayerCodeGen);

var ConditionalExpressionCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(ConditionalExpressionCodeGen, _LayerCodeGen);

  function ConditionalExpressionCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = ConditionalExpressionCodeGen.prototype;

  _proto.getCondtionalASTFromJSON = function getCondtionalASTFromJSON(conditionJSON, fileId) {//
  };

  _proto.generate = function generate(json, extraParams) {
    return this.context.baseCodeGen.generate(json.test, _extends({}, extraParams, {
      textLiteral: false
    })) + " ?\n    " + this.context.baseCodeGen.generate(json.consequent, _extends({}, extraParams, {
      textLiteral: true
    })) + " : " + this.context.baseCodeGen.generate(json.alternate, _extends({}, extraParams, {
      textLiteral: true
    }));
  };

  return ConditionalExpressionCodeGen;
}(LayerCodeGen);

var LogicalExpressionCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(LogicalExpressionCodeGen, _LayerCodeGen);

  function LogicalExpressionCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = LogicalExpressionCodeGen.prototype;

  _proto.getCondtionalASTFromJSON = function getCondtionalASTFromJSON(conditionJSON, fileId) {//
  };

  _proto.generate = function generate(json, extraParams) {
    if (extraParams && extraParams.textLiteral) {
      extraParams.textLiteral = false;
    }

    var leftExp = this.context.baseCodeGen.generate(json.left, extraParams);

    if (leftExp.indexOf('this.props') !== -1) {
      leftExp = leftExp.replace('this.props', 'props');
    }

    var rightExp = this.context.baseCodeGen.generate(json.right, _extends({}, extraParams, {
      textLiteral: true
    }));
    return "\n      (" + leftExp + ")\n      " + json.operator + "\n        (" + rightExp + ")\n      ";
  };

  return LogicalExpressionCodeGen;
}(LayerCodeGen);

var LoopCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(LoopCodeGen, _LayerCodeGen);

  function LoopCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = LoopCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    addImportToContext(this.context, {
      "import": {
        isDefaultImport: false,
        layerName: 'times',
        packageName: 'lodash'
      }
    });
    return " {times(" + json.template.repetitions + ", () =>  " + this.context.baseCodeGen.generate(json.children[0], extraParams) + ")}";
  };

  return LoopCodeGen;
}(LayerCodeGen);

var WrapperCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(WrapperCodeGen, _LayerCodeGen);

  function WrapperCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = WrapperCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    var childrenCode = generateChildren(json, this.context.baseCodeGen.generate, {
      parent: json
    });

    if (json.type === 'row' || json.type === 'column') {
      json.props.style.display = 'flex';
    }

    updateWrapperStyleName(json, extraParams);
    this.context.styles[json.styleName] = {
      style: json.props.style,
      layerName: layerNameMap[json["import"].layerName]
    };
    return "<" + pascalCase$8(json.styleName) + " " + this.generateProps(json, extraParams) + ">\n      " + childrenCode + "\n      </" + pascalCase$8(json.styleName) + ">";
  };

  return WrapperCodeGen;
}(LayerCodeGen);

var InlineViewCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(InlineViewCodeGen, _LayerCodeGen);

  function InlineViewCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = InlineViewCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    return "<div " + this.generateProps(json, extraParams) + " style={" + this.generateJSLiteralCode(json.props.style, extraParams) + "}>\n      " + generateChildren(json, this.context.baseCodeGen.generate, {
      parent: json
    }) + "\n      </div>";
  };

  return InlineViewCodeGen;
}(LayerCodeGen);

var IconCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(IconCodeGen, _LayerCodeGen);

  function IconCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = IconCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    this.context.styles[json.styleName] = {
      style: json.props.style,
      layerName: 'ThirdParty'
    }; // let layerSpecificStyles = "";

    var _json$props = json.props,
        remainingProps = _objectWithoutPropertiesLoose(_json$props, ["type", "name"]); // let iconClass = "";
    // let value = undefined;


    addImportToContext(this.context, json, this.generateJSLiteralCode); // const propsCode = this.generateProps(json, extraParams);
    // let materialChildCode = "";
    // let tagName = `${json.props.type}${pascalCase(json.styleName)} `;

    var currentFamily = getCurrentFamily(json, this.generateJSLiteralCode);

    if (json.props.type) {
      delete json.props.type;
    }

    return "<" + currentFamily + "Icon " + this.generateProps(json, extraParams) + " style={" + this.generateJSLiteralCode(json.props.style, extraParams) + "}>\n    " + generateChildren(json, this.context.baseCodeGen.generate, {
      parent: json
    }) + "\n    </" + currentFamily + "Icon>";
  };

  return IconCodeGen;
}(LayerCodeGen);

var LoaderCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(LoaderCodeGen, _LayerCodeGen);

  function LoaderCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = LoaderCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    this.context.styles[json.styleName] = {
      style: json.props.style,
      layerName: 'ThirdParty'
    };
    addImportToContext(this.context, json);
    return "<CircularProgress style={" + this.generateJSLiteralCode(json.props.style, extraParams) + "}>\n        " + generateChildren(json, this.context.baseCodeGen.generate, {
      parent: json
    }) + "\n        </CircularProgress>";
  };

  return LoaderCodeGen;
}(LayerCodeGen);

var pascalCase$6 = /*#__PURE__*/require('pascal-case');

var MapCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(MapCodeGen, _LayerCodeGen);

  function MapCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = MapCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    addImportToContext(this.context, json);
    this.context.styles[json.styleName] = {
      style: json.props.style,
      layerName: 'div'
    };
    var mapStyle = this.context.mapDuplicate.lastNumber === 1 ? 'GoogleMapReact' : "GoogleMapReact" + this.context.mapDuplicate.lastNumber;
    return "<" + pascalCase$6(json.styleName) + "  >\n          <" + mapStyle + "\n          bootstrapURLKeys={{key:\"YOUR_API_KEY\"}}\n          defaultZoom={4}\n          " + this.generateProps(json, extraParams) + "\n          />\n          " + generateChildren(json, this.context.baseCodeGen.generate, {
      parent: json
    }) + "\n        </" + pascalCase$6(json.styleName) + ">";
  };

  return MapCodeGen;
}(LayerCodeGen);

var SliderCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(SliderCodeGen, _LayerCodeGen);

  function SliderCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = SliderCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    this.context.styles[json.styleName] = {
      style: json.props.style,
      layerName: 'ThirdParty'
    };
    addImportToContext(this.context, json);
    Object.assign(json.props, {
      min: json.props.minimumValue ? json.props.minimumValue : '0'
    });
    Object.assign(json.props, {
      max: json.props.maximumValue ? json.props.maximumValue : '100'
    });
    delete json.props.minimumValue;
    delete json.props.maximumValue;
    return "<Slider defaultValue={50} style={" + this.generateJSLiteralCode(json.props.style, extraParams) + "}/>";
  };

  return SliderCodeGen;
}(LayerCodeGen);

var pascalCase$7 = /*#__PURE__*/require('pascal-case');

var SwitchCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(SwitchCodeGen, _LayerCodeGen);

  function SwitchCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = SwitchCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    this.context.styles[json.styleName] = {
      style: json.props.style,
      layerName: layerNameMap[json["import"].layerName],
      category: 'switch'
    };

    var _json$props = json.props,
        thumbTintColor = _json$props.thumbTintColor,
        remainingProps = _objectWithoutPropertiesLoose(_json$props, ["onTintColor", "tintColor", "value", "thumbTintColor"]);

    json.props = _extends({}, remainingProps, {
      checked: json.props.value
    });
    var tag = this.context.switchDuplicate.lastNumber === 1 ? 'MaterialUISwitch' : "MaterialUISwitch" + this.context.switchDuplicate.lastNumber;
    addImportToContext(this.context, json);
    return "<" + pascalCase$7(json.styleName) + ">\n  <" + tag + "  color=\"primary\" " + this.generateProps(json, extraParams) + " " + (thumbTintColor ? "style={{color:\"" + thumbTintColor + "\"}}" : '') + " >\n  " + generateChildren(json, this.context.baseCodeGen.generate, {
      parent: json
    }) + "\n   </" + tag + ">\n   </" + pascalCase$7(json.styleName) + ">";
  };

  return SwitchCodeGen;
}(LayerCodeGen);

var BaseCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(BaseCodeGen, _LayerCodeGen);

  function BaseCodeGen() {
    var _this;

    _this = _LayerCodeGen.apply(this, arguments) || this;
    _this.context = {
      styles: {},
      imports: {
        react: {
          named: ['Component'],
          "default": 'React',
          cssFile: undefined
        },
        'styled-components': {
          named: ['css'],
          "default": 'styled',
          cssFile: undefined
        }
      },
      filePath: '',
      conditionals: [],
      isPlatformConditional: false,
      fileHasTabView: false,
      baseCodeGen: _assertThisInitialized(_this),
      smartFlexTransformed: false,
      switchDuplicate: {
        isDuplicate: false,
        lastNumber: 1
      },
      mapDuplicate: {
        isDuplicate: false,
        lastNumber: 1
      },
      buttonDuplicate: {
        isDuplicate: false,
        lastNumber: 1,
        exists: false,
        codeGenerated: false
      }
    };
    _this.componentCodeGenMap = new Map(lodash.entries({
      view: DivCodeGen,
      root: DivCodeGen,
      file: FileCodeGen,
      text: TextCodeGen,
      image: ImageCodeGen,
      ellipse: EllipseCodeGen,
      scrollView: ScrollViewCodeGen,
      symbol: SymbolLayerCodeGen,
      textInput: TextInputCodeGen,
      touchableOpacity: ButtonCodeGen,
      path: PathCodeGen,
      literal: LiteralCodeGen,
      // thirdParty: ThirdPartyCodeGen,
      icon: IconCodeGen,
      activityIndicator: LoaderCodeGen,
      mapView: MapCodeGen,
      slider: SliderCodeGen,
      "switch": SwitchCodeGen,
      expressionStatement: ExpressionStatementCodeGen,
      binaryExpression: BinaryExpressionCodeGen,
      expression: ExpressionCodeGen,
      conditionalExpression: ConditionalExpressionCodeGen,
      logicalExpression: LogicalExpressionCodeGen,
      loop: LoopCodeGen,
      stack: WrapperCodeGen,
      row: WrapperCodeGen,
      column: WrapperCodeGen,
      body: WrapperCodeGen,
      flexFiller: WrapperCodeGen,
      inlineView: InlineViewCodeGen
    }));

    _this.generate = function (json, extraParams) {
      if (json.type === 'file') {
        _this.context.buttonDuplicate.exists = false;
        traverseLayersForStyleName(json.layer, _this.context);
        jsonHasButtonLayer(json.layer, _this.context);
      }

      addFlexValuesForScrollViewChildren(extraParams, json);

      var lastSlash = _this.context.filePath.lastIndexOf('/');

      var fileName = _this.context.filePath.substring(lastSlash + 1, _this.context.filePath.length - 3);

      if (json.styleName) {
        if (json.styleName.toLowerCase() === fileName.toLowerCase()) {
          json.styleName = json.styleName + "Style";
        }
      }

      var LayerCodeGenClass = _this.componentCodeGenMap.get(json.type);

      if (json.type === 'statusBar') {
        return '';
      }

      if (json.props) {
        if (json.props.style.hasOwnProperty('borderWidth') && !json.props.style.hasOwnProperty('borderStyle')) {
          json.props.style = _extends({}, json.props.style, {
            borderStyle: 'solid'
          });
        }

        if (json.props.style['position'] === 'absolute' && lodash.get(extraParams, 'parent.type') !== 'root' && lodash.get(extraParams, 'parent.props.style') && !lodash.get(extraParams, 'parent.props.style.position')) {
          extraParams.parent.props.style.position = 'relative';
        }

        if (lodash.get(json, 'props.style.position') !== 'absolute' && lodash.get(extraParams, 'parent.props.style')) {
          extraParams.parent.props.style.display = 'flex';
        }
      }

      var opacity = lodash.get(json, 'props.style.opacity', undefined);

      if (opacity === 1) {
        delete json.props.style.opacity;
      }

      var borderRadius = lodash.get(json, 'props.style.borderRadius', undefined);

      if (borderRadius === 0) {
        delete json.props.style.borderRadius;
      }

      var transform = lodash.get(json, 'props.style.transform', undefined);

      if (transform) {
        var rotation = getRotation(transform);

        if (rotation) {
          json.props.style.transform = "rotate(" + rotation.toFixed(2) + "deg)";
        } else {
          delete json.props.style.transform;
        }
      } // Deleting source_local field for image layer
      // source_local to store local image url


      var sourceLocal = lodash.get(json, 'props.source_local', undefined);

      if (sourceLocal) {
        delete json.props.source_local;
      }

      console.log(json, 'json here');

      if (lodash.get(json, 'template.centerVertical') || lodash.get(json, 'template.centerHorizontal')) {
        var centerCodeGen = new CenterCodeGen(_this.context);
        centerCodeGen.config = _this.config;
        return centerCodeGen.generate(json, extraParams);
      }

      if (LayerCodeGenClass) {
        var layerCodeGen = new LayerCodeGenClass(_this.context);
        layerCodeGen.config = _this.config;
        return layerCodeGen.generate(json, extraParams);
      } else {
        console.error(json.type + ' layer not handled');
      }

      return '';
    };

    return _this;
  }

  return BaseCodeGen;
}(LayerCodeGen);

var ReactEngine = /*#__PURE__*/function () {
  function ReactEngine() {}

  var _proto = ReactEngine.prototype;

  _proto.getFileCode = function getFileCode(fileJSON, config) {
    // console.log(fileJSON, "codeengine*");
    var baseCodeGen = new BaseCodeGen();
    baseCodeGen.config = config;
    var code = baseCodeGen.generate(fileJSON, {
      parent: fileJSON
    }); // TODO: Temporary Fix in case if this.props is still present in the code

    code = code.replace(/this.props/g, 'props');
    code = prettier.format(code, {
      plugins: [prettierBabylon],
      parser: 'babylon'
    });
    return code;
  };

  _proto.getAppFiles = function getAppFiles(files) {
    var router = '';
    var imports = '';
    lodash.forEach(files.artboards, function (artboard, index) {
      if (index === 0) {
        router += "<Route path=\"/\" exact component={" + artboard + "} />";
      }

      router += "<Route path=\"/" + (artboard + '/') + "\" exact component={" + artboard + "} />";
      imports += "import " + artboard + " from \"./screens/" + artboard + "\";";
    });
    var appJSCode = "import React from \"react\";\n    import { BrowserRouter as Router, Route } from \"react-router-dom\";\n    import \"./icons.js\";\n    " + imports + "\n    " + (files.assets.length > 0 ? "import \"./style.css\";" : '') + "\n\n    function App() {\n      return (\n        <Router>\n          <div>\n            " + router + "\n         </div>\n        </Router>\n      );\n    }\n\n    export default App;";
    var styleCSSCode = "";
    lodash.forEach(files.assets, function (asset) {
      var fontName = path.basename(asset, path.extname(asset));
      styleCSSCode += "@font-face {\n        font-family: \"" + fontName + "\";\n        src: url(\"" + asset.replace('/src', '.') + "\") format(\"truetype\");\n      }\n";
    });
    return [{
      path: '/src/App.js',
      content: prettier.format(appJSCode, {
        plugins: [prettierBabylon],
        parser: 'babylon'
      })
    }, {
      path: '/src/style.css',
      content: styleCSSCode
    }];
  };

  _proto.getIndexWithFont = function getIndexWithFont(assets) {
    var indexFileCode = "import React from \"react\";\n    import \"./style.css\";\n    import Index from \"./index.js\";\n    function IndexWithFont() {\n      return (\n        <Index/>\n      );\n    }\n    export default IndexWithFont;";
    var styleCSSCode = "";
    lodash.forEach(assets, function (asset) {
      var fontName = path.basename(asset, path.extname(asset));
      var type = path.extname(asset).substr(1);

      if (type === 'ttf') {
        type = 'truetype';
      }

      styleCSSCode += "@font-face {\n        font-family: \"" + fontName + "\";\n        src: url(\"." + asset + "\") format(\"" + type + "\");\n      }\n";
    });
    return [{
      path: './indexWithFont.js',
      content: prettier.format(indexFileCode, {
        plugins: [prettierBabylon],
        parser: 'babylon'
      })
    }, {
      path: './style.css',
      content: styleCSSCode
    }];
  };

  return ReactEngine;
}();
ReactEngine.engineName = 'react';

var packageJSON = {
  name: 'bx-app',
  version: '0.1.0',
  "private": true,
  dependencies: {
    '@material-ui/core': '^4.2.1',
    'google-map-react': '^1.1.4',
    'material-ui-slider': '^3.0.8',
    'pure-react-carousel': '^1.21.1',
    react: '^16.8.6',
    'react-dom': '^16.8.6',
    'react-list': '^0.8.11',
    'react-router-dom': '^5.0.1',
    'react-scripts': '3.0.1',
    'styled-components': '^4.3.2',
    'react-app-rewired': '2.1.3',
    'react-native-vector-icons': '6.6.0',
    'react-native-web': '0.11.7'
  },
  scripts: {
    start: 'react-app-rewired start',
    build: 'react-app-rewired build',
    test: 'react-app-rewired test',
    eject: 'react-app-rewired eject'
  },
  eslintConfig: {
    "extends": 'react-app'
  },
  browserslist: {
    production: ['>0.2%', 'not dead', 'not op_mini all'],
    development: ['last 1 chrome version', 'last 1 firefox version', 'last 1 safari version']
  }
};
var appTestJS = "import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nit('renders without crashing', () => {\n  const div = document.createElement('div');\n  ReactDOM.render(<App />, div);\n  ReactDOM.unmountComponentAtNode(div);\n});\n";
var indexJS = "import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n";
var indexCSS = "body {\n  margin: 0;\n  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", \"Roboto\", \"Oxygen\",\n    \"Ubuntu\", \"Cantarell\", \"Fira Sans\", \"Droid Sans\", \"Helvetica Neue\",\n    sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\ncode {\n  font-family: source-code-pro, Menlo, Monaco, Consolas, \"Courier New\",\n    monospace;\n}";
var publicManifest = {
  short_name: 'React App',
  name: 'Create React App Sample',
  icons: [{
    src: 'favicon.ico',
    sizes: '64x64 32x32 24x24 16x16',
    type: 'image/x-icon'
  }],
  start_url: '.',
  display: 'standalone',
  theme_color: '#000000',
  background_color: '#ffffff'
};
var serviceWorkerJSContent = "// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (" + '"development" === "production"' + "&& 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = \"./service-worker.js\";\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}";
var indexHTML = "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <link rel=\"shortcut icon\" href=\"%PUBLIC_URL%/favicon.ico\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <meta name=\"theme-color\" content=\"#000000\" />\n    <!--\n      manifest.json provides metadata used when your web app is installed on a\n      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/\n    -->\n    <link rel=\"manifest\" href=\"%PUBLIC_URL%/manifest.json\" />\n    <link\n      href=\"https://unpkg.com/ionicons@4.5.10-1/dist/css/ionicons.min.css\"\n      rel=\"stylesheet\"\n    />\n    <link\n      href=\"https://cdnjs.cloudflare.com/ajax/libs/entypo/2.0/entypo-social.eot\"\n      rel=\"stylesheet\"\n    />\n    <link\n      rel=\"stylesheet\"\n      href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css\"\n    />\n    <link\n      href=\"https://fonts.googleapis.com/icon?family=Material+Icons\"\n      rel=\"stylesheet\"\n    />\n    <link\n      rel=\"stylesheet\"\n      href=\"https://cdn.jsdelivr.net/npm/evil-icons@1.9.0/assets/evil-icons.min.css\"\n    />\n    <script src=\"https://cdn.jsdelivr.net/npm/evil-icons@1.9.0/assets/evil-icons.min.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js\"></script>\n    <link\n      rel=\"stylesheet\"\n      type=\"text/css\"\n      href=\"//at.alicdn.com/t/font_o5hd5vvqpoqiwwmi.css\"\n    />\n    <link\n      href=\"https://cdnjs.cloudflare.com/ajax/libs/octicons/4.4.0/font/octicons.min.css\"\n      rel=\"stylesheet\"\n    />\n    <link\n      href=\"https://cdnjs.cloudflare.com/ajax/libs/simple-line-icons/2.4.1/css/simple-line-icons.css\"\n      rel=\"stylesheet\"\n    />\n    <link\n      href=\"https://cdnjs.cloudflare.com/ajax/libs/css-social-buttons/1.3.0/css/zocial.css\"\n      rel=\"stylesheet\"\n    />\n    <link\n      href=\"https://cdnjs.cloudflare.com/ajax/libs/material-design-icons/3.0.1/iconfont/material-icons.min.css\"\n      rel=\"stylesheet\"\n    />\n    <script src=\"https://code.iconify.design/1/1.0.2/iconify.min.js\"></script>\n    <link\n      href=\"https://cdn.materialdesignicons.com/3.6.95/css/materialdesignicons.min.css\"\n      rel=\"stylesheet\"\n    />\n    <link\n      href=\"https://fonts.googleapis.com/icon?family=Material+Icons\"\n      rel=\"stylesheet\"\n    />\n    <!--\n      Notice the use of %PUBLIC_URL% in the tags above.\n      It will be replaced with the URL of the \"public\" folder during the build.\n      Only files inside the \"public\" folder can be referenced from the HTML.\n      Unlike \"/favicon.ico\" or \"favicon.ico\", \"%PUBLIC_URL%/favicon.ico\" will\n      work correctly both with client-side routing and a non-root public URL.\n      Learn how to configure a non-root public URL by running \"npm run build\".\n    -->\n    <title>React App</title>\n  </head>\n  <body>\n    <noscript>You need to enable JavaScript to run this app.</noscript>\n    <div id=\"root\"></div>\n    <!--\n      This HTML file is a template.\n      If you open it directly in the browser, you will see an empty page.\n      You can add webfonts, meta tags, or analytics to this file.\n      The build step will place the bundled scripts into the <body> tag.\n      To begin the development, run \"npm start\" or \"yarn start\".\n      To create a production bundle, use \"npm run build\" or \"yarn build\".\n    -->\n  </body>\n</html>\n";
var gitIgnoreContent = "# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.\n\n# dependencies\n/node_modules\n/.pnp\n.pnp.js\n\n# testing\n/coverage\n\n# production\n/build\n\n# misc\n.DS_Store\n.env.local\n.env.development.local\n.env.test.local\n.env.production.local\n\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\n"; // tslint:disable: max-line-length

var componentReadme = "This component was created with [BuilderX](https://cloud.builderx.io/).\n\n## BuilderX uses third party libraries for some of the react components such as\n\n```\n@material-ui/core@4.2.1\ngoogle-map-react@1.1.4\nmaterial-ui-slider@3.0.8\npure-react-carousel@1.21.1\nreact-list@0.8.11\nreact-router-dom@5.0.1\nstyled-components@4.3.2\nreact-native-vector-icons\n```\n\nYou can add these packages by running `yarn add [packageName]` or `npm install [packageName]`\n\n## Please add the extracted component folder in your project and import the component folder.\n\nEg import Component from `[folder path]`\n\n**Note: You might need to load custom fonts that has been used in the component. Font files are available in the `assets/fonts` folder.**\n\n- Create style.css at the root of you project\n- Add each font like this\n\n```\n@font-face {\n  font-family: <fontName>;\n  src: url(<relative-path-to-font-file>) format(<file-format>);\n}\n```\n\n- import style.css in your index.js file\n";
var projectReadme = "This project was created with [BuilderX](https://builderx.io/).\n\n## BuilderX uses third party libraries for some of the react components such as\n\n```\n@material-ui/core@4.2.1\ngoogle-map-react@1.1.4\nmaterial-ui-slider@3.0.8\nreact-router-dom@5.0.1\nstyled-components@4.3.2\nreact-native-vector-icons\n```\n\nThese packages are included as dependencies in package.json file.\n\n## Steps to run project\n\nIn the project directory, you can run:\n\n### `yarn` or `npm install`\n\nThis will add the dependencies required to run the project.\n\n### `yarn start` or `npm start`\n\nThis will start the project.\n";
var favicon = "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";
var projectConfig = "const path = require(\"path\");\n\n// eslint-disable-next-line no-unused-vars\nmodule.exports = function override(config, env) {\n  config.module.rules.push({\n    test: /.ttf$/,\n    loader: \"file-loader\",\n    include: path.resolve(__dirname, \"./static/media/[name].[ext]\")\n  });\n\n  return config;\n};\n";
var iconsJS = "/* eslint-disable camelcase */\nimport FontAwesome_ttf from \"react-native-vector-icons/Fonts/FontAwesome.ttf\";\nimport Entypo_ttf from \"react-native-vector-icons/Fonts/Entypo.ttf\";\nimport Octicons_ttf from \"react-native-vector-icons/Fonts/Octicons.ttf\";\nimport SimpleLineIcons_ttf from \"react-native-vector-icons/Fonts/SimpleLineIcons.ttf\";\nimport MaterialIcons_ttf from \"react-native-vector-icons/Fonts/MaterialIcons.ttf\";\nimport EvilIcons_ttf from \"react-native-vector-icons/Fonts/EvilIcons.ttf\";\nimport Feather_ttf from \"react-native-vector-icons/Fonts/Feather.ttf\";\nimport Ionicons_ttf from \"react-native-vector-icons/Fonts/Ionicons.ttf\";\nimport MaterialCommunityIcons_ttf from \"react-native-vector-icons/Fonts/MaterialCommunityIcons.ttf\";\nconst IconsCSS = `\n@font-face {\n  src: url(${FontAwesome_ttf});\n  font-family: FontAwesome;\n}\n@font-face {\n  src: url(${Entypo_ttf});\n  font-family: Entypo;\n}\n@font-face {\n  src: url(${Octicons_ttf});\n  font-family: Octicons;\n}\n@font-face {\n  src: url(${SimpleLineIcons_ttf});\n  font-family: SimpleLineIcons;\n}\n@font-face {\n  src: url(${MaterialIcons_ttf});\n  font-family: MaterialIcons;\n}\n@font-face {\n  src: url(${EvilIcons_ttf});\n  font-family: EvilIcons;\n}\n@font-face {\n  src: url(${Feather_ttf});\n  font-family: Feather;\n}\n@font-face {\n  src: url(${Ionicons_ttf});\n  font-family: Ionicons;\n}\n@font-face {\n  src: url(${MaterialCommunityIcons_ttf});\n  font-family: MaterialCommunityIcons;\n}\n`;\n\nconst style = document.createElement(\"style\");\nstyle.type = \"text/css\";\nif (style.styleSheet) style.styleSheet.cssText = IconsCSS;\nelse style.appendChild(document.createTextNode(IconsCSS));\n\ndocument.head.appendChild(style);\n";

var CRAFiles = {
  __proto__: null,
  packageJSON: packageJSON,
  appTestJS: appTestJS,
  indexJS: indexJS,
  indexCSS: indexCSS,
  publicManifest: publicManifest,
  serviceWorkerJSContent: serviceWorkerJSContent,
  indexHTML: indexHTML,
  gitIgnoreContent: gitIgnoreContent,
  componentReadme: componentReadme,
  projectReadme: projectReadme,
  favicon: favicon,
  projectConfig: projectConfig,
  iconsJS: iconsJS
};

var ReactCodeEngine = function ReactCodeEngine() {
  var _this = this;

  this.reactEngine = new ReactEngine();
  this.meta = {
    name: 'React',
    displayName: 'React',
    icon: 'https://pre-cloud.builderx.io/assets/plugins/component/icons/React.svg'
  };

  this.execute = function (fileJSON, config) {
    return _this.reactEngine.getFileCode(fileJSON, config);
  };

  this.getFiles = function () {
    return CRAFiles;
  };

  this.getFilesToWrite = function () {
    var filesMap = new Map();
    filesMap.set('/package.json', {
      content: JSON.stringify(packageJSON, null, 2)
    });
    filesMap.set('/.gitignore', {
      content: gitIgnoreContent
    });
    filesMap.set('/src/serviceWorker.js', {
      content: serviceWorkerJSContent
    });
    filesMap.set('/src/index.js', {
      content: indexJS
    });
    filesMap.set('/src/index.css', {
      content: indexCSS
    });
    filesMap.set('/src/App.test.js', {
      content: appTestJS
    });
    filesMap.set('/public/index.html', {
      content: indexHTML
    });
    filesMap.set('/public/manifest.json', JSON.stringify(publicManifest, null, 2));
    filesMap.set('/public/favicon.ico', {
      content: favicon,
      config: {
        base64: true
      }
    });
    filesMap.set('/config-overrides.js', {
      content: projectConfig
    });
    filesMap.set('/src/icons.js', {
      content: iconsJS
    });
    filesMap.set('/README.md', {
      content: projectReadme
    });
    return filesMap;
  };

  this.writeFiles = function (zip) {
    zip.file('/package.json', JSON.stringify(packageJSON, null, 2));
    zip.file('/.gitignore', gitIgnoreContent);
    zip.file('/src/serviceWorker.js', serviceWorkerJSContent);
    zip.file('/src/index.js', indexJS);
    zip.file('/src/index.css', indexCSS);
    zip.file('/src/App.test.js', appTestJS);
    zip.file('/public/index.html', indexHTML);
    zip.file('/public/manifest.json', JSON.stringify(publicManifest, null, 2));
    zip.file('/public/favicon.ico', favicon, {
      base64: true
    });
    zip.file('/config-overrides.js', projectConfig);
    zip.file('/src/icons.js', iconsJS);
    zip.file('/README.md', projectReadme);
  };
};

var ReactCodeGen = /*#__PURE__*/function () {
  function ReactCodeGen() {
    this.name = 'ReactCodeGen';
  }

  var _proto = ReactCodeGen.prototype;

  _proto.init = function init(session) {
    this.session = session;
  };

  _proto.activate = function activate() {
    var codeEngine = new ReactCodeEngine();
    this.session.addCodeEngine(codeEngine);
  };

  _proto.deactivate = function deactivate() {};

  _proto.logSession = function logSession() {
    this.session.executeFunction('logSession');
  };

  return ReactCodeGen;
}();

exports.ReactCodeGen = ReactCodeGen;
exports.ReactEngine = ReactEngine;
//# sourceMappingURL=react-plugin.cjs.development.js.map
