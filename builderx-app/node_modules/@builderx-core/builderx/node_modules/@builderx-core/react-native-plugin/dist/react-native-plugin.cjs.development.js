'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var lodash = require('lodash');
var path = require('path');
var prettier = _interopDefault(require('prettier/standalone'));
var prettierBabylon = _interopDefault(require('prettier/parser-babylon'));

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

// import { layerJSON } from "src/AstModule/src/intialState";

var getRandomString = function getRandomString(length) {
  if (length === void 0) {
    length = 6;
  }

  var text = '';
  var possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  text = possible.charAt(Math.floor(Math.random() * 52));

  for (var i = 0; i < length; i++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  }

  return text;
};
var addImportToContext = function addImportToContext(context, layerJSON, generateJSLiteralCode) {
  if (layerJSON["import"].layerName.includes('.')) {
    return;
  } // Write import transformation code after this line


  if (layerJSON["import"].packageName === 'native') {
    layerJSON["import"].packageName = 'react-native';
  } // For backwards compatibility with older version of Expo


  if (layerJSON["import"].layerName === 'MapView') {
    layerJSON["import"].packageName = 'react-native-maps';
    layerJSON["import"].isDefaultImport = true;
  }

  if (layerJSON["import"].packageName === '@builderx/icons' || layerJSON["import"].packageName === 'VectorIcons') {
    if (typeof layerJSON.props.type === 'string') {
      layerJSON["import"].packageName = "react-native-vector-icons/" + layerJSON.props.type;
    } else {
      var currentFamily = getCurrentFamily(layerJSON, generateJSLiteralCode);
      layerJSON["import"].packageName = "react-native-vector-icons/" + currentFamily;
    }
  }

  if (layerJSON.type === 'symbol') {
    if (context.filePath.indexOf('screens') !== -1) {
      layerJSON["import"].packageName = "../components/" + layerJSON["import"].layerName;
    } else if (context.filePath.indexOf('preview') !== -1) {
      layerJSON["import"].packageName = "./components/" + layerJSON["import"].layerName;
    } else if (context.filePath.indexOf('symbols') !== -1 || context.filePath.indexOf('components') !== -1) {
      layerJSON["import"].packageName = "./" + layerJSON["import"].layerName;
    }
  }

  if (!context.imports[layerJSON["import"].packageName]) {
    context.imports[layerJSON["import"].packageName] = {
      named: [],
      "default": false
    };
  }

  var contextImportObj = context.imports[layerJSON["import"].packageName];

  if (layerJSON["import"].isDefaultImport) {
    if (layerJSON["import"].packageName.indexOf('react-native-vector-icons') !== -1 && context.iconCount > 1) {
      var _currentFamily = getCurrentFamily(layerJSON, generateJSLiteralCode);

      contextImportObj["default"] = "" + _currentFamily + layerJSON["import"].layerName;
    } else {
      contextImportObj["default"] = layerJSON["import"].layerName;
    }
  } else if (layerJSON["import"].layerName === 'Image' && layerJSON["import"].packageName === 'react-native-svg') {
    context.imports[layerJSON["import"].packageName] = {
      named: [{
        name: layerJSON["import"].layerName,
        asName: layerJSON["import"].asName
      }],
      "default": false
    };
  } else {
    if (contextImportObj.named.indexOf(layerJSON["import"].layerName) === -1) {
      contextImportObj.named.push(layerJSON["import"].layerName);
    }
  }
};
var isTabViewSpecificStyleProp = function isTabViewSpecificStyleProp(propName) {
  return ['tabBarStyle', 'indicatorStyle', 'labelStyle', 'tabStyle'].indexOf(propName) !== -1;
};
var escapeTextForJSX = function escapeTextForJSX(text) {
  if (typeof text === 'string') {
    text = text.trim();
    text = lodash.escape(text);
  }

  if (lodash.includes(text, '\n')) {
    text = lodash.replace(text, new RegExp('\n', 'g'), "{\"\\n\"}");
    text = lodash.replace(text, new RegExp('\t', 'g'), "{\"\\t\"}");
  }

  return text;
};
var getIconCount = function getIconCount(context, layer) {
  if (!layer) {
    return 0;
  }

  layer.children.forEach(function (child) {
    if (lodash.get(child, 'children', 0) && child.children.length !== 0) {
      getIconCount(context, child);
    }

    if (lodash.get(child, 'import.layerName', 0) && child["import"].layerName === 'Icon') {
      context.iconCount = context.iconCount + 1;
    }
  });
  return context.iconCount;
}; // export const hasDuplicateLayers = (layer: any) => {
//   let hasDuplicatechildren = false;
//   layer.children.forEach((child: any) => {
//     let currentStyleName = child.styleName;
//     layer.children.forEach((innerChild: any) => {
//       if (child !== innerChild) {
//         if (innerChild.styleName === currentStyleName) {
//         }
//       }
//     });
//   });
// };

var getCurrentFamily = function getCurrentFamily(layerJSON, generateJSLiteralCode) {
  var conditionalStatement = generateJSLiteralCode(layerJSON.props.type);
  var currentFamily = '';
  var families = ['Entypo', 'EvilIcons', 'Feather', 'FontAwesome', 'MaterialIcons', 'MaterialCommunityIcons', 'SimpleLineIcons', 'Octicons', 'Zocial', 'Ionicons'];

  for (var i = 0; i < families.length; i++) {
    if (conditionalStatement.indexOf(families[i]) !== -1) {
      currentFamily = families[i];
      break;
    }
  }

  return currentFamily;
};
var isButtonLayer = function isButtonLayer(layer) {
  if (layer.type === 'touchableOpacity' && layer.hasOwnProperty('navigateTo')) {
    return true;
  }

  return false;
};
function getFilteredImageStyle(style) {
  var filteredImageStyle = {};

  if ((style.borderWidth || style.borderLeftWidth || style.borderRightWidth) && style.width) {
    var borderRightWidth = style.borderRightWidth ? style.borderRightWidth : style.borderWidth ? style.borderWidth : 0;
    var borderLeftWidth = style.borderLeftWidth ? style.borderLeftWidth : style.borderWidth ? style.borderWidth : 0;
    filteredImageStyle.width = style.width - (borderRightWidth + borderLeftWidth);
  }

  if ((style.borderWidth || style.borderTopWidth || style.borderBottomWidth) && style.height) {
    var borderTopWidth = style.borderTopWidth ? style.borderTopWidth : style.borderWidth ? style.borderWidth : 0;
    var borderBottomWidth = style.borderBottomWidth ? style.borderBottomWidth : style.borderWidth ? style.borderWidth : 0;
    filteredImageStyle.height = style.height - (borderTopWidth + borderBottomWidth);
  }

  if (style.borderRadius || style.borderTopLeftRadius || style.borderTopRightRadius || style.borderBottomRightRadius || style.borderBottomLeftRadius) {
    style.overflow = 'hidden';
  }

  if (style.opacity) {
    filteredImageStyle.opacity = style.opacity;
    delete style.opacity;
  }

  return filteredImageStyle;
}

var MapStyles = {
  Standard: [],
  Silver: [{
    elementType: 'geometry',
    stylers: [{
      color: '#f5f5f5'
    }]
  }, {
    elementType: 'labels.icon',
    stylers: [{
      visibility: 'off'
    }]
  }, {
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#616161'
    }]
  }, {
    elementType: 'labels.text.stroke',
    stylers: [{
      color: '#f5f5f5'
    }]
  }, {
    featureType: 'administrative.land_parcel',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#bdbdbd'
    }]
  }, {
    featureType: 'poi',
    elementType: 'geometry',
    stylers: [{
      color: '#eeeeee'
    }]
  }, {
    featureType: 'poi',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#757575'
    }]
  }, {
    featureType: 'poi.park',
    elementType: 'geometry',
    stylers: [{
      color: '#e5e5e5'
    }]
  }, {
    featureType: 'poi.park',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#9e9e9e'
    }]
  }, {
    featureType: 'road',
    elementType: 'geometry',
    stylers: [{
      color: '#ffffff'
    }]
  }, {
    featureType: 'road.arterial',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#757575'
    }]
  }, {
    featureType: 'road.highway',
    elementType: 'geometry',
    stylers: [{
      color: '#dadada'
    }]
  }, {
    featureType: 'road.highway',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#616161'
    }]
  }, {
    featureType: 'road.local',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#9e9e9e'
    }]
  }, {
    featureType: 'transit.line',
    elementType: 'geometry',
    stylers: [{
      color: '#e5e5e5'
    }]
  }, {
    featureType: 'transit.station',
    elementType: 'geometry',
    stylers: [{
      color: '#eeeeee'
    }]
  }, {
    featureType: 'water',
    elementType: 'geometry',
    stylers: [{
      color: '#c9c9c9'
    }]
  }, {
    featureType: 'water',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#9e9e9e'
    }]
  }],
  Retro: [{
    elementType: 'geometry',
    stylers: [{
      color: '#ebe3cd'
    }]
  }, {
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#523735'
    }]
  }, {
    elementType: 'labels.text.stroke',
    stylers: [{
      color: '#f5f1e6'
    }]
  }, {
    featureType: 'administrative',
    elementType: 'geometry.stroke',
    stylers: [{
      color: '#c9b2a6'
    }]
  }, {
    featureType: 'administrative.land_parcel',
    elementType: 'geometry.stroke',
    stylers: [{
      color: '#dcd2be'
    }]
  }, {
    featureType: 'administrative.land_parcel',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#ae9e90'
    }]
  }, {
    featureType: 'landscape.natural',
    elementType: 'geometry',
    stylers: [{
      color: '#dfd2ae'
    }]
  }, {
    featureType: 'poi',
    elementType: 'geometry',
    stylers: [{
      color: '#dfd2ae'
    }]
  }, {
    featureType: 'poi',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#93817c'
    }]
  }, {
    featureType: 'poi.park',
    elementType: 'geometry.fill',
    stylers: [{
      color: '#a5b076'
    }]
  }, {
    featureType: 'poi.park',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#447530'
    }]
  }, {
    featureType: 'road',
    elementType: 'geometry',
    stylers: [{
      color: '#f5f1e6'
    }]
  }, {
    featureType: 'road.arterial',
    elementType: 'geometry',
    stylers: [{
      color: '#fdfcf8'
    }]
  }, {
    featureType: 'road.highway',
    elementType: 'geometry',
    stylers: [{
      color: '#f8c967'
    }]
  }, {
    featureType: 'road.highway',
    elementType: 'geometry.stroke',
    stylers: [{
      color: '#e9bc62'
    }]
  }, {
    featureType: 'road.highway.controlled_access',
    elementType: 'geometry',
    stylers: [{
      color: '#e98d58'
    }]
  }, {
    featureType: 'road.highway.controlled_access',
    elementType: 'geometry.stroke',
    stylers: [{
      color: '#db8555'
    }]
  }, {
    featureType: 'road.local',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#806b63'
    }]
  }, {
    featureType: 'transit.line',
    elementType: 'geometry',
    stylers: [{
      color: '#dfd2ae'
    }]
  }, {
    featureType: 'transit.line',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#8f7d77'
    }]
  }, {
    featureType: 'transit.line',
    elementType: 'labels.text.stroke',
    stylers: [{
      color: '#ebe3cd'
    }]
  }, {
    featureType: 'transit.station',
    elementType: 'geometry',
    stylers: [{
      color: '#dfd2ae'
    }]
  }, {
    featureType: 'water',
    elementType: 'geometry.fill',
    stylers: [{
      color: '#b9d3c2'
    }]
  }, {
    featureType: 'water',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#92998d'
    }]
  }],
  Dark: [{
    elementType: 'geometry',
    stylers: [{
      color: '#212121'
    }]
  }, {
    elementType: 'labels.icon',
    stylers: [{
      visibility: 'off'
    }]
  }, {
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#757575'
    }]
  }, {
    elementType: 'labels.text.stroke',
    stylers: [{
      color: '#212121'
    }]
  }, {
    featureType: 'administrative',
    elementType: 'geometry',
    stylers: [{
      color: '#757575'
    }]
  }, {
    featureType: 'administrative.country',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#9e9e9e'
    }]
  }, {
    featureType: 'administrative.land_parcel',
    stylers: [{
      visibility: 'off'
    }]
  }, {
    featureType: 'administrative.locality',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#bdbdbd'
    }]
  }, {
    featureType: 'poi',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#757575'
    }]
  }, {
    featureType: 'poi.park',
    elementType: 'geometry',
    stylers: [{
      color: '#181818'
    }]
  }, {
    featureType: 'poi.park',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#616161'
    }]
  }, {
    featureType: 'poi.park',
    elementType: 'labels.text.stroke',
    stylers: [{
      color: '#1b1b1b'
    }]
  }, {
    featureType: 'road',
    elementType: 'geometry.fill',
    stylers: [{
      color: '#2c2c2c'
    }]
  }, {
    featureType: 'road',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#8a8a8a'
    }]
  }, {
    featureType: 'road.arterial',
    elementType: 'geometry',
    stylers: [{
      color: '#373737'
    }]
  }, {
    featureType: 'road.highway',
    elementType: 'geometry',
    stylers: [{
      color: '#3c3c3c'
    }]
  }, {
    featureType: 'road.highway.controlled_access',
    elementType: 'geometry',
    stylers: [{
      color: '#4e4e4e'
    }]
  }, {
    featureType: 'road.local',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#616161'
    }]
  }, {
    featureType: 'transit',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#757575'
    }]
  }, {
    featureType: 'water',
    elementType: 'geometry',
    stylers: [{
      color: '#000000'
    }]
  }, {
    featureType: 'water',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#3d3d3d'
    }]
  }],
  Night: [{
    elementType: 'geometry',
    stylers: [{
      color: '#242f3e'
    }]
  }, {
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#746855'
    }]
  }, {
    elementType: 'labels.text.stroke',
    stylers: [{
      color: '#242f3e'
    }]
  }, {
    featureType: 'administrative.locality',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#d59563'
    }]
  }, {
    featureType: 'poi',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#d59563'
    }]
  }, {
    featureType: 'poi.park',
    elementType: 'geometry',
    stylers: [{
      color: '#263c3f'
    }]
  }, {
    featureType: 'poi.park',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#6b9a76'
    }]
  }, {
    featureType: 'road',
    elementType: 'geometry',
    stylers: [{
      color: '#38414e'
    }]
  }, {
    featureType: 'road',
    elementType: 'geometry.stroke',
    stylers: [{
      color: '#212a37'
    }]
  }, {
    featureType: 'road',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#9ca5b3'
    }]
  }, {
    featureType: 'road.highway',
    elementType: 'geometry',
    stylers: [{
      color: '#746855'
    }]
  }, {
    featureType: 'road.highway',
    elementType: 'geometry.stroke',
    stylers: [{
      color: '#1f2835'
    }]
  }, {
    featureType: 'road.highway',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#f3d19c'
    }]
  }, {
    featureType: 'transit',
    elementType: 'geometry',
    stylers: [{
      color: '#2f3948'
    }]
  }, {
    featureType: 'transit.station',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#d59563'
    }]
  }, {
    featureType: 'water',
    elementType: 'geometry',
    stylers: [{
      color: '#17263c'
    }]
  }, {
    featureType: 'water',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#515c6d'
    }]
  }, {
    featureType: 'water',
    elementType: 'labels.text.stroke',
    stylers: [{
      color: '#17263c'
    }]
  }],
  Aubergine: [{
    elementType: 'geometry',
    stylers: [{
      color: '#1d2c4d'
    }]
  }, {
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#8ec3b9'
    }]
  }, {
    elementType: 'labels.text.stroke',
    stylers: [{
      color: '#1a3646'
    }]
  }, {
    featureType: 'administrative.country',
    elementType: 'geometry.stroke',
    stylers: [{
      color: '#4b6878'
    }]
  }, {
    featureType: 'administrative.land_parcel',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#64779e'
    }]
  }, {
    featureType: 'administrative.province',
    elementType: 'geometry.stroke',
    stylers: [{
      color: '#4b6878'
    }]
  }, {
    featureType: 'landscape.man_made',
    elementType: 'geometry.stroke',
    stylers: [{
      color: '#334e87'
    }]
  }, {
    featureType: 'landscape.natural',
    elementType: 'geometry',
    stylers: [{
      color: '#023e58'
    }]
  }, {
    featureType: 'poi',
    elementType: 'geometry',
    stylers: [{
      color: '#283d6a'
    }]
  }, {
    featureType: 'poi',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#6f9ba5'
    }]
  }, {
    featureType: 'poi',
    elementType: 'labels.text.stroke',
    stylers: [{
      color: '#1d2c4d'
    }]
  }, {
    featureType: 'poi.park',
    elementType: 'geometry.fill',
    stylers: [{
      color: '#023e58'
    }]
  }, {
    featureType: 'poi.park',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#3C7680'
    }]
  }, {
    featureType: 'road',
    elementType: 'geometry',
    stylers: [{
      color: '#304a7d'
    }]
  }, {
    featureType: 'road',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#98a5be'
    }]
  }, {
    featureType: 'road',
    elementType: 'labels.text.stroke',
    stylers: [{
      color: '#1d2c4d'
    }]
  }, {
    featureType: 'road.highway',
    elementType: 'geometry',
    stylers: [{
      color: '#2c6675'
    }]
  }, {
    featureType: 'road.highway',
    elementType: 'geometry.stroke',
    stylers: [{
      color: '#255763'
    }]
  }, {
    featureType: 'road.highway',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#b0d5ce'
    }]
  }, {
    featureType: 'road.highway',
    elementType: 'labels.text.stroke',
    stylers: [{
      color: '#023e58'
    }]
  }, {
    featureType: 'transit',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#98a5be'
    }]
  }, {
    featureType: 'transit',
    elementType: 'labels.text.stroke',
    stylers: [{
      color: '#1d2c4d'
    }]
  }, {
    featureType: 'transit.line',
    elementType: 'geometry.fill',
    stylers: [{
      color: '#283d6a'
    }]
  }, {
    featureType: 'transit.station',
    elementType: 'geometry',
    stylers: [{
      color: '#3a4762'
    }]
  }, {
    featureType: 'water',
    elementType: 'geometry',
    stylers: [{
      color: '#0e1626'
    }]
  }, {
    featureType: 'water',
    elementType: 'labels.text.fill',
    stylers: [{
      color: '#4e6d70'
    }]
  }]
};

var MARGIN_PROPERTIES = ['margin', 'marginBottom', 'marginHorizontal', 'marginLeft', 'marginRight', 'marginTop', 'marginVertical'];
var ROUNDABLE_LAYOUT_PROPERTIES = /*#__PURE__*/['bottom', 'fontSize', 'height', 'left', 'maxHeight', 'maxWidth', 'minHeight', 'minWidth', 'padding', 'paddingBottom', 'paddingHorizontal', 'paddingLeft', 'paddingRight', 'paddingTop', 'paddingVertical', 'right', 'width', 'top'].concat(MARGIN_PROPERTIES);
var ROUNDABLE_TO_TWO_DECIMALS_LAYOUT_PROPERTIES = ['flex'];

var LayerCodeGen = /*#__PURE__*/function () {
  function LayerCodeGen() {
    var _this = this;

    this.generateChildren = function (layer, extraParams) {
      var childrenCode = '';
      layer.children.forEach(function (child) {
        if (['expressionStatement', 'binaryExpression', 'expression', 'conditionalExpression', 'logicalExpression'].includes(child.type)) {
          childrenCode += "{" + _this.context.baseCodeGen.generate(child, extraParams) + "\n      }";
        } else {
          childrenCode += _this.context.baseCodeGen.generate(child, extraParams) + "\n      ";
        }
      });
      return childrenCode;
    };

    this.generateProps = function (json, extraParams) {
      var propsCode = '';

      if (json.props) {
        if (json["import"].layerName === 'FlatList') {
          json.props = _extends({}, json.props, {
            data: [{}, {}]
          });
        }

        lodash.forEach(json.props, function (propValue, propName) {
          if (propName === 'onPress') {
            if (typeof propValue === 'string') {
              propsCode = propName + "={" + propValue.replace(/;/g, '') + "}";
            } else {
              // TODO: Handle conditional navigation
              propsCode += '/* Conditional navigation not supported at the moment */';
            } // TODO: check for all callback props

          } else if (lodash.get(json, 'import.layerName') === 'FlatList' && propName === 'renderItem') {
            propsCode += propName + "={({ item, separators }) => " + _this.context.baseCodeGen.generate(propValue, extraParams) + "}";
          } else if (lodash.get(json, 'import.layerName') === 'FlatList' && (propName === 'ListHeaderComponent' || propName === 'ListFooterComponent' || propName === 'ItemSeparatorComponent')) {
            propsCode += propName + "={() => " + _this.context.baseCodeGen.generate(propValue, extraParams) + "}";
          } else if (lodash.get(json, 'import.layerName') === 'Switch' && (propName === 'onTintColor' || propName === 'tintColor')) {
            var onOffColorCode = '';

            if (lodash.get(json, 'props.onTintColor')) {
              onOffColorCode += "true: " + _this.generateJSLiteralCode(lodash.get(json, 'props.onTintColor'), extraParams) + ",";
            }

            if (lodash.get(json, 'props.tintColor')) {
              onOffColorCode += "false: " + _this.generateJSLiteralCode(lodash.get(json, 'props.tintColor'), extraParams);
            }

            delete lodash.get(json, 'props', {}).onTintColor;
            delete lodash.get(json, 'props', {}).tintColor;

            if (onOffColorCode) {
              propsCode += "trackColor={{" + onOffColorCode + "}}";
            }
          } else if (lodash.get(json, 'import.layerName') === 'Switch' && propName === 'thumbTintColor') {
            if (propValue) {
              if (typeof propValue === 'string') {
                propsCode += "thumbColor=" + _this.generateJSLiteralCode(propValue, extraParams);
              } else {
                propsCode += "thumbColor={" + _this.generateJSLiteralCode(propValue, extraParams) + "}";
              }
            }
          } else if (lodash.get(json, 'import.layerName') === 'MapView' && propName === 'provider') {
            propsCode += propName + "={" + _this.generateJSLiteralCode(propValue, extraParams, true) + "}";
          } else if (propName === 'source') {
            propsCode += _this.generateSourcePropCode(path.basename(propValue.uri));
          } else if (lodash.get(json, 'import.layerName') === 'MapView' && propName === 'customMapStyle') {
            propValue = MapStyles[propValue];
            propsCode += propName + "={" + _this.generateJSLiteralCode(propValue, extraParams) + "}";
          } else if (lodash.get(json, 'import.layerName') === 'Icon' && propName === 'type') ; else if (!isTabViewSpecificStyleProp(propName) && propName !== 'style' && propName !== 'contentContainerStyle' && propName !== 'imageStyle') {
            if (typeof propValue === 'string') {
              propsCode += propName + "=" + _this.generateJSLiteralCode(propValue, extraParams);
            } else {
              var ellipseProps = ['cx', 'cy', 'rx', 'ry'];

              if (ellipseProps.includes(propName)) {
                propValue = lodash.round(propValue);
              }

              propsCode += propName + "={" + _this.generateJSLiteralCode(propValue, extraParams) + "}";
            }
          }
        });
      }

      return propsCode;
    };

    this.generateStyle = function (json, extraParams, stylePropName) {
      if (stylePropName === void 0) {
        stylePropName = 'style';
      }

      if (lodash.get(json, 'import.layerName') === 'Picker.Item') {
        return '';
      }

      var style = lodash.get(json, "props." + stylePropName, {}); // if (stylePropName === "imageStyle" && Object.keys(style).length === 0) {
      //   return "";
      // }
      // if (
      //   json.type === "root" &&
      //   this.context.filePath.indexOf("symbols") !== -1
      // ) {
      //   delete json.props.style.flex;
      // }
      // if (json.type === "text") {
      //   json.props.style.fontFamily
      //     ? json.props.style.fontFamily
      //     : delete json.props.style.fontFamily;
      // }

      var conditionalStyles = {};
      lodash.forEach(style, function (styleValue, styleProperty) {
        if (styleValue && ['expressionStatement', 'binaryExpression', 'expression', 'conditionalExpression', 'logicalExpression'].includes(styleValue.type)) {
          conditionalStyles[styleProperty] = _this.context.baseCodeGen.generate(styleValue, extraParams);
          delete _this.context.styles[json.styleName][styleProperty];
        }
      });

      if (Object.keys(conditionalStyles).length !== 0) {
        var conditionalStyleObjCode = '';
        lodash.forEach(conditionalStyles, function (code, styleProperty) {
          return conditionalStyleObjCode += styleProperty + ": " + code + ",";
        });
        return stylePropName + "={[\n        styles." + json.styleName + (stylePropName !== 'style' ? '_' + stylePropName : '') + ",\n        {\n          " + conditionalStyleObjCode + "\n        }\n      ]}";
      }

      if (json.type === 'root' && (_this.context.filePath.indexOf('symbols') !== -1 || _this.context.filePath.indexOf('components') !== -1)) {
        return stylePropName + "={[styles." + json.styleName + ",props.style]" + (stylePropName !== 'style' ? '_' + stylePropName : '') + "}";
      }

      return stylePropName + "={styles." + json.styleName + (stylePropName !== 'style' ? '_' + stylePropName : '') + "}";
    };

    this.generateJSLiteralCode = function (literal, extraParams, jsExpression) {
      if (jsExpression === void 0) {
        jsExpression = false;
      }

      var code = '';
      var literalType = typeof literal;

      if (literal === null) {
        literalType = literal; // Handle null literal, otherwise it takes type object
      }

      if (Array.isArray(literal)) {
        literalType = 'array';
      }

      switch (literalType) {
        case 'object':
          // TODO:if is not handelled
          if (['expressionStatement', 'binaryExpression', 'expression', 'conditionalExpression', 'logicalExpression'].includes(literal.type)) {
            code = _this.context.baseCodeGen.generate(literal, extraParams);
          } else {
            code = "" + _this.generateJSObjectCode(literal, extraParams);
          }

          break;

        case 'array':
          code = "" + _this.generateJSArrayCode(literal, extraParams);
          break;

        case 'boolean':
          code = "" + literal;
          break;

        case 'number':
          code = String(literal); // TODO: consider setValueinInt

          break;

        case 'string':
        default:
          if (jsExpression) {
            code = "" + literal;
          } else {
            code = "\"" + literal + "\"";
          }

      }

      return code;
    };

    this.generateJSObjectCode = function (obj, extraParams) {
      var code = '';

      if (obj.hasOwnProperty('display') && obj['display'] === 'none') {
        var _obj = obj,
            restObj = _objectWithoutPropertiesLoose(_obj, ["height", "width", "display", "opacity"]);

        obj = _extends({}, restObj, {
          height: 0,
          width: 0,
          opacity: 0
        });
      }

      lodash.forEach(obj, function (value, key) {
        if (value !== undefined) {
          if (ROUNDABLE_LAYOUT_PROPERTIES.includes(key)) {
            if (typeof value === 'number') {
              value = Math.round(value);
            } else if (typeof value === 'string' && value.includes('%')) {
              // For percentage values
              var numValue = parseFloat(value.replace('%', ''));
              numValue = Math.round(numValue * 100) / 100;
              value = numValue + '%';
            }
          } else if (ROUNDABLE_TO_TWO_DECIMALS_LAYOUT_PROPERTIES.includes(key)) {
            if (typeof value === 'number') {
              value = Math.round(value * 100) / 100;
            }
          }

          code += key + ": " + _this.generateJSLiteralCode(value, extraParams) + ",\n        ";
        }
      });
      return "{\n      " + code + "\n    }";
    };

    this.generateJSArrayCode = function (obj, extraParams) {
      var code = '';
      obj.forEach(function (value) {
        code += _this.generateJSLiteralCode(value, extraParams) + ",\n      ";
      });
      return "[\n      " + code + "\n    ]";
    };
  }

  var _proto = LayerCodeGen.prototype;

  _proto.generateSymbolOverrideProps = function generateSymbolOverrideProps(scopeVariables, extraParams) {
    var _this2 = this;

    var code = '';
    lodash.forEach(scopeVariables, function (value, key) {
      if (typeof value === 'string') {
        code += key.replace('this.props.', '') + "=" + _this2.generateJSLiteralCode(value, extraParams);
      } else {
        code += key.replace('this.props.', '') + "={" + _this2.generateJSLiteralCode(value, extraParams) + "}";
      }
    });
    return code;
  };

  _proto.generateSourcePropCode = function generateSourcePropCode(imageName, category) {
    var assetsRelativePath = this.config.isPreviewFile ? './assets/images/' : '../assets/images/';

    if (category === 'svgImage') {
      return "" + assetsRelativePath + imageName;
    }

    return "source={require(\"" + assetsRelativePath + imageName + "\")}";
  };

  return LayerCodeGen;
}();

var ViewCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(ViewCodeGen, _LayerCodeGen);

  function ViewCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = ViewCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    var newParams = _extends({}, extraParams, {
      parent: json
    });

    this.context.styles[json.styleName] = json.props.style;
    addImportToContext(this.context, json);
    var layerStylePropCode = this.generateStyle(json, newParams);

    if (json.props.style.gradient) {
      delete json.props.style.gradient;
      json.props.imageStyle = getFilteredImageStyle(json.props.style);
      this.context.styles[json.styleName + "_imageStyle"] = json.props.imageStyle;
      layerStylePropCode += " " + this.generateStyle(json, _extends({}, extraParams, {
        parent: json
      }), 'imageStyle');
      addImportToContext(this.context, {
        "import": {
          isDefaultImport: false,
          layerName: 'ImageBackground',
          packageName: 'react-native'
        }
      });
      delete json.props.style['backgroundImage'];
      var width = lodash.get(json, 'props.style.width');
      var height = lodash.get(json, 'props.style.height');
      var gradientImage = json.props.gradientImage;
      delete json.props.gradientImage;

      if (height && typeof height === 'string' && height.includes('%') || width && typeof width === 'string' && width.includes('%')) {
        return "<View style={[" + this.generateJSLiteralCode(json.props.style, newParams) + ", {overflow:\"hidden\"}]} >\n          <ImageBackground " + this.generateProps(json, newParams) + " style={{width: \"100%\", height: \"100%\"}} " + this.generateStyle(json, _extends({}, extraParams, {
          parent: json
        }), 'imageStyle') + " " + this.generateSourcePropCode(gradientImage) + ">" + this.generateChildren(json, newParams) + "</ImageBackground>\n        </View>";
      }

      return "<ImageBackground " + this.generateProps(json, newParams) + "  " + layerStylePropCode + " " + this.generateSourcePropCode(gradientImage) + ">" + this.generateChildren(json, newParams) + "</ImageBackground>";
    } else {
      return "<View " + this.generateProps(json, newParams) + " " + layerStylePropCode + ">\n      " + this.generateChildren(json, newParams) + "\n      </View>";
    }
  };

  return ViewCodeGen;
}(LayerCodeGen);

var FileCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(FileCodeGen, _LayerCodeGen);

  function FileCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;

    _this.isNavigatingButton = function (json) {
      var hasButtonLayer = false;
      json.layer.children.forEach(function (child) {
        if (isButtonLayer(child)) {
          hasButtonLayer = true;
        }
      });
      return hasButtonLayer;
    };

    _this.isFileComponent = function () {
      if (_this.context.filePath.indexOf('component') !== -1 || _this.context.filePath.indexOf('symbol') !== -1) {
        return true;
      }

      return false;
    };

    _this.includeProps = function (json) {
      return _this.isFileComponent() || _this.isNavigatingButton(json);
    };

    _this.context = context;
    return _this;
  }

  var _proto = FileCodeGen.prototype;

  _proto.generateStyleNames = function generateStyleNames(extraParams) {
    return this.generateJSLiteralCode(this.context.styles, extraParams);
  };

  _proto.generateConditionalVariables = function generateConditionalVariables() {
    var conditionalVariables = '';

    for (var i = 0; i < this.context.conditionals.length; i++) {
      conditionalVariables += "let " + this.context.conditionals[i] + "=true;";
    }

    return conditionalVariables;
  };

  _proto.generateImports = function generateImports() {
    var importsCode = '';
    lodash.forEach(this.context.imports, function (importObj, packageName) {
      var defaultImportCode = '';

      if (importObj["default"]) {
        defaultImportCode = importObj.named.length > 0 ? importObj["default"] + "," : importObj["default"];
      }

      var namedImportsCode = '';
      lodash.forEach(importObj.named, function (layerName, index) {
        if (index === 0) {
          namedImportsCode += '{ ';
        }

        if (typeof layerName === 'object') {
          if (layerName.hasOwnProperty('name') && layerName.hasOwnProperty('asName')) {
            namedImportsCode += layerName.name + " as " + layerName.asName + ",";
          }
        } else {
          namedImportsCode += layerName + ", ";
        }

        if (index === importObj.named.length - 1) {
          namedImportsCode += '}';
        }
      });

      if (importObj.named.length > 0 || importObj["default"]) {
        importsCode += "import " + defaultImportCode + " " + namedImportsCode + " from \"" + packageName + "\";\n        ";
      }
    });
    return importsCode;
  };

  _proto.generate = function generate(json, extraParams) {
    var className = json.path;
    className = className.substring(className.lastIndexOf('/') + 1, className.lastIndexOf('.'));
    this.context.filePath = json.path;
    var layersCode = this.context.baseCodeGen.generate(json.layer, _extends({}, extraParams, {
      parent: json
    }));
    return this.generateImports() + "\n      " + this.generateConditionalVariables() + "\n    function " + className + "(props) {\n        return " + layersCode + ";\n    }\n\n    const styles = StyleSheet.create(" + this.generateStyleNames(extraParams) + ");\n\n    export default " + className;
  };

  return FileCodeGen;
}(LayerCodeGen);

var LiteralCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(LiteralCodeGen, _LayerCodeGen);

  function LiteralCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = LiteralCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    if (lodash.get(json, 'value.type', '') === 'unknown') {
      return 'null';
    } else if (json.value && json.value.type) {
      return this.context.baseCodeGen.generate(json.value, extraParams);
    }

    if (typeof json.value === 'string') {
      if (extraParams && !extraParams.textLiteral) {
        json.value = escapeTextForJSX(json.value);
      } else {
        var newLine = '\\' + 'n';
        json.value = lodash.replace(json.value, new RegExp('\n', 'g'), newLine);
        var tab = '\\' + 't';
        json.value = lodash.replace(json.value, new RegExp('\t', 'g'), tab);
      } // Only replace opening curly braces `{` with `{"{"} and `


      if (extraParams && !extraParams.textLiteral) {
        json.value = json.value.replace(/(\{+)([^"])/g, "{\"$1\"}$2");
      }

      return this.generateJSLiteralCode(json.value, extraParams, extraParams && typeof extraParams.textLiteral === 'boolean' ? !extraParams.textLiteral : false);
    } else {
      // const errorMessage = `json.value should be string but received ${JSON.stringify(
      //   json.value
      // )} for ${this.context.filePath}`;
      // console.error(errorMessage);
      // this.context.baseCodeGen.ipc.executeCommand("captureErrorForSentry", [
      //   new Error(errorMessage)
      // ]);
      // if (json.value.toString) {
      //   json.value = json.value.toString();
      // } else {
      //   const errorMessage2 = `json.value should be string but received ${JSON.stringify(
      //     json.value
      //   )} for ${this.context.filePath}`;
      //   console.error(errorMessage2);
      //   this.context.baseCodeGen.ipc.executeCommand("captureErrorForSentry", [
      //     new Error(errorMessage2)
      //   ]);
      //   json.value = "";
      // }
      return this.generateJSLiteralCode(json.value, extraParams, true);
    } // return json.value;

  };

  return LiteralCodeGen;
}(LayerCodeGen);

var TextCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(TextCodeGen, _LayerCodeGen);

  function TextCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = TextCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    delete json.props.style.fontWeight;
    delete json.props.style.fontStyle;
    json.props.style.fontFamily = json.props.style.fontPostscriptName;
    delete json.props.style.fontPostscriptName;
    this.context.styles[json.styleName] = json.props.style;
    addImportToContext(this.context, json);
    return "<Text " + this.generateProps(json, _extends({}, extraParams, {
      parent: json
    })) + " " + this.generateStyle(json, _extends({}, extraParams, {
      parent: json
    })) + ">\n      " + this.generateChildren(json, _extends({}, extraParams, {
      parent: json,
      textLiteral: false
    })) + "\n    </Text>";
  };

  return TextCodeGen;
}(LayerCodeGen);

function getRadiusAdjustment(pointsArray, currentIndex, nextIndex, maxRadius) {
  if (!pointsArray[currentIndex] || !pointsArray[nextIndex]) {
    return {
      x: 0,
      y: 0
    };
  }

  var radius = maxRadius > pointsArray[currentIndex].cornerRadius ? pointsArray[currentIndex].cornerRadius : maxRadius;
  var x0 = pointsArray[currentIndex].point.x;
  var y0 = pointsArray[currentIndex].point.y;
  var x1 = pointsArray[nextIndex].point.x;
  var y1 = pointsArray[nextIndex].point.y;

  if (x1 === x0 && y1 === y0) {
    return {
      x: 0,
      y: 0
    };
  } else if (x1 === x0) {
    return {
      x: 0,
      y: y1 > y0 ? radius : -radius
    };
  } else {
    var angle = Math.atan2(y1 - y0, x1 - x0);
    return {
      x: Math.cos(angle) * radius,
      y: Math.sin(angle) * radius
    };
  }
}

function generateSVGPath(pointsArray, strokeWidthOffset, isClosed, viewBox) {
  var generatedPath = '';

  if (!pointsArray) {
    return '';
  }

  var dims = viewBox && viewBox.split ? viewBox.split(' ') : [0, 0, 100, 100];
  var maxRadius = Math.min(dims[2] - dims[0], dims[3] - dims[1]) / 2;
  strokeWidthOffset = strokeWidthOffset <= 1 ? 0 : strokeWidthOffset / 2;
  var initialIndex = 0; // Maintains track of each shape start after combining

  var d1 = {
    x: 0,
    y: 0
  }; // Distance with radius

  for (var i = 0; i < pointsArray.length; i++) {
    if (i === initialIndex) {
      // Moving to initial points with "M"
      var xy0 = pointsArray[i].point;

      if (pointsArray[i].cornerRadius) {
        d1 = getRadiusAdjustment(pointsArray, i, i + 1, maxRadius);
      }

      var x0 = (strokeWidthOffset + xy0.x + d1.x).toFixed(2);
      var y0 = (strokeWidthOffset + xy0.y + d1.y).toFixed(2);
      generatedPath += 'M' + x0 + ' ' + y0 + ' ';
      generatedPath += getNextPathPoint(pointsArray, i, strokeWidthOffset, initialIndex, maxRadius);
    } else if (isFillerCondition(pointsArray[i])) {
      initialIndex = i + 1;

      if (i !== pointsArray.length - 1 && isFillerClosed(pointsArray[i])) {
        generatedPath += 'Z ';
      }
    } else if (i === pointsArray.length - 1 || i !== pointsArray.length - 1 && isFillerCondition(pointsArray[i + 1])) {
      // adding additional point in the end of string
      if (isClosed && pointsArray[i].point.x !== pointsArray[initialIndex].point.x && pointsArray[i].point.y !== pointsArray[initialIndex].point.y) {
        var pointTo = pointsArray[initialIndex].point;
        var radiusPoint = void 0;

        if (pointsArray[i].cornerRadius) {
          d1 = getRadiusAdjustment(pointsArray, i, initialIndex, maxRadius);
          var passedPointIndex = pointsArray[initialIndex + 1] ? initialIndex + 1 : initialIndex;
          var d2 = getRadiusAdjustment(pointsArray, initialIndex, passedPointIndex, maxRadius);
          var px0 = (strokeWidthOffset + pointTo.x + d2.x).toFixed(2);
          var py0 = (strokeWidthOffset + pointTo.y + d2.y).toFixed(2);
          var curveFromX0 = (strokeWidthOffset + pointTo.x - d1.x / 2).toFixed(2);
          var curveFromY0 = (strokeWidthOffset + pointTo.y - d1.y / 2).toFixed(2);
          var curveToX0 = (strokeWidthOffset + pointTo.x + d2.x / 2).toFixed(2);
          var curveToY0 = (strokeWidthOffset + pointTo.y + d2.y / 2).toFixed(2);
          radiusPoint = 'C' + curveFromX0 + ' ' + curveFromY0 + ' ' + curveToX0 + ' ' + curveToY0 + ' ' + px0 + ' ' + py0 + ' ';
        }

        var px = (strokeWidthOffset + pointTo.x - d1.x).toFixed(2);
        var py = (strokeWidthOffset + pointTo.y - d1.y).toFixed(2);
        var curveFromPoint = pointsArray[i].curveFrom;
        var curveFromX = (strokeWidthOffset + curveFromPoint.x).toFixed(2);
        var curveFromY = (strokeWidthOffset + curveFromPoint.y).toFixed(2);
        var curveTo = pointsArray[initialIndex].curveTo;
        var curveToX = (strokeWidthOffset + curveTo.x).toFixed(2);
        var curveToY = (strokeWidthOffset + curveTo.y).toFixed(2);

        if (pointsArray[initialIndex] && pointsArray[initialIndex].hasCurveTo || pointsArray[i].hasCurveFrom) {
          generatedPath += 'C' + curveFromX + ' ' + curveFromY + ' ' + curveToX + ' ' + curveToY + ' ' + px + ' ' + py + ' ' + (radiusPoint || '');
        } else {
          generatedPath += 'L' + px + ' ' + py + ' ' + (radiusPoint || '');
        }
      }
    } else {
      generatedPath += getNextPathPoint(pointsArray, i, strokeWidthOffset, initialIndex, maxRadius);
    }
  }

  if (isClosed) {
    generatedPath += 'Z';
  } // console.log("*** generatedPath", generatedPath);


  return generatedPath;
}

function getNextPathPoint(pointsArray, i, strokeWidthOffset, initialIndex, maxRadius) {
  if (i + 1 >= pointsArray.length) {
    return '';
  }

  var nextPoint = '';
  var pointTo = pointsArray[i + 1].point;
  var d1 = {
    x: 0,
    y: 0
  };
  var radiusPoint;

  if (pointsArray[i].cornerRadius) {
    d1 = getRadiusAdjustment(pointsArray, i, i + 1, maxRadius);
    var passedPointIndex = pointsArray[i + 2] ? i + 2 : initialIndex;
    var d2 = getRadiusAdjustment(pointsArray, i + 1, passedPointIndex, maxRadius);
    var px0 = (strokeWidthOffset + pointTo.x + d2.x).toFixed(2);
    var py0 = (strokeWidthOffset + pointTo.y + d2.y).toFixed(2);
    var curveFromX0 = (strokeWidthOffset + pointTo.x - d1.x / 2).toFixed(2);
    var curveFromY0 = (strokeWidthOffset + pointTo.y - d1.y / 2).toFixed(2);
    var curveToX0 = (strokeWidthOffset + pointTo.x + d2.x / 2).toFixed(2);
    var curveToY0 = (strokeWidthOffset + pointTo.y + d2.y / 2).toFixed(2);
    radiusPoint = 'C' + curveFromX0 + ' ' + curveFromY0 + ' ' + curveToX0 + ' ' + curveToY0 + ' ' + px0 + ' ' + py0 + ' ';
  }

  var px = (strokeWidthOffset + pointTo.x - d1.x).toFixed(2);
  var py = (strokeWidthOffset + pointTo.y - d1.y).toFixed(2);
  var curveFromPoint = pointsArray[i].curveFrom;
  var curveFromX = (strokeWidthOffset + curveFromPoint.x).toFixed(2);
  var curveFromY = (strokeWidthOffset + curveFromPoint.y).toFixed(2);
  var curveTo = pointsArray[i + 1].curveTo;
  var curveToX = (strokeWidthOffset + curveTo.x).toFixed(2);
  var curveToY = (strokeWidthOffset + curveTo.y).toFixed(2);

  if (pointsArray[i + 1] && pointsArray[i + 1].hasCurveTo || pointsArray[i].hasCurveFrom) {
    nextPoint += 'C' + curveFromX + ' ' + curveFromY + ' ' + curveToX + ' ' + curveToY + ' ' + px + ' ' + py + ' ' + (radiusPoint || '');
  } else {
    nextPoint += 'L' + px + ' ' + py + ' ' + (radiusPoint || '');
  }

  return nextPoint;
}

function isFillerCondition(point) {
  return point.cornerRadius === 777 && point.curveMode === 777 || point.cornerRadius === 776 && point.curveMode === 776;
}

function isFillerClosed(point) {
  return point.cornerRadius === 776 && point.curveMode === 776;
}

var ImageCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(ImageCodeGen, _LayerCodeGen);

  function ImageCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = ImageCodeGen.prototype;

  _proto.generateDefs = function generateDefs(json, maskId) {
    var defsCode = '';
    var maskCode = '';
    var maskPathCode = "<Path fill=\"white\" d={\"" + generateSVGPath(json.props.mask, 0, true, json.props.viewBox) + "\"}/>"; // const viewBox = json.props.viewBox.split(" ");

    maskCode = "<Mask id=\"" + maskId + "\" x={0} y={0}>\n      " + maskPathCode + "\n      </Mask>";

    if (maskCode) {
      defsCode = "<Defs>\n    " + maskCode + "\n    </Defs>";
    }

    return defsCode;
  };

  _proto.generate = function generate(json, extraParams) {
    addImportToContext(this.context, json);
    this.context.styles[json.styleName] = json.props.style;

    if (json.props.mask) {
      addImportToContext(this.context, {
        "import": {
          isDefaultImport: false,
          layerName: 'Defs',
          packageName: 'react-native-svg'
        }
      });
      addImportToContext(this.context, {
        "import": {
          isDefaultImport: false,
          layerName: 'Svg',
          packageName: 'react-native-svg'
        }
      });
      addImportToContext(this.context, {
        "import": {
          isDefaultImport: false,
          layerName: 'Path',
          packageName: 'react-native-svg'
        }
      });
      addImportToContext(this.context, {
        "import": {
          isDefaultImport: false,
          layerName: 'Mask',
          packageName: 'react-native-svg'
        }
      });
      var _json$props = json.props,
          viewBox = _json$props.viewBox,
          style = _json$props.style;

      var svgJson = _extends({}, json, {
        props: {
          viewBox: viewBox,
          style: style
        }
      });

      var maskId = getRandomString();
      return "<Svg " + this.generateProps(svgJson, _extends({}, extraParams, {
        parent: json
      })) + " " + this.generateStyle(json, _extends({}, extraParams, {
        parent: json
      })) + ">\n      " + this.generateDefs(json, maskId) + "\n      <SvgImage href={require(\"" + this.generateSourcePropCode(path.basename(json.props.source.uri), 'svgImage') + "\")} x={" + json.props.svgDims.x + "} y={" + json.props.svgDims.y + "} width={" + json.props.svgDims.width + "} height={" + json.props.svgDims.height + "} mask={\"url(#" + maskId + ")\"}>\n      " + this.generateChildren(json, _extends({}, extraParams, {
        parent: json
      })) + "\n      </SvgImage>\n      </Svg>";
    }

    var layerStylePropCode = this.generateStyle(json, _extends({}, extraParams, {
      parent: json
    }));
    var tagName = 'Image';

    if (json.children.length !== 0) {
      json.props.imageStyle = getFilteredImageStyle(json.props.style);
      this.context.styles[json.styleName + "_imageStyle"] = json.props.imageStyle;
      tagName = 'ImageBackground';
      addImportToContext(this.context, {
        "import": {
          isDefaultImport: false,
          layerName: 'ImageBackground',
          packageName: 'react-native'
        }
      });
      layerStylePropCode += " " + this.generateStyle(json, _extends({}, extraParams, {
        parent: json
      }), 'imageStyle');
    }

    return "<" + tagName + " " + this.generateProps(json, _extends({}, extraParams, {
      parent: json
    })) + " " + layerStylePropCode + ">\n      " + this.generateChildren(json, _extends({}, extraParams, {
      parent: json
    })) + "\n    </" + tagName + ">";
  };

  return ImageCodeGen;
}(LayerCodeGen);

var EllipseCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(EllipseCodeGen, _LayerCodeGen);

  function EllipseCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = EllipseCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    json.props.viewBox = json.props.viewBox.split(' ').map(function (v) {
      return Math.round(parseFloat(v) * 100) / 100;
    }).join(' ');
    this.context.styles[json.styleName] = json.props.style;
    addImportToContext(this.context, json);
    addImportToContext(this.context, {
      "import": {
        isDefaultImport: true,
        layerName: 'Svg',
        packageName: 'react-native-svg'
      }
    });

    var _json$props = json.props,
        viewBox = _json$props.viewBox,
        style = _json$props.style,
        ellipseProps = _objectWithoutPropertiesLoose(_json$props, ["viewBox", "style"]);

    var ellipseJson = _extends({}, json, {
      props: ellipseProps
    });

    var svgJson = _extends({}, json, {
      props: {
        viewBox: viewBox,
        style: style
      }
    });

    return "<Svg " + this.generateProps(svgJson, _extends({}, extraParams, {
      parent: json
    })) + " " + this.generateStyle(json, _extends({}, extraParams, {
      parent: json
    })) + ">\n    <Ellipse " + this.generateProps(ellipseJson, _extends({}, extraParams, {
      parent: json
    })) + ">\n      " + this.generateChildren(json, _extends({}, extraParams, {
      parent: json
    })) + "\n    </Ellipse>\n    </Svg>";
  };

  return EllipseCodeGen;
}(LayerCodeGen);

var LAYOUT_PROPERTIES_AFFECTING_CHILDREN = ['alignContent', 'alignItems', 'direction', 'flexDirection', 'flexWrap', 'justifyContent', 'overflow', 'padding', 'paddingBottom', 'paddingEnd', 'paddingHorizontal', 'paddingLeft', 'paddingRight', 'paddingStart', 'paddingTop', 'paddingVertical'];

function getScrollViewContentContainerStyle(layer) {
  var scrollViewContentContainerStyle = {};

  if (layer.props.horizontal) {
    var totalWidth = getTotalWidthForScrollView(layer);
    scrollViewContentContainerStyle.width = totalWidth;
    scrollViewContentContainerStyle.height = layer.props.style.height;
  } else {
    var totalHeight = getTotalHeightForScrollView(layer);
    scrollViewContentContainerStyle.height = totalHeight;
    scrollViewContentContainerStyle.width = layer.props.style.width;
  }

  lodash.forEach(layer.props.style, function (value, key) {
    if (LAYOUT_PROPERTIES_AFFECTING_CHILDREN.includes(key)) {
      scrollViewContentContainerStyle[key] = value;
      delete layer.props.style[key];
    }
  });
  return scrollViewContentContainerStyle;
}

function getTotalHeightForScrollView(layer) {
  var totalMaxHeight = 0;
  lodash.forEach(layer.children, function (compiledChild) {
    var childBoundingClientRect = compiledChild.rcDims;

    if (childBoundingClientRect.height + childBoundingClientRect.y > totalMaxHeight) {
      totalMaxHeight = childBoundingClientRect.height + childBoundingClientRect.y;
    }
  });
  var layerBoundingClientRect = layer.rcDims;

  if (layerBoundingClientRect.height > totalMaxHeight) {
    totalMaxHeight = layerBoundingClientRect.height;
  } else {
    totalMaxHeight = totalMaxHeight;
  }

  return totalMaxHeight;
}

function getTotalWidthForScrollView(layer) {
  var totalMaxWidth = 0;
  lodash.forEach(layer.children, function (compiledChild) {
    var childBoundingClientRect = compiledChild.rcDims;

    if (childBoundingClientRect.width + childBoundingClientRect.x > totalMaxWidth) {
      totalMaxWidth = childBoundingClientRect.width + childBoundingClientRect.x;
    }
  });
  var layerBoundingClientRect = layer.rcDims;

  if (layerBoundingClientRect.width > totalMaxWidth) {
    totalMaxWidth = layerBoundingClientRect.width;
  } else {
    totalMaxWidth = totalMaxWidth;
  }

  return totalMaxWidth;
}

var ScrollViewCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(ScrollViewCodeGen, _LayerCodeGen);

  function ScrollViewCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = ScrollViewCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    this.context.styles[json.styleName] = json.props.style;
    addImportToContext(this.context, json);
    addImportToContext(this.context, {
      "import": {
        isDefaultImport: false,
        layerName: 'View',
        packageName: 'react-native'
      }
    });
    var layerSpecificStyles = '';
    var contentContainerStyle = getScrollViewContentContainerStyle(json);
    this.context.styles[json.styleName + "_contentContainerStyle"] = contentContainerStyle;
    layerSpecificStyles += "" + this.generateStyle(json, _extends({}, extraParams, {
      parent: json
    }), 'contentContainerStyle');
    return "<View " + this.generateStyle(json, _extends({}, extraParams, {
      parent: json
    })) + "><ScrollView " + this.generateProps(json, _extends({}, extraParams, {
      parent: json
    })) + " " + layerSpecificStyles + ">\n      " + this.generateChildren(json, _extends({}, extraParams, {
      parent: json
    })) + "\n    </ScrollView></View>";
  };

  return ScrollViewCodeGen;
}(LayerCodeGen);

var TextInputCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(TextInputCodeGen, _LayerCodeGen);

  function TextInputCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = TextInputCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    delete json.props.style.fontWeight;
    delete json.props.style.fontStyle;
    json.props.style.fontFamily = json.props.style.fontPostscriptName;
    delete json.props.style.fontPostscriptName;
    this.context.styles[json.styleName] = json.props.style;
    addImportToContext(this.context, json);

    if (lodash.includes(json.props.placeholder, '\n')) {
      json.props.placeholder = lodash.replace(json.props.placeholder, new RegExp('\n', 'g'), ' ');
      json.props.placeholder = lodash.replace(json.props.placeholder, new RegExp('\t', 'g'), ' ');
    }

    delete json.props.value;
    return "<TextInput " + this.generateProps(json, _extends({}, extraParams, {
      parent: json
    })) + " " + this.generateStyle(json, _extends({}, extraParams, {
      parent: json
    })) + ">\n      " + this.generateChildren(json, _extends({}, extraParams, {
      parent: json
    })) + "\n    </TextInput>";
  };

  return TextInputCodeGen;
}(LayerCodeGen);

var SymbolLayerCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(SymbolLayerCodeGen, _LayerCodeGen);

  function SymbolLayerCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = SymbolLayerCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    this.context.styles[json.styleName] = json.props.style;
    addImportToContext(this.context, json);
    var tagName = json["import"].layerName;
    return "<" + tagName + " " + this.generateProps(json, _extends({}, extraParams, {
      parent: json
    })) + " " + this.generateSymbolOverrideProps(json.scopeVariables, _extends({}, extraParams, {
      parent: json
    })) + this.generateStyle(json, _extends({}, extraParams, {
      parent: json
    })) + ">\n      " + this.generateChildren(json, _extends({}, extraParams, {
      parent: json
    })) + "\n    </" + tagName + ">";
  };

  return SymbolLayerCodeGen;
}(LayerCodeGen);

var TouchableOpacityCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(TouchableOpacityCodeGen, _LayerCodeGen);

  function TouchableOpacityCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = TouchableOpacityCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    this.context.styles[json.styleName] = json.props.style;
    var isInSymbol = this.context.filePath.indexOf('symbols') !== -1 || this.context.filePath.indexOf('components') !== -1;
    var navigate = !json.navigateTo ? '' : isInSymbol ? "onPress = {() => console.log(\"Navigate to " + json.navigateTo + "\")}" : json.navigateTo === 'Go Back' ? "onPress = {() => props.navigation.goBack()}" : "onPress = {() => props.navigation.navigate(\"" + json.navigateTo + "\")}";
    addImportToContext(this.context, json);
    return "<TouchableOpacity " + this.generateProps(json, _extends({}, extraParams, {
      parent: json
    })) + "\n    " + (json.navigateTo ? "" + navigate : '') + " " + this.generateStyle(json, _extends({}, extraParams, {
      parent: json
    })) + ">\n      " + this.generateChildren(json, _extends({}, extraParams, {
      parent: json
    })) + "\n    </TouchableOpacity>";
  };

  return TouchableOpacityCodeGen;
}(LayerCodeGen);

var CenterCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(CenterCodeGen, _LayerCodeGen);

  function CenterCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = CenterCodeGen.prototype;

  _proto.generateCenterProps = function generateCenterProps(template) {
    if (template.centerVertical && !template.centerHorizontal) {
      return 'vertical';
    } else if (!template.centerVertical && template.centerHorizontal) {
      return 'horizontal';
    }

    return '';
  };

  _proto.generate = function generate(json, extraParams) {
    addImportToContext(this.context, {
      "import": {
        isDefaultImport: false,
        layerName: 'Center',
        packageName: '@builderx/utils'
      }
    });
    var propsCode = this.generateCenterProps(json.template);
    delete json.template.centerHorizontal;
    delete json.template.centerVertical;
    return "<Center " + propsCode + " >\n      " + this.context.baseCodeGen.generate(json, extraParams) + "\n    </Center>";
  };

  return CenterCodeGen;
}(LayerCodeGen);

var ExpressionStatementCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(ExpressionStatementCodeGen, _LayerCodeGen);

  function ExpressionStatementCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = ExpressionStatementCodeGen.prototype;

  _proto.getCondtionalASTFromJSON = function getCondtionalASTFromJSON(conditionJSON, fileId) {//
  };

  _proto.generate = function generate(json, extraParams) {
    return this.context.baseCodeGen.generate(json.expression, _extends({}, extraParams, {
      textLiteral: true
    }));
  };

  return ExpressionStatementCodeGen;
}(LayerCodeGen);

var BinaryExpressionCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(BinaryExpressionCodeGen, _LayerCodeGen);

  function BinaryExpressionCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = BinaryExpressionCodeGen.prototype;

  _proto.getCondtionalASTFromJSON = function getCondtionalASTFromJSON(conditionJSON, fileId) {//
  };

  _proto.generate = function generate(json, extraParams) {
    // addImportToContext(this.context, {
    //   import: {
    //     isDefaultImport: false,
    //     layerName: "Platform",
    //     packageName: "react-native"
    //   }
    // });
    return "\n      " + this.context.baseCodeGen.generate(json.left, extraParams) + "\n        " + json.operator + "\n        " + this.context.baseCodeGen.generate(json.right, extraParams) + "\n      ";
  };

  return BinaryExpressionCodeGen;
}(LayerCodeGen);

var ExpressionCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(ExpressionCodeGen, _LayerCodeGen);

  function ExpressionCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = ExpressionCodeGen.prototype;

  _proto.getCondtionalASTFromJSON = function getCondtionalASTFromJSON(conditionJSON, fileId) {//
  };

  _proto.generate = function generate(json, extraParams) {
    var expression = json.expression;

    if (expression !== 'platform' && expression.indexOf('.') === -1) {
      this.context.conditionals.push(expression);
    }

    if (expression === 'platform') {
      addImportToContext(this.context, {
        "import": {
          isDefaultImport: false,
          layerName: 'Platform',
          packageName: 'react-native'
        }
      });
      expression = 'Platform.OS';
    }

    return this.generateJSLiteralCode(expression, extraParams, true);
  };

  return ExpressionCodeGen;
}(LayerCodeGen);

var ConditionalExpressionCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(ConditionalExpressionCodeGen, _LayerCodeGen);

  function ConditionalExpressionCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = ConditionalExpressionCodeGen.prototype;

  _proto.getCondtionalASTFromJSON = function getCondtionalASTFromJSON(conditionJSON, fileId) {//
  };

  _proto.generate = function generate(json, extraParams) {
    var expression = lodash.get(json, 'test.expression', undefined);

    if (expression) {
      expression = expression.replace('this.props', 'props');
    }

    return this.context.baseCodeGen.generate(json.test, _extends({}, extraParams, {
      textLiteral: false
    })) + " ?\n    " + this.context.baseCodeGen.generate(json.consequent, _extends({}, extraParams, {
      textLiteral: true
    })) + " : " + this.context.baseCodeGen.generate(json.alternate, _extends({}, extraParams, {
      textLiteral: true
    }));
  };

  return ConditionalExpressionCodeGen;
}(LayerCodeGen);

var LogicalExpressionCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(LogicalExpressionCodeGen, _LayerCodeGen);

  function LogicalExpressionCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = LogicalExpressionCodeGen.prototype;

  _proto.getCondtionalASTFromJSON = function getCondtionalASTFromJSON(conditionJSON, fileId) {//
  };

  _proto.generate = function generate(json, extraParams) {
    var leftExp = this.context.baseCodeGen.generate(json.left, extraParams);

    if (leftExp.indexOf('this.props') !== -1) {
      leftExp = leftExp.replace('this.props', 'props');
    }

    var rightExp = this.context.baseCodeGen.generate(json.right, _extends({}, extraParams, {
      textLiteral: true
    }));
    return "\n      (" + leftExp + ")\n      " + json.operator + "\n        (" + rightExp + ")\n      ";
  };

  return LogicalExpressionCodeGen;
}(LayerCodeGen);

var PathCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(PathCodeGen, _LayerCodeGen);

  function PathCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = PathCodeGen.prototype;

  _proto.generateDefs = function generateDefs(json) {
    var defsCode = '';
    var gradId, maskId;
    var gradientCode = '';
    var gradient = json.props.style.gradient;
    delete json.props.style.gradient;

    if (gradient && gradient.gradientType === 'LinearGradient') {
      var x1 = gradient.from.x;
      x1 = typeof x1 === 'number' ? x1 * 100 : parseFloat(x1) * 100;
      var y1 = gradient.from.y;
      y1 = typeof y1 === 'number' ? y1 * 100 : parseFloat(y1) * 100;
      var x2 = gradient.to.x;
      x2 = typeof x2 === 'number' ? x2 * 100 : parseFloat(x2) * 100;
      var y2 = gradient.to.y;
      y2 = typeof y2 === 'number' ? y2 * 100 : parseFloat(y2) * 100;
      gradId = getRandomString();
      var linearGradProps = "id=\"" + gradId + "\" x1=\"" + x1 + "%\" x2=\"" + x2 + "%\" y1=\"" + y1 + "%\" y2=\"" + y2 + "%\"";
      var stopsCode = '';
      lodash.forEach(gradient.stops, function (stop) {
        if (typeof stop.offset === 'string') {
          stop.offset = parseFloat(stop.offset);
        }

        stopsCode += "<Stop offset=\"" + stop.offset.toFixed(2).toString() + "\" stopColor=\"" + stop.stopColor + "\" />";
      });
      gradientCode = "<LinearGradient " + linearGradProps + ">\n      " + stopsCode + "\n      </LinearGradient>";
    }

    var maskCode = '';

    if (json.props.mask) {
      var maskPathD = generateSVGPath(json.props.mask, 1, true, json.props.viewBox);
      var maskPathCode = "<Path d=\"" + maskPathD + "\" fill=\"white\" />";
      var viewBox = ['0', '0', json.rcDims.width + '', json.rcDims.height + ''];

      if (json.props.viewBox) {
        // TODO: We're getting props.viewBox undeifned in some case which should never happen
        viewBox = json.props.viewBox.split(' ');
      }

      maskId = getRandomString();
      maskCode = "<Mask id=\"" + maskId + "\" x={0} y={0} width={" + parseInt(viewBox[2], 10) + "} height={" + parseInt(viewBox[3], 10) + "}>\n      " + maskPathCode + "\n      </Mask>";
    }

    if (gradientCode || maskCode) {
      defsCode = "<Defs>\n    " + gradientCode + "\n    " + maskCode + "\n    </Defs>";
    }

    return {
      code: defsCode,
      gradId: gradId,
      maskId: maskId
    };
  };

  _proto.generate = function generate(json, extraParams) {
    json.props.viewBox = json.props.viewBox.split(' ').map(function (v) {
      return Math.round(parseFloat(v) * 100) / 100;
    }).join(' ');
    delete json.props.gradientImage;
    this.context.styles[json.styleName] = json.props.style;
    addImportToContext(this.context, json);
    addImportToContext(this.context, {
      "import": {
        isDefaultImport: true,
        layerName: 'Svg',
        packageName: 'react-native-svg'
      }
    });

    if (json.props.style.gradient) {
      addImportToContext(this.context, {
        "import": {
          isDefaultImport: false,
          layerName: 'Stop',
          packageName: 'react-native-svg'
        }
      });
      addImportToContext(this.context, {
        "import": {
          isDefaultImport: false,
          layerName: 'Defs',
          packageName: 'react-native-svg'
        }
      });
      addImportToContext(this.context, {
        "import": {
          isDefaultImport: false,
          layerName: 'LinearGradient',
          packageName: 'react-native-svg'
        }
      });
    }

    if (json.props.mask) {
      addImportToContext(this.context, {
        "import": {
          isDefaultImport: false,
          layerName: 'Defs',
          packageName: 'react-native-svg'
        }
      });
      addImportToContext(this.context, {
        "import": {
          isDefaultImport: false,
          layerName: 'Mask',
          packageName: 'react-native-svg'
        }
      });
    }

    var _json$props = json.props,
        viewBox = _json$props.viewBox,
        style = _json$props.style,
        points = _json$props.points,
        isClosed = _json$props.isClosed,
        pathProps = _objectWithoutPropertiesLoose(_json$props, ["viewBox", "style", "points", "isClosed"]);

    var svgPath = generateSVGPath(points, json.props.strokeWidth || 0, isClosed, viewBox);

    var pathJson = _extends({}, json, {
      props: _extends({}, pathProps, {
        d: svgPath
      })
    });

    var svgJson = _extends({}, json, {
      props: {
        viewBox: viewBox,
        style: style
      }
    });

    var _this$generateDefs = this.generateDefs(json),
        gradId = _this$generateDefs.gradId,
        maskId = _this$generateDefs.maskId,
        defsCode = _this$generateDefs.code;

    if (gradId) {
      pathJson.props.fill = "url(#" + gradId + ")";
    }

    if (maskId) {
      pathJson.props.mask = "url(#" + maskId + ")";
    }

    return "<Svg " + this.generateProps(svgJson, _extends({}, extraParams, {
      parent: json
    })) + " " + this.generateStyle(json, _extends({}, extraParams, {
      parent: json
    })) + ">\n    " + defsCode + "\n    <Path " + this.generateProps(pathJson, _extends({}, extraParams, {
      parent: json
    })) + ">\n      " + this.generateChildren(json, _extends({}, extraParams, {
      parent: json
    })) + "\n    </Path>\n    </Svg>";
  };

  return PathCodeGen;
}(LayerCodeGen);

var LoopCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(LoopCodeGen, _LayerCodeGen);

  function LoopCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = LoopCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    addImportToContext(this.context, {
      "import": {
        isDefaultImport: false,
        layerName: 'times',
        packageName: 'lodash'
      }
    });
    return " {times(" + json.template.repetitions + ", () =>  " + this.context.baseCodeGen.generate(json.children[0], _extends({}, extraParams, {
      parent: json
    })) + ")}";
  };

  return LoopCodeGen;
}(LayerCodeGen);

function isStatusBarDefault(statusBar) {
  return statusBar.display === true && statusBar.barStyle === 'default' && statusBar.backgroundColor === undefined && statusBar.animated === false;
}

var RootCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(RootCodeGen, _LayerCodeGen);

  function RootCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = RootCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    this.context.styles[json.styleName] = json.props.style;
    addImportToContext(this.context, json);
    var layerStylePropCode = this.generateStyle(json, _extends({}, extraParams, {
      parent: json
    }));
    var statusBarCode = '';

    if (!isStatusBarDefault(extraParams.parent.statusBar)) {
      addImportToContext(this.context, {
        "import": {
          isDefaultImport: false,
          layerName: 'StatusBar',
          packageName: 'react-native'
        }
      });
      var statusBar = extraParams.parent.statusBar;
      statusBarCode = "<StatusBar \n      " + (statusBar.display === false ? 'hidden' : '') + " \n      " + (statusBar.animated === true ? 'animated' : '') + " \n      " + (statusBar.barStyle !== 'default' ? "barStyle=\"" + statusBar.barStyle + "\"" : '') + " \n      " + (statusBar.backgroundColor ? "backgroundColor=\"" + statusBar.backgroundColor + "\"" : '') + " />";
    }

    var gradient = json.props.style.gradient;
    delete json.props.style.gradient;

    if (gradient) {
      // TODO: Currently, we won't get gradient for root layer but this condition is handled incorrectly,
      // should fix for future cases
      json.props.imageStyle = getFilteredImageStyle(json.props.style);
      this.context.styles[json.styleName + "_imageStyle"] = json.props.imageStyle;
      layerStylePropCode += " " + this.generateStyle(json, _extends({}, extraParams, {
        parent: json
      }), 'imageStyle');
      addImportToContext(this.context, {
        "import": {
          isDefaultImport: false,
          layerName: 'ImageBackground',
          packageName: 'react-native'
        }
      });
      delete json.props.style['backgroundImage'];
      var gradientImage = json.props.gradientImage;
      delete json.props.gradientImage;
      return "<ImageBackground " + this.generateProps(json, _extends({}, extraParams, {
        parent: json
      })) + " " + layerStylePropCode + " " + this.generateSourcePropCode(gradientImage) + "/>";
    } else {
      return "<" + json["import"].layerName + " " + this.generateProps(json, _extends({}, extraParams, {
        parent: json
      })) + " " + this.generateStyle(json, _extends({}, extraParams, {
        parent: json
      })) + ">\n      " + statusBarCode + "\n      " + this.generateChildren(json, _extends({}, extraParams, {
        parent: json
      })) + "\n      </" + json["import"].layerName + ">";
    }
  };

  return RootCodeGen;
}(LayerCodeGen);

function randomString(length) {
  var text = '';
  var possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  text = possible.charAt(Math.floor(Math.random() * 52));

  for (var i = 0; i < length - 1; i++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  }

  return text;
}

function updateWrapperStyleName(json, extraParams) {
  if (json.type === 'row' || json.type === 'column' || json.type === 'stack') {
    var firstChildStyleName = lodash.get(json, 'children.0.styleName', randomString(6));
    json.styleName = firstChildStyleName + json.type.charAt(0).toUpperCase() + json.type.slice(1);
  } else if (json.type === 'flexFiller') {
    var siblingsLength = lodash.get(extraParams, 'parent.children.length', 1);
    var previousSiblingStyleName = lodash.get(extraParams, 'parent.children.0.styleName');

    if (previousSiblingStyleName && previousSiblingStyleName !== 'flexFiller') {
      json.styleName = previousSiblingStyleName + 'Filler';
    } else {
      json.styleName = lodash.get(extraParams, "parent.children." + (siblingsLength - 1) + ".styleName", randomString(6)) + 'Filler';
    } // const previousSiblingStyleName = get(
    //   extraParams,
    //   "parent.children.0.styleName",
    // );
    // json.styleName = previousSiblingStyleName + "Filler";

  }
}
function getRotation(transform) {
  var rotation = 0;

  if (transform) {
    var transformValue = lodash.isArray(transform) ? transform : transform['value'];
    var index = lodash.findIndex(transformValue, function (item) {
      var rotate = lodash.keys(item).indexOf('rotate');
      return rotate !== -1 && !lodash.isNil(item['rotate']);
    });

    if (index > -1) {
      var value = transformValue[index]['rotate'] && transformValue[index]['rotate'].type ? transformValue[index]['rotate'].value : transformValue[index]['rotate'];

      if (value && value.indexOf) {
        if (value.indexOf('rad') > -1) {
          value = parseFloat(value.slice(0, -3));
          rotation = value * 180 / Math.PI;
        } else {
          value = parseFloat(value.slice(0, -3));
          rotation = value;
        }
      }
    }
  }

  return rotation;
}

var WrapperCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(WrapperCodeGen, _LayerCodeGen);

  function WrapperCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = WrapperCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    addImportToContext(this.context, json);
    var childrenCode = this.generateChildren(json, _extends({}, extraParams, {
      parent: json
    })); // let {
    //   flexDirection,
    //   display,
    //   position,
    //   height,
    //   width,
    //   flex,
    //   ...restStyles
    // } = json.props.style;
    // if (json.type === "stack") {
    //   restStyles = { ...restStyles, height, width, flex, position };
    // } else if (json.type === "row" || json.type === "column") {
    //   restStyles = { ...restStyles, height, width, flex };
    // } else if (json.type === "body") {
    //   restStyles = { ...restStyles, flexDirection };
    // }
    // this.context.styles[json.styleName] =
    //   json.type === "stack"
    //     ? { position: "relative" }
    //     : json.type === "body"
    //     ? { flex: 1 }
    //     : { flexDirection: json.type };

    updateWrapperStyleName(json, extraParams);
    this.context.styles[json.styleName] = json.props.style;
    return "<View " + this.generateProps(json, _extends({}, extraParams, {
      parent: json
    })) + " style={styles." + json.styleName + "}>\n      " + childrenCode + "\n      </View>";
  };

  return WrapperCodeGen;
}(LayerCodeGen);

var InlineViewCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(InlineViewCodeGen, _LayerCodeGen);

  function InlineViewCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = InlineViewCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    addImportToContext(this.context, json);
    var randomStyleName = getRandomString(6);
    this.context.styles[randomStyleName] = json.props.style;
    return "<View " + this.generateProps(json, _extends({}, extraParams, {
      parent: json
    })) + " style={styles." + randomStyleName + "}>\n      " + this.generateChildren(json, _extends({}, extraParams, {
      parent: json
    })) + "\n      </View>";
  };

  return InlineViewCodeGen;
}(LayerCodeGen);

var IconCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(IconCodeGen, _LayerCodeGen);

  function IconCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = IconCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    this.context.styles[json.styleName] = json.props.style;
    addImportToContext(this.context, json, this.generateJSLiteralCode);
    var tagName = '';
    var layerSpecificStyles = '';
    var currentFamily = getCurrentFamily(json, this.generateJSLiteralCode);
    tagName = this.context.iconCount > 1 ? "" + currentFamily + json["import"].layerName : json["import"].layerName;
    delete json.props.style.fontPostscriptName;
    return "<" + tagName + " " + this.generateProps(json, _extends({}, extraParams, {
      parent: json
    })) + " " + this.generateStyle(json, _extends({}, extraParams, {
      parent: json
    })) + " " + layerSpecificStyles + ">\n      " + this.generateChildren(json, _extends({}, extraParams, {
      parent: json
    })) + "\n    </" + tagName + ">";
  };

  return IconCodeGen;
}(LayerCodeGen);

var ActivityIndicatorCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(ActivityIndicatorCodeGen, _LayerCodeGen);

  function ActivityIndicatorCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = ActivityIndicatorCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    this.context.styles[json.styleName] = json.props.style;
    addImportToContext(this.context, json, this.generateJSLiteralCode);
    var tagName = '';
    var layerSpecificStyles = '';
    tagName = json["import"].layerName;
    return "<" + tagName + " " + this.generateProps(json, _extends({}, extraParams, {
      parent: json
    })) + " " + this.generateStyle(json, _extends({}, extraParams, {
      parent: json
    })) + " " + layerSpecificStyles + ">\n      " + this.generateChildren(json, _extends({}, extraParams, {
      parent: json
    })) + "\n    </" + tagName + ">";
  };

  return ActivityIndicatorCodeGen;
}(LayerCodeGen);

var MapViewCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(MapViewCodeGen, _LayerCodeGen);

  function MapViewCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = MapViewCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    this.context.styles[json.styleName] = json.props.style;
    addImportToContext(this.context, json, this.generateJSLiteralCode);
    var tagName = '';
    var layerSpecificStyles = '';
    tagName = json["import"].layerName;
    return "<" + tagName + " " + this.generateProps(json, _extends({}, extraParams, {
      parent: json
    })) + " " + this.generateStyle(json, _extends({}, extraParams, {
      parent: json
    })) + " " + layerSpecificStyles + ">\n      " + this.generateChildren(json, _extends({}, extraParams, {
      parent: json
    })) + "\n    </" + tagName + ">";
  };

  return MapViewCodeGen;
}(LayerCodeGen);

var SwitchCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(SwitchCodeGen, _LayerCodeGen);

  function SwitchCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = SwitchCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    this.context.styles[json.styleName] = json.props.style;
    addImportToContext(this.context, json, this.generateJSLiteralCode);
    var tagName = '';
    var layerSpecificStyles = '';
    tagName = json["import"].layerName;
    return "<" + tagName + " " + this.generateProps(json, _extends({}, extraParams, {
      parent: json
    })) + " " + this.generateStyle(json, _extends({}, extraParams, {
      parent: json
    })) + " " + layerSpecificStyles + ">\n      " + this.generateChildren(json, _extends({}, extraParams, {
      parent: json
    })) + "\n    </" + tagName + ">";
  };

  return SwitchCodeGen;
}(LayerCodeGen);

var SliderCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(SliderCodeGen, _LayerCodeGen);

  function SliderCodeGen(context) {
    var _this;

    _this = _LayerCodeGen.call(this) || this;
    _this.context = context;
    return _this;
  }

  var _proto = SliderCodeGen.prototype;

  _proto.generate = function generate(json, extraParams) {
    this.context.styles[json.styleName] = json.props.style;
    addImportToContext(this.context, json, this.generateJSLiteralCode);
    var tagName = '';
    var layerSpecificStyles = '';
    tagName = json["import"].layerName;
    return "<" + tagName + " " + this.generateProps(json, _extends({}, extraParams, {
      parent: json
    })) + " " + this.generateStyle(json, _extends({}, extraParams, {
      parent: json
    })) + " " + layerSpecificStyles + ">\n      " + this.generateChildren(json, _extends({}, extraParams, {
      parent: json
    })) + "\n    </" + tagName + ">";
  };

  return SliderCodeGen;
}(LayerCodeGen);

var BaseCodeGen = /*#__PURE__*/function (_LayerCodeGen) {
  _inheritsLoose(BaseCodeGen, _LayerCodeGen);

  function BaseCodeGen() {
    var _this;

    _this = _LayerCodeGen.apply(this, arguments) || this;
    _this.context = {
      styles: {},
      imports: {
        react: {
          named: ['Component'],
          "default": 'React'
        },
        'react-native': {
          named: ['StyleSheet'],
          "default": false
        }
      },
      conditionals: [],
      filePath: '',
      iconCount: 0,
      baseCodeGen: _assertThisInitialized(_this)
    }; // TODO: any => LayerCodeGen in next line

    _this.componentCodeGenMap = new Map(lodash.entries({
      view: ViewCodeGen,
      root: RootCodeGen,
      file: FileCodeGen,
      text: TextCodeGen,
      image: ImageCodeGen,
      ellipse: EllipseCodeGen,
      scrollView: ScrollViewCodeGen,
      symbol: SymbolLayerCodeGen,
      textInput: TextInputCodeGen,
      touchableOpacity: TouchableOpacityCodeGen,
      path: PathCodeGen,
      literal: LiteralCodeGen,
      icon: IconCodeGen,
      activityIndicator: ActivityIndicatorCodeGen,
      mapView: MapViewCodeGen,
      slider: SliderCodeGen,
      "switch": SwitchCodeGen,
      expressionStatement: ExpressionStatementCodeGen,
      binaryExpression: BinaryExpressionCodeGen,
      expression: ExpressionCodeGen,
      conditionalExpression: ConditionalExpressionCodeGen,
      logicalExpression: LogicalExpressionCodeGen,
      loop: LoopCodeGen,
      stack: WrapperCodeGen,
      row: WrapperCodeGen,
      body: WrapperCodeGen,
      column: WrapperCodeGen,
      flexFiller: WrapperCodeGen,
      inlineView: InlineViewCodeGen
    }));

    _this.generate = function (json, extraParams) {
      var iconCount = _this.context.iconCount;

      if (json.type === 'file') {
        iconCount = getIconCount(_this.context, json.layer);
      }

      _this.context.iconCount = iconCount;

      var LayerCodeGenClass = _this.componentCodeGenMap.get(json.type);

      var display = lodash.get(json, 'props.style.display', undefined);

      if (display === 'flex') {
        delete json.props.style.display;
      }

      var flexDirection = lodash.get(json, 'props.style.flexDirection', undefined);

      if (flexDirection === 'column') {
        delete json.props.style.flexDirection;
      }

      var opacity = lodash.get(json, 'props.style.opacity', undefined);

      if (opacity === 1) {
        delete json.props.style.opacity;
      }

      var borderRadius = lodash.get(json, 'props.style.borderRadius', undefined);

      if (borderRadius === 0) {
        delete json.props.style.borderRadius;
      }

      var transform = lodash.get(json, 'props.style.transform', undefined);

      if (transform) {
        var rotation = getRotation(transform);

        if (rotation) {
          json.props.style.transform = [{
            rotate: rotation.toFixed(2) + 'deg'
          }];
        } else {
          delete json.props.style.transform;
        }
      } // Deleting source_local field for image layer
      // source_local to store local image url


      var sourceLocal = lodash.get(json, 'props.source_local', undefined);

      if (sourceLocal) {
        delete json.props.source_local;
      }

      if (lodash.get(json, 'template.centerVertical') || lodash.get(json, 'template.centerHorizontal')) {
        var centerCodeGen = new CenterCodeGen(_this.context);
        centerCodeGen.config = _this.config;
        return centerCodeGen.generate(json, extraParams);
      }

      if (LayerCodeGenClass) {
        var layerCodeGen = new LayerCodeGenClass(_this.context);
        layerCodeGen.config = _this.config;
        return layerCodeGen.generate(json, extraParams);
      } else {
        console.error(json.type + ' layer not handled');
      }

      return '';
    };

    return _this;
  }

  return BaseCodeGen;
}(LayerCodeGen);

var ReactNativeEngine = /*#__PURE__*/function () {
  function ReactNativeEngine() {}

  var _proto = ReactNativeEngine.prototype;

  _proto.getFileCode = function getFileCode(fileJSON, config) {
    // console.log(fileJSON, "codeengine*");
    var baseCodeGen = new BaseCodeGen();
    baseCodeGen.config = config;
    var code = baseCodeGen.generate(fileJSON, {
      parent: fileJSON
    }); // TODO: Temporary Fix in case if this.props is still present in the code

    code = code.replace(/this.props/g, 'props');
    code = prettier.format(code, {
      plugins: [prettierBabylon],
      parser: 'babylon'
    });
    return code;
  };

  _proto.getAppFiles = function getAppFiles(files) {
    // console.log(files, "files");
    var stackNavigator = "DrawerNavigation: {\n      screen: DrawerNavigation\n    },";
    var navigator = "";
    var imports = "";
    lodash.forEach(files.artboards, function (artboard) {
      navigator += artboard + ":" + artboard + ",";
      imports += "import " + artboard + " from \"./src/screens/" + artboard + "\";";
    });
    stackNavigator += navigator;
    var fonts = '';
    lodash.forEach(files.assets, function (font) {
      fonts += "\"" + path.basename(font, path.extname(font)) + "\": require(\"." + font + "\"),";
    });
    lodash.forEach(files.missingAssets, function (missingAsset) {
      fonts += "\"" + path.basename(missingAsset.file.path, path.extname(missingAsset.file.path)) + "\": require(\"." + missingAsset.fallbackPath + "\"),";
    });
    fonts = "Font.loadAsync({\n      " + fonts + "\n    })";
    var code = "import React,{useState} from 'react';\n    import { createAppContainer } from \"react-navigation\";\n    import { createStackNavigator } from \"react-navigation-stack\";\n    import { createDrawerNavigator } from \"react-navigation-drawer\";\n    import { AppLoading } from \"expo\";\n    " + (files.assets.length > 0 ? "import * as Font from \"expo-font\";" : '') + "\n    " + imports + "\n\n    const DrawerNavigation = createDrawerNavigator({" + navigator + "});\n\n    const StackNavigation = createStackNavigator({" + stackNavigator + "},\n      {\n        headerMode: \"none\"\n      });\n\n      const AppContainer = createAppContainer(StackNavigation);\n\n      function App() {\n        const\xA0[isLoadingComplete,\xA0setLoadingComplete]\xA0=\xA0useState(false);\n        if\xA0(!isLoadingComplete)\xA0{\n        return\xA0(\n        <AppLoading\n        startAsync={loadResourcesAsync}\n        onError={handleLoadingError}\n        onFinish={()\xA0=>\xA0handleFinishLoading(setLoadingComplete)}\n        />\n        );\n      }\n      else\xA0{\n        return\xA0isLoadingComplete\xA0?\xA0<AppContainer/>\xA0:\xA0<AppLoading\xA0/>;\n      }\n    }\n    async\xA0function\xA0loadResourcesAsync()\xA0{\n      await\xA0Promise.all([\n      \n      " + fonts + "\n      \n      ]);\n      }  \n      function\xA0handleLoadingError(error)\xA0{\n\n        console.warn(error);\n        \n        }\n        \n        function\xA0handleFinishLoading(setLoadingComplete)\xA0{\n        \n        setLoadingComplete(true);\n        \n        }\n        \n        export\xA0default\xA0App";
    return [{
      path: '/App.js',
      content: prettier.format(code, {
        plugins: [prettierBabylon],
        parser: 'babylon'
      })
    }];
  };

  _proto.getIndexWithFont = function getIndexWithFont(assets) {
    var fonts = '';
    lodash.forEach(assets, function (font) {
      fonts += "\"" + path.basename(font, path.extname(font)) + "\": require(\"." + font.replace('src/assets', 'assets') + "\"),";
    });
    fonts = "await Font.loadAsync({\n      " + fonts + "\n    });";
    var code = "import React from 'react';\n    import { YellowBox } from 'react-native';\n    import { AppLoading } from \"expo\";\n    import Index from \"./index\";\n    " + (assets.length > 0 ? "import * as Font from \"expo-font\";" : '') + "\n\n    export default class IndexWithFont extends React.Component {\n\n      constructor() {\n        super();\n        this.state = {\n          fontLoaded: false\n        };\n        YellowBox.ignoreWarnings([\n          'Warning: componentWillMount is deprecated',\n          'Warning: componentWillReceiveProps is deprecated',\n          'Warning: componentWillUpdate is deprecated',\n        ]);\n      }\n\n      " + (assets.length > 0 ? 'async' : '') + " componentDidMount() {\n        " + (assets.length > 0 ? fonts : '') + "\n        this.setState({ fontLoaded: true });\n      }\n\n      render() {\n        return this.state.fontLoaded ? <Index /> : <AppLoading />;\n      }\n    }";
    return [{
      path: './indexWithFont.js',
      content: prettier.format(code, {
        plugins: [prettierBabylon],
        parser: 'babylon'
      })
    }];
  };

  return ReactNativeEngine;
}();
ReactNativeEngine.engineName = 'react-native-new';

var packageJSON = {
  "private": true,
  main: 'node_modules/expo/AppEntry.js',
  scripts: {
    start: 'expo start',
    android: 'expo start --android',
    ios: 'expo start --ios',
    web: 'expo start --web',
    eject: 'expo eject'
  },
  dependencies: {
    '@builderx/utils': '~0.1.7',
    expo: '^35.0.0',
    'expo-font': '~7.0.0',
    lodash: '~4.17.4',
    react: '16.8.3',
    'react-dom': '16.8.3',
    'react-native': 'https://github.com/expo/react-native/archive/sdk-35.0.0.tar.gz',
    'react-native-gesture-handler': '~1.3.0',
    'react-native-reanimated': '~1.2.0',
    'react-native-screens': '~1.0.0-alpha.23',
    'react-native-svg': '9.9.5',
    'react-native-web': '~0.11.7',
    'react-native-web-maps': '^0.2.0',
    'react-navigation': '4.0.10',
    'react-navigation-drawer': '~2.3.3',
    'react-navigation-stack': '~1.10.3'
  },
  devDependencies: {
    'babel-plugin-module-resolver': '^4.0.0',
    'babel-preset-expo': '^7.0.0'
  }
};
var appJSON = {
  expo: {
    name: 'BxProject',
    slug: 'BxProject',
    privacy: 'public',
    sdkVersion: '35.0.0',
    platforms: ['ios', 'android', 'web'],
    version: '1.0.0',
    orientation: 'portrait',
    updates: {
      fallbackToCacheTimeout: 0
    },
    ios: {
      supportsTablet: true
    }
  }
};
var babelConfigJSContent = "module.exports = function (api) {\n  api.cache(true);\n  return {\n    presets: [\"babel-preset-expo\"],\n    plugins: [\n      [\n        \"module-resolver\",\n        {\n          root: [\"./src\"],\n          alias: {\n            \"react-native-maps\": \"react-native-web-maps\",\n          },\n        },\n      ],\n    ],\n  };\n};\n";
var indexHTML = "<!DOCTYPE html>\n<html lang=\"%LANG_ISO_CODE%\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta httpEquiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <!-- \n      This viewport works for phones with notches.\n      It's optimized for gestures by disabling global zoom.\n     -->\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1.00001, viewport-fit=cover\"\n    />\n    <title>%WEB_TITLE%</title>\n    <script src=\"https://maps.googleapis.com/maps/api/js?key=<YOUR_GOOGLE_API_KEY>\"></script>\n    <style>\n      /**\n       * Extend the react-native-web reset:\n       * https://github.com/necolas/react-native-web/blob/master/packages/react-native-web/src/exports/StyleSheet/initialRules.js\n       */\n      html,\n      body,\n      #root {\n        width: 100%;\n        /* To smooth any scrolling behavior */\n        -webkit-overflow-scrolling: touch;\n        margin: 0px;\n        padding: 0px;\n        /* Allows content to fill the viewport and go beyond the bottom */\n        min-height: 100%;\n      }\n      #root {\n        flex-shrink: 0;\n        flex-basis: auto;\n        flex-grow: 1;\n        display: flex;\n        flex: 1;\n      }\n\n      html {\n        scroll-behavior: smooth;\n        /* Prevent text size change on orientation change https://gist.github.com/tfausak/2222823#file-ios-8-web-app-html-L138 */\n        -webkit-text-size-adjust: 100%;\n        height: 100%;\n      }\n\n      body {\n        display: flex;\n        /* Allows you to scroll below the viewport; default value is visible */\n        overflow-y: auto;\n        overscroll-behavior-y: none;\n        text-rendering: optimizeLegibility;\n        -webkit-font-smoothing: antialiased;\n        -moz-osx-font-smoothing: grayscale;\n        -ms-overflow-style: scrollbar;\n      }\n      /* Enable for apps that support dark-theme */\n      /*@media (prefers-color-scheme: dark) {\n        body {\n          background-color: black;\n        }\n      }*/\n    </style>\n  </head>\n\n  <body>\n    <!-- \n      A generic no script element with a reload button and a message.\n      Feel free to customize this however you'd like.\n    -->\n    <noscript>\n      <form\n        action=\"\"\n        style=\"\n          background-color: #fff;\n          position: fixed;\n          top: 0;\n          left: 0;\n          right: 0;\n          bottom: 0;\n          z-index: 9999;\n        \"\n      >\n        <div\n          style=\"\n            font-size: 18px;\n            font-family: Helvetica, sans-serif;\n            line-height: 24px;\n            margin: 10%;\n            width: 80%;\n          \"\n        >\n          <p>Oh no! It looks like JavaScript is not enabled in your browser.</p>\n          <p style=\"margin: 20px 0;\">\n            <button\n              type=\"submit\"\n              style=\"\n                background-color: #4630eb;\n                border-radius: 100px;\n                border: none;\n                box-shadow: none;\n                color: #fff;\n                cursor: pointer;\n                font-weight: bold;\n                line-height: 20px;\n                padding: 6px 16px;\n              \"\n            >\n              Reload\n            </button>\n          </p>\n        </div>\n      </form>\n    </noscript>\n    <!-- The root element for your Expo app. -->\n    <div id=\"root\"></div>\n  </body>\n</html>\n\n"; // tslint:disable: max-line-length

var flowConfigContent = "[ignore]\n; We fork some components by platform\n.*/*[.]android.js\n\n; Ignore templates for 'react-native init'\n<PROJECT_ROOT>/node_modules/react-native/local-cli/templates/.*\n\n; Ignore RN jest\n<PROJECT_ROOT>/node_modules/react-native/jest/.*\n\n; Ignore RNTester\n<PROJECT_ROOT>/node_modules/react-native/RNTester/.*\n\n; Ignore the website subdir\n<PROJECT_ROOT>/node_modules/react-native/website/.*\n\n; Ignore the Dangerfile\n<PROJECT_ROOT>/node_modules/react-native/danger/dangerfile.js\n\n; Ignore Fbemitter\n<PROJECT_ROOT>/node_modules/fbemitter/.*\n\n; Ignore \"BUCK\" generated dirs\n<PROJECT_ROOT>/node_modules/react-native/.buckd/\n\n; Ignore unexpected extra \"@providesModule\"\n.*/node_modules/.*/node_modules/fbjs/.*\n\n; Ignore polyfills\n<PROJECT_ROOT>/node_modules/react-native/Libraries/polyfills/.*\n\n; Ignore various node_modules\n<PROJECT_ROOT>/node_modules/react-native-gesture-handler/.*\n<PROJECT_ROOT>/node_modules/expo/.*\n<PROJECT_ROOT>/node_modules/react-navigation/.*\n<PROJECT_ROOT>/node_modules/xdl/.*\n<PROJECT_ROOT>/node_modules/reqwest/.*\n<PROJECT_ROOT>/node_modules/metro-bundler/.*\n\n[include]\n\n[libs]\nnode_modules/react-native/Libraries/react-native/react-native-interface.js\nnode_modules/react-native/flow/\nnode_modules/expo/flow/\n\n[options]\nemoji=true\n\nmodule.system=haste\n\nmodule.file_ext=.js\nmodule.file_ext=.jsx\nmodule.file_ext=.json\nmodule.file_ext=.ios.js\n\nmunge_underscores=true\n\nmodule.name_mapper='^[./a-zA-Z0-9$_-]+.(bmp|gif|jpg|jpeg|png|psd|svg|webp|m4v|mov|mp4|mpeg|mpg|webm|aac|aiff|caf|m4a|mp3|wav|html|pdf)$' -> 'RelativeImageStub'\n\nsuppress_type=$FlowIssue\nsuppress_type=$FlowFixMe\nsuppress_type=$FlowFixMeProps\nsuppress_type=$FlowFixMeState\nsuppress_type=$FixMe\n\nsuppress_comment=\\(.\\|\n\\)*\\$FlowFixMe\\($\\|[^(]\\|(\\(>=0\\.\\(5[0-6]\\|[1-4][0-9]\\|[0-9]\\).[0-9]\\)? *\\(site=[a-z,_]*react_native_oss[a-z,_]*\\)?)\\)\nsuppress_comment=\\(.\\|\n\\)*\\$FlowIssue\\((\\(>=0\\.\\(5[0-6]\\|[1-4][0-9]\\|[0-9]\\).[0-9]\\)? *\\(site=[a-z,_]*react_native_oss[a-z,_]*\\)?)\\)?:? #[0-9]+\nsuppress_comment=\\(.\\|\n\\)*\\$FlowFixedInNextDeploy\nsuppress_comment=\\(.\\|\n\\)*\\$FlowExpectedError\n\nunsafe.enable_getters_and_setters=true\n\n[version]\n^0.56.0\n";
var watchmanConfigContent = "{}\n";
var gitIgnoreContent = "# See https://help.github.com/ignore-files/ for more about ignoring files.\n\n# expo\n.expo/\n\n# dependencies\n/node_modules\n\n# misc\n.env.local\n.env.development.local\n.env.test.local\n.env.production.local\n\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\n";
var componentReadme = "This component was created with [BuilderX](https://builderx.io/).\n\n## BuilderX uses third party libraries for some of the react-native components such as\n\n```\n@builderx/utils@0.1.6\nlodash\nreact-navigation@4.0.10\nreact-native-svg\nreact-native-maps\n```\n\nYou can add these packages by running `yarn add [packageName]` or `npm install [packageName]`.\n\n## Please add the extracted component folder in your project and import the component folder.\n\nE.g. import Component from `[folder path]`.\n\n**Note: You might need to load custom fonts that have been used in the component. Font files are available in the `assets/fonts` folder. You can add this code to load these fonts**\n\n### For Expo project\n\n```\nimport { Font } from \"expo\";\n\nasync componentDidMount(){\n  await Font.loadAsync({\n    <font-name>:require(<relative-path-to-font-file>)\n  })\n}\n```\n\n### For React-Native project\n\n1. Add rnpm to package.json providing the path to the font files.\n```\n\"rnpm\": {\n  \"assets\": [\n    \"./src/assets/fonts/\"\n  ]\n}\n```\n2. Run react-native link.\n";
var projectReadme = "This project was created with [BuilderX](https://builderx.io/).\n\n## BuilderX uses third party libraries for some of the react-native components such as\n\n```\n@builderx/utils@0.1.6\nlodash\nreact-navigation@4.0.10\nreact-native-svg\nreact-native-maps\n```\n\nThese packages are included as dependencies in package.json file\n\n## Steps to run project\n\nIn the project directory, you can run:\n\n### `yarn` or `npm install`\n\nThis will add the dependencies required to run the project.\n\n### `yarn start` or `npm start`\n\nThis will start the project.\n\n**Note: BuilderX generates Expo project at the moment, if you want to add custom fonts in your create-react-native-app project please refer these steps**\n\n1. Add Fonts to an \"assets/fonts\" folder in the root of your project.\n2. Add rnpm to package.json providing the path to the font files:\n\n```\n\"rnpm\": {\n  \"assets\": [\n    \"./assets/fonts/\"\n  ]\n}\n```\n\n3. Run react-native link\n\n##### This should add your custom fonts in the react native project.\n\n";

var ExpoFiles = {
  __proto__: null,
  packageJSON: packageJSON,
  appJSON: appJSON,
  babelConfigJSContent: babelConfigJSContent,
  indexHTML: indexHTML,
  flowConfigContent: flowConfigContent,
  watchmanConfigContent: watchmanConfigContent,
  gitIgnoreContent: gitIgnoreContent,
  componentReadme: componentReadme,
  projectReadme: projectReadme
};

var reactNativeEngine = /*#__PURE__*/new ReactNativeEngine();

var ReactNativeCodeEngine = function ReactNativeCodeEngine() {
  this.meta = {
    name: 'react-native',
    title: 'React Native',
    icon: 'https://pre-cloud.builderx.io/assets/plugins/component/icons/React.svg'
  };

  this.execute = function (fileJSON, config) {
    return reactNativeEngine.getFileCode(fileJSON, config);
  };

  this.getFiles = function () {
    return ExpoFiles;
  };

  this.getFilesToWrite = function () {
    var filesMap = new Map();
    filesMap.set('/package.json', {
      content: JSON.stringify(packageJSON, null, 2)
    });
    filesMap.set('/app.json', {
      content: JSON.stringify(appJSON, null, 2)
    });
    filesMap.set('/babel.config.js', {
      content: babelConfigJSContent
    });
    filesMap.set('/web/index.html', {
      content: indexHTML
    });
    filesMap.set('/.watchmanconfig', {
      content: watchmanConfigContent
    });
    filesMap.set('/.flowconfig', {
      content: flowConfigContent
    });
    filesMap.set('/.gitignore', {
      content: gitIgnoreContent
    });
    filesMap.set('/README.md', {
      content: projectReadme
    });
    return filesMap;
  }; // this.baseCondeGen = new BaseCodeGen();

};

var ReactNativeCodeGen = /*#__PURE__*/function () {
  function ReactNativeCodeGen() {
    this.name = 'ReactNativeCodeGen';
  }

  var _proto = ReactNativeCodeGen.prototype;

  _proto.init = function init(session) {
    this.session = session;
  };

  _proto.activate = function activate() {
    var codeEngine = new ReactNativeCodeEngine();
    this.session.addCodeEngine(codeEngine);
  };

  _proto.deactivate = function deactivate() {};

  _proto.logSession = function logSession() {
    this.session.executeFunction('logSession');
  };

  return ReactNativeCodeGen;
}();

exports.ReactNativeCodeGen = ReactNativeCodeGen;
exports.ReactNativeEngine = ReactNativeEngine;
//# sourceMappingURL=react-native-plugin.cjs.development.js.map
