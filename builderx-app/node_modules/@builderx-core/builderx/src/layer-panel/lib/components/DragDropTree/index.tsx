import * as React from "react";
import Node from "../../components/Node";
import { Layer as LayerModel } from "domain-x";
import NodeStart from "../../components/NodeStart";
import NodeEnd from "../../components/NodeEnd";
import { get } from "lodash";
export default class DragDropTree extends React.PureComponent<
  {
    layer: LayerModel;
    onChange: any;
    renderNode: (props: any, children: any, getRef: any) => any;
    renderWrapper: (layer: any) => any;
    renderDivider: (props: any) => any;
    fetchChildren: (layer: LayerModel) => any;
    fetchPath: (layer: LayerModel) => any;
    onClick: (target: any, layer: any) => any;
    onDoubleClick: (target: any, layer: any) => any;
    onContextMenu: (target: any, layer: any, originalEvent: any) => any;
    onHover: (target: any, layer: any) => any;
    onDragHover: (target: any, layer: any, position: string) => any;
    onMouseOut: (target: any, layer: any) => any;
    onMouseOver: (target: any, layer: any) => any;
    onMouseEnter: (target: any, layer: any) => any;
    onMouseLeave: (target: any, layer: any) => any;
    onDragEnd: (target: any, layer: any) => any;
  },
  any
> {
  draggedNode: any;
  position: any;
  targetNode: any;
  targetNodeId: string;
  dropTargetLayerHover: LayerModel | undefined;
  dropTargetLayer: LayerModel | undefined;
  dropTargetNode: any;
  dropTargetPosition: any;
  dropToNext: boolean = false;
  prevPageY: number | undefined;

  getTargetLayer() {
    const positionsArray = this.getPositionsArray();
    let position = positionsArray[positionsArray.length - 1];
    return get(this.props.layer, position);
  }

  getPositionsArray() {
    if (!this.position) {
      return null;
    }
    return this.position.split("_");
  }

  getDraggedNode(path: string) {
    return get(this.props.layer, path) as LayerModel;
  }
  onChangeDragOver = (target: any, layer: LayerModel) => {
    let position: string = "";
    let nodeId: string = "";
    this.dropTargetLayerHover = undefined;
    this.dropTargetLayer = undefined;
    this.dropTargetNode = undefined;
    this.dropTargetPosition = undefined;
    if (target && target.getAttribute("data-position")) {
      position = target.getAttribute("data-position");
      nodeId = target.getAttribute("data-node-id");
    }
    this.targetNodeId = nodeId;
    this.position = position;
    if (position) {
      this.dropTargetLayerHover = layer;
      this.dropTargetLayer = layer;
      this.dropTargetNode = target;
      let pos = this.getPositionsArray()[1];
      if (layer.isGroup || pos !== "inside") {
        this.props.onDragHover(target, layer, pos);
      }
    }
  };
  onChangeDragEnd = (
    target: any,
    sourceLayer: LayerModel,
    dataPath: string
  ) => {
    this.props.onDragEnd(target, sourceLayer);
    this.draggedNode = this.getDraggedNode(dataPath);
    let targetPosition = this.getPositionsArray();
    if (!targetPosition) {
      return;
    }
    targetPosition = targetPosition[1];
    const targetLayer = this.getTargetLayer();
    if (!sourceLayer || !targetLayer) {
      return;
    }
    this.props.onChange(
      sourceLayer,
      targetLayer,
      targetPosition,
      this.dropTargetLayer,
      this.dropTargetPosition
    );
    this.dropTargetPosition = undefined;
  };
  onChangeClick = (target: any, layer: LayerModel) => {
    this.props.onClick(target, layer);
  };
  onDoubleClick = (target: any, layer: LayerModel) => {
    this.props.onDoubleClick(target, layer);
  };
  onContextMenu = (target: any, layer: LayerModel, originalEvent: any) => {
    this.props.onContextMenu(target, layer, originalEvent);
  };
  onHover = (target: any, layer: LayerModel) => {
    this.props.onHover(target, layer);
  };
  onMouseOut = (target: any, layer: LayerModel) => {
    this.props.onMouseOut(target, layer);
  };
  onMouseOver = (target: any, layer: LayerModel) => {
    this.props.onMouseOver(target, layer);
  };
  onMouseEnter = (target: any, layer: LayerModel) => {
    this.dropToNext = false;
    this.props.onMouseEnter(target, layer);
  };
  onMouseLeave = (target: any, layer: LayerModel) => {
    this.dropToNext = false;
    this.props.onMouseLeave(target, layer);
  };
  onDrag = (target: any, e: any, layer: LayerModel) => {
    let bounds: any = {};
    if (
      this.dropTargetNode &&
      e.pageY !== this.prevPageY &&
      target &&
      this.dropTargetLayerHover &&
      !this.dropTargetLayerHover.isGroup &&
      this.dropTargetLayerHover.parent &&
      get(this.getPositionsArray(), "[1]") === "inside"
    ) {
      bounds = this.dropTargetNode.getBoundingClientRect();
      // DOC: checking if the mouse position is greater than half of the target node height
      this.dropToNext = e.pageY > bounds.top + bounds.height / 2 ? true : false;
      let index = this.dropTargetLayerHover.parent.children.indexOf(
        this.dropTargetLayerHover
      );
      if (index > 0 && !this.dropToNext) {
        let prevLayer = this.dropTargetLayerHover.parent.children[index - 1];
        this.dropTargetPosition = "before";
        this.dropTargetLayer = prevLayer;
        this.props.onDragHover(target, prevLayer, "before");
      } else {
        this.dropTargetPosition = this.dropToNext ? "before" : "after";
        this.dropTargetLayer = this.dropTargetLayerHover;
        this.props.onDragHover(
          target,
          this.dropTargetLayerHover,
          this.dropToNext ? "before" : "after"
        );
      }
    }
    this.prevPageY = e.pageY;
  };
  render() {
    return this.props.renderWrapper([
      <NodeEnd
        key={"nodeEnd" + "_" + this.props.fetchPath(this.props.layer)}
        renderDivider={this.props.renderDivider}
        onChangeDragOver={this.onChangeDragOver}
        path={""}
        layer={this.props.layer}
      />,
      <Node
        key={"nodeData" + "_" + this.props.fetchPath(this.props.layer)}
        layer={this.props.layer}
        path={""}
        onChangeDragOver={this.onChangeDragOver}
        onChangeDragEnd={this.onChangeDragEnd}
        renderNode={this.props.renderNode}
        renderWrapper={this.props.renderWrapper}
        renderDivider={this.props.renderDivider}
        fetchChildren={this.props.fetchChildren}
        fetchPath={this.props.fetchPath}
        onChangeClick={this.onChangeClick}
        onDoubleClick={this.onDoubleClick}
        onHover={this.onHover}
        onContextMenu={this.onContextMenu}
        onMouseOut={this.onMouseOut}
        onMouseOver={this.onMouseOver}
        onMouseEnter={this.onMouseEnter}
        onMouseLeave={this.onMouseLeave}
        onDrag={this.onDrag}
      />,
      <NodeStart
        key={"nodeStart" + "_" + this.props.fetchPath(this.props.layer)}
        renderDivider={this.props.renderDivider}
        onChangeDragOver={this.onChangeDragOver}
        path={""}
        layer={this.props.layer}
      />
    ]);
  }
}
