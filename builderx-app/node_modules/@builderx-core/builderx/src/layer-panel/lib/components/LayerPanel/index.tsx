import * as React from "react";
import { IEvent } from "common-interfaces";
import {
  Button,
  Icon,
  Layer,
  LayerAfter,
  LayerBar,
  LayerBefore,
  LayerBody,
  LayerChildren,
  LayerLeft,
  LayerRight,
  Text
} from "components-x";
import { File as DomainFile, Layer as LayerModel } from "domain-x";
import { ResolveNodeValue, Utils } from "utils";
import DragDropTree from "../DragDropTree";
import { get, split, reverse } from "lodash";
const updateProps = [
  // "hovered",
  // "selected",
  // "locked",
  // "collapsed",
  // "dragHoverInside",
  // "dragHoverBefore",
  // "dragHoverAfter",
  // "dragHoverParent",
  "children"
  // "isGroup"
];
class LayerPanel extends React.PureComponent<
  {
    layer: LayerModel;
    onEvent: (event: IEvent) => void;
    active: boolean;
  },
  any
> {
  onUpdate = () => {
    this.forceUpdate();
  };
  hasChildren = (layer: LayerModel) => {
    let display = false;
    if (layer) {
      const layerName = get(layer, "import.layerName", "");
      if (
        layerName &&
        (layerName === "View" ||
          layerName === "TouchableOpacity" ||
          layerName === "ImageBackground" ||
          (layerName === "ScrollView" && this.props.layer === layer)) &&
        layer.children.length > 0
      ) {
        display = true;
      }
    }
    return display;
  };
  componentDidMount() {
    if (Utils.shouldIgnoreLayer(this.props.layer.type)) {
      return;
    }
    const file = this.props.layer.parent as DomainFile;
    file.on("scopeVariables", this.onUpdate);
    this.props.layer.on(updateProps, this.onUpdate);
    this.props.layer.props.style.on("display", this.onUpdate);
  }

  componentDidUpdate(prevProps: any) {
    if (Utils.shouldIgnoreLayer(this.props.layer.type)) {
      return;
    }
    const prevFile = prevProps.layer.parent as DomainFile;
    const newFile = this.props.layer.parent as DomainFile;

    if (newFile && prevFile && newFile !== prevFile) {
      prevFile.off("scopeVariables", this.onUpdate);
      newFile.on("scopeVariables", this.onUpdate);
      this.onUpdate();
    }

    if (this.props.layer !== prevProps.layer) {
      prevProps.layer.off(updateProps, this.onUpdate);
      if (prevProps.layer.props) {
        prevProps.layer.props.style.off("display", this.onUpdate);
      }
      this.props.layer.on(updateProps, this.onUpdate);
      this.props.layer.props.style.on("display", this.onUpdate);
    }
  }

  componentWillUnmount() {
    if (Utils.shouldIgnoreLayer(this.props.layer.type)) {
      return;
    }
    const file = this.props.layer.parent as DomainFile;
    if (file) {
      file.off("scopeVariables", this.onUpdate);
    }
    this.props.layer.off(updateProps, this.onUpdate);
    this.props.layer.props.style.off("display", this.onUpdate);
  }

  getResolvedLayer(layer: any): any {
    if (!layer || !layer.type || layer.type === "unknown") {
      return false;
    }
    if (layer.type === "loop") {
      layer = layer.children[0];
    }
    if (layer && layer.type && Utils.shouldIgnoreLayer(layer.type)) {
      let scopeVariables = {};
      let file = layer.getFile();

      if (file) {
        scopeVariables = file.scopeVariables;
      }
      layer = ResolveNodeValue(layer, scopeVariables);
    }
    return layer;
  }
  upperCaseFirst(styleName: string): string {
    return styleName.charAt(0).toUpperCase() + styleName.slice(1);
  }
  renderNode = (props: any, children: any, getRef: any) => {
    let layer = this.getResolvedLayer(props.layer);
    if (!layer || layer.type === "unknown") {
      return null;
    }

    if (layer.type === "loop") {
      layer = layer.children[0];
    }

    // if (layer && layer.type === "statusBar") {
    //   props.draggable = false;
    // }
    let layerCollapsed: boolean = layer.collapsed || false;
    if (!layer._parent) {
      return null;
    }
    let layerHidden = layer.hidden;

    let abstractedLayer = layer.getAbstractedLayer();
    let decomposedPartialId = abstractedLayer.getPartialPath
      ? split(abstractedLayer.getPartialPath(), ".").filter(
          (item: any) => item !== "children"
        )
      : "";
    let iconName: string = "folder";
    switch (layer.type) {
      case "view":
      case "touchableOpacity":
        iconName =
          this.hasChildren(layer) || layer.isGroup
            ? "folder"
            : "rectangle-shape";
        break;
      case "text":
      case "textInput":
        iconName = "text";
        break;
      case "icon":
        iconName = "icon";
        break;
      case "image":
        iconName = "image";
        break;
      case "ellipse":
        iconName = "ellipse-shape";
        break;
      case "path":
        iconName = "shape";
        break;
      case "scrollView":
        iconName = "scrollview";
        break;
      default:
        break;
    }
    let isRootView = layer.type === "root";
    let level = 0;
    level = Math.max(decomposedPartialId.length - 2, 0);
    const onDoubleClick = props.onDoubleClick;
    delete props.onDoubleClick;
    return (
      layer && (
        <Layer
          borderBottom={!isRootView}
          open={!layerCollapsed}
          dragHoverParent={layer.dragHoverParent}
        >
          {!isRootView && (
            <LayerBar
              sublayer
              dragHoverBefore={layer.dragHoverBefore}
              dragHoverAfter={layer.dragHoverAfter}
              dragHoverParent={layer.dragHoverParent}
              selected={layer.selected}
              hover={!layer.locked && layer.hovered}
              dragHoverInside={layer.dragHoverInside}
              level={level}
              {...props}
              ref={(c: any) => {
                getRef(c);
              }}
              onClick={(e: any) => {
                if (!layer.locked && !layer.hidden) {
                  this.props.onEvent({
                    type: "onClick",
                    payload: { layer },
                    originalEvent: {}
                  });
                }
              }}
            >
              <LayerLeft
                style={{ display: "flex" }}
                onClick={(e: any) => {
                  e.stopPropagation();
                  this.props.onEvent({
                    type: "toggleCollapse",
                    payload: layer,
                    originalEvent: {}
                  });
                }}
              >
                {this.hasChildren(layer) && (
                  <Button
                    transparent
                    marginTop={-2}
                    paddingLeft={0}
                    paddingRight={4}
                    marginLeftCustom={-14}
                    icon={
                      <Icon
                        name={layerCollapsed ? "right2" : "right"}
                        size={10}
                      />
                    }
                    uiSize="xs"
                  />
                )}
                <Icon name={iconName} size={16} />
              </LayerLeft>
              <LayerBody onDoubleClick={onDoubleClick}>
                <Text
                  style={{
                    overflow: "hidden",
                    textOverflow: "ellipsis",
                    lineHeight: 1.4
                  }}
                >
                  {this.upperCaseFirst(
                    layer.styleName ? layer.styleName : layer.type
                  )}
                </Text>
              </LayerBody>
              <LayerRight style={{ display: "flex" }}>
                {layer.hovered || layer.locked ? (
                  <Button
                    transparent
                    icon={
                      <Icon
                        name="lock"
                        size={16}
                        onMouseEnter={() => {
                          // self.onBtnHoverEnter(layerId);
                        }}
                        onMouseLeave={() => {
                          // self.onBtnHoverEnter(layerId);
                        }}
                      />
                    }
                    onClick={(e: any) => {
                      e.stopPropagation();
                      this.props.onEvent({
                        type: "toggleLock",
                        payload: layer,
                        originalEvent: {}
                      });
                    }}
                    onMouseEnter={() => {
                      // self.onBtnHoverEnter(layerId);
                    }}
                    uiSize="xs"
                  />
                ) : null}
                {(!layer.locked && layer.hovered) || layerHidden ? (
                  <Button
                    transparent
                    icon={
                      <Icon
                        name={!layerHidden ? "show_layer" : "hide_layer"}
                        size={16}
                        onMouseEnter={() => {
                          // self.onBtnHoverEnter(layerId);
                        }}
                        onMouseLeave={() => {
                          // self.onBtnHoverEnter(layerId);
                        }}
                      />
                    }
                    onMouseEnter={() => {
                      // self.onBtnHoverEnter(layerId);
                    }}
                    onClick={(e: any) => {
                      e.stopPropagation();
                      this.props.onEvent({
                        type: "toggleHide",
                        payload: layer,
                        originalEvent: {}
                      });
                    }}
                    uiSize="xs"
                  />
                ) : null}
              </LayerRight>
            </LayerBar>
          )}
          <LayerChildren>{children}</LayerChildren>
        </Layer>
      )
    );
  };

  renderDivider = (props: any) => {
    let layer = this.getResolvedLayer(props.layer);

    if (!layer || layer.type === "unknown") {
      return false;
    }

    let isFirstItem = false;
    let open: boolean = false;

    if (layer.children && !layer.collapsed) {
      open = true;
    }
    let position = props["data-position"].split("_")[1];
    let isRootView = layer.type === "root";
    const siblings = get(layer, "parent.children");
    let level = 0;
    let abstractedLayer = layer.getAbstractedLayer();
    let decomposedPartialId = abstractedLayer.getPartialPath
      ? split(abstractedLayer.getPartialPath(), ".").filter(
          (item: any) => item !== "children"
        )
      : "";
    level = Math.max(decomposedPartialId.length - 2, 0);
    if (siblings && siblings.indexOf(layer) === 0) {
      isFirstItem = true;
    }
    if (position === "before") {
      return (
        layer &&
        !isRootView && (
          <LayerBefore
            {...props}
            level={level}
            hover={!layer.collapsed && layer.hovered}
            selected={layer.selected}
            dragHoverInside={layer.dragHoverInside}
            isGroup={layer.isGroup}
            dragHoverBefore={layer.dragHoverBefore}
            dragHoverAfter={layer.dragHoverAfter}
          />
        )
      );
    } else if (position === "after" && layer) {
      return (
        !isRootView &&
        isFirstItem && (
          <LayerAfter
            {...props}
            level={level}
            hover={!layer.collapsed && layer.hovered}
            selected={layer.selected}
            dragHoverInside={layer.dragHoverInside}
            dragHoverAfter={layer.dragHoverAfter}
            open={open}
          />
        )
      );
    } else {
      return null;
    }
  };
  renderWrapper(node: any) {
    return <div>{node}</div>;
  }

  fetchChildren = (layer: LayerModel) => {
    if (!this.hasChildren(layer)) {
      return [];
    }
    let children: any = [...layer.children];

    let newChildren: any = [];
    children.map((child: any) => {
      const resolvedChild = this.getResolvedLayer(child);
      if (resolvedChild) {
        newChildren.push(resolvedChild);
      }
    });
    return newChildren;
  };

  fetchPath = (layer: LayerModel) => {
    const abstractedLayer = layer.getAbstractedLayer();
    const currentRootLayerPath = this.props.layer.getPartialPath();
    return abstractedLayer
      .getPartialPath()
      .substring(currentRootLayerPath.length + 1);
  };

  onChange = (
    sourceLayer: LayerModel,
    targetLayer: LayerModel,
    targetPosition: string,
    dropTargetLayer?: string,
    dropTargetPosition?: string
  ) => {
    if (!sourceLayer || !targetLayer) {
      return;
    }
    let parentLayerOfSourceLayer = sourceLayer.parent;
    let parentLayerOfTargetLayer = targetLayer.parent;

    const abstractedSourceLayer = sourceLayer.getAbstractedLayer();
    const abstractedTargetLayer = targetLayer.getAbstractedLayer();
    let draggedNodeIdSplitArray = abstractedSourceLayer
      .getPartialPath()
      .split(".");

    let fromIndexString =
      draggedNodeIdSplitArray[draggedNodeIdSplitArray.length - 1];
    let fromIndex = parseInt(fromIndexString, 10);
    let targetNodeIdSplitArray = abstractedTargetLayer
      .getPartialPath()
      .split(".");

    let toIndexString =
      targetNodeIdSplitArray[targetNodeIdSplitArray.length - 1];
    let toIndex = parseInt(toIndexString, 10);

    if (!parentLayerOfSourceLayer || !parentLayerOfTargetLayer) {
      return;
    }
    if (
      parentLayerOfSourceLayer === parentLayerOfTargetLayer &&
      fromIndex === toIndex
    ) {
      // Do nothing when DraggedNode and the TargetNode are same.
      return;
    }

    // return if drag inside its child
    if (
      sourceLayer &&
      targetLayer &&
      abstractedTargetLayer
        .getPartialPath()
        .indexOf(abstractedSourceLayer.getPartialPath()) === 0
    ) {
      return;
    }

    if (targetPosition === "after" || targetPosition === "before") {
      // Layer is dragged after the target Layer, toIndex remains same.
      toIndex = toIndex;
    } else if (targetPosition === "inside") {
      parentLayerOfTargetLayer = targetLayer;
      if (
        parentLayerOfTargetLayer.type !== "root" &&
        !parentLayerOfTargetLayer.isGroup &&
        targetLayer.parent
      ) {
        parentLayerOfTargetLayer = targetLayer.parent;
      }
      let indexOfDropTargetLayer = parentLayerOfTargetLayer.children.indexOf(
        dropTargetLayer
      );
      if (parentLayerOfSourceLayer === parentLayerOfTargetLayer) {
        toIndex =
          (fromIndex < indexOfDropTargetLayer &&
            dropTargetPosition === "before") ||
          dropTargetPosition === "after"
            ? indexOfDropTargetLayer
            : indexOfDropTargetLayer + 1;
      } else {
        toIndex =
          indexOfDropTargetLayer === -1
            ? parentLayerOfTargetLayer.children.length
            : dropTargetPosition === "before"
            ? indexOfDropTargetLayer + 1
            : indexOfDropTargetLayer;
      }
    }
    this.props.onEvent({
      type: "moveLayer",
      payload: {
        fromParent: parentLayerOfSourceLayer,
        fromIndex,
        toIndex,
        toParent: parentLayerOfTargetLayer,
        layer: sourceLayer
      },
      originalEvent: {}
    });
  };

  onClick = (target: any, layer: LayerModel) => {
    this.props.onEvent({
      type: "onClick",
      payload: { layer },
      originalEvent: {}
    });
  };

  onDoubleClick = async (target: any, layer: LayerModel) => {
    this.props.onEvent({
      type: "onDoubleClick",
      payload: { layer },
      originalEvent: {}
    });
  };

  onContextMenu = (target: any, layer: LayerModel, originalEvent: any) => {
    this.props.onEvent({
      type: "onContextMenu",
      payload: { layer, tab: "layer" },
      originalEvent
    });
  };

  onHover = (target: any, layer: LayerModel) => {
    this.props.onEvent({
      type: "onHover",
      payload: { layer },
      originalEvent: {}
    });
  };

  onDragHover = (target: any, layer: LayerModel, position: string) => {
    this.props.onEvent({
      type: "onDragHover",
      payload: {
        layer,
        position
      },
      originalEvent: {}
    });
  };
  onMouseEnter = (target: any, layer: LayerModel) => {
    this.props.onEvent({
      type: "onMouseEnter",
      payload: { layer },
      originalEvent: {}
    });
  };
  onMouseLeave = (target: any, layer: LayerModel) => {
    this.props.onEvent({
      type: "onMouseLeave",
      payload: { layer },
      originalEvent: {}
    });
  };
  onDragEnd = (target: any, layer: LayerModel) => {
    this.props.onEvent({
      type: "onDragEnd",
      payload: { layer },
      originalEvent: {}
    });
  };

  onMouseOut = (target: any, layer: LayerModel) => {
    this.props.onEvent({
      type: "onMouseOut",
      payload: { layer },
      originalEvent: {}
    });
  };

  onMouseOver = (target: any, layer: LayerModel) => {
    this.props.onEvent({
      type: "onMouseOver",
      payload: { layer },
      originalEvent: {}
    });
  };
  render() {
    if (!this.props.active) {
      return null;
    }
    return (
      <DragDropTree
        layer={this.props.layer}
        onChange={this.onChange}
        renderWrapper={this.renderWrapper}
        renderDivider={this.renderDivider}
        renderNode={this.renderNode}
        fetchChildren={this.fetchChildren}
        fetchPath={this.fetchPath}
        onClick={this.onClick}
        onDoubleClick={this.onDoubleClick}
        onContextMenu={this.onContextMenu}
        onHover={this.onHover}
        onMouseOut={this.onMouseOut}
        onMouseOver={this.onMouseOver}
        onDragHover={this.onDragHover}
        onMouseEnter={this.onMouseEnter}
        onMouseLeave={this.onMouseLeave}
        onDragEnd={this.onDragEnd}
      />
    );
  }
}

export default LayerPanel;
