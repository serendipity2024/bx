import * as React from "react";
import NodeStart from "../NodeStart";
import NodeEnd from "../NodeEnd";
import { Layer as LayerModel, File as DomainFile } from "domain-x";
import { Utils } from "utils";
import * as ReactDOM from "react-dom";
import { COLORS } from "components-x";

const updateProps = [
  "hovered",
  "selected",
  "locked",
  "collapsed",
  "dragHoverInside",
  "dragHoverBefore",
  "dragHoverAfter",
  "dragHoverParent",
  "styleName",
  "isGroup"
];
export default class Node extends React.PureComponent<
  {
    layer: LayerModel;
    path: string;
    onChangeDragOver: (target: any, layer: LayerModel) => void;
    onChangeDragEnd: (str: string, layer: LayerModel, path: string) => void;
    renderNode: (props: any, children: any, getRef: any) => any;
    renderWrapper: (node: any) => any;
    renderDivider: (props: any) => any;
    fetchChildren: (layer: LayerModel) => Array<any>;
    fetchPath: (layer: LayerModel) => any;
    onChangeClick: (node: any, layer: LayerModel) => any;
    onDoubleClick: (node: any, layer: LayerModel) => any;
    onContextMenu: (node: any, layer: LayerModel, originalEvent: any) => any;
    onHover: (target: any, layer: LayerModel) => any;
    onMouseOut: (target: any, layer: LayerModel) => any;
    onMouseOver: (target: any, layer: LayerModel) => any;
    onMouseEnter: (target: any, layer: LayerModel) => any;
    onMouseLeave: (target: any, layer: LayerModel) => any;
    onDrag: (target: any, e: any, layer: LayerModel) => any;
  },
  any
> {
  nodeRef: any;
  file: DomainFile;
  onUpdate = (keys: any) => {
    this.forceUpdate();
  };
  onUpdateDom = (keys: any) => {
    const dom = ReactDOM.findDOMNode(this.nodeRef);
    if (dom) {
      const isHovered = this.props.layer.hovered;
      dom["style"].backgroundColor = COLORS.GREY[isHovered ? 700 : 800];
    }
  };

  componentDidMount() {
    if (this.nodeRef) {
      this.nodeRef.addEventListener(
        "dragstart",
        (e: any) => {
          var crt: any = this.nodeRef.cloneNode(true);
          crt.style.display = "none";
          document.body.appendChild(crt);
          e.dataTransfer.setDragImage(crt, 0, 0);
        },
        false
      );
    }

    this.file = this.props.layer.getFile() as DomainFile;
    this.file.on("scopeVariables", this.onUpdate);

    if (!Utils.shouldIgnoreLayer(this.props.layer.type)) {
      if (this.props.layer.type !== "root") {
        this.props.layer.on(updateProps, this.onUpdate);
        this.props.layer.on(["hoveredDom"], this.onUpdateDom);
      }
      this.props.layer.on("children", this.onUpdate);
      this.props.layer.props.style.on("display", this.onUpdate);
    }
  }

  componentDidUpdate(prevProps: any) {
    if (this.props.layer.getFile() !== this.file) {
      this.file.off("scopeVariables", this.onUpdate);
      this.file = this.props.layer.getFile() as DomainFile;
      this.file.on("scopeVariables", this.onUpdate);
    }
    if (!Utils.shouldIgnoreLayer(prevProps.layer.type)) {
      if (prevProps.layer.type !== "root") {
        prevProps.layer.off(updateProps, this.onUpdate);
        prevProps.layer.off(["hoveredDom"], this.onUpdateDom);
      }
      prevProps.layer.off("children", this.onUpdate);
      prevProps.layer.off(updateProps, this.onUpdate);
      prevProps.layer.off(["hoveredDom"], this.onUpdateDom);
      if (prevProps.layer.props) {
        prevProps.layer.props.style.off("display", this.onUpdate);
      }
    }
    if (!Utils.shouldIgnoreLayer(this.props.layer.type)) {
      if (this.props.layer.type !== "root") {
        this.props.layer.on(updateProps, this.onUpdate);
        this.props.layer.on(["hoveredDom"], this.onUpdateDom);
      }
      this.props.layer.on("children", this.onUpdate);
      this.props.layer.props.style.on("display", this.onUpdate);
    }
  }

  componentWillUnmount() {
    this.file.off("scopeVariables", this.onUpdate);
    if (!Utils.shouldIgnoreLayer(this.props.layer.type)) {
      if (this.props.layer.type !== "root") {
        this.props.layer.off(updateProps, this.onUpdate);
        this.props.layer.off(["hoveredDom"], this.onUpdateDom);
      }
      this.props.layer.off("children", this.onUpdate);
      this.props.layer.props.style.off("display", this.onUpdate);
    }
  }

  renderChildren() {
    if (!this.props.layer || (this.props.layer && this.props.layer.collapsed)) {
      return;
    }

    let children: any = this.props.fetchChildren(this.props.layer);
    return children
      ? this.props.renderWrapper(
          children.map((layer: any, i: number) => {
            if (layer.type === "unknown" || layer.type === "statusBar") {
              return null;
            }
            return [
              <NodeEnd
                key={"nodeEnd" + "_" + this.props.fetchPath(layer)}
                renderDivider={this.props.renderDivider}
                path={this.props.fetchPath(layer)}
                onChangeDragOver={this.props.onChangeDragOver}
                layer={layer}
              />,
              <Node
                key={"nodeData" + "_" + this.props.fetchPath(layer)}
                layer={layer}
                path={this.props.fetchPath(layer)}
                onChangeDragOver={this.props.onChangeDragOver}
                onChangeDragEnd={this.props.onChangeDragEnd}
                renderNode={this.props.renderNode}
                renderDivider={this.props.renderDivider}
                renderWrapper={this.props.renderWrapper}
                fetchChildren={this.props.fetchChildren}
                fetchPath={this.props.fetchPath}
                onChangeClick={this.props.onChangeClick}
                onDoubleClick={this.props.onDoubleClick}
                onContextMenu={this.props.onContextMenu}
                onHover={this.props.onHover}
                onMouseOut={this.props.onMouseOut}
                onMouseOver={this.props.onMouseOver}
                onMouseEnter={this.props.onMouseEnter}
                onMouseLeave={this.props.onMouseLeave}
                onDrag={this.props.onDrag}
              />,
              <NodeStart
                key={"nodeStart" + "_" + this.props.fetchPath(layer)}
                renderDivider={this.props.renderDivider}
                path={this.props.fetchPath(layer)}
                onChangeDragOver={this.props.onChangeDragOver}
                layer={layer}
              />
            ];
          })
        )
      : null;
  }

  onDragStart(e: any) {
    //
  }

  onDragEnter() {
    //
  }

  onDragOver(e: any) {
    this.props.onChangeDragOver(this.nodeRef, this.props.layer);
  }

  onDragLeave() {
    //
  }
  onDrag(e: any) {
    this.props.onDrag(this.nodeRef, e, this.props.layer);
  }
  onDrop(e: any) {
    // this.props.onChangeDragOver(this.nodeRef);
  }
  onMouseOut(e: any, layer: LayerModel) {
    this.props.onMouseOut(this.nodeRef, layer);
  }
  onMouseEnter(e: any, layer: LayerModel) {
    this.props.onMouseEnter(this.nodeRef, layer);
  }
  onMouseLeave(e: any, layer: LayerModel) {
    this.props.onMouseLeave(this.nodeRef, layer);
  }
  onMouseOver(e: any, layer: LayerModel) {
    e.stopPropagation();
    this.props.onMouseOver(this.nodeRef, layer);
  }
  onClick(e: any, layer: LayerModel) {
    e.preventDefault();
    e.stopPropagation();
    this.props.onChangeClick(this.nodeRef, layer);
  }
  onDoubleClick(e: any, layer: LayerModel) {
    e.preventDefault();
    e.stopPropagation();
    this.props.onDoubleClick(this.nodeRef, layer);
  }
  onContextMenu(e: any, layer: LayerModel) {
    this.props.onContextMenu(this.nodeRef, layer, e);
  }
  onDragEnd(e: any, layer: LayerModel, path: string) {
    e.preventDefault();
    e.stopPropagation();
    this.props.onChangeDragEnd(this.nodeRef, layer, path);
  }

  render() {
    const path = this.props.path;
    const nodeId = "";
    const position = "_inside_" + this.props.path;
    const props = {
      onDragStart: (e: any) => {
        //
      },
      onDragEnter: (e: any) => {
        e.dataTransfer.dropEffect = "move";
        this.onDragOver(e);
      },
      onDrag: (e: any) => {
        e.preventDefault();
        this.onDrag(e);
      },
      onDragOver: (e: any) => {
        e.stopPropagation();
        e.preventDefault();
      },
      onDragLeave: (e: any) => {
        this.onDragLeave();
      },
      onDrop: (e: any) => {
        this.onDrop(e);
      },
      onDragEnd: (e: any) => {
        this.onDragEnd(e, this.props.layer, path);
      },
      onClick: (e: any) => {
        this.onClick(e, this.props.layer);
      },
      onDoubleClick: (e: any) => {
        this.onDoubleClick(e, this.props.layer);
      },
      onContextMenu: (e: any) => {
        this.onContextMenu(e, this.props.layer);
      },
      onMouseOut: (e: any) => {
        this.onMouseOut(e, this.props.layer);
      },
      onMouseEnter: (e: any) => {
        this.onMouseEnter(e, this.props.layer);
      },
      onMouseLeave: (e: any) => {
        this.onMouseLeave(e, this.props.layer);
      },
      onMouseOver: (e: any) => {
        this.onMouseOver(e, this.props.layer);
      },
      draggable: true,
      "data-path": path,
      "data-position": position,
      "data-node-id": nodeId,
      layer: this.props.layer
    };
    return this.props.renderNode(props, this.renderChildren(), (ref: any) => {
      this.nodeRef = ref;
    });
  }
}
