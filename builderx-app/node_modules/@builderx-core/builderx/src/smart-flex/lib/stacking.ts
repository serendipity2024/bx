import { Layer, CompareLayersCallback } from "./interfaces";
import {
  // getRandomString,
  // adjustAbsoluteValues,
  // hasSamePositionTypeInCoordinate,
  // getWrapperLayerStyle,
  // hasCordinateInPercent,
  // getBoundingBox,
  wrapLayers,
  isAuto,
  shouldIgnoreLayer,
  isWidthInfinite,
  isHeightInfinite,
  isOneOfTheHeightIsInfinite,
  isOneOfTheWidthIsInfinite,
  compareLayers,
  overlapsVertically,
  overlapsHorizontally
} from "./utils";

export function implementDFS(layer: Layer) {
  // console.log("Via implementing");
  let transformedLayer = JSON.parse(JSON.stringify(layer));
  if (!transformedLayer.children) {
    return transformedLayer;
  }
  for (let j = 0; j < transformedLayer.children.length; j++) {
    // if (!shouldIgnoreLayer(transformedLayer.children[j])) {
    transformedLayer.children[j] = implementDFS(transformedLayer.children[j]);
    // }
  }

  return stacking(transformedLayer);
}
export function stacking(transformedLayer: Layer): Layer {
  // let transformedLayer: Layer = JSON.parse(JSON.stringify(layer));
  if (
    !transformedLayer.children ||
    (transformedLayer.children && transformedLayer.children.length === 0) ||
    transformedLayer.type === "text"
  ) {
    return transformedLayer;
  }
  // for (let j = 0; j < transformedLayer.children.length; j++) {
  //   if (!shouldIgnoreLayer(transformedLayer.children[j])) {
  //     transformedLayer.children[j] = stacking(transformedLayer.children[j]);
  //   }
  // }

  let stacked = false;
  for (let i = 0; i < transformedLayer.children.length; i++) {
    if (shouldIgnoreLayer(transformedLayer.children[i])) {
      continue;
    }
    let currentIntersectionArray: Array<Layer> = [];

    if (i !== transformedLayer.children.length - 1) {
      currentIntersectionArray.push(transformedLayer.children[i]);

      for (let j = i + 1; j < transformedLayer.children.length; j++) {
        if (shouldIgnoreLayer(transformedLayer.children[j])) {
          continue;
        }
        let isIAuto = false;
        let isJAuto = false;
        if (isAuto(transformedLayer.children[i])) {
          isIAuto = true;
          transformedLayer.children[i].props.style = {
            ...transformedLayer.children[i].props.style,
            height: transformedLayer.children[i].rcDims.height,
            width: transformedLayer.children[i].rcDims.width
          };
        }
        if (isAuto(transformedLayer.children[j])) {
          isJAuto = true;
          transformedLayer.children[j].props.style = {
            ...transformedLayer.children[j].props.style,
            height: transformedLayer.children[j].rcDims.height,
            width: transformedLayer.children[j].rcDims.width
          };
        }

        let layer1 = transformedLayer.children[i];
        let layer2 = transformedLayer.children[j];

        let stackedOnX = false,
          stackedOnY = false;

        const getCompareLayersCallback = (
          axis: "x" | "y"
        ): CompareLayersCallback => () => ({
          lrlr: ({ layer1: layerC1, layer2: layerC2 }) => {
            ({ stackedOnX, stackedOnY } = stackedRCDims(
              axis,
              layerC1,
              layerC2,
              stackedOnX,
              stackedOnY
            ));
            // console.log("Compromise with lrlr in stacking"); // Do not remove this comment
          },
          lrrw: ({ layer1: layerC1, layer2: layerC2 }) => {
            ({ stackedOnX, stackedOnY } = stackedRCDims(
              axis,
              layerC1,
              layerC2,
              stackedOnX,
              stackedOnY
            ));
            // console.log("Compromise with lrrw in stacking"); // Do not remove this comment
          },
          lrlw: ({ layer1: layerC1, layer2: layerC2 }) => {
            ({ stackedOnX, stackedOnY } = stackedRCDims(
              axis,
              layerC1,
              layerC2,
              stackedOnX,
              stackedOnY
            ));
            // console.log("Compromise with lrlw in stacking"); // Do not remove this comment
          },

          rwlr: ({ layer1: layerC1, layer2: layerC2 }) => {
            ({ stackedOnX, stackedOnY } = stackedRCDims(
              axis,
              layerC1,
              layerC2,
              stackedOnX,
              stackedOnY
            ));
            // console.log("Compromise with rwlr in stacking"); // Do not remove this comment
          },
          rwrw: ({ r1, w1, r2, w2 }) => {
            if (
              // r1 lies within layer2
              (r1 >= r2 && r1 <= r2 + w2) ||
              // r2 lies within layer1
              (r2 >= r1 && r2 <= r1 + w1)
            ) {
              if (axis === "x") {
                stackedOnX = true;
              } else if (axis === "y") {
                stackedOnY = true;
              }
            }
          },
          rwlw: ({ layer1: layerC1, layer2: layerC2 }) => {
            ({ stackedOnX, stackedOnY } = stackedRCDims(
              axis,
              layerC1,
              layerC2,
              stackedOnX,
              stackedOnY
            ));
            // console.log("Compromise with rwlw in stacking"); // Do not remove this comment
          },

          lwlr: ({ layer1: layerC1, layer2: layerC2 }) => {
            ({ stackedOnX, stackedOnY } = stackedRCDims(
              axis,
              layerC1,
              layerC2,
              stackedOnX,
              stackedOnY
            ));
            // console.log("Compromise with lwlr in stacking"); // Do not remove this comment
          },
          lwrw: ({ layer1: layerC1, layer2: layerC2 }) => {
            ({ stackedOnX, stackedOnY } = stackedRCDims(
              axis,
              layerC1,
              layerC2,
              stackedOnX,
              stackedOnY
            ));
            // console.log("Compromise with lwrw in stacking"); // Do not remove this comment
          },
          lwlw: ({ l1, w1, l2, w2 }) => {
            if (
              // l1 lies within layer2
              (l1 >= l2 && l1 <= l2 + w2) ||
              // l2 lies within layer1
              (l2 >= l1 && l2 <= l1 + w1)
            ) {
              if (axis === "x") {
                stackedOnX = true;
              } else if (axis === "y") {
                stackedOnY = true;
              }
            }
          }
        });

        compareLayers(
          layer1,
          layer2,
          transformedLayer.rcDims,
          "x",
          getCompareLayersCallback("x")
        );

        compareLayers(
          layer1,
          layer2,
          transformedLayer.rcDims,
          "y",
          getCompareLayersCallback("y")
        );

        if (
          layer1.template.centerHorizontal ||
          layer2.template.centerHorizontal
        ) {
          ({ stackedOnX, stackedOnY } = stackedRCDims(
            "x",
            layer1,
            layer2,
            stackedOnX,
            stackedOnY
          ));
        }
        if (layer1.template.centerVertical || layer2.template.centerVertical) {
          ({ stackedOnX, stackedOnY } = stackedRCDims(
            "y",
            layer1,
            layer2,
            stackedOnX,
            stackedOnY
          ));
        }

        if (stackedOnX && stackedOnY) {
          currentIntersectionArray.push(transformedLayer.children[j]);
          stacked = true;
        }

        if (currentIntersectionArray.length > 0) {
          for (let k = 0; k < currentIntersectionArray.length; k++) {
            let layer3 = currentIntersectionArray[k];

            stackedOnX = false;
            stackedOnY = false;

            compareLayers(
              layer3,
              layer2,
              transformedLayer.rcDims,
              "x",
              getCompareLayersCallback("x")
            );

            compareLayers(
              layer3,
              layer2,
              transformedLayer.rcDims,
              "y",
              getCompareLayersCallback("y")
            );

            if (
              layer3.template.centerHorizontal ||
              layer2.template.centerHorizontal
            ) {
              ({ stackedOnX, stackedOnY } = stackedRCDims(
                "x",
                layer3,
                layer2,
                stackedOnX,
                stackedOnY
              ));
            }
            if (
              layer3.template.centerVertical ||
              layer2.template.centerVertical
            ) {
              ({ stackedOnX, stackedOnY } = stackedRCDims(
                "y",
                layer3,
                layer2,
                stackedOnX,
                stackedOnY
              ));
            }

            if (
              stackedOnX &&
              stackedOnY &&
              layer3 !== layer2 &&
              !currentIntersectionArray.includes(transformedLayer.children[j])
            ) {
              currentIntersectionArray.push(transformedLayer.children[j]);
            }
          }
        }
        if (isIAuto) {
          delete transformedLayer.children[i]._height;
          delete transformedLayer.children[i]._width;
          delete transformedLayer.children[i].props.style.height;
          delete transformedLayer.children[i].props.style.width;
        }
        if (isJAuto) {
          delete transformedLayer.children[j]._height;
          delete transformedLayer.children[j]._width;
          delete transformedLayer.children[j].props.style.height;
          delete transformedLayer.children[j].props.style.width;
        }
      }
      // console.log("Current intersection array is ", currentIntersectionArray);
      // Functionality
      if (currentIntersectionArray.length > 1) {
        let layers = [...currentIntersectionArray];

        let stackWidthInfinite = false,
          stackHeightInfinite = false;
        layers.forEach(layer => {
          if (isWidthInfinite(layer)) {
            stackWidthInfinite = true;
          }
          if (isHeightInfinite(layer)) {
            stackHeightInfinite = true;
          }
        });
        transformedLayer.children[i] = wrapLayers(
          layers,
          "stack",
          transformedLayer
        );

        // if (stackWidthInfinite) {
        //   transformedLayer.children[i].props.style.left =
        //     transformedLayer.children[i].rcDims.x;
        //   transformedLayer.children[i].props.style.right =
        //     transformedLayer.rcDims.width -
        //     (transformedLayer.children[i].rcDims.x +
        //       transformedLayer.children[i].rcDims.width);

        //   delete transformedLayer.children[i].props.style.width;
        // }
        // if (stackHeightInfinite) {
        //   transformedLayer.children[i].props.style.top =
        //     transformedLayer.children[i].rcDims.y;
        //   transformedLayer.children[i].props.style.bottom =
        //     transformedLayer.rcDims.height -
        //     (transformedLayer.children[i].rcDims.y +
        //       transformedLayer.children[i].rcDims.height);

        //   delete transformedLayer.children[i].props.style.height;
        // }
      }

      for (let k = 1; k < currentIntersectionArray.length; k++) {
        let layerIndex = transformedLayer.children.indexOf(
          currentIntersectionArray[k]
        );

        if (layerIndex !== -1) {
          transformedLayer.children.splice(layerIndex, 1);
        }
      }
    }
  }
  // if (transformedLayer.children.length !== 0) {
  //   transformedLayer.children = transformedLayer.children.map((child: any) => {
  //     return stacking(child);
  //   });
  // }
  if (stacked) {
    // because Stack agar ban gaya to us stack k saath bhi stack ho sakta hai isiliye ye likha
    stacking(transformedLayer);
  }
  return transformedLayer;
}
function stackedRCDims(
  axis: string,
  layerC1: Layer,
  layerC2: Layer,
  stackedOnX: boolean,
  stackedOnY: boolean
) {
  if (axis === "x" && overlapsVertically(layerC1, layerC2)) {
    stackedOnX = true;
  } else if (axis === "y" && overlapsHorizontally(layerC1, layerC2)) {
    stackedOnY = true;
  }
  return { stackedOnX, stackedOnY };
}
