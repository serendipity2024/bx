import { Layer } from "./interfaces";
import {
  forEachChild,
  wrapLayers,
  createWrapperLayerForFlex,
  getFlexFiller,
  isWidthInfinite,
  isHeightInfinite
} from "./utils";
import { isNil, get } from "lodash";

export default function flexGrouping(layer: Layer): Layer {
  const transformedLayer: Layer = JSON.parse(JSON.stringify(layer));

  if (
    (transformedLayer.children && transformedLayer.children.length === 0) ||
    transformedLayer.type === "text"
  ) {
    return transformedLayer;
  }
  if (transformedLayer.type === "stack") {
    forEachChild(transformedLayer, (child, index) => {
      transformedLayer.children[index] = flexGrouping(child);
    });
    return transformedLayer;
  }

  let flexDirection = transformedLayer.props.style.flexDirection;

  forEachChild(transformedLayer, (child: Layer, index: number) => {
    transformedLayer.children[index] = flexGrouping(child);
  });
  if (!flexDirection) {
    return transformedLayer;
  }

  if (flexDirection === "row" || flexDirection === "column") {
    const startChildrenIndexes: number[] = [];
    const endChildrenIndexes: number[] = [];
    const remainingChildrenIndexes: number[] = [];

    // If more that one child and one child is centered on both axis, remove center on flex main axis
    forEachChild(transformedLayer, (child: Layer, index: number) => {
      if (
        child.template.centerHorizontal &&
        child.template.centerVertical &&
        transformedLayer.children.length > 1
      ) {
        if (flexDirection === "column") {
          child.props.style.top = child.rcDims.y;
          child.template.centerVertical = false;
        } else if (flexDirection === "row") {
          child.props.style.left = child.rcDims.x;
          child.template.centerHorizontal = false;
        }
      }
    });

    // No flex grouping if any flex child is present
    let flexChildIsPresent = false;
    transformedLayer.children.forEach(child => {
      if (
        !flexChildIsPresent &&
        child.type !== "statusBar" &&
        get(child, "props.style")
      ) {
        flexChildIsPresent = !get(child, "props.style.position");
      }
    });
    if (flexChildIsPresent) {
      return transformedLayer;
    }

    forEachChild(transformedLayer, (child: Layer, index: number) => {
      if (flexDirection === "row") {
        if (
          typeof child.props.style.left === "number" &&
          typeof child.props.style.right !== "number"
        ) {
          startChildrenIndexes.push(index);
        } else if (
          typeof child.props.style.right === "number" &&
          typeof child.props.style.left !== "number"
        ) {
          endChildrenIndexes.push(index);
        } else {
          remainingChildrenIndexes.push(index);
        }
      } else if (flexDirection === "column") {
        if (
          typeof child.props.style.top === "number" &&
          typeof child.props.style.bottom !== "number"
        ) {
          startChildrenIndexes.push(index);
        } else if (
          typeof child.props.style.bottom === "number" &&
          typeof child.props.style.top !== "number"
        ) {
          endChildrenIndexes.push(index);
        } else {
          remainingChildrenIndexes.push(index);
        }

        // if (typeof child.props.style.right === "number" && typeof child.props.style.left !== "number") {
        //   child.props.style.alignSelf = "flex-end";
        //   flexEndCount++
        // } else {
        //   nonFlexEndCount++
        // }
      }
    });

    const ingnoredChildrenIndexes: number[] = [];
    transformedLayer.children.forEach((child, index) => {
      const consideredChildrenIndexes = [
        ...startChildrenIndexes,
        ...endChildrenIndexes,
        ...remainingChildrenIndexes
      ];

      if (!consideredChildrenIndexes.includes(index)) {
        ingnoredChildrenIndexes.push(index);
      }
    });

    const ignoredChildren = ingnoredChildrenIndexes.map(
      i => transformedLayer.children[i]
    );

    if (
      endChildrenIndexes.length === 0 &&
      remainingChildrenIndexes.length === 0
    ) {
      applyFlexEndByMajority(flexDirection, transformedLayer);
      return transformedLayer;
    }

    if (endChildrenIndexes.length === 0 && startChildrenIndexes.length === 0) {
      return transformedLayer;
    }

    // TODO: If we have all the items in only remainingChildren, return, because no need to group further

    // if(flexEndCount > nonFlexEndCount) {
    //   transformedLayer.props.style.alignItems = ""
    // }

    let startWrapper;
    if (startChildrenIndexes.length > 1) {
      startWrapper = wrapLayers(
        startChildrenIndexes.map(l => transformedLayer.children[l]),
        flexDirection,
        transformedLayer
      );
      // delete startWrapper._width;
      // delete startWrapper._height;
      // delete startWrapper.props.style.width;
      // delete startWrapper.props.style.height;

      startWrapper.styleName = "startWrapper";
      startWrapper.props.style.flexDirection = flexDirection;
      // startWrapper.type = "inlineView";

      applyFlexEndByMajority(flexDirection, startWrapper);
      // modifyWrapperStyles(flexDirection, startWrapper, transformedLayer);
    } else if (startChildrenIndexes.length > 0) {
      startWrapper = transformedLayer.children[startChildrenIndexes[0]];

      setFlexEndForLayer(flexDirection, startWrapper);
    }

    let endWrapper;
    if (endChildrenIndexes.length > 1) {
      // if (flexDirection === "row") {
      //   delete transformedLayer._width;
      //   delete transformedLayer.props.style.width;
      // } else if (flexDirection === "column") {
      //   delete transformedLayer._height;
      //   delete transformedLayer.props.style.height;
      // }

      endWrapper = wrapLayers(
        endChildrenIndexes.map(l => transformedLayer.children[l]),
        flexDirection,
        transformedLayer
      );
      // delete endWrapper._width;
      // delete endWrapper.props.style.width;
      // delete endWrapper._height;
      // delete endWrapper.props.style.height;

      // if (flexDirection === "row") {
      //   delete endWrapper._left;
      //   delete endWrapper.props.style.left;
      // } else if (flexDirection === "column") {
      //   delete endWrapper._top;
      //   delete endWrapper.props.style.top;
      // }

      // temp fix
      // endWrapper._right = transformedLayer.children[endChildren[0]]._right;
      // endWrapper.props.style.right =
      //   transformedLayer.children[endChildren[0]].props.style.right;

      endWrapper.styleName = "endWrapper";
      endWrapper.props.style.flexDirection = flexDirection;
      // endWrapper.type = "inlineView";

      applyFlexEndByMajority(flexDirection, endWrapper);
      // modifyWrapperStyles(flexDirection, endWrapper, transformedLayer);
    } else if (endChildrenIndexes.length > 0) {
      endWrapper = transformedLayer.children[endChildrenIndexes[0]];

      setFlexEndForLayer(flexDirection, endWrapper);
    }

    // [...startChildren, ...endChildren]
    //   .sort((a, b) => b - a)
    //   .forEach(index => {
    //     transformedLayer.children.splice(index, 1);
    //   });

    // rightChildren.forEach(index => {
    //   transformedLayer.children.splice(index, 1);
    // });
    let flexFiller;
    if (
      remainingChildrenIndexes.length === 1 &&
      ((flexDirection === "row" &&
        isWidthInfinite(
          transformedLayer.children[remainingChildrenIndexes[0]]
        )) ||
        (flexDirection === "column" &&
          isHeightInfinite(
            transformedLayer.children[remainingChildrenIndexes[0]]
          )))
    ) {
      // When there is a single child remaining sandwiched between opposite aligned layers,
      // treat the remaining child as body
      flexFiller = transformedLayer.children[remainingChildrenIndexes[0]];
    } else if (endWrapper || remainingChildrenIndexes.length > 0) {
      flexFiller = getFlexFiller(
        { flex: 1 },
        remainingChildrenIndexes.map(
          rIndex => transformedLayer.children[rIndex]
        )
      );

      let infiniteDimensionAlongFlexDirectionCount = 0;
      if (flexDirection === "row") {
        flexFiller.children.forEach(child => {
          if (
            typeof child.props.style.left === "number" &&
            typeof child.props.style.right === "number"
          ) {
            infiniteDimensionAlongFlexDirectionCount++;
          }
        });
      } else if (flexDirection === "column") {
        flexFiller.children.forEach(child => {
          if (
            typeof child.props.style.top === "number" &&
            typeof child.props.style.bottom === "number"
          ) {
            infiniteDimensionAlongFlexDirectionCount++;
          }
        });
      }

      if (infiniteDimensionAlongFlexDirectionCount < 2) {
        flexFiller.props.style.flexDirection = flexDirection;
      } else {
        delete flexFiller.props.style.flexDirection;
      }
      applyFlexEndByMajority(flexDirection, flexFiller);
    }
    let newLength = 0;
    if (endWrapper) {
      transformedLayer.children.unshift(endWrapper);
      newLength++;
    }
    if (flexFiller) {
      transformedLayer.children.unshift(flexFiller);
      newLength++;
    }
    if (startWrapper) {
      transformedLayer.children.unshift(startWrapper);
      newLength++;
    }

    // remove all remianing original items after newLength
    transformedLayer.children.length = newLength;
    // if (startWrapper && endWrapper) {
    //   // remove all remianing original items after index 2
    //   transformedLayer.children.length = 3;
    // } else if (startWrapper) {
    //   // remove all remianing original items after index 0
    //   transformedLayer.children.length = 1;
    // }
    // applyFlexEndByMajority(flexDirection, transformedLayer);

    transformedLayer.children.push(...ignoredChildren);
  }

  return transformedLayer;
}

function setFlexEndForLayer(flexDirection: string, wrapper: Layer) {
  if (
    flexDirection === "row" &&
    typeof wrapper.props.style.bottom === "number" &&
    typeof wrapper.props.style.top !== "number"
  ) {
    wrapper.props.style.alignSelf = "flex-end";
  }
  if (
    flexDirection === "column" &&
    typeof wrapper.props.style.right === "number" &&
    typeof wrapper.props.style.left !== "number"
  ) {
    wrapper.props.style.alignSelf = "flex-end";
  }
}

function applyFlexEndByMajority(flexDirection: string, wrapper: Layer) {
  let flexEndCount = 0,
    nonFlexEndCount = 0;
  if (flexDirection === "row") {
    forEachChild(wrapper, child => {
      if (
        typeof child.props.style.bottom === "number" &&
        typeof child.props.style.top !== "number"
      ) {
        child.props.style.alignSelf = "flex-end";
        flexEndCount++;
      } else {
        nonFlexEndCount++;
      }
    });
  } else if (flexDirection === "column") {
    forEachChild(wrapper, child => {
      if (
        typeof child.props.style.right === "number" &&
        typeof child.props.style.left !== "number"
      ) {
        child.props.style.alignSelf = "flex-end";
        flexEndCount++;
      } else {
        nonFlexEndCount++;
      }
    });
  }
  if (flexEndCount > nonFlexEndCount) {
    forEachChild(wrapper, child => {
      if (child.props.style.alignSelf === "flex-end") {
        delete child.props.style.alignSelf;
      } else if (isNil(child.props.style.alignSelf)) {
        child.props.style.alignSelf = "flex-start";
      }
    });
    wrapper.props.style.alignItems = "flex-end";
  }
}
