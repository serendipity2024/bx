import {
  overlapsHorizontally,
  overlapsVertically,
  shouldIgnoreLayer,
  isWidthInfinite
} from "./utils";
import { Layer } from "./interfaces";
import { isNil, get } from "lodash";
export default function getOverlapDirection(layer: Layer): any {
  let transformedLayer = JSON.parse(JSON.stringify(layer));
  let horizontallyOverlapped = false;
  let verticallyOverlapped = false;
  let stoppingCondition = false;
  if (!transformedLayer.children) {
    return "absolute";
  }
  if (transformedLayer.children.length === 1) {
    // For a single child which is right aligned flexDirection should be row, and if it is also bottom aligned,
    // it will be handled in flexGrouping step by giving the child alignSelf flex-end
    if (
      isNil(get(transformedLayer, "children.0.props.style.left")) &&
      !isNil(get(transformedLayer, "children.0.props.style.right"))
    ) {
      return "horizontal";
    }

    return "vertical";
  }
  for (let i = 0; i < transformedLayer.children.length; i++) {
    if (shouldIgnoreLayer(transformedLayer.children[i])) {
      continue;
    }
    for (let j = i + 1; j < transformedLayer.children.length; j++) {
      if (shouldIgnoreLayer(transformedLayer.children[j])) {
        continue;
      }

      if (!horizontallyOverlapped) {
        let xOverlap = overlapsHorizontally(
          transformedLayer.children[i],
          transformedLayer.children[j]
        );
        // console.log(
        //   "Horizontal of layer ",
        //   i,
        //   "and layer ",
        //   j,
        //   "is ",
        //   xOverlap
        // );
        if (xOverlap) {
          horizontallyOverlapped = true;
          stoppingCondition = true;
        }
      }
      if (!verticallyOverlapped) {
        let yOverlap = overlapsVertically(
          transformedLayer.children[i],
          transformedLayer.children[j]
        );
        // console.log("Vertical of layer ", i, "and layer ", j, "is ", yOverlap);
        if (yOverlap) {
          verticallyOverlapped = true;
          stoppingCondition = true;
        }
      }
      if (verticallyOverlapped && horizontallyOverlapped) {
        stoppingCondition = false;
        return undefined;
      }
    }
  }
  if (!verticallyOverlapped && !horizontallyOverlapped) {
    return "absolute";
  }
  if (stoppingCondition) {
    if (horizontallyOverlapped) {
      return "horizontal";
    }
    return "vertical";
  }
  return undefined;
}

export function isStoppingCondition(layer: Layer) {
  const overlapDirection = getOverlapDirection(layer);
  // console.log("Overlap Direction is ", overlapDirection);
  if (overlapDirection === undefined) {
    return false;
  }
  return true;
}
