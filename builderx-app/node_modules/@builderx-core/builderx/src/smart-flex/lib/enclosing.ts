import { Layer, CompareLayersCallback, Dims } from "./interfaces";
import {
  adjustAbsoluteValues,
  isAuto,
  compareLayers,
  shouldIgnoreLayer,
  modifyColorAlpha,
  adjustColorProperties,
  hasHexColor,
  hexToRgb,
  adjustGradientOpacity
} from "./utils";
import { get } from "lodash";
function isValidParentForEnclosing(layer: Layer) {
  // console.log("Layer type is ", layer.type);
  if (
    layer.type === "view" ||
    layer.type === "touchableOpacity" ||
    layer.type === "scrollView" ||
    layer.type === "image"
  ) {
    return true;
  }
  return false;
}

export default function enclosing(layer: Layer): Layer {
  let transformedLayer: Layer = JSON.parse(JSON.stringify(layer));
  if (
    !transformedLayer.children ||
    (transformedLayer.children && transformedLayer.children.length === 0)
  ) {
    return transformedLayer;
  }
  // console.log("Layer is received as ", layer);
  const existingChildrenOfParent = {};
  for (let i = transformedLayer.children.length - 1; i > 0; i = i - 1) {
    if (shouldIgnoreLayer(transformedLayer.children[i])) {
      continue;
    }
    for (let j = i - 1; j >= 0; j = j - 1) {
      if (
        shouldIgnoreLayer(transformedLayer.children[j]) ||
        !isValidParentForEnclosing(transformedLayer.children[j]) ||
        (transformedLayer.children[j].children.length > 0 &&
          transformedLayer.children[j].props.style.hasOwnProperty("opacity"))
      ) {
        continue;
      }
      let isAutoText = false;
      let parentLayer = transformedLayer.children[j];
      let childLayer = transformedLayer.children[i];
      if (
        childLayer.type === "text" ||
        (childLayer.import && childLayer.import.layerName === "Icon")
      ) {
        if (isAuto(childLayer)) {
          isAutoText = true;
          let height = childLayer.rcDims.height;
          let width = childLayer.rcDims.width;
          childLayer.props.style = {
            ...childLayer.props.style,
            ...{ height: height, width: width }
          };
        }
      }

      let containedOnX = false,
        containedOnY = false;

      const getCompareLayersCallback = (
        axis: "x" | "y"
      ): CompareLayersCallback => () => ({
        lrlr: ({ l1, r1, l2, r2 }) => {
          if (l1 <= l2 && r1 <= r2) {
            if (axis === "x") {
              containedOnX = true;
            } else if (axis === "y") {
              containedOnY = true;
            }
          }
        },
        lrrw: ({ layer1, layer2 }) => {
          ({ containedOnX, containedOnY } = isContainedRCDims(
            axis,
            layer1.rcDims,
            layer2.rcDims,
            containedOnX,
            containedOnY
          ));

          // console.log("Compromise with lrrw in enclosing"); // Do not remove this comment
        },
        lrlw: ({ layer1, layer2 }) => {
          ({ containedOnX, containedOnY } = isContainedRCDims(
            axis,
            layer1.rcDims,
            layer2.rcDims,
            containedOnX,
            containedOnY
          ));
          // console.log("Compromise with lrlw in enclosing"); // Do not remove this comment
        },

        rwlr: ({ layer1, layer2 }) => {
          ({ containedOnX, containedOnY } = isContainedRCDims(
            axis,
            layer1.rcDims,
            layer2.rcDims,
            containedOnX,
            containedOnY
          ));
          // console.log("Compromise with rwlr in enclosing"); // Do not remove this comment
        },
        rwrw: ({ r1, w1, r2, w2 }) => {
          if (r1 <= r2 && r2 + w2 <= r1 + w1) {
            if (axis === "x") {
              containedOnX = true;
            } else if (axis === "y") {
              containedOnY = true;
            }
          }
        },
        rwlw: ({ layer1, layer2 }) => {
          ({ containedOnX, containedOnY } = isContainedRCDims(
            axis,
            layer1.rcDims,
            layer2.rcDims,
            containedOnX,
            containedOnY
          ));
          // console.log("Compromise with rwlw in enclosing"); // Do not remove this comment
        },

        lwlr: ({ layer1, layer2 }) => {
          ({ containedOnX, containedOnY } = isContainedRCDims(
            axis,
            layer1.rcDims,
            layer2.rcDims,
            containedOnX,
            containedOnY
          ));
          // console.log("Compromise with lwlr in enclosing"); // Do not remove this comment
        },
        lwrw: ({ layer1, layer2 }) => {
          ({ containedOnX, containedOnY } = isContainedRCDims(
            axis,
            layer1.rcDims,
            layer2.rcDims,
            containedOnX,
            containedOnY
          ));
          // console.log("Compromise with lwrw in enclosing"); // Do not remove this comment
        },
        lwlw: ({ l1, w1, l2, w2 }) => {
          if (l1 <= l2 && l2 + w2 <= l1 + w1) {
            if (axis === "x") {
              containedOnX = true;
            } else if (axis === "y") {
              containedOnY = true;
            }
          }
        }
      });

      compareLayers(
        parentLayer,
        childLayer,
        transformedLayer.rcDims,
        "x",
        getCompareLayersCallback("x")
      );

      compareLayers(
        parentLayer,
        childLayer,
        transformedLayer.rcDims,
        "y",
        getCompareLayersCallback("y")
      );

      if (
        parentLayer.template.centerHorizontal ||
        childLayer.template.centerHorizontal
      ) {
        ({ containedOnX, containedOnY } = isContainedRCDims(
          "x",
          parentLayer.rcDims,
          childLayer.rcDims,
          containedOnX,
          containedOnY
        ));
      }
      if (
        parentLayer.template.centerVertical ||
        childLayer.template.centerVertical
      ) {
        ({ containedOnX, containedOnY } = isContainedRCDims(
          "y",
          parentLayer.rcDims,
          childLayer.rcDims,
          containedOnX,
          containedOnY
        ));
      }

      if (containedOnX && containedOnY) {
        // console.log("yes everything is contained");
        let adjustedValues = adjustAbsoluteValues(childLayer, parentLayer);

        childLayer.props.style = {
          ...childLayer.props.style,
          ...adjustedValues.styleValues
        };
        if (childLayer.type === "text" && isAutoText) {
          delete childLayer.props.style.height;
          delete childLayer.props.style.width;
        }

        if (!existingChildrenOfParent[j]) {
          existingChildrenOfParent[j] = parentLayer.children;
          parentLayer.children = [];
        }

        // Reset center if layer's parent is being changed and parent wasn't centered
        const parentLeft = get(parentLayer, "props.style.left");
        const parentRight = get(parentLayer, "props.style.right");
        const widthIsInfinite =
          typeof parentLeft === "number" &&
          typeof parentRight === "number" &&
          Math.round(parentLeft) === Math.round(parentRight);
        // if (childLayer.template.centerHorizontal && !widthIsInfinite) {
        if (
          !parentLayer.template.centerHorizontal &&
          !widthIsInfinite &&
          childLayer.template.centerHorizontal
        ) {
          childLayer.template.centerHorizontal = false;
          childLayer.props.style.left = childLayer.rcDims.x;
        }
        const parentTop = get(parentLayer, "props.style.top");
        const parentBottom = get(parentLayer, "props.style.bottom");
        const heightIsInfinite =
          typeof parentTop === "number" &&
          typeof parentBottom === "number" &&
          Math.round(parentTop) === Math.round(parentBottom);
        if (
          !parentLayer.template.centerVertical &&
          !heightIsInfinite &&
          childLayer.template.centerVertical
        ) {
          childLayer.template.centerVertical = false;
          childLayer.props.style.top = childLayer.rcDims.y;
        }
        let opacity = get(parentLayer, "props.style.opacity", undefined);
        if (opacity) {
          adjustColorProperties(parentLayer.props.style, opacity);
        }
        if (parentLayer.gradient) {
          adjustGradientOpacity(parentLayer);
        }
        if (opacity && parentLayer.type !== "image" && !parentLayer.gradient) {
          delete parentLayer.props.style.opacity;
        }

        parentLayer.children.unshift(childLayer);
        transformedLayer.children.splice(i, 1);
        break;
      }

      if (isAutoText) {
        delete childLayer.props.style.height;
        delete childLayer.props.style.width;
      }
    }

    if (existingChildrenOfParent[i - 1]) {
      transformedLayer.children[i - 1].children = existingChildrenOfParent[
        i - 1
      ].concat(transformedLayer.children[i - 1].children);
    }
  }
  transformedLayer.children = transformedLayer.children.map((child: any) => {
    return enclosing(child);
  });

  return transformedLayer;
}

function isContainedRCDims(
  axis: string,
  rcDims1: Dims,
  rcDims2: Dims,
  containedOnX: boolean,
  containedOnY: boolean
) {
  if (axis === "x") {
    const leftContained = rcDims1.x <= rcDims2.x;
    const rightContained =
      rcDims1.x + rcDims1.width >= rcDims2.x + rcDims2.width;
    if (leftContained && rightContained) {
      containedOnX = true;
    }
  } else if (axis === "y") {
    const topContained = rcDims1.y <= rcDims2.y;
    const bottomContained =
      rcDims1.y + rcDims1.height >= rcDims2.y + rcDims2.height;
    if (topContained && bottomContained) {
      containedOnY = true;
    }
  }
  return { containedOnX, containedOnY };
}

function isContained(position: string, layer1: Layer, layer2: Layer) {
  switch (position) {
    case "top":
      let topContained = layer1.rcDims.y <= layer2.rcDims.y;
      return topContained;
    case "left":
      let leftContained = layer1.rcDims.x <= layer2.rcDims.x;
      return leftContained;
    case "bottom":
      let bottomContained =
        layer1.rcDims.y + layer1.rcDims.height >=
        layer2.rcDims.y + layer2.rcDims.height;
      return bottomContained;
    case "right":
      let rightContained =
        layer1.rcDims.x + layer1.rcDims.width >=
        layer2.rcDims.x + layer2.rcDims.width;
      return rightContained;
    default:
      return false;
  }
}
