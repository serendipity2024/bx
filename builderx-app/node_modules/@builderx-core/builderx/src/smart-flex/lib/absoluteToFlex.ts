import { Layer } from "./interfaces";
import {
  forEachChild,
  isWidthInfinite,
  isHeightInfinite,
  shouldIgnoreLayer
} from "./utils";
import { isNil, forEach, get } from "lodash";

export default function absoluteToFlex(layer: Layer): Layer {
  const transformedLayer: Layer = JSON.parse(JSON.stringify(layer));

  if (
    !transformedLayer.children ||
    (transformedLayer.children && transformedLayer.children.length === 0) ||
    transformedLayer.type === "text"
  ) {
    return transformedLayer;
  }
  if (transformedLayer.type === "stack") {
    forEachChild(transformedLayer, (child, index) => {
      transformedLayer.children[index] = absoluteToFlex(child);
    });
    return transformedLayer;
  }
  let flexDirection = transformedLayer.props.style.flexDirection;

  forEach(transformedLayer.children, (child: Layer, index: number) => {
    transformedLayer.children[index] = absoluteToFlex(child);
  });
  if (!flexDirection) {
    return transformedLayer;
  }

  let cumulativeDistance = 0;

  if (transformedLayer._flexParent) {
    return transformedLayer;
  }

  forEachChild(transformedLayer, (child: Layer, index: number) => {
    if (child.styleName === "flexFiller") {
      return;
    }
    // console.log("I for Each child is ", child);
    if (child.props.style) {
      delete child.props.style.position;

      if (flexDirection === "column") {
        if (isHeightInfinite(child)) {
          child.props.style.flex = 1;
        }

        // TODO: replace all _ values with style properties and rcDims
        if (!isNil(child.props.style.bottom)) {
          // let { left, right, bottom, top, ...restStyles } = child.props.style;
          let marginBottom =
            transformedLayer.children[index + 1] &&
            !shouldIgnoreLayer(transformedLayer.children[index + 1])
              ? transformedLayer.children[index + 1].rcDims.y -
                child.rcDims.y -
                child.rcDims.height
              : child.props.style.bottom;

          // if (index === transformedLayer.children.length - 1) {
          if (marginBottom && Math.round(marginBottom as number) !== 0) {
            child.props.style.marginBottom = marginBottom;
          }

          // } else {
          //   child.props.style = {
          //     ...restStyles
          //   };
          // }
        }
        if (!isNil(child.props.style.top)) {
          const marginTop = (child.props.style.top as any) - cumulativeDistance;
          if (Math.round(marginTop) !== 0) {
            child.props.style.marginTop =
              (child.props.style.top as any) - cumulativeDistance;
          }

          cumulativeDistance +=
            !isNil(marginTop) && !isNil(child.rcDims.height)
              ? marginTop + child.rcDims.height
              : 0;
        }

        if (
          !isNil(child.props.style.left) &&
          Math.round(child.props.style.left as number) !== 0
        ) {
          child.props.style.marginLeft = child.props.style.left;
        }
        if (
          !isNil(child.props.style.right) &&
          Math.round(child.props.style.right as number) !== 0
        ) {
          child.props.style.marginRight = child.props.style.right;
        }
        if (child.template.centerHorizontal) {
          child.props.style = { ...child.props.style, alignSelf: "center" };
          child.template.centerHorizontal = false;
        }
        if (
          child.template.centerVertical &&
          transformedLayer.children.length === 1
        ) {
          transformedLayer.props.style.justifyContent = "center";
          child.template.centerVertical = false;
          delete child.props.style.marginTop;
          delete child.props.style.marginBottom;
        }
      } else {
        if (isWidthInfinite(child)) {
          child.props.style.flex = 1;
        }

        if (!isNil(child.props.style.right)) {
          // let { left, right, bottom, top, ...restStyles } = child.props.style;
          let marginRight =
            transformedLayer.children[index + 1] &&
            !shouldIgnoreLayer(transformedLayer.children[index + 1])
              ? transformedLayer.children[index + 1].rcDims.x -
                child.rcDims.x -
                child.rcDims.width
              : child.props.style.right;

          // if (index === transformedLayer.children.length - 1) {
          if (marginRight && Math.round(marginRight as number) !== 0) {
            child.props.style.marginRight = marginRight;
          }

          // } else {
          //   child.props.style = {
          //     ...restStyles
          //   };
          // }
        }
        // }

        if (
          !isNil(child.props.style.left)
          //  && child.type !== "body"
        ) {
          let marginLeft = (child.props.style.left as any) - cumulativeDistance;
          if (Math.round(marginLeft) !== 0) {
            child.props.style.marginLeft =
              (child.props.style.left as any) - cumulativeDistance;
          }
          cumulativeDistance +=
            !isNil(marginLeft) && !isNil(child.rcDims.width)
              ? marginLeft + child.rcDims.width
              : 0;
        }

        if (
          !isNil(child.props.style.top) &&
          Math.round(child.props.style.top as number) !== 0
        ) {
          child.props.style.marginTop = child.props.style.top;
        }
        if (
          !isNil(child.props.style.bottom) &&
          Math.round(child.props.style.bottom as number) !== 0
        ) {
          child.props.style.marginBottom = child.props.style.bottom;
        }

        if (child.template.centerVertical) {
          child.props.style = { ...child.props.style, alignSelf: "center" };
          child.template.centerVertical = false;
        }
        if (
          child.template.centerHorizontal &&
          transformedLayer.children.length === 1
        ) {
          transformedLayer.props.style.justifyContent = "center";
          child.template.centerHorizontal = false;
          delete child.props.style.marginLeft;
          delete child.props.style.marginRight;
        }
      }
      if (
        child.template.centerHorizontal &&
        child.template.centerVertical &&
        transformedLayer.children.length === 1
      ) {
        child.template.centerVertical = false;
        child.template.centerHorizontal = false;
        delete child.props.style.marginBottom;
        delete child.props.style.marginLeft;
        delete child.props.style.marginRight;
        delete child.props.style.marginTop;

        transformedLayer.props.style.justifyContent = "center";
        transformedLayer.props.style.alignItems = "center";
        // if (transformedLayer.props.style.position !== "absolute") {
        //   transformedLayer.props.style.position = "relative";
        // }
      } else if (child.template.centerHorizontal) {
        child.template.centerHorizontal = false;
        child.props.style.marginLeft = child.rcDims.x;
      } else if (child.template.centerVertical) {
        child.template.centerVertical = false;
        child.props.style.marginTop = child.rcDims.y;
      }
      if (!isNil(child.props.style.top)) {
        delete child.props.style.top;
      }
      if (!isNil(child.props.style.left)) {
        delete child.props.style.left;
      }
      if (!isNil(child.props.style.right)) {
        delete child.props.style.right;
      }
      if (!isNil(child.props.style.bottom)) {
        delete child.props.style.bottom;
      }
    }

    // if (child.type === "scrollView") {
    //   if (!child.props.contentContainerStyle.flexDirection) {
    //     child.props.contentContainerStyle.flexDirection =
    //       child.props.style.flexDirection;
    //     delete child.props.style.flexDirection;
    //   }

    //   if (!child.props.contentContainerStyle.alignItems) {
    //     child.props.contentContainerStyle.alignItems =
    //       child.props.style.alignItems;
    //     delete child.props.style.alignItems;
    //   }

    //   if (!child.props.contentContainerStyle.justifyContent) {
    //     child.props.contentContainerStyle.justifyContent =
    //       child.props.style.justifyContent;
    //     delete child.props.style.justifyContent;
    //   }

    //   if (flexDirection === "column" && isNil(child.props.style.width)) {
    //     delete child.props.contentContainerStyle.width;
    //   } else if (flexDirection === "row" && isNil(child.props.style.height)) {
    //     delete child.props.contentContainerStyle.height;
    //   }
    // }

    // TODO: Review Himanshu
    // if (child.type === "text") {
    //   if (isAuto(child) && child.props.style.textAlign === "center") {
    //     delete child.props.style.textAlign;
    //   }
    // }

    // if (!isNil(child.props.style.width) && child._originalWidth) {
    //   child.props.style.width = child._originalWidth;
    // }
    // if (!isNil(child.props.style.height) && child._originalHeight) {
    //   child.props.style.height = child._originalHeight;
    // }
  });

  // console.log("Returning finally layer as ", transformedLayer);
  return transformedLayer;
}
