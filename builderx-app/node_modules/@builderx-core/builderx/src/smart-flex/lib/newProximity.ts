import { Layer } from "./interfaces";
import {
  forEachChild,
  shouldIgnoreLayer,
  overlapsVertically,
  overlapsHorizontally,
  wrapLayers,
  dontGroupByProximity
} from "./utils";
import { remove, difference, forEach, get } from "lodash";
import getOverlapDirection from "./getOverlapDirection";

export default function proximity(
  layer: Layer,
  directionVertical: boolean = false
) {
  const direction = directionVertical ? "vertical" : "horizontal";
  let transformedLayer: Layer = JSON.parse(JSON.stringify(layer));
  if (
    (transformedLayer.children && transformedLayer.children.length === 0) ||
    transformedLayer.type === "text" ||
    !transformedLayer.children
  ) {
    return transformedLayer;
  }
  if (transformedLayer.type === "stack") {
    forEach(transformedLayer.children, (child, index) => {
      transformedLayer.children[index] = proximity(child);
    });
    return transformedLayer;
  }

  const overlapDirection = getOverlapDirection(transformedLayer);
  let noProximityGrouping = dontGroupByProximity(
    transformedLayer,
    overlapDirection
  );

  // No abs to flex if any flex child is present
  let flexChildIsPresent = false;
  transformedLayer.children.forEach(child => {
    // No flex filler

    if (
      !flexChildIsPresent &&
      child.type !== "statusBar" &&
      get(child, "props.style")
    ) {
      flexChildIsPresent = !get(child, "props.style.position");
    }
  });
  if (flexChildIsPresent) {
    transformedLayer._flexParent = true;
    noProximityGrouping = true;
  }

  for (let i = 0; i < transformedLayer.children.length; i++) {
    const layerI = transformedLayer.children[i];
    if (!layerI || shouldIgnoreLayer(layerI)) {
      // Even if the layer is ignored, run the algo for its children (e.g flex parents)
      // It will be checked in its own onvocation whether this layer has any children
      if (layerI) {
        transformedLayer.children[i] = proximity(layerI);
      }
      continue;
    }

    let group: Layer;
    if (noProximityGrouping) {
      group = layerI;
    } else {
      group = groupAlongDirection(transformedLayer, i, direction);
    }

    if (
      // group.children.length > 1 &&
      group.type === "column" ||
      group.type === "row"
    ) {
      // To handle case where 4 or more children overlap with each other horizontally as well as
      // vertically causing the recursion to run infinitely
      if (
        transformedLayer.children.length === 1 && // this means that all the original children of transformed layer
        // were grouped
        ((transformedLayer.type === "column" && group.type === "row") ||
          (transformedLayer.type === "row" && group.type === "column"))
      ) {
        //
        transformedLayer.children[0] = wrapLayers(
          group.children,
          "stack",
          transformedLayer
        );
        break;
      } else {
        transformedLayer.children[i] = proximity(group, !directionVertical);
      }
    } else {
      transformedLayer.children[i] = proximity(group);
    }
  }

  if (transformedLayer._absolute) {
    return transformedLayer;
  }

  // if (!layerIsAbsolute) {
  const parentWrapperType =
    overlapDirection === "horizontal"
      ? "row"
      : overlapDirection === "vertical"
      ? "column"
      : undefined;

  if (!transformedLayer.props.style.flexDirection && parentWrapperType) {
    transformedLayer.props.style.flexDirection = parentWrapperType;
    transformedLayer.props.style.display = "flex";
  } else if (!transformedLayer.props.style.flexDirection) {
    transformedLayer.props.style.flexDirection = "column";
    transformedLayer.props.style.display = "flex";
  }
  // }

  return transformedLayer;
}

function groupAlongDirection(
  layer: Layer,
  layerIndexToConsider: number,
  direction?: "vertical" | "horizontal"
) {
  const overlaps =
    direction === "vertical" ? overlapsVertically : overlapsHorizontally;
  const overlapsCross =
    direction === "vertical" ? overlapsHorizontally : overlapsVertically;

  const layersToWrap: Array<Layer> = [layer.children[layerIndexToConsider]];
  const coveredLayers: Array<Layer> = [];

  let remainingLayers = difference(layersToWrap, coveredLayers);
  while (
    remainingLayers.length > 0 &&
    layersToWrap.length !== layer.children.length
  ) {
    let exitForUnknownCase = false;
    remainingLayers.forEach(remainingLayer => {
      for (let j = 0; j < layer.children.length; j++) {
        const layerJ = layer.children[j];
        if (shouldIgnoreLayer(layerJ) || layersToWrap.includes(layerJ)) {
          continue;
        }

        const overlapsOnMainAxis = overlaps(remainingLayer, layerJ);
        const overlapsOnCrossAxis = overlapsCross(remainingLayer, layerJ);

        if (overlapsOnMainAxis && overlapsOnCrossAxis) {
          if (process.env.NODE_ENV !== "production") {
            throw new Error("Unknown case for proximity grouping");
          }
          exitForUnknownCase = true;
          return;
        }
        if (overlapsOnMainAxis) {
          if (!layersToWrap.includes(layerJ)) {
            layersToWrap.push(layerJ);
          }
        }
      }

      coveredLayers.push(remainingLayer);
    });

    if (exitForUnknownCase) {
      layer._absolute = true;
      return layer.children[layerIndexToConsider];
    }

    remainingLayers = difference(layersToWrap, coveredLayers);
  }

  if (layersToWrap.length > 1) {
    const wrapperType = direction === "vertical" ? "column" : "row";
    layer.children[layerIndexToConsider] = wrapLayers(
      layersToWrap,
      wrapperType,
      layer,
      true
    );

    layer.children[
      layerIndexToConsider
    ].props.style.flexDirection = wrapperType;
    layer.children[layerIndexToConsider].props.style.display = "flex";

    for (let k = layersToWrap.length - 1; k > 0; k--) {
      remove(layer.children, child => child === layersToWrap[k]);
    }
  }

  return layer.children[layerIndexToConsider];
  console.log(layersToWrap, "newProx layersTowrap");
}
