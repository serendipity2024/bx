import { Layer, Style, Dims, CompareLayersCallback } from "./interfaces";
import { omitBy, isUndefined, isNil, minBy, maxBy, forEach, get } from "lodash";
import { Utils } from "utils";
// import { number } from "prop-types";
// import { tsExternalModuleReference } from "@babel/types";

// function getCleanDividedValue(val1: any, val2: any) {
//   return !isNil(val1) && !isNil(val2)
//     ? Number(((val1 / val2) * 100).toFixed(2)).toString() + "%"
//     : isNil(val2)
//     ? "100%"
//     : undefined;
// }
function getCleanSubtractedValue(val1: any, val2: any) {
  return !isNil(val1) && !isNil(val2)
    ? (val1 - val2).toFixed(2) === "-0.00"
      ? 0
      : Number((val1 - val2).toFixed(2).toString())
    : isNil(val2) && !isNil(val1)
    ? Number(val1.toFixed(2))
    : undefined;
}
function getAbsoluteSubtractedValue(val1: any, val2: any) {
  return !isNil(val1) && !isNil(val2)
    ? val1 - val2
    : isNil(val2)
    ? val1
    : undefined;
}
export function adjustAbsoluteValues(
  childLayer: Layer,
  parentLayer: Layer
): { styleValues: Style } {
  let top: any, left: any, height: any, width: any, right: any, bottom: any;

  top = getCleanSubtractedValue(
    childLayer.props.style.top,
    parentLayer.rcDims.y
  );
  childLayer.rcDims.y =
    getAbsoluteSubtractedValue(childLayer.rcDims.y, parentLayer.rcDims.y) || 0;
  left = getCleanSubtractedValue(
    childLayer.props.style.left,
    parentLayer.rcDims.x
  );
  childLayer.rcDims.x =
    getAbsoluteSubtractedValue(childLayer.rcDims.x, parentLayer.rcDims.x) || 0;
  right = !isNil(childLayer.props.style.right)
    ? parentLayer.rcDims.width - (childLayer.rcDims.width + childLayer.rcDims.x)
    : undefined;
  bottom = !isNil(childLayer.props.style.bottom)
    ? parentLayer.rcDims.height -
      (childLayer.rcDims.height + childLayer.rcDims.y)
    : undefined;
  // rcDims.height = childLayer.rcDims.height;
  // rcDims.width = childLayer.rcDims.width;

  return {
    styleValues: omitBy(
      { top, left, height, width, right, bottom, position: "absolute" },
      isUndefined
    )
  };
}
export function isValueInPercentage(value: any) {
  if (typeof value === "string" && value.includes("%")) {
    return true;
  }
  return false;
}
export function hasCordinateInPercent(
  coordinate: "x" | "y",
  style: Style
): boolean {
  let lORt = coordinate === "x" ? style.left : style.top;
  let wORh = coordinate === "x" ? style.width : style.height;
  let rORb = coordinate === "x" ? style.right : style.bottom;
  if (
    (isValueInPercentage(lORt) && isValueInPercentage(wORh)) ||
    (isValueInPercentage(rORb) && isValueInPercentage(wORh)) ||
    (isValueInPercentage(lORt) && isValueInPercentage(rORb))
  ) {
    return true;
  }
  return false;
}
export function hasSamePositionTypeInCoordinate(
  coordinate: "x" | "y",
  style1: Style,
  style2: Style
) {
  let properties;

  if (coordinate === "x") {
    properties = ["left", "width", "right"];
  } else {
    properties = ["top", "height", "bottom"];
  }

  let allFixed = true;

  properties.forEach(property => {
    if (isNil(style1[property]) && isNil(style2[property])) {
      // noop
    } else if (
      typeof style1[property] === "number" &&
      typeof style2[property] === "number"
    ) {
      // noop
    } else {
      allFixed = false;
    }
  });

  if (allFixed) {
    return allFixed;
  }

  let allPercentage = true;

  properties.forEach(property => {
    if (isNil(style1[property]) && isNil(style2[property])) {
      // noop
    } else if (
      isValueInPercentage(style1[property]) &&
      isValueInPercentage(style2[property])
    ) {
      // noop
    } else {
      allPercentage = false;
    }
  });

  if (allPercentage) {
    return allPercentage;
  }

  return false;
}

export function getRandomString() {
  let text = "";
  let possible =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  text = possible.charAt(Math.floor(Math.random() * 52));
  for (let i = 0; i < 5; i++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  }
  return text;
}
export function modifyLayerForCalculation(
  layer: Layer,
  operation: "add" | "delete"
) {
  switch (operation) {
    case "add":
      layer.props.style = {
        ...layer.props.style,
        ...{ height: layer.rcDims.height, width: layer.rcDims.width }
      };
      break;
    case "delete":
    default:
      let restLayer = layer;
      let { width, height, ...restStyles } = layer.props.style;
      layer = { ...restLayer };
      layer.props.style = { ...restStyles };
      break;
  }
}
export function overlapsHorizontally(layer1: Layer, layer2: Layer): boolean {
  let isIAuto = false;
  let isJAuto = false;
  let overlappingX = false;
  if (isAuto(layer1)) {
    isIAuto = true;
    modifyLayerForCalculation(layer1, "add");
  }
  if (isAuto(layer2)) {
    isJAuto = true;
    modifyLayerForCalculation(layer2, "add");
  }
  if (
    // hasSamePositionTypeInCoordinate(
    //   "y",
    //   layer1.props.style,
    //   layer2.props.style
    // ) &&
    (layer2.rcDims.y >= layer1.rcDims.y &&
      layer2.rcDims.y < layer1.rcDims.y + layer1.rcDims.height) ||
    (layer1.rcDims.y >= layer2.rcDims.y &&
      layer1.rcDims.y < layer2.rcDims.y + layer2.rcDims.height)
  ) {
    // console.log("Overlap X is true");
    overlappingX = true;
  }
  // console.log("Overlap X is false");
  if (isIAuto) {
    modifyLayerForCalculation(layer1, "delete");
  }
  if (isJAuto) {
    modifyLayerForCalculation(layer2, "delete");
  }
  return overlappingX;
}
export function overlapsVertically(layer1: Layer, layer2: Layer): boolean {
  let isIAuto = false;
  let isJAuto = false;
  let overlappingY = false;
  if (isAuto(layer1)) {
    isIAuto = true;
    modifyLayerForCalculation(layer1, "add");
  }
  if (isAuto(layer2)) {
    isJAuto = true;
    modifyLayerForCalculation(layer2, "add");
  }
  if (
    // hasSamePositionTypeInCoordinate(
    //   "x",
    //   layer1.props.style,
    //   layer2.props.style
    // ) &&
    (layer2.rcDims.x >= layer1.rcDims.x &&
      layer2.rcDims.x < layer1.rcDims.x + layer1.rcDims.width) ||
    (layer1.rcDims.x >= layer2.rcDims.x &&
      layer1.rcDims.x < layer2.rcDims.x + layer2.rcDims.width)
  ) {
    overlappingY = true;
  }
  if (isIAuto) {
    modifyLayerForCalculation(layer1, "delete");
  }
  if (isJAuto) {
    modifyLayerForCalculation(layer2, "delete");
  }
  return overlappingY;
}
export function getHorizontalOverlap(layer1: Layer, layer2: Layer) {
  let horizontalOverlap: number | undefined;
  if (overlapsHorizontally(layer1, layer2)) {
    let top = layer2.rcDims.y - layer1.rcDims.y;
    horizontalOverlap = (layer1.rcDims.height - top) / layer2.rcDims.height;
  }
  // console.log(
  //   "Horizontal overlap of ",
  //   layer1.styleName,
  //   "and ",
  //   layer2.styleName,
  //   "is ",
  //   horizontalOverlap
  // );
  return horizontalOverlap;
}
export function getVerticalOverlap(layer1: Layer, layer2: Layer) {
  let verticalOverlap: number | undefined = 0;
  if (overlapsVertically(layer1, layer2)) {
    let left = (layer1.rcDims.width - layer2.rcDims.x) / layer1.rcDims.width;
    verticalOverlap = (layer1.rcDims.width - left) / layer2.rcDims.width;
  }
  return verticalOverlap;
}
export function getHorizontalProximity(layer1: Layer, layer2: Layer): number {
  if (layer2.rcDims.x > layer1.rcDims.x) {
    return (
      Number(layer2.rcDims.x) -
      (Number(layer1.rcDims.x) + Number(layer1.rcDims.width))
    );
  } else {
    return (
      Number(layer1.rcDims.x) -
      (Number(layer2.rcDims.x) + Number(layer2.rcDims.width))
    );
  }
}
export function getVerticalProximity(layer1: Layer, layer2: Layer): number {
  if (layer2.rcDims.y > layer1.rcDims.y) {
    return (
      Number(layer2.rcDims.y) -
      (Number(layer1.rcDims.y) + Number(layer1.rcDims.height))
    );
  } else {
    return (
      Number(layer1.rcDims.y) -
      (Number(layer2.rcDims.y) + Number(layer2.rcDims.height))
    );
  }
}
export function getBoundingBox(
  layers: Array<Layer>,
  withoutRotation: boolean = false
): {
  x: number,
  y: number,
  width: number,
  height: number,
  rotation: number
} {
  let box = { x: 0, y: 0, height: 0, width: 0, rotation: 0 };
  if (layers.length > 0 || withoutRotation) {
    let layerPoints: any = [];
    layers.map(layer => {
      let localBox = {
        x: layer.rcDims.x,
        y: layer.rcDims.y,
        width: layer.rcDims.width,
        height: layer.rcDims.height
      };
      let points = getPointsFromBoundingBox(localBox);
      layerPoints = layerPoints.concat(points);
    });
    let minXLayer: any = minBy(layerPoints, (layer: any) => {
      return layer[0];
    });
    let minYLayer: any = minBy(layerPoints, (layer: any) => {
      return layer[1];
    });
    let maxXLayer: any = maxBy(layerPoints, (layer: any) => {
      return layer[0];
    });
    let maxYLayer: any = maxBy(layerPoints, (layer: any) => {
      return layer[1];
    });
    minXLayer = minXLayer ? minXLayer[0] : 0;
    minYLayer = minYLayer ? minYLayer[1] : 0;
    maxXLayer = maxXLayer ? maxXLayer[0] : 0;
    maxYLayer = maxYLayer ? maxYLayer[1] : 0;
    box.x = Math.round(minXLayer * 100) / 100;
    box.y = Math.round(minYLayer * 100) / 100;
    box.width = maxXLayer ? Math.round((maxXLayer - minXLayer) * 100) / 100 : 0;
    box.height = maxYLayer
      ? Math.round((maxYLayer - minYLayer) * 100) / 100
      : 0;
    box.rotation = 0;
  }
  // console.log("returning box as ", box);

  return box;
}
function getPointsFromBoundingBox(box: any, rotation: number = 0) {
  let poly = [
    [box.x, box.y],
    [box.x + box.width, box.y],
    [box.x + box.width, box.y + box.height],
    [box.x, box.y + box.height]
  ];
  return poly;
  // var centroid = getCentroid(poly);
  // var rotatedPoly = rotatePolygon(poly, rotation);
}
export function getWrapperLayerStyle(
  boundingBox: any,
  layers: Array<Layer>,
  wrapperType: string,
  parentLayer: Layer,
  forProximity: boolean = false
): { style: Style, rcDims: any } {
  let rcDims: { x: number, y: number, height: number, width: number } = {
    x: boundingBox.x,
    y: boundingBox.y,
    height: boundingBox.height,
    width: boundingBox.width
  };

  let wrapperStyle: Style = {
    top: rcDims.y,
    left: rcDims.x,
    width: rcDims.width,
    height: rcDims.height,
    position: "absolute"
  };

  if (parentLayer && wrapperType === "row" && forProximity) {
    wrapperStyle = {
      top: rcDims.y,
      left: rcDims.x,
      right: parentLayer.rcDims.width - (rcDims.x + rcDims.width),
      height: rcDims.height,
      position: "absolute"
    };

    let topCount = 0,
      bottomCount = 0;

    layers.forEach(layer => {
      if (typeof layer.props.style.top === "number") {
        topCount++;
      }
      if (typeof layer.props.style.bottom === "number") {
        bottomCount++;
      }
    });

    if (bottomCount > topCount) {
      delete wrapperStyle.top;
      wrapperStyle.bottom =
        parentLayer.rcDims.height - (rcDims.y + rcDims.height);
    }
  } else if (parentLayer && wrapperType === "column" && forProximity) {
    wrapperStyle = {
      top: rcDims.y,
      left: rcDims.x,
      bottom: parentLayer.rcDims.height - (rcDims.y + rcDims.height),
      width: rcDims.width,
      position: "absolute"
    };

    let leftCount = 0,
      rightCount = 0;

    layers.forEach(layer => {
      if (typeof layer.props.style.left === "number") {
        leftCount++;
      }
      if (typeof layer.props.style.right === "number") {
        rightCount++;
      }
    });

    if (rightCount > leftCount) {
      delete wrapperStyle.left;
      wrapperStyle.right = parentLayer.rcDims.width - (rcDims.x + rcDims.width);
    }
  } else {
    let topCount = 0,
      bottomCount = 0;

    layers.forEach(layer => {
      if (typeof layer.props.style.top === "number") {
        topCount++;
      }
      if (typeof layer.props.style.bottom === "number") {
        bottomCount++;
      }
    });

    if (bottomCount > topCount) {
      delete wrapperStyle.top;
      wrapperStyle.bottom =
        parentLayer.rcDims.height - (rcDims.y + rcDims.height);
    }

    let leftCount = 0,
      rightCount = 0;

    layers.forEach(layer => {
      if (typeof layer.props.style.left === "number") {
        leftCount++;
      }
      if (typeof layer.props.style.right === "number") {
        rightCount++;
      }
    });

    if (rightCount > leftCount) {
      delete wrapperStyle.left;
      wrapperStyle.right = parentLayer.rcDims.width - (rcDims.x + rcDims.width);
    }
  }

  return { style: wrapperStyle, rcDims: rcDims };
}
export function wrapLayers(
  layers: Array<Layer>,
  wrapperType: string,
  parentLayer: Layer,
  forProximity: boolean = false
) {
  let boundingBox = getBoundingBox(layers);
  // console.log("Bounding box for layers", layers, "is ", boundingBox);
  let adjustedWrapperValues = getWrapperLayerStyle(
    boundingBox,
    layers,
    wrapperType,
    parentLayer,
    forProximity
  );

  let wrapperLayer: Layer = {
    import: {
      asName: "",
      isDefaultImport: false,
      layerName: "View",
      packageName: "native"
    },
    overrideKeys: [],
    template: {
      centerVertical: false,
      centerHorizontal: false
    },
    rcDims: adjustedWrapperValues.rcDims,
    props: {
      style: adjustedWrapperValues.style
    },
    children: [...layers],

    styleName: wrapperType,
    type: wrapperType
  };

  if (wrapperType === "stack") {
    let stackWidthInfinite = false,
      stackHeightInfinite = false;
    layers.forEach(layer => {
      if (isWidthInfinite(layer)) {
        stackWidthInfinite = true;
      }
      if (isHeightInfinite(layer)) {
        stackHeightInfinite = true;
      }
    });
    if (stackWidthInfinite) {
      wrapperLayer.props.style.left = wrapperLayer.rcDims.x;
      wrapperLayer.props.style.right =
        parentLayer.rcDims.width -
        (wrapperLayer.rcDims.x + wrapperLayer.rcDims.width);

      delete wrapperLayer.props.style.width;
    }
    if (stackHeightInfinite) {
      wrapperLayer.props.style.top = wrapperLayer.rcDims.y;
      wrapperLayer.props.style.bottom =
        parentLayer.rcDims.height -
        (wrapperLayer.rcDims.y + wrapperLayer.rcDims.height);

      delete wrapperLayer.props.style.height;
    }
  } else if (!forProximity) {
    // only for wrappers in flexGrouping
    modifyWrapperStylesForFlexGrouping(wrapperType, wrapperLayer, parentLayer);
  }

  for (let k = 0; k < wrapperLayer.children.length; k++) {
    // Reset center if layer's parent is being changed and parent wasn't centered
    const childLayer = wrapperLayer.children[k];

    const wrapperLeft = get(wrapperLayer, "props.style.left");
    const wrapperRight = get(wrapperLayer, "props.style.right");
    const widthIsInfinite =
      typeof wrapperLeft === "number" &&
      typeof wrapperRight === "number" &&
      Math.round(wrapperLeft) === Math.round(wrapperRight);
    if (childLayer.template.centerHorizontal && !widthIsInfinite) {
      childLayer.template.centerHorizontal = false;
      childLayer.props.style.left = childLayer.rcDims.x;
    }

    const wrapperTop = get(wrapperLayer, "props.style.top");
    const wrapperBottom = get(wrapperLayer, "props.style.bottom");
    const heightIsInfinite =
      typeof wrapperTop === "number" &&
      typeof wrapperBottom === "number" &&
      Math.round(wrapperTop) === Math.round(wrapperBottom);
    if (childLayer.template.centerVertical && !heightIsInfinite) {
      childLayer.template.centerVertical = false;
      childLayer.props.style.top = childLayer.rcDims.y;
    }

    let adjustedValues = adjustAbsoluteValues(childLayer, wrapperLayer);
    childLayer.props.style = {
      ...childLayer.props.style,
      ...adjustedValues.styleValues
    };
  }
  return wrapperLayer;
}
export function isAuto(layer: Layer): boolean {
  if (
    (isNil(layer.props.style.width) || isNil(layer.props.style.height)) &&
    (layer.type === "text" || get(layer, "import.layerName") === "Icon")
  ) {
    return true;
  }
  return false;
}
export function forEachChild(
  layer: Layer,
  callback: (childLayer: Layer, index: number) => void
) {
  if (typeof layer.children === "string") {
    return;
  }
  forEach(layer.children, (childLayer: Layer, index: number) => {
    if (!shouldIgnoreLayer(childLayer)) {
      callback(childLayer, index);
    }
  });
}

export function shouldIgnoreLayer(layer: Layer) {
  return (
    !get(layer, "props.style.position") ||
    layer.type === "unknown" ||
    layer.type === "conditionalExpression" ||
    layer.type === "expressionStatement" ||
    layer.type === "binaryExpression" ||
    layer.type === "logicalExpression" ||
    layer.type === "literal" ||
    layer.type === "" ||
    layer.type === "expression"
  );
}
export function isWidthInfinite(layer: Layer): boolean {
  if (
    typeof get(layer, "props.style.left") === "number" &&
    typeof get(layer, "props.style.right") === "number"
  ) {
    return true;
  }
  if (get(layer, "props.style.width") === "100%") {
    return true;
  }
  // console.log("returning false");
  return false;
}
export function isHeightInfinite(layer: Layer): boolean {
  if (
    typeof get(layer, "props.style.top") === "number" &&
    typeof get(layer, "props.style.bottom") === "number"
  ) {
    return true;
  }
  if (get(layer, "props.style.height") === "100%") {
    return true;
  }
  return false;
}

export function hasPercentageValues(dimension: any) {
  if (typeof dimension === "string") {
    if (dimension.indexOf("%") !== -1) {
      return true;
    }
  }
  return false;
}
export function haveSameUnits(dimensions: any): any {
  let { top, bottom, right, left } = dimensions;
  let sameDimensions = false;
  if (!isNil(top) && !isNil(bottom)) {
    if (
      (typeof top === "number" && typeof bottom === "number") ||
      (hasPercentageValues(top) && hasPercentageValues(bottom))
    ) {
      sameDimensions = true;
    } else {
      return false;
    }
  }
  if (!isNil(left) && !isNil(right)) {
    if (
      (typeof left === "number" && typeof right === "number") ||
      (hasPercentageValues(left) && hasPercentageValues(right))
    ) {
      sameDimensions = true;
    } else {
      return false;
    }
  }
}
export function isFixedFromSides(layer: Layer, flexDirection: string): boolean {
  let { style } = layer.props;

  if (flexDirection === "column") {
    let infiniteWidth = isHeightInfinite(layer);
    if (infiniteWidth) {
      return true;
    }
    return false;
  }
  if (flexDirection === "row") {
    let infiniteHeight = isWidthInfinite(layer);
    if (infiniteHeight) {
      return true;
    }
    return false;
  }
  return false;
}
export function isFlexCondition(layer: Layer): boolean {
  if (layer.children.length > 1) {
    if (layer.props.style.flexDirection === "column") {
      if (
        isWidthInfinite(layer.children[0]) &&
        !isNil(layer.children[0].props.style.top)
      ) {
        if (
          isWidthInfinite(layer.children[layer.children.length - 1]) &&
          !isNil(layer.children[layer.children.length - 1].props.style.bottom)
        ) {
          return true;
        }
      }
    } else if (layer.props.style.flexDirection === "row") {
      if (
        isHeightInfinite(layer.children[0]) &&
        !isNil(layer.children[0].props.style.left)
      ) {
        if (
          isHeightInfinite(layer.children[layer.children.length - 1]) &&
          !isNil(layer.children[layer.children.length - 1].props.style.right)
        ) {
          return true;
        }
      }
    }
  }

  return false;
}

export function isColumnHeader(layer: Layer) {
  return (
    isWidthInfinite(layer) &&
    !isNil(layer.props.style.top) &&
    isNil(layer.props.style.bottom)
  );
}
export function isColumnFooter(layer: Layer) {
  return (
    isWidthInfinite(layer) &&
    isNil(layer.props.style.top) &&
    !isNil(layer.props.style.bottom)
  );
}
export function isRowHeader(layer: Layer) {
  return (
    isHeightInfinite(layer) &&
    !isNil(layer.props.style.left) &&
    isNil(layer.props.style.right)
  );
}
export function isRowFooter(layer: Layer) {
  return (
    isHeightInfinite(layer) &&
    isNil(layer.props.style.left) &&
    !isNil(layer.props.style.right)
  );
}

export function isBody(layer: Layer) {
  return isWidthInfinite(layer) && isHeightInfinite(layer);
}
export function isFlexConditionForAbsolute(layer: Layer) {
  if (layer.children.length >= 1) {
    if (
      (isColumnHeader(layer.children[0]) || isBody(layer.children[0])) &&
      (isColumnFooter(layer.children[layer.children.length - 1]) ||
        isBody(layer.children[layer.children.length - 1]))
    ) {
      return true;
    } else if (
      (isRowHeader(layer.children[0]) || isBody(layer.children[0])) &&
      (isRowFooter(layer.children[layer.children.length - 1]) ||
        isBody(layer.children[layer.children.length - 1]))
    ) {
      return true;
    } else if (
      // In case we have a single child which is a footer
      isColumnFooter(layer.children[0]) &&
      layer.children.length === 1
    ) {
      return true;
    }
  }
  return false;
}
export function getBodyDims(layer: Layer, flexDirection: string) {
  let headerStyles;
  if (
    layer.children.length > 1 ||
    isColumnHeader(layer.children[0]) ||
    isRowHeader(layer.children[0])
  ) {
    headerStyles = {
      height: layer.children[0].rcDims.height,
      width: layer.children[0].rcDims.width,
      top: layer.children[0].rcDims.y,
      bottom:
        layer.rcDims.height -
        layer.children[0].rcDims.y -
        layer.children[0].rcDims.height,
      left: layer.children[0].rcDims.x,
      right:
        layer.rcDims.width -
        layer.children[0].rcDims.x -
        layer.children[0].rcDims.width
    };
  } else {
    headerStyles = {
      height: 0,
      width: 0,
      top: 0,
      left: 0,
      bottom: layer.rcDims.height,
      right: layer.rcDims.width
    };
  }
  let footerStyles;
  if (
    layer.children.length > 1 ||
    isColumnFooter(layer.children[0]) ||
    isRowFooter(layer.children[0])
  ) {
    footerStyles = {
      height: layer.children[layer.children.length - 1].rcDims.height,
      width: layer.children[layer.children.length - 1].rcDims.width,
      top: layer.children[layer.children.length - 1].rcDims.y,
      bottom:
        layer.rcDims.height -
        layer.children[layer.children.length - 1].rcDims.y -
        layer.children[layer.children.length - 1].rcDims.height,
      left: layer.children[layer.children.length - 1].rcDims.x,
      right:
        layer.rcDims.width -
        layer.children[layer.children.length - 1].rcDims.x -
        layer.children[layer.children.length - 1].rcDims.width
    };
  } else {
    footerStyles = {
      height: 0,
      width: 0,
      top: layer.rcDims.height,
      left: 0,
      bottom: 0,
      right: layer.rcDims.width
    };
  }
  let bodyStyles = {
    height:
      flexDirection === "column"
        ? layer.rcDims.height -
          (headerStyles.top +
            headerStyles.height +
            footerStyles.height +
            footerStyles.bottom)
        : flexDirection === "row"
        ? layer.rcDims.height
        : undefined,
    width:
      flexDirection === "column"
        ? layer.rcDims.width
        : flexDirection === "row"
        ? layer.rcDims.width -
          (headerStyles.left +
            headerStyles.width +
            footerStyles.width +
            footerStyles.right)
        : undefined,
    top:
      flexDirection === "column"
        ? headerStyles.top + headerStyles.height
        : layer.rcDims.y,
    left: flexDirection === "row" ? headerStyles.left + headerStyles.width : 0, // TODO: Vanshu
    // TODO:Consider Padding of parent
    bottom:
      flexDirection === "column"
        ? footerStyles.height + footerStyles.bottom
        : 0,
    right:
      flexDirection === "column" ? 0 : footerStyles.width + footerStyles.right
  };
  return bodyStyles;
}
export function createWrapperLayerForFlex(
  layers: Array<Layer>,
  flexDirection: string,
  bodyDims: any
) {
  let layer: Layer = {
    import: {
      asName: "",
      isDefaultImport: false,
      layerName: "View",
      packageName: "native"
    },
    overrideKeys: [],
    template: {
      centerVertical: false,
      centerHorizontal: false
    },
    rcDims: {
      x: bodyDims.left,
      y: bodyDims.top,
      height: bodyDims.height,
      width: bodyDims.width
    },
    props: {
      style: {
        top: bodyDims.top,
        left: bodyDims.left,
        bottom: bodyDims.bottom,
        right: bodyDims.right,
        flexDirection: flexDirection,
        position: "absolute"
      }
    },
    children: [...layers],

    styleName: "body",
    type: "body"
  };
  for (let k = 0; k < layer.children.length; k++) {
    let adjustedValues = adjustAbsoluteValues(layer.children[k], layer);
    layer.children[k].props.style = {
      ...layer.children[k].props.style,
      ...adjustedValues.styleValues
    };
  }
  return layer;
}
export function isOneOfTheWidthIsInfinite(layer1: Layer, layer2: Layer) {
  if (
    isWidthInfinite(layer1) &&
    !isWidthInfinite(layer2) &&
    typeof get(layer2, "props.style.width") === "number"
  ) {
    return true;
  } else if (
    isWidthInfinite(layer2) &&
    !isWidthInfinite(layer1) &&
    typeof get(layer1, "props.style.width") === "number"
  ) {
    return true;
  }
  return false;
}
export function isOneOfTheHeightIsInfinite(layer1: Layer, layer2: Layer) {
  if (
    isHeightInfinite(layer1) &&
    !isHeightInfinite(layer2) &&
    typeof get(layer2, "props.style.height") === "number"
  ) {
    return true;
  } else if (
    isHeightInfinite(layer2) &&
    !isHeightInfinite(layer1) &&
    typeof get(layer1, "props.style.height") === "number"
  ) {
    return true;
  }
  return false;
}

export function dontGroupByProximity(
  layer: Layer,
  overlapDirection: "horizontal" | "vertical" | "absolute"
) {
  if (!layer.children) {
    return true;
  }
  if (
    layer.children.length === 1 &&
    ((overlapDirection === "vertical" &&
      !isNil(layer.children[0].props.style.bottom) &&
      isNil(layer.children[0].props.style.top)) ||
      (overlapDirection === "horizontal" &&
        !isNil(layer.children[0].props.style.right) &&
        isNil(layer.children[0].props.style.left)))
  ) {
    return true;
  } else if (layer.children.length === 1) {
    return false;
  }

  let firstValidLayer;
  for (let i = 0; i < layer.children.length; i++) {
    // if (
    //   (shouldIgnoreLayer(layer.children[0]) &&
    //     layer.children[0].type !== "statusBar") ||
    //   (shouldIgnoreLayer(layer.children[i]) &&
    //     layer.children[i].type !== "statusBar")
    // ) {
    //   return true;
    // } else
    //  {

    if (shouldIgnoreLayer(layer.children[i])) {
      continue;
    }

    if (!firstValidLayer) {
      firstValidLayer = layer.children[i];
      continue;
    }

    let is0Auto = false;
    let isIAuto = false;
    if (isAuto(firstValidLayer)) {
      is0Auto = true;
      modifyLayerForCalculation(firstValidLayer, "add");
    }
    if (isAuto(layer.children[i])) {
      isIAuto = true;
      modifyLayerForCalculation(layer.children[i], "add");
    }

    if (
      (overlapDirection === "vertical" &&
        !isNil(layer.children[i].props.style.bottom) &&
        isNil(layer.children[i].props.style.top)) ||
      (overlapDirection === "horizontal" &&
        !isNil(layer.children[i].props.style.right) &&
        isNil(layer.children[i].props.style.left))
    ) {
      if (is0Auto) {
        modifyLayerForCalculation(firstValidLayer, "delete");
      }
      if (isIAuto) {
        modifyLayerForCalculation(layer.children[i], "delete");
      }
      return true;
    } else if (
      overlapDirection === "vertical" &&
      !hasSamePositionTypeInCoordinate(
        "y",
        get(firstValidLayer, "props.style", {}),
        get(layer.children[i], "props.style", {})
      )
    ) {
      if (is0Auto) {
        modifyLayerForCalculation(firstValidLayer, "delete");
      }
      if (isIAuto) {
        modifyLayerForCalculation(layer.children[i], "delete");
      }
      return true;
    } else if (
      overlapDirection === "horizontal" &&
      !hasSamePositionTypeInCoordinate(
        "x",
        get(firstValidLayer, "props.style", {}),
        get(layer.children[i], "props.style", {})
      )
    ) {
      if (is0Auto) {
        modifyLayerForCalculation(firstValidLayer, "delete");
      }
      if (isIAuto) {
        modifyLayerForCalculation(layer.children[i], "delete");
      }
      return true;
    }

    if (is0Auto) {
      modifyLayerForCalculation(firstValidLayer, "delete");
    }
    if (isIAuto) {
      modifyLayerForCalculation(layer.children[i], "delete");
    }
    // }
  }

  return false;
}
export function isWidthOfAnyLayerInfinite(layers: Array<Layer>) {
  let isInfiniteWidth = false;
  for (let i = 0; i < layers.length; i++) {
    if (isWidthInfinite(layers[i])) {
      return true;
    }
  }
  return false;
}
export function insertHeight(layer: Layer): boolean {
  if (
    layer.props.style.hasOwnProperty("top") &&
    layer.props.style.hasOwnProperty("bottom") // TODO: Vanshu
  ) {
    let { top, bottom, ...restStyles } = layer.props.style;
    if (
      (hasPercentageValues(top) && typeof bottom === "number") ||
      (hasPercentageValues(bottom) && typeof top === "number")
    ) {
      return true;
    }
  }
  return false;
}

export function getFlexFiller(style: Style, children: Layer[] = []) {
  return {
    import: {
      asName: "",
      isDefaultImport: false,
      layerName: "View",
      packageName: "native"
    },
    overrideKeys: [],
    template: {
      centerVertical: false,
      centerHorizontal: false
    },
    rcDims: {
      x: 0,
      y: 0,
      height: 0,
      width: 0
    },
    props: {
      style: style
    },
    children: [...children],

    styleName: "flexFiller",
    type: "flexFiller"
  };
}

export function compareLayers(
  layer1: Layer,
  layer2: Layer,
  parentRCDims: Dims,
  axis: "x" | "y",
  callback: CompareLayersCallback
) {
  const l1 = axis === "x" ? layer1.rcDims.x : layer1.rcDims.y;
  const l2 = axis === "x" ? layer2.rcDims.x : layer2.rcDims.y;
  const r1 =
    axis === "x"
      ? parentRCDims.width - (layer1.rcDims.x + layer1.rcDims.width)
      : parentRCDims.height - (layer1.rcDims.y + layer1.rcDims.height);
  const r2 =
    axis === "x"
      ? parentRCDims.width - (layer2.rcDims.x + layer2.rcDims.width)
      : parentRCDims.height - (layer2.rcDims.y + layer2.rcDims.height);
  const w1 = axis === "x" ? layer1.rcDims.width : layer1.rcDims.height;
  const w2 = axis === "x" ? layer2.rcDims.width : layer2.rcDims.height;

  if (
    typeof l1 === "number" &&
    typeof r1 === "number" &&
    typeof l2 === "number" &&
    typeof r2 === "number"
  ) {
    callback().lrlr({ l1, r1, l2, r2, layer1, layer2 });
  } else if (
    typeof l1 === "number" &&
    typeof r1 === "number" &&
    typeof r2 === "number" &&
    typeof w2 === "number"
  ) {
    callback().lrrw({ l1, r1, r2, w2, layer1, layer2 });
  } else if (
    typeof l1 === "number" &&
    typeof r1 === "number" &&
    typeof l2 === "number" &&
    typeof w2 === "number"
  ) {
    callback().lrlw({ l1, r1, l2, w2, layer1, layer2 });
  } else if (
    typeof r1 === "number" &&
    typeof w1 === "number" &&
    typeof l2 === "number" &&
    typeof r2 === "number"
  ) {
    callback().rwlr({ r1, w1, l2, r2, layer1, layer2 });
  } else if (
    typeof r1 === "number" &&
    typeof w1 === "number" &&
    typeof r2 === "number" &&
    typeof w2 === "number"
  ) {
    callback().rwrw({ r1, w1, r2, w2, layer1, layer2 });
  } else if (
    typeof r1 === "number" &&
    typeof w1 === "number" &&
    typeof l2 === "number" &&
    typeof w2 === "number"
  ) {
    callback().rwlw({ r1, w1, l2, w2, layer1, layer2 });
  } else if (
    typeof l1 === "number" &&
    typeof w1 === "number" &&
    typeof l2 === "number" &&
    typeof r2 === "number"
  ) {
    callback().lwlr({ l1, w1, l2, r2, layer1, layer2 });
  } else if (
    typeof l1 === "number" &&
    typeof w1 === "number" &&
    typeof r2 === "number" &&
    typeof w2 === "number"
  ) {
    callback().lwrw({ l1, w1, r2, w2, layer1, layer2 });
  } else if (
    typeof l1 === "number" &&
    typeof w1 === "number" &&
    typeof l2 === "number" &&
    typeof w2 === "number"
  ) {
    callback().lwlw({ l1, w1, l2, w2, layer1, layer2 });
  }
}
function modifyWrapperStylesForFlexGrouping(
  flexDirection: string,
  wrapper: Layer,
  parentLayer: Layer
) {
  if (flexDirection === "row") {
    let topCount = 0,
      bottomCount = 0;
    wrapper.children.forEach(child => {
      if (typeof child.props.style.top === "number") {
        topCount++;
      }
      if (typeof child.props.style.bottom === "number") {
        bottomCount++;
      }
    });

    if (bottomCount > 0 && topCount > 0) {
      if (bottomCount > topCount) {
        wrapper.props.style.top = wrapper.rcDims.y;
        delete wrapper.props.style.height;
      } else {
        wrapper.props.style.bottom =
          parentLayer.rcDims.height -
          (wrapper.rcDims.y + wrapper.rcDims.height);
        delete wrapper.props.style.height;
      }
    }

    delete wrapper._width;
    delete wrapper.props.style.width;
  } else if (flexDirection === "column") {
    let leftCount = 0,
      rightCount = 0;
    wrapper.children.forEach(child => {
      if (typeof child.props.style.left === "number") {
        leftCount++;
      }
      if (typeof child.props.style.right === "number") {
        rightCount++;
      }
    });

    if (rightCount > 0 && leftCount > 0) {
      if (rightCount > leftCount) {
        wrapper.props.style.left = wrapper.rcDims.x;
        delete wrapper.props.style.width;
      } else {
        wrapper.props.style.right =
          parentLayer.rcDims.width - (wrapper.rcDims.x + wrapper.rcDims.width);
        delete wrapper.props.style.width;
      }
    }

    delete wrapper._height;
    delete wrapper.props.style.height;
  }
}
export function modifyColorAlpha(
  colorStyle: string,
  newAlpha: string | number
) {
  if (hasHexColor(colorStyle)) {
    let convertedColor = hexToRgb(colorStyle);
    if (convertedColor !== null) {
      colorStyle = `rgba(${convertedColor.r},${convertedColor.g},${convertedColor.b},${convertedColor.a})`;
    }
  }
  let rgbaRegex = /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*(\d*(?:\.\d+)?)\)$/;
  if (rgbaRegex.test(colorStyle)) {
    let helperIndex = colorStyle.lastIndexOf(",");
    let existingAlpha = Number(
      colorStyle.substring(helperIndex + 1, colorStyle.length - 1)
    );
    newAlpha = Number(newAlpha);
    let modifiedAlpha = existingAlpha * newAlpha;
    let newColorStyle =
      colorStyle.substring(0, helperIndex + 1) + modifiedAlpha + ")";
    return newColorStyle;
  }
  return colorStyle;
}
export function adjustColorProperties(style: any, opacity: number) {
  let borderProperties = [
    "borderColor",
    "backgroundColor",
    "borderTopColor",
    "borderLeftColor",
    "borderRightColor",
    "borderBottomColor"
  ];
  forEach(Object.keys(style), (key: string, index: number) => {
    if (borderProperties.includes(key) && style[key]) {
      if (hasHexColor(style[key])) {
        let hexStyle = hexToRgb(style[key]);
        if (hexStyle !== null) {
          style[
            key
          ] = `rgba(${hexStyle.r},${hexStyle.g},${hexStyle.b},${hexStyle.a})`;
        }
      }
      style[key] = modifyColorAlpha(style[key], opacity);
    }
  });
}
export function hexToRgb(hex: any) {
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result
    ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16),
        a: 1
      }
    : null;
}
export function hasHexColor(color: string): boolean {
  return color && typeof color === "string" ? color.startsWith("#") : false;
}
export function adjustGradientOpacity(layer: Layer) {
  forEach(layer.gradient.stops, (stop, index) => {
    stop.stopColor = modifyColorAlpha(
      stop.stopColor,
      layer.props.style.opacity ? layer.props.style.opacity : 1
    );
  });
  // For React Code Gen background Image is generated again after adjusting opacity into alphas
  layer.props.style.backgroundImage = Utils.getGradient(layer.gradient);
}
