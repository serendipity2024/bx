import { forEach, get, isEmpty, round } from "lodash";
import { Config, Context, ExtraParams } from "./types";
import { isTabViewSpecificStyleProp, anyChildIsFlex } from "./utils";
import * as path from "path";
import {
  ROUNDABLE_LAYOUT_PROPERTIES,
  ROUNDABLE_TO_TWO_DECIMALS_LAYOUT_PROPERTIES
} from "bx-constants";
const pascalCase = require("pascal-case");
const toStyleString = require("to-style").string;
type JSLiteralTypes =
  | "string"
  | "number"
  | "bigint"
  | "boolean"
  | "symbol"
  | "undefined"
  | "object"
  | "function"
  | "array";

const flexProperties = [
  "flex",
  "justifyContent",
  "alignItems",
  "alignSelf",
  "flexWrap"
];
export default class LayerCodeGen {
  context: Context;
  config: Config;
  generate(json: any, extraParams: ExtraParams): string {
    return "";
  }

  generateProps = (json: any, extraParams: ExtraParams) => {
    let propsCode = "";

    if (json.props) {
      forEach(json.props, (propValue: any, propName: string) => {
        if (propName === "onPress") {
          if (typeof propValue === "string") {
            propsCode = `onClick={${propValue.replace(/;/g, "")}}`;
          } else {
            // TODO: Handle conditional navigation
            propsCode +=
              "/* Conditional navigation not supported at the moment */";
          }
          // TODO: check for all callback props
        } else if (
          get(json, "import.layerName").indexOf("GoogleMapReact") !== -1 &&
          propName === "initialRegion"
        ) {
          propName = "defaultCenter";
          delete propValue.longitude;
          delete propValue.latitudeDelta;
          delete propValue.longitudeDelta;
          Object.assign(propValue, {
            lat: 20.5937,
            lng: 78.9629
          });
          propsCode += `${propName}={${this.generateJSLiteralCode(
            propValue,
            extraParams
          )}}`;
        } else if (
          get(json, "import.layerName") === "ReactList" &&
          propName === "renderItem"
        ) {
          propName = "itemRenderer";
          propsCode += `${propName}={({ item, separators }) => ${this.context.baseCodeGen.generate(
            propValue,
            extraParams
          )}}`;
        } else if (
          get(json, "import.layerName") === "ReactList" &&
          (propName === "ListHeaderComponent" ||
            propName === "ListFooterComponent" ||
            propName === "ItemSeparatorComponent")
        ) {
          propsCode += `${propName}={() => ${this.context.baseCodeGen.generate(
            propValue,
            extraParams
          )}}`;
        } else if (propName === "source") {
          propName = "src";
          propsCode += this.generateSourcePropCode(
            path.basename(propValue.uri)
          );
        } else if (
          !isTabViewSpecificStyleProp(propName) &&
          propName !== "style" &&
          propName !== "contentContainerStyle"
        ) {
          if (typeof propValue === "string") {
            propsCode += `${propName}=${this.generateJSLiteralCode(
              propValue,
              extraParams
            )}`;
          } else {
            const ellipseProps = ["cx", "cy", "rx", "ry"];
            if (ellipseProps.includes(propName)) {
              propValue = round(propValue);
            }
            propsCode += `${propName}={${this.generateJSLiteralCode(
              propValue,
              extraParams
            )}}`;
          }
        }
        if (propName === "style") {
          for (let prop in json.props.style) {
            if (
              typeof json.props.style[prop] !== "string" &&
              typeof json.props.style[prop] !== "number" &&
              prop.indexOf("shadow") === -1 &&
              prop.indexOf("transform") === -1
            ) {
              propsCode += `${propName}={{${prop}:${this.generateJSLiteralCode(
                json.props.style[prop],
                extraParams
              )}}}`;
              delete json.props.style[prop];
            }
          }
        }
      });
    }

    return propsCode;
  };

  generateStyle = (
    json: any,
    extraParams: ExtraParams,
    stylePropName: string = "style"
  ) => {
    if (get(json, "import.layerName") === "Picker.Item") {
      return "";
    }
    const style = get(json, `props.${stylePropName}`, {});
    const conditionalStyles: { [key: string]: string } = {};
    forEach(style, (styleValue: any, styleProperty: any) => {
      if (
        styleValue &&
        [
          "expressionStatement",
          "binaryExpression",
          "expression",
          "conditionalExpression",
          "logicalExpression"
        ].includes(styleValue.type)
      ) {
        conditionalStyles[styleProperty] = this.context.baseCodeGen.generate(
          styleValue,
          extraParams
        );

        delete this.context.styles[json.styleName][styleProperty];
      }
    });

    if (Object.keys(conditionalStyles).length !== 0) {
      let conditionalStyleObjCode = "";
      forEach(
        conditionalStyles,
        (code, styleProperty) =>
          (conditionalStyleObjCode += `${styleProperty}: ${code},`)
      );
      return `${stylePropName}={[
        styles.${json.styleName}${
        stylePropName !== "style" ? "_" + stylePropName : ""
      },
        {
          ${conditionalStyleObjCode}
        }
      ]}`;
    }
    return `${stylePropName}={styles.${json.styleName}${
      stylePropName !== "style" ? "_" + stylePropName : ""
    }}`;
  };

  generateSourcePropCode(imageName: string, category?: string) {
    // TODO:Confirm from @HimanshuSatija about JS expressions
    const assetsRelativePath = this.config.isPreviewFile
      ? "./assets/images/"
      : "../assets/images/";
    if (category === "svgImage") {
      return `${assetsRelativePath}${imageName}`;
    }
    return `src={require("${assetsRelativePath}${imageName}")}`;
  }

  generateStyleComponentCode = (
    literal: any,
    json: any,
    extraParams: ExtraParams
  ) => {
    let code = "";
    // let restStyles = {};
    forEach(
      literal,
      (
        element: { style: any; layerName: string; category?: string },
        key: string
      ) => {
        // if (element.hasOwnProperty("style")) {
        //   let { flex, ...remainingStyles } = element.style;
        //   restStyles = remainingStyles;
        // }
        if (element.category === "text" || element.category === "TextInput") {
          element.style = { fontFamily: "Arial", ...element.style };
          let styleCode = this.generateStyleCode(
            element.style,
            extraParams,
            element.category
          );
          code += `const ${pascalCase(key)} = styled.${
            element.layerName
          }\`\n${styleCode}\`;\n\n`;
        } else if (
          element.layerName !== "ThirdParty" &&
          element.layerName !== "svg" &&
          element.layerName !== "Symbol" &&
          element.category !== "Center" &&
          (element.category !== "root" ||
            this.context.filePath.indexOf("symbols") === -1 ||
            this.context.filePath.indexOf("components") === -1)
        ) {
          let styleCode = this.generateStyleCode(
            element.style,
            extraParams,
            element.category,
            json
          );
          // if (
          //   !isEmpty(restStyles) ||
          //   this.context.filePath.indexOf("symbols") !== -1 ||
          //   this.context.filePath.indexOf("components") !== -1
          // ) {
          //   // TODO:Condition can be improved
          //   if (isEmpty(restStyles)) {
          //     // This is the case of empty object and symbol
          //     code += `const ${pascalCase(key)} = styled.${
          //       element.layerName
          //     }\`\``;
          //   } else {
          //     code += `const ${pascalCase(key)} = styled.${
          //       element.layerName
          //     }\`\n${styleCode}\`;\n\n`;
          //   }
          // } else {
          code += `const ${pascalCase(key)} = styled.${
            element.layerName
          }\`\n${styleCode}\`\n\n`;
          // }
        } else if (element.category === "Center") {
          code += `const ${pascalCase(key)} = styled.${element.layerName}\`
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  flex-direction: column;
  position: absolute;
  pointer-events: none;

  \${props=>
  ((props.horizontal && !props.vertical)
  ||(!props.horizontal && !props.vertical)) && css \`
      align-items: center;
  \`};


  \${props=>
  ((props.vertical &&!props.horizontal)
  ||(!props.horizontal&&!props.vertical)) && css \`
      justify-content: center;
  \`};
  \`;\n\n`;
        } else if (
          element.category === "root" &&
          (this.context.filePath.indexOf("symbols") !== -1 ||
            this.context.filePath.indexOf("components") !== -1)
        ) {
          code += `const ${pascalCase(key)}=styled.${element.layerName}(
            ${this.generateJSLiteralCode(
              element.style,
              extraParams,
              false,
              element.category
            )}
          );`;
        }

        if (
          this.context.buttonDuplicate.exists &&
          !this.context.buttonDuplicate.codeGenerated
        ) {
          code += `const ButtonOverlay${
            this.context.buttonDuplicate.lastNumber !== 1
              ? this.context.buttonDuplicate.lastNumber
              : ""
          } = styled.button\`
 display: block;
 background: none;
 height: 100%;
 width: 100%;
 border:none
 \`;`;
          this.context.buttonDuplicate.codeGenerated = true;
          this.context.buttonDuplicate.exists = false;
        }
      }
    );
    return code;
  };
  generateStyleCode(
    obj: any,
    extraParams: ExtraParams,
    category?: string,
    json?: any
  ) {
    let flexStyles = get(obj, "flex");
    if (category === "tabView") {
      obj = { ...obj, position: "absolute" };
    }

    if (flexStyles && category !== "root") {
      let flexDirection = get(
        extraParams,
        "parent.props.style.flexDirection",
        undefined
      );

      let flexValue = obj["flex"];
      let styles = {
        display: "flex",
        flexDirection: obj.flexDirection ? obj.flexDirection : "column"
      };
      if (
        typeof flexValue === "number" ||
        (typeof flexValue === "string" && flexValue.indexOf(" ") === -1)
      ) {
        Object.assign(styles, { flex: `${flexValue} 1 0%` });
      }

      if (flexDirection) {
        switch (flexDirection) {
          case "row":
            Object.assign(styles, { width: "100%" });
            break;
          case "column":
            Object.assign(styles, { height: "100%" });
            break;
        }
      }
      obj = { ...obj, ...styles };
    } else if (category === "root") {
      let styles = {};
      if (flexStyles) {
        delete obj.flex;
      }
      let res: Array<string> = [];
      Object.keys(obj).forEach((key, index) => {
        if (flexProperties.includes(key)) {
          res.push(key);
        }
      });
      const hasFlex: boolean = res.length !== 0;
      if (
        (obj.hasOwnProperty("backgroundColor") &&
          this.context.filePath.indexOf("preview") === -1) ||
        (json && anyChildIsFlex(json.layer)) ||
        hasFlex
      ) {
        // Appending styles to root only we have backgroundColor as one of the property
        styles = {
          height: obj.height ? obj.height : "100vh",
          width: obj.width ? obj.width : "100vw"
        };
        obj = { ...obj, ...styles };
      }
      if (obj.hasOwnProperty("flexDirection")) {
        styles = {
          display: "flex"
        };
        obj = { ...styles, ...obj };
      }
      if (
        this.context.filePath.indexOf("symbols") !== -1 ||
        this.context.filePath.indexOf("components") !== -1
      ) {
        delete obj.height;
        delete obj.width;
      } else {
        obj = { ...obj, ...styles };
      }
    }
    if (obj.hasOwnProperty("shadowOffset")) {
      obj = {
        ...obj,
        boxShadow: `${obj.shadowOffset.width ? obj.shadowOffset.width : 0}px ${
          obj.shadowOffset.height ? obj.shadowOffset.height : 0
        }px ${obj.shadowRadius ? obj.shadowRadius : 0}px  ${
          obj.shadowOpacity ? obj.shadowOpacity : 0
        }px ${obj.shadowColor && obj.shadowColor} `
      };
      let junk = obj.shadowOffset && delete obj.shadowOffset;
      junk = obj.shadowColor && delete obj.shadowColor;
      junk = obj.shadowOpacity && delete obj.shadowOpacity;
      junk = obj.shadowRadius && delete obj.shadowRadius;
      junk = obj.elevation && delete obj.elevation;
    }
    for (let key in obj) {
      if (typeof obj[key] !== "string") {
        let passVal = obj[key];
        if (
          typeof obj[key] === "number" &&
          ROUNDABLE_LAYOUT_PROPERTIES.includes(key)
        ) {
          passVal = round(passVal);
        }
        obj[key] = this.generateJSLiteralCode(passVal, extraParams);
      }
    }
    let style = toStyleString(obj);
    if (style === "") {
      return style;
    }
    let styleProperties = style.split(";");
    style = "";
    let length = styleProperties.length;
    for (let i = 0; i < length; i++) {
      if (i === 0 && length > 1) {
        style = style + `  ${styleProperties[i]};\n`;
      } else {
        style = style + ` ${styleProperties[i]};\n`;
      }
    }
    return style;
  }
  generateSymbolOverrideProps(scopeVariables: any, extraParams: ExtraParams) {
    let code = "";
    forEach(scopeVariables, (value: any, key: string) => {
      if (typeof value === "string") {
        code += `${key.replace("this.props.", "")}=${this.generateJSLiteralCode(
          value,
          extraParams
        )}`;
      } else {
        code += `${key.replace(
          "this.props.",
          ""
        )}={${this.generateJSLiteralCode(value, extraParams)}}`;
      }
    });
    return code;
  }
  generateJSLiteralCode = (
    literal: any,
    extraParams: ExtraParams,
    jsExpression: boolean = false,
    category?: string
  ) => {
    let code = "";

    let literalType: JSLiteralTypes = typeof literal;

    if (literal === null) {
      literalType = literal; // Handle null literal, otherwise it takes type object
    }

    if (Array.isArray(literal)) {
      literalType = "array";
    }

    switch (literalType) {
      case "object":
        // TODO:if is not handelled
        if (
          [
            "expressionStatement",
            "binaryExpression",
            "expression",
            "conditionalExpression",
            "logicalExpression"
          ].includes(literal.type)
        ) {
          code = this.context.baseCodeGen.generate(literal, extraParams);
        } else {
          code = `${this.generateJSObjectCode(literal, extraParams, category)}`;
        }
        break;
      case "array":
        code = `${this.generateJSArrayCode(literal, extraParams)}`;
        break;
      case "boolean":
        code = `${literal}`;
        break;
      case "number":
        code = String(literal); // TODO: consider setValueinInt
        break;
      case "string":
      default:
        if (jsExpression) {
          code = `${literal}`;
        } else {
          code = `"${literal}"`;
        }
    }

    return code;
  };

  generateJSObjectCode = (
    obj: any,
    extraParams: ExtraParams,
    category?: string
  ) => {
    let code = "";
    if (obj.hasOwnProperty("shadowOffset")) {
      obj = {
        ...obj,
        boxShadow: `${obj.shadowOffset.width ? obj.shadowOffset.width : 0}px ${
          obj.shadowOffset.height ? obj.shadowOffset.height : 0
        }px ${obj.shadowRadius ? obj.shadowRadius : 0}px  ${
          obj.shadowOpacity ? obj.shadowOpacity : 0
        }px ${obj.shadowColor && obj.shadowColor} `
      };
      let junk = obj.shadowOffset && delete obj.shadowOffset;
      junk = obj.shadowColor && delete obj.shadowColor;
      junk = obj.shadowOpacity && delete obj.shadowOpacity;
      junk = obj.shadowRadius && delete obj.shadowRadius;
      junk = obj.elevation && delete obj.elevation;
    }
    forEach(obj, (value, key) => {
      if (value !== undefined) {
        if (key === "transform") {
          value = `rotate(${value[0]["rotate"]})`;
        }

        if (key === "lineHeight") {
          value = value + "px";
        }
        // if (key === "fontSize") {
        //   value = `${value * 0.5}px`;
        // }

        if (ROUNDABLE_LAYOUT_PROPERTIES.includes(key)) {
          if (typeof value === "number") {
            value = Math.round(value);
          } else if (typeof value === "string" && value.includes("%")) {
            // For percentage values
            let numValue = parseFloat(value.replace("%", ""));
            numValue = Math.round(numValue * 100) / 100;
            value = numValue + "%";
          }
        } else if (ROUNDABLE_TO_TWO_DECIMALS_LAYOUT_PROPERTIES.includes(key)) {
          if (typeof value === "number") {
            value = Math.round(value * 100) / 100;
          }
        }

        code += `${key}: ${this.generateJSLiteralCode(value, extraParams)},
      `;
      }
    });

    return `{
      ${code}
    }`;
  };

  generateJSArrayCode = (obj: any, extraParams: ExtraParams) => {
    let code = "";
    obj.forEach((value: any) => {
      code += `${this.generateJSLiteralCode(value, extraParams)},
      `;
    });

    return `[
      ${code}
    ]`;
  };
}
