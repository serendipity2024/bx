import { Context, ExtraParams } from "../types";
import { replace, includes, escape, get } from "lodash";
let switchHighestNumber = 0;
let mapHighestNumber = 0;
let buttonHighestNumber = 0;
let hasButtonLayer = false;
export const generateChildren = (
  layer: any,
  generateChildCallback: (child: any, extraParams: any) => string,
  extraParams: any
) => {
  let childrenCode = "";
  layer.children.forEach((child: any) => {
    if (
      [
        "expressionStatement",
        "binaryExpression",
        "expression",
        "conditionalExpression",
        "logicalExpression"
      ].includes(child.type)
    ) {
      childrenCode += `{${generateChildCallback(child, extraParams)}
    }`;
    } else if (layer.styleName.indexOf("carousel") !== -1) {
      childrenCode += `<Slide>${generateChildCallback(
        child,
        extraParams
      )}</Slide>`;
    } else {
      childrenCode += `${generateChildCallback(child, extraParams)}
    `;
    }
  });
  return childrenCode;
};
export const addImportToContext = (
  context: Context,
  layerJSON: any,
  generateJSLiteralCode?: any
) => {
  // console.log("Adding imports with json as ", context);
  if (layerJSON.import.layerName.includes(".")) {
    return;
  }
  if (
    layerJSON.import.packageName === "@builderx/icons" ||
    layerJSON.import.packageName === "VectorIcons"
  ) {
    let currentFamily = getCurrentFamily(layerJSON, generateJSLiteralCode);
    layerJSON.import.packageName = `react-native-vector-icons/dist/${currentFamily}`;
  }
  if (layerJSON.import.packageName === "native") {
    layerJSON.import.packageName = "react-native";
  }
  if (layerJSON.type === "symbol") {
    if (context.filePath.indexOf("screens") !== -1) {
      layerJSON.import.packageName = `../components/${layerJSON.import.layerName}`;
    } else if (context.filePath.indexOf("preview") !== -1) {
      layerJSON.import.packageName = `./components/${layerJSON.import.layerName}`;
    } else if (
      context.filePath.indexOf("symbols") !== -1 ||
      context.filePath.indexOf("components") !== -1
    ) {
      layerJSON.import.packageName = `./${layerJSON.import.layerName}`;
    }
  }
  switch (layerJSON.import.layerName) {
    case "MapView":
      layerJSON.import = {
        ...layerJSON.import,
        ...{
          packageName: "google-map-react",
          layerName: `GoogleMapReact${
            context.mapDuplicate.lastNumber === 1
              ? ""
              : context.mapDuplicate.lastNumber
          }`,
          isDefaultImport: true
        }
      };
      break;
    case "Swiper":
      layerJSON.import = {
        ...layerJSON,
        ...{
          packageName: "pure-react-carousel",
          layerName: "Carousel"
        }
      };
      context.imports[layerJSON.import.packageName] = {
        named: [
          "CarouselProvider",
          "Slider as CarouselSlider",
          "Slide",
          "DotGroup"
        ],
        default: false,
        cssFile: "pure-react-carousel/dist/react-carousel.es.css"
      };
      break;
    case "TabView":
      layerJSON.import = {
        ...layerJSON,
        ...{
          packageName: "@material-ui/core",
          layerName: "AppBar"
        }
      };
      context.imports[layerJSON.import.packageName] = {
        named: ["Tabs", "Tab as LabelledTab"],
        default: false
      };
      break;
    case "FlatList":
      layerJSON.import = {
        ...layerJSON,
        ...{
          packageName: "react-list",
          layerName: "ReactList",
          isDefaultImport: true
        }
      };
      break;
    case "Switch":
      layerJSON.import = {
        ...layerJSON,
        ...{
          packageName: "@material-ui/core/Switch",
          layerName:
            context.switchDuplicate.lastNumber === 1
              ? "MaterialUISwitch"
              : `MaterialUISwitch${context.switchDuplicate.lastNumber}`,
          isDefaultImport: true
        }
      };
      break;
    case "Slider":
      layerJSON.import = {
        ...layerJSON.import,
        ...{
          packageName: "material-ui-slider",
          layerName: "Slider"
        }
      };
      break;
    case "ActivityIndicator":
      layerJSON.import = {
        ...layerJSON.import,
        ...{
          packageName: "@material-ui/core/CircularProgress",
          layerName: "CircularProgress",
          isDefaultImport: true
        }
      };
      break;
    case "TouchableOpacity":
      layerJSON.import = {
        ...layerJSON.import,
        ...{
          packageName: "react-router-dom",
          layerName: "Link"
        }
      };
      break;
    default:
      break;
  }
  if (!context.imports[layerJSON.import.packageName]) {
    context.imports[layerJSON.import.packageName] = {
      named: [],
      default: false
    };
  }
  const contextImportObj = context.imports[layerJSON.import.packageName];
  if (
    layerJSON.import.packageName.indexOf("react-native-vector-icons") !== -1
  ) {
    let currentFamily = getCurrentFamily(layerJSON, generateJSLiteralCode);
    contextImportObj.default = `${currentFamily}${layerJSON.import.layerName}`;
  } else if (layerJSON.import.isDefaultImport) {
    contextImportObj.default = layerJSON.import.layerName;
  } else {
    if (contextImportObj.named.indexOf(layerJSON.import.layerName) === -1) {
      contextImportObj.named.push(layerJSON.import.layerName);
    }
  }
};
export const importTabViewFile = (
  fileName: string,
  context: Context,
  layerJSON: any
) => {
  //
};
export const isTabViewSpecificStyleProp = (propName: string) => {
  return (
    ["tabBarStyle", "indicatorStyle", "labelStyle", "tabStyle"].indexOf(
      propName
    ) !== -1
  );
};
export const escapeTextForJSX = (text: string) => {
  if (typeof text === "string") {
    text = text.trim();
    text = escape(text);
  }
  if (includes(text, "\n")) {
    text = replace(text, new RegExp("\n", "g"), `{\"\\n"}`);
    text = replace(text, new RegExp("\t", "g"), `{\"\\t"}`);
  }
  return text;
};
export const anyChildIsFlex = (layer: any) => {
  let hasFlexChild = false;
  layer.children.forEach((child: any) => {
    let { flex, ...restStyles } = child.props.style;
    if (flex) {
      hasFlexChild = true;
    }
  });
  return hasFlexChild;
};
export const jsonHasButtonLayer = (layer: any, context: Context) => {
  layer.children.forEach((child: any) => {
    if (
      get(child, "import.layerName", 0) &&
      child.import.layerName === "TouchableOpacity"
    ) {
      context.buttonDuplicate.exists = true;
      return;
    }
    if (child.children && child.children.length !== 0) {
      jsonHasButtonLayer(child, context);
    }
  });
  return hasButtonLayer;
};
export const traverseLayersForStyleName = (layer: any, context: Context) => {
  layer.children.forEach((child: any) => {
    if (
      child.styleName &&
      (child.styleName.startsWith("materialUISwitch") ||
        child.styleName.startsWith("MaterialUISwitch"))
    ) {
      if (typeof child.styleName === "string") {
        let followedString = child.styleName.substring(
          16,
          child.styleName.length
        );
        if (!isNaN(followedString)) {
          let currentNumber = Number(followedString);
          if (currentNumber > switchHighestNumber) {
            switchHighestNumber = currentNumber;
          } else if (currentNumber === 0) {
            switchHighestNumber++;
          }
        }
      }
    }
    context.switchDuplicate.lastNumber = switchHighestNumber + 1;
    if (
      child.styleName &&
      (child.styleName.startsWith("googleMapReact") ||
        child.styleName.startsWith("GoogleMapReact"))
    ) {
      if (typeof child.styleName === "string") {
        let followedString = child.styleName.substring(
          14,
          child.styleName.length
        );
        if (!isNaN(followedString)) {
          let currentNumber = Number(followedString);
          if (currentNumber > mapHighestNumber) {
            mapHighestNumber = currentNumber;
          } else if (currentNumber === 0) {
            mapHighestNumber++;
          }
        }
        if (
          child.styleName &&
          (child.styleName === "googleMapReact" ||
            child.styleName === "GoogleMapReact")
        ) {
          mapHighestNumber++;
        }
      }
    }
    context.mapDuplicate.lastNumber = mapHighestNumber + 1;
    if (
      child.styleName &&
      (child.styleName.startsWith("buttonOverlay") ||
        child.styleName.startsWith("ButtonOverlay"))
    ) {
      if (typeof child.styleName === "string") {
        let followedString = child.styleName.substring(
          13,
          child.styleName.length
        );
        doesNumberExist(
          "buttonOverlay",
          context.buttonDuplicate.lastNumber,
          layer,
          context
        );
      }
    }
  });
};
export const getCurrentFamily = (
  layerJSON: any,
  generateJSLiteralCode: any
) => {
  let conditionalStatement = generateJSLiteralCode(layerJSON.props.type);
  let currentFamily = "";
  let families = [
    "Entypo",
    "EvilIcons",
    "Feather",
    "FontAwesome",
    "MaterialIcons",
    "MaterialCommunityIcons",
    "SimpleLineIcons",
    "Octicons",
    "Zocial",
    "Ionicons"
  ];
  for (let i = 0; i < families.length; i++) {
    if (conditionalStatement.indexOf(families[i]) !== -1) {
      currentFamily = families[i];
      break;
    }
  }
  return currentFamily;
};
const doesNumberExist = (
  category: string,
  num: number,
  layer: any,
  context: Context
): any => {
  layer.children.forEach((child: any) => {
    if (typeof child.styleName === "string") {
      let compareWith =
        num === 1
          ? `${category}`.toLowerCase()
          : `${category}${num}`.toLowerCase();
      if (child.styleName.toLowerCase() === compareWith) {
        context.buttonDuplicate.lastNumber++;
        doesNumberExist(
          category,
          context.buttonDuplicate.lastNumber,
          layer,
          context
        );
      }
    }
    if (child.children && child.children.length !== 0) {
      doesNumberExist(
        category,
        context.buttonDuplicate.lastNumber,
        layer,
        context
      );
    }
  });
  return;
};
export const isContainerLayer = (layer: any) => {
  let type = get(layer, "type", undefined);
  let validTypes = ["view", "image", "touchableopacity", "scrollview"];
  return type && validTypes.includes(type);
};
export const hasPositionProperty = (layer: any) => {
  let position = get(layer, "props.style.position", undefined);
  return position ? true : false;
};
export const hasAbsolutePosition = (styles: any) => {
  return styles.position === "absolute";
};
export const layerHasAbsoluteChild = (layer: any) => {
  let hasAbsoluteChild = false;
  for (let i = 0; i < layer.children.length; i++) {
    if (
      hasPositionProperty(layer.children[i]) &&
      hasAbsolutePosition(layer.children[i].props.style)
    ) {
      hasAbsoluteChild = true;
      break;
    }
  }
  return hasAbsoluteChild;
};

export const addFlexValuesForScrollViewChildren = (
  extraParams: ExtraParams,
  json: any
) => {
  let parent = get(extraParams, "parent", undefined);

  if (parent && parent.type && parent.type.toLowerCase() === "scrollview") {
    let parentStyles = get(parent, "props.style", undefined);
    if (
      parentStyles &&
      parentStyles.display &&
      parentStyles.display === "flex"
    ) {
      json.props.style = { ...json.props.style, flex: "0 0 auto" };
    }
  }
};
