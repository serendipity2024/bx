import { entries, get } from "lodash";
import { Context, ExtraParams } from "./types";
import LayerCodeGen from "./LayerCodeGen";
import DivCodeGen from "./layers/DivCodeGen";
import CenterCodeGen from "./specialLayers/CenterCodeGen";
import FileCodeGen from "./layers/FileCodeGen";
import LiteralCodeGen from "./specialLayers/LiteralCodeGen";
import TextCodeGen from "./layers/TextCodeGen";
import ImageCodeGen from "./layers/ImageCodeGen";
import EllipseCodeGen from "./layers/EllipseCodeGen";
import ScrollViewCodeGen from "./layers/ScrollViewCodeGen";
import SymbolLayerCodeGen from "./layers/SymbolLayerCodeGen";
import TextInputCodeGen from "./layers/TextInputCodeGen";
import ButtonCodeGen from "./layers/ButtonCodeGen";
import PathCodeGen from "./layers/PathCodeGen";
import ExpressionStatementCodeGen from "./specialLayers/ExpressionStatementCodeGen";
import BinaryExpressionCodeGen from "./specialLayers/BinaryExpressionCodeGen";
import ExpressionCodeGen from "./specialLayers/ExpressionCodeGen";
import ConditionalExpressionCodeGen from "./specialLayers/ConditionalExpressionCodeGen";
import LogicalExpressionCodeGen from "./specialLayers/LogicalExpressionCodeGen";
import LoopCodeGen from "./layers/LoopCodeGen";
import WrapperCodeGen from "./layers/WrapperCodeGen";
import InlineViewCodeGen from "./layers/InlineViewCodeGen";
import {
  traverseLayersForStyleName,
  jsonHasButtonLayer,
  addFlexValuesForScrollViewChildren
} from "./utils";
import IPC from "../IPC";
import IconCodeGen from "./layers/IconCodeGen";
import LoaderCodeGen from "./layers/LoaderCodeGen";
import MapCodeGen from "./layers/MapCodeGen";
import SliderCodeGen from "./layers/SliderCodeGen";
import SwitchCodeGen from "./layers/SwitchCodeGen";
import { getRotation } from "../utils";

export default class BaseCodeGen extends LayerCodeGen {
  ipc: IPC;
  context: Context = {
    styles: {},
    imports: {
      react: {
        named: ["Component"],
        default: "React",
        cssFile: undefined
      },
      "styled-components": {
        named: ["css"],
        default: "styled",
        cssFile: undefined
      }
    },
    filePath: "",
    conditionals: [],
    isPlatformConditional: false,
    fileHasTabView: false,
    baseCodeGen: this,
    smartFlexTransformed: false,
    switchDuplicate: {
      isDuplicate: false,
      lastNumber: 1
    },
    mapDuplicate: {
      isDuplicate: false,
      lastNumber: 1
    },
    buttonDuplicate: {
      isDuplicate: false,
      lastNumber: 1,
      exists: false,
      codeGenerated: false
    }
  };

  componentCodeGenMap = new Map<string, any>(
    entries({
      view: DivCodeGen,
      root: DivCodeGen,
      file: FileCodeGen,
      text: TextCodeGen,
      image: ImageCodeGen,
      ellipse: EllipseCodeGen,
      scrollView: ScrollViewCodeGen,
      symbol: SymbolLayerCodeGen,
      textInput: TextInputCodeGen,
      touchableOpacity: ButtonCodeGen,
      path: PathCodeGen,
      literal: LiteralCodeGen,
      // thirdParty: ThirdPartyCodeGen,
      icon: IconCodeGen,
      activityIndicator: LoaderCodeGen,
      mapView: MapCodeGen,
      slider: SliderCodeGen,
      switch: SwitchCodeGen,
      expressionStatement: ExpressionStatementCodeGen,
      binaryExpression: BinaryExpressionCodeGen,
      expression: ExpressionCodeGen,
      conditionalExpression: ConditionalExpressionCodeGen,
      logicalExpression: LogicalExpressionCodeGen,
      loop: LoopCodeGen,
      stack: WrapperCodeGen,
      row: WrapperCodeGen,
      column: WrapperCodeGen,
      body: WrapperCodeGen,
      flexFiller: WrapperCodeGen,
      inlineView: InlineViewCodeGen
    })
  );

  generate = (json: any, extraParams: ExtraParams) => {
    if (json.type === "file") {
      this.context.buttonDuplicate.exists = false;
      traverseLayersForStyleName(json.layer, this.context);
      jsonHasButtonLayer(json.layer, this.context);
    }
    addFlexValuesForScrollViewChildren(extraParams, json);
    let lastSlash = this.context.filePath.lastIndexOf("/");
    let fileName = this.context.filePath.substring(
      lastSlash + 1,
      this.context.filePath.length - 3
    );
    if (json.styleName) {
      if (json.styleName.toLowerCase() === fileName.toLowerCase()) {
        json.styleName = `${json.styleName}Style`;
      }
    }

    const LayerCodeGenClass = this.componentCodeGenMap.get(json.type);
    if (json.type === "statusBar") {
      return "";
    }
    if (json.props) {
      if (
        json.props.style.hasOwnProperty("borderWidth") &&
        !json.props.style.hasOwnProperty("borderStyle")
      ) {
        json.props.style = { ...json.props.style, borderStyle: "solid" };
      }

      if (
        json.props.style["position"] === "absolute" &&
        get(extraParams, "parent.type") !== "root" &&
        get(extraParams, "parent.props.style") &&
        !get(extraParams, "parent.props.style.position")
      ) {
        extraParams.parent.props.style.position = "relative";
      }

      if (
        get(json, "props.style.position") !== "absolute" &&
        get(extraParams, "parent.props.style")
      ) {
        extraParams.parent.props.style.display = "flex";
      }
    }

    let opacity = get(json, "props.style.opacity", undefined);
    if (opacity === 1) {
      delete json.props.style.opacity;
    }

    let borderRadius = get(json, "props.style.borderRadius", undefined);
    if (borderRadius === 0) {
      delete json.props.style.borderRadius;
    }

    let transform = get(json, "props.style.transform", undefined);
    if (transform) {
      const rotation = getRotation(transform);
      if (rotation) {
        json.props.style.transform = `rotate(${rotation.toFixed(2)}deg)`;
      } else {
        delete json.props.style.transform;
      }
    }

    // Deleting source_local field for image layer
    // source_local to store local image url
    let sourceLocal = get(json, "props.source_local", undefined);
    if (sourceLocal) {
      delete json.props.source_local;
    }

    if (
      get(json, "template.centerVertical") ||
      get(json, "template.centerHorizontal")
    ) {
      const centerCodeGen = new CenterCodeGen(this.context);
      centerCodeGen.config = this.config;
      return centerCodeGen.generate(json, extraParams);
    }
    if (LayerCodeGenClass) {
      const layerCodeGen = new LayerCodeGenClass(this.context);
      layerCodeGen.config = this.config;
      return layerCodeGen.generate(json, extraParams);
    } else {
      console.error(json.type + " layer not handled");
    }

    return "";
  };
}
