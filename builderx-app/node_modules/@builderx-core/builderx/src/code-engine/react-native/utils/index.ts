import { Context } from "../types";
import { replace, includes, escape, get } from "lodash";

// import BaseCodeGen from "../BaseCodeGen";
// import { layerJSON } from "src/AstModule/src/intialState";

export const addImportToContext = (
  context: Context,
  layerJSON: any,
  generateJSLiteralCode?: any
) => {
  if (layerJSON.import.layerName.includes(".")) {
    return;
  }
  // Write import transformation code after this line

  if (layerJSON.import.packageName === "native") {
    layerJSON.import.packageName = "react-native";
  }

  // For backwards compatibility with older version of Expo
  if (layerJSON.import.layerName === "MapView") {
    layerJSON.import.packageName = "react-native-maps";
    layerJSON.import.isDefaultImport = true;
  }

  if (
    layerJSON.import.packageName === "@builderx/icons" ||
    layerJSON.import.packageName === "VectorIcons"
  ) {
    if (typeof layerJSON.props.type === "string") {
      layerJSON.import.packageName = `react-native-vector-icons/${layerJSON.props.type}`;
    } else {
      let currentFamily = getCurrentFamily(layerJSON, generateJSLiteralCode);
      layerJSON.import.packageName = `react-native-vector-icons/${currentFamily}`;
    }
  }

  if (layerJSON.type === "symbol") {
    if (context.filePath.indexOf("screens") !== -1) {
      layerJSON.import.packageName = `../components/${layerJSON.import.layerName}`;
    } else if (context.filePath.indexOf("preview") !== -1) {
      layerJSON.import.packageName = `./components/${layerJSON.import.layerName}`;
    } else if (
      context.filePath.indexOf("symbols") !== -1 ||
      context.filePath.indexOf("components") !== -1
    ) {
      layerJSON.import.packageName = `./${layerJSON.import.layerName}`;
    }
  }

  if (!context.imports[layerJSON.import.packageName]) {
    context.imports[layerJSON.import.packageName] = {
      named: [],
      default: false
    };
  }

  const contextImportObj = context.imports[layerJSON.import.packageName];
  if (layerJSON.import.isDefaultImport) {
    if (
      layerJSON.import.packageName.indexOf("react-native-vector-icons") !==
        -1 &&
      context.iconCount > 1
    ) {
      let currentFamily = getCurrentFamily(layerJSON, generateJSLiteralCode);
      contextImportObj.default = `${currentFamily}${layerJSON.import.layerName}`;
    } else {
      contextImportObj.default = layerJSON.import.layerName;
    }
  } else if (
    layerJSON.import.layerName === "Image" &&
    layerJSON.import.packageName === "react-native-svg"
  ) {
    context.imports[layerJSON.import.packageName] = {
      named: [
        { name: layerJSON.import.layerName, asName: layerJSON.import.asName }
      ],
      default: false
    };
  } else {
    if (contextImportObj.named.indexOf(layerJSON.import.layerName) === -1) {
      contextImportObj.named.push(layerJSON.import.layerName);
    }
  }
};

export const isTabViewSpecificStyleProp = (propName: string) => {
  return (
    ["tabBarStyle", "indicatorStyle", "labelStyle", "tabStyle"].indexOf(
      propName
    ) !== -1
  );
};

export const escapeTextForJSX = (text: string) => {
  if (typeof text === "string") {
    text = text.trim();
    text = escape(text);
  }
  if (includes(text, "\n")) {
    text = replace(text, new RegExp("\n", "g"), `{\"\\n"}`);
    text = replace(text, new RegExp("\t", "g"), `{\"\\t"}`);
  }
  return text;
};
export const getIconCount = (context: Context, layer: any) => {
  if (!layer) {
    return 0;
  }
  layer.children.forEach((child: any) => {
    if (get(child, "children", 0) && child.children.length !== 0) {
      getIconCount(context, child);
    }
    if (
      get(child, "import.layerName", 0) &&
      child.import.layerName === "Icon"
    ) {
      context.iconCount = context.iconCount + 1;
    }
  });
  return context.iconCount;
};
// export const hasDuplicateLayers = (layer: any) => {
//   let hasDuplicatechildren = false;
//   layer.children.forEach((child: any) => {
//     let currentStyleName = child.styleName;
//     layer.children.forEach((innerChild: any) => {
//       if (child !== innerChild) {
//         if (innerChild.styleName === currentStyleName) {
//         }
//       }
//     });
//   });
// };
export const getCurrentFamily = (
  layerJSON: any,
  generateJSLiteralCode: any
) => {
  let conditionalStatement = generateJSLiteralCode(layerJSON.props.type);
  let currentFamily = "";
  let families = [
    "Entypo",
    "EvilIcons",
    "Feather",
    "FontAwesome",
    "MaterialIcons",
    "MaterialCommunityIcons",
    "SimpleLineIcons",
    "Octicons",
    "Zocial",
    "Ionicons"
  ];
  for (let i = 0; i < families.length; i++) {
    if (conditionalStatement.indexOf(families[i]) !== -1) {
      currentFamily = families[i];
      break;
    }
  }
  return currentFamily;
};
export const isButtonLayer = (layer: any) => {
  if (layer.type === "touchableOpacity" && layer.hasOwnProperty("navigateTo")) {
    return true;
  }
  return false;
};

export function getFilteredImageStyle(style: any) {
  const filteredImageStyle: any = {};

  if (
    (style.borderWidth || style.borderLeftWidth || style.borderRightWidth) &&
    style.width
  ) {
    const borderRightWidth = style.borderRightWidth
      ? style.borderRightWidth
      : style.borderWidth
      ? style.borderWidth
      : 0;
    const borderLeftWidth = style.borderLeftWidth
      ? style.borderLeftWidth
      : style.borderWidth
      ? style.borderWidth
      : 0;
    filteredImageStyle.width =
      style.width - (borderRightWidth + borderLeftWidth);
  }

  if (
    (style.borderWidth || style.borderTopWidth || style.borderBottomWidth) &&
    style.height
  ) {
    const borderTopWidth = style.borderTopWidth
      ? style.borderTopWidth
      : style.borderWidth
      ? style.borderWidth
      : 0;
    const borderBottomWidth = style.borderBottomWidth
      ? style.borderBottomWidth
      : style.borderWidth
      ? style.borderWidth
      : 0;
    filteredImageStyle.height =
      style.height - (borderTopWidth + borderBottomWidth);
  }

  if (
    style.borderRadius ||
    style.borderTopLeftRadius ||
    style.borderTopRightRadius ||
    style.borderBottomRightRadius ||
    style.borderBottomLeftRadius
  ) {
    style.overflow = "hidden";
  }
  if (style.opacity) {
    filteredImageStyle.opacity = style.opacity;
    delete style.opacity;
  }
  return filteredImageStyle;
}
