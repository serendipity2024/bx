import { forEach, get, round } from "lodash";
import { Config, ExtraParams, Context } from "./types";
import {
  MapStyles,
  ROUNDABLE_LAYOUT_PROPERTIES,
  ROUNDABLE_TO_TWO_DECIMALS_LAYOUT_PROPERTIES
} from "bx-constants";
import { isTabViewSpecificStyleProp } from "./utils";
import * as path from "path";

type JSLiteralTypes =
  | "string"
  | "number"
  | "bigint"
  | "boolean"
  | "symbol"
  | "undefined"
  | "object"
  | "function"
  | "array";

export default abstract class LayerCodeGen {
  context: Context;
  config: Config;
  abstract generate(json: any, extraParams: ExtraParams): string;

  generateChildren = (layer: any, extraParams: ExtraParams) => {
    let childrenCode = "";
    layer.children.forEach((child: any) => {
      if (
        [
          "expressionStatement",
          "binaryExpression",
          "expression",
          "conditionalExpression",
          "logicalExpression"
        ].includes(child.type)
      ) {
        childrenCode += `{${this.context.baseCodeGen.generate(
          child,
          extraParams
        )}
      }`;
      } else {
        childrenCode += `${this.context.baseCodeGen.generate(
          child,
          extraParams
        )}
      `;
      }
    });

    return childrenCode;
  };

  generateProps = (json: any, extraParams: ExtraParams) => {
    let propsCode = "";
    if (json.props) {
      if (json.import.layerName === "FlatList") {
        json.props = { ...json.props, data: [{}, {}] };
      }
      forEach(json.props, (propValue: any, propName: string) => {
        if (propName === "onPress") {
          if (typeof propValue === "string") {
            propsCode = `${propName}={${propValue.replace(/;/g, "")}}`;
          } else {
            // TODO: Handle conditional navigation
            propsCode +=
              "/* Conditional navigation not supported at the moment */";
          }
          // TODO: check for all callback props
        } else if (
          get(json, "import.layerName") === "FlatList" &&
          propName === "renderItem"
        ) {
          propsCode += `${propName}={({ item, separators }) => ${this.context.baseCodeGen.generate(
            propValue,
            extraParams
          )}}`;
        } else if (
          get(json, "import.layerName") === "FlatList" &&
          (propName === "ListHeaderComponent" ||
            propName === "ListFooterComponent" ||
            propName === "ItemSeparatorComponent")
        ) {
          propsCode += `${propName}={() => ${this.context.baseCodeGen.generate(
            propValue,
            extraParams
          )}}`;
        } else if (
          get(json, "import.layerName") === "Switch" &&
          (propName === "onTintColor" || propName === "tintColor")
        ) {
          let onOffColorCode = "";

          if (get(json, "props.onTintColor")) {
            onOffColorCode += `true: ${this.generateJSLiteralCode(
              get(json, "props.onTintColor"),
              extraParams
            )},`;
          }
          if (get(json, "props.tintColor")) {
            onOffColorCode += `false: ${this.generateJSLiteralCode(
              get(json, "props.tintColor"),
              extraParams
            )}`;
          }

          delete get(json, "props", {}).onTintColor;
          delete get(json, "props", {}).tintColor;

          if (onOffColorCode) {
            propsCode += `trackColor={{${onOffColorCode}}}`;
          }
        } else if (
          get(json, "import.layerName") === "Switch" &&
          propName === "thumbTintColor"
        ) {
          if (propValue) {
            if (typeof propValue === "string") {
              propsCode += `thumbColor=${this.generateJSLiteralCode(
                propValue,
                extraParams
              )}`;
            } else {
              propsCode += `thumbColor={${this.generateJSLiteralCode(
                propValue,
                extraParams
              )}}`;
            }
          }
        } else if (
          get(json, "import.layerName") === "MapView" &&
          propName === "provider"
        ) {
          propsCode += `${propName}={${this.generateJSLiteralCode(
            propValue,
            extraParams,
            true
          )}}`;
        } else if (propName === "source") {
          propsCode += this.generateSourcePropCode(
            path.basename(propValue.uri)
          );
        } else if (
          get(json, "import.layerName") === "MapView" &&
          propName === "customMapStyle"
        ) {
          propValue = MapStyles[propValue];
          propsCode += `${propName}={${this.generateJSLiteralCode(
            propValue,
            extraParams
          )}}`;
        } else if (
          get(json, "import.layerName") === "Icon" &&
          propName === "type"
        ) {
          // Do nothing and Skip
        } else if (
          !isTabViewSpecificStyleProp(propName) &&
          propName !== "style" &&
          propName !== "contentContainerStyle" &&
          propName !== "imageStyle"
        ) {
          if (typeof propValue === "string") {
            propsCode += `${propName}=${this.generateJSLiteralCode(
              propValue,
              extraParams
            )}`;
          } else {
            const ellipseProps = ["cx", "cy", "rx", "ry"];
            if (ellipseProps.includes(propName)) {
              propValue = round(propValue);
            }
            propsCode += `${propName}={${this.generateJSLiteralCode(
              propValue,
              extraParams
            )}}`;
          }
        }
      });
    }

    return propsCode;
  };

  generateSymbolOverrideProps(scopeVariables: any, extraParams: ExtraParams) {
    let code = "";
    forEach(scopeVariables, (value: any, key: string) => {
      if (typeof value === "string") {
        code += `${key.replace("this.props.", "")}=${this.generateJSLiteralCode(
          value,
          extraParams
        )}`;
      } else {
        code += `${key.replace(
          "this.props.",
          ""
        )}={${this.generateJSLiteralCode(value, extraParams)}}`;
      }
    });
    return code;
  }
  generateStyle = (
    json: any,
    extraParams: ExtraParams,
    stylePropName: string = "style"
  ) => {
    if (get(json, "import.layerName") === "Picker.Item") {
      return "";
    }

    const style = get(json, `props.${stylePropName}`, {});

    // if (stylePropName === "imageStyle" && Object.keys(style).length === 0) {
    //   return "";
    // }
    // if (
    //   json.type === "root" &&
    //   this.context.filePath.indexOf("symbols") !== -1
    // ) {
    //   delete json.props.style.flex;
    // }
    // if (json.type === "text") {
    //   json.props.style.fontFamily
    //     ? json.props.style.fontFamily
    //     : delete json.props.style.fontFamily;
    // }
    const conditionalStyles: { [key: string]: string } = {};
    forEach(style, (styleValue: any, styleProperty: any) => {
      if (
        styleValue &&
        [
          "expressionStatement",
          "binaryExpression",
          "expression",
          "conditionalExpression",
          "logicalExpression"
        ].includes(styleValue.type)
      ) {
        conditionalStyles[styleProperty] = this.context.baseCodeGen.generate(
          styleValue,
          extraParams
        );

        delete this.context.styles[json.styleName][styleProperty];
      }
    });

    if (Object.keys(conditionalStyles).length !== 0) {
      let conditionalStyleObjCode = "";
      forEach(
        conditionalStyles,
        (code, styleProperty) =>
          (conditionalStyleObjCode += `${styleProperty}: ${code},`)
      );
      return `${stylePropName}={[
        styles.${json.styleName}${
        stylePropName !== "style" ? "_" + stylePropName : ""
      },
        {
          ${conditionalStyleObjCode}
        }
      ]}`;
    }
    if (
      json.type === "root" &&
      (this.context.filePath.indexOf("symbols") !== -1 ||
        this.context.filePath.indexOf("components") !== -1)
    ) {
      return `${stylePropName}={[styles.${json.styleName},props.style]${
        stylePropName !== "style" ? "_" + stylePropName : ""
      }}`;
    }
    return `${stylePropName}={styles.${json.styleName}${
      stylePropName !== "style" ? "_" + stylePropName : ""
    }}`;
  };

  generateSourcePropCode(imageName: string, category?: string) {
    const assetsRelativePath = this.config.isPreviewFile
      ? "./assets/images/"
      : "../assets/images/";
    if (category === "svgImage") {
      return `${assetsRelativePath}${imageName}`;
    }
    return `source={require("${assetsRelativePath}${imageName}")}`;
  }

  generateJSLiteralCode = (
    literal: any,
    extraParams: ExtraParams,
    jsExpression: boolean = false
  ) => {
    let code = "";

    let literalType: JSLiteralTypes = typeof literal;

    if (literal === null) {
      literalType = literal; // Handle null literal, otherwise it takes type object
    }
    if (Array.isArray(literal)) {
      literalType = "array";
    }

    switch (literalType) {
      case "object":
        // TODO:if is not handelled
        if (
          [
            "expressionStatement",
            "binaryExpression",
            "expression",
            "conditionalExpression",
            "logicalExpression"
          ].includes(literal.type)
        ) {
          code = this.context.baseCodeGen.generate(literal, extraParams);
        } else {
          code = `${this.generateJSObjectCode(literal, extraParams)}`;
        }
        break;
      case "array":
        code = `${this.generateJSArrayCode(literal, extraParams)}`;
        break;
      case "boolean":
        code = `${literal}`;
        break;
      case "number":
        code = String(literal); // TODO: consider setValueinInt
        break;
      case "string":
      default:
        if (jsExpression) {
          code = `${literal}`;
        } else {
          code = `"${literal}"`;
        }
    }
    return code;
  };

  generateJSObjectCode = (obj: any, extraParams: ExtraParams) => {
    let code = "";
    if (obj.hasOwnProperty("display") && obj["display"] === "none") {
      let { height, width, display, opacity, ...restObj } = obj;
      obj = { ...restObj, height: 0, width: 0, opacity: 0 };
    }
    forEach(obj, (value, key) => {
      if (value !== undefined) {
        if (ROUNDABLE_LAYOUT_PROPERTIES.includes(key)) {
          if (typeof value === "number") {
            value = Math.round(value);
          } else if (typeof value === "string" && value.includes("%")) {
            // For percentage values
            let numValue = parseFloat(value.replace("%", ""));
            numValue = Math.round(numValue * 100) / 100;
            value = numValue + "%";
          }
        } else if (ROUNDABLE_TO_TWO_DECIMALS_LAYOUT_PROPERTIES.includes(key)) {
          if (typeof value === "number") {
            value = Math.round(value * 100) / 100;
          }
        }

        code += `${key}: ${this.generateJSLiteralCode(value, extraParams)},
        `;
      }
    });

    return `{
      ${code}
    }`;
  };

  generateJSArrayCode = (obj: any, extraParams: ExtraParams) => {
    let code = "";
    obj.forEach((value: any) => {
      code += `${this.generateJSLiteralCode(value, extraParams)},
      `;
    });

    return `[
      ${code}
    ]`;
  };
}
