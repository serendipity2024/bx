import { v4 as uuid } from "uuid";
import CodeEngine from "./CodeEngine";

export default class IPC {
  messageIPCQueue: any = {};
  codeEngine: CodeEngine;
  worker: Worker;
  ipcQueue: any;
  id: string;

  constructor(worker: Worker) {
    this.codeEngine = new CodeEngine(this);
    this.worker = worker;
  }

  executeCommand(
    command: string,
    args: Array<any> = [],
    transferables: Array<Transferable> = []
  ) {
    return new Promise((resolve, reject) => {
      if (this.worker.postMessage) {
        const messageId = uuid();
        this.worker.postMessage({
          type: "command",
          messageId,
          command,
          args
        });
        this.messageIPCQueue[messageId] = {
          resolve,
          reject
        };
      }
    });
  }
  async ipcOnMessage(event: any) {
    const message = event.data;
    if (message.type === "command") {
      // console.log(`${message.command} command received on code IPC ***`);
      try {
        if (!this.codeEngine[message.command]) {
          this.executeCommand("captureErrorForSentry", [
            new Error(`${message.command} command not found on CodeEngine`)
          ]);
        }
        const returnData = await this.codeEngine[message.command](
          ...message.args
        );

        this.worker.postMessage({
          type: "ack",
          messageId: message.messageId,
          success: true,
          data: returnData
        });
      } catch (err) {
        console.error("code engine error", err);
        this.worker.postMessage({
          type: "ack",
          messageId: message.messageId,
          success: false,
          error: err,
          functionName: message.command
        });
        if (process.env.NODE_ENV === "production") {
          // TODO: sentry build error
          // Sentry.captureException(err);
        }
      }
    }
    if (message.type === "ack") {
      const messageIPC = this.messageIPCQueue[message.messageId];
      if (!messageIPC) {
        return;
      }
      if (message.success) {
        messageIPC.resolve(message.data);
      } else {
        messageIPC.reject(message.error);
      }
      delete this.messageIPCQueue[message.messageId];
    }
  }
}
