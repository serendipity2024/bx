import colorString from "color-string";
import { Config, FlutterContext } from "./types";
import { forEach } from "lodash";

type JSLiteralTypes =
  | "string"
  | "number"
  | "bigint"
  | "boolean"
  | "symbol"
  | "undefined"
  | "object"
  | "function"
  | "array";

export default class LayerCodeGen {
  context: FlutterContext;

  config: Config;

  fontSize: number = 14;

  getAngleValue = (value: string) => {
    let angle = 180 / parseFloat(value);
    return `${angle.toFixed(2)}`;
  };
  generateContainerElements = (json: any, type: string) => {
    var dynamicJSON;
    if (type === "container") {
      dynamicJSON = json.props.style;
    } else if (type === "scrollable") {
      dynamicJSON = json.props.contentContainerStyle;
    }
    return `
    ${this.generatePropertiesCode(dynamicJSON, ["height", "width"])}
    ${
      dynamicJSON.margin
        ? `
            margin : EdgeInsets.all(${this.generatePropertiesCode(dynamicJSON, [
              "margin"
            ])}),
          `
        : ``
    }

    ${
      dynamicJSON.marginBottom ||
      dynamicJSON.marginTop ||
      dynamicJSON.marginLeft ||
      dynamicJSON.marginRight
        ? `
          margin : EdgeInsets.fromLTRB(
            ${this.getAttributes(dynamicJSON, "margin")}
          ),
        `
        : ``
    }

    ${
      dynamicJSON.padding
        ? `
            padding : EdgeInsets.all(${this.generatePropertiesCode(
              dynamicJSON,
              ["padding"]
            )}),
          `
        : ``
    }
    ${
      dynamicJSON.paddingBottom ||
      dynamicJSON.paddingTop ||
      dynamicJSON.paddingLeft ||
      dynamicJSON.paddingRight
        ? `
          padding : EdgeInsets.fromLTRB(
            ${this.getAttributes(dynamicJSON, "padding")}
          ),
        `
        : ``
    }

    decoration: BoxDecoration(
      ${
        dynamicJSON.borderColor
          ? `
              border: Border.all(
                ${this.generatePropertiesCode(dynamicJSON, [
                  "borderColor",
                  "borderWidth"
                ])}
              ),
              ${this.generatePropertiesCode(dynamicJSON, ["borderRadius"])}
           `
          : ``
      }

      ${
        json.gradient
          ? `gradient : ${this.getGradientCode(
              json.gradient,
              json.gradient.gradientType
            )}`
          : `${this.generatePropertiesCode(dynamicJSON, ["backgroundColor"])}`
      }
      ),

    `;
  };
  getGradientCode(gradientJson: any, gradientType: string) {
    return `${this.generatePropertiesCode(gradientJson, ["gradientType"])} (
      ${
        gradientType === "RadialGradient"
          ? `radius:0.7,`
          : this.generatePropertiesCode(gradientJson, ["from"])
      }

          ${this.generatePropertiesCode(gradientJson, ["stops"])}
        ),`;
  }

  getAttributes(json: any, property: "margin" | "padding") {
    var properties = {
      Left: 0,
      Top: 0,
      Right: 0,
      Bottom: 0
    };
    if (json[property + "Left"]) {
      properties.Left = json[property + "Left"];
    }
    if (json[property + "Top"]) {
      properties.Top = json[property + "Top"];
    }
    if (json[property + "Right"]) {
      properties.Right = json[property + "Right"];
    }
    if (json[property + "Bottom"]) {
      properties.Bottom = json[property + "Bottom"];
    }
    return `${properties.Left}, ${properties.Top}, ${properties.Right}, ${
      properties.Bottom
    }`;
  }

  generateJSArrayCode = (obj: any) => {
    let code = "";
    obj.forEach((value: any) => {
      code += `${this.generateJSLiteralCode(value)},
      `;
    });

    return `[
      ${code}
    ]`;
  };

  generateJSObjectCode = (obj: any) => {
    let code = "";
    forEach(obj, (value, key) => {
      code += `${key}: ${this.generateJSLiteralCode(value)},
      `;
    });

    return `{
      ${code}
    }`;
  };

  generateJSLiteralCode = (literal: any, jsExpression: boolean = false) => {
    let code = "";

    let literalType: JSLiteralTypes = typeof literal;

    if (Array.isArray(literal)) {
      literalType = "array";
    }

    switch (literalType) {
      case "string":
        if (jsExpression) {
          code = `${literal}`;
        } else {
          code = `"${literal}"`;
        }
        break;
      case "object":
        // TODO:if is not handelled
        if (literal.type === "expressionStatement") {
          code = this.context.baseCodeGen.generate(literal);
        } else {
          code = `${this.generateJSObjectCode(literal)}`;
        }
        break;
      case "array":
        code = `${this.generateJSArrayCode(literal)}`;
        break;
      case "boolean":
        code = `${literal}`;
        break;
      case "number":
      default:
        code = String(Math.round(literal * 100) / 100); // TODO: consider setValueinInt
    }

    return code;
  };
  getImageName(value: string) {
    var imageName = value.split("/");
    return imageName[imageName.length - 1];
  }
  generateColorRGBO(color: string) {
    if (typeof color !== "string") {
      // TODO: Handle conditional color value
      return "Color.fromRGBO(0, 0, 0, 1)";
    }
    let values = colorString.get.rgb(color);
    if (values) {
      return `Color.fromRGBO(${values[0]}, ${values[1]}, ${values[2]}, ${
        values[3]
      })`;
    }
    return `Color.fromRGBO(0, 0, 0, 1)`;
  }

  generateFontFamily(value: string) {
    let fontFamily = "";
    fontFamily = value.replace(/-/g, " ");
    return fontFamily;
  }
  generateFontWeight(value: string) {
    let fontWeight = "";
    if (value === "normal" || value === "bold") {
      fontWeight = value;
    } else {
      fontWeight = "w" + value;
    }

    return "FontWeight." + fontWeight;
  }

  generateStops(value: Array<any>) {
    let stops = "stops : [ ";
    let colors = "colors : [ ";
    for (var i = 0; i < value.length; i++) {
      let rgbColor = this.generateColorRGBO(value[i].stopColor);
      colors += rgbColor + ", \n";
      stops += value[i].offset + ", \n";
    }
    colors += " ],";
    stops += " ],";

    return colors + stops;
  }
  generatePropertiesCode(data: {}, properties: string[]) {
    // TODO: Handle conditional properties
    let code = "";
    properties.forEach((property: string) => {
      if (data[property]) {
        let value = data[property];
        if (typeof value === "number") {
          value = Math.round(data[property]);
          // code += `${property} : ${Math.round(value * 100) / 100},`;
        }
        switch (property) {
          case "alignSelf":
            switch (value) {
              case "flex-start":
                code += `alignment: Alignment.topLeft,`;
                break;
              case "center":
                code += `alignment: Alignment.center,`;
                break;
              case "flex-end":
                code += `alignment: Alignment.bottomRight,`;
                break;
              default:
                code += "";
                break;
            }
            break;
          case "placeholder":
            code += `hintText: "${value}", \n`;
            break;
          case "placeholderTextColor":
            code += `hintStyle : TextStyle(
              color: ${this.generateColorRGBO(value)}, \n
            ),`;
            break;
          case "maxLength":
            code += `maxLength: ${value}, \n`;
            break;
          case "props":
            let bgcolor = value.style.backgroundColor;
            code += `filled:true, \n
                      fillColor: ${this.generateColorRGBO(bgcolor)}, \n
            `;
            break;
          case "horizontal":
            if (value === true) {
              code += `scrollDirection : Axis.horizontal, \n`;
            } else if (value === false) {
              code += `scrollDirection : Axis.vertical, \n`;
            }
            break;

          case "margin":
            code += `${value}`;
            break;
          case "marginLeft":
            code += `${value}`;
            break;
          case "marginRight":
            code += `${value}`;
            break;
          case "marginTop":
            code += `${value}`;
            break;
          case "marginBottom":
            code += `${value}`;
            break;
          case "padding":
            code += `${value}`;
            break;
          case "paddingLeft":
            code += `${value}`;
            break;
          case "paddingRight":
            code += `${value}`;
            break;
          case "paddingTop":
            code += `${value}`;
            break;
          case "paddingBottom":
            code += `${value}`;
            break;
          case "textAlign":
            code += `textAlign : TextAlign.${value}, \n`;
            break;
          case "borderRadius":
            code += `borderRadius : BorderRadius.circular(${value}), \n`;
            break;
          case "borderWidth":
            code += `width : ${value}, \n`;
            break;
          case "borderColor":
            code += `color : ${this.generateColorRGBO(value)}, \n`;
            break;
          case "onPress":
            code += `onTap:(){${value}},`;
            break;
          case "height":
            code += `height: ${value}, \n `;
            break;
          case "width":
            code += `width: ${value}, \n `;
            break;
          case "top":
            code += `top: ${value}, \n `;
            break;
          case "left":
            code += `left: ${value}, \n `;
            break;
          case "right":
            code += `right: ${value}, \n `;
            break;
          case "bottom":
            code += `bottom: ${value}, \n `;
            break;
          case "color":
            code += `color: ${this.generateColorRGBO(value)}, \n `;
            break;
          case "backgroundColor":
            code += `color: ${this.generateColorRGBO(value)}, \n `;
            break;
          case "fontSize":
            code += `fontSize: ${value}, \n `;
            this.fontSize = value;
            break;
          case "fontFamily":
            code += `fontFamily: "${this.generateFontFamily(value)}", \n `;
            break;
          case "fontStyle":
            code += `fontStyle: FontStyle.${value}, \n `;
            break;
          case "fontWeight":
            code += `fontWeight: ${this.generateFontWeight(value)}, \n `;
            break;
          case "textAlign":
            code += `textAlign : TextAlign.${value}, \n`;
            break;
          case "letterSpacing":
            code += `letterSpacing : ${value}, \n`;
            break;
          case "lineHeight":
            let height = value / this.fontSize;
            code += `height : ${height.toFixed(2)}, \n`;
            break;
          case "type":
            code += `${value}.getIconData(`;
            break;
          case "name":
            code += `"${value}"), \n`;
            break;
          case "style":
            code += `size : ${value.fontSize}, \n`;
            break;
          case "uri":
            code += `"assets/images/${this.getImageName(value)}"`;
            break;
          case "gradientType":
            code += `${value} \n`;
            break;
          case "stops":
            code += `${this.generateStops(value)}`;
            break;
          case "from":
            if (value.x === 0 && value.y === 1) {
              code += `begin : Alignment.bottomCenter, end : Alignment.topCenter, \n`;
            } else if (value.x === 1 && value.y === 0) {
              code += `begin : Alignment.centerLeft, end : Alignment.centerRight, \n`;
            } else if (value.x === 2 && value.y === 1) {
              code += `begin : Alignment.topCenter, end : Alignment.bottomCenter, \n`;
            } else if (value.x === 1 && value.y === 2) {
              code += `begin : Alignment.centerRight, end : Alignment.centerLeft, \n`;
            }
            break;

          case "layerName":
            code += value;
            break;

          default:
            break;
        }
      }
    });
    return code;
  }

  generateFlexAlignment = (data: any) => {
    function getFlexValue(value: any) {
      switch (value) {
        case "flex-start":
          return "start";
        case "center":
          return "center";
        case "flex-end":
          return "end";
        case "stretch":
          return "stretch";
        case "baseline":
          return "baseline";
        case "space-evenly":
          return "spaceEvenly";
        case "space-around":
          return "spaceAround";
        case "space-between":
          return "spaceBetween";
        default:
          return "start";
      }
    }

    return `crossAxisAlignment: CrossAxisAlignment.${getFlexValue(
      data.alignItems
    )},
            mainAxisAlignment: MainAxisAlignment.${getFlexValue(
              data.justifyContent
            )},`;
  };
}
