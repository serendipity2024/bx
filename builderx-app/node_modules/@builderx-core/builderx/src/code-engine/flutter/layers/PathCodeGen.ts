import { FlutterContext } from "../types";
import LayerCodeGen from "../LayerCodeGen";
import { wrapIt, rotateWrap } from "../utils/index";
import { capitalize } from "lodash";

export default class PathCodeGen extends LayerCodeGen {
  context: FlutterContext;
  constructor(context: FlutterContext) {
    super();
    this.context = context;
  }

  generatePath = (points: any, pathObj: string) => {
    let path = `${pathObj}.moveTo(${points[0].point.x},${points[0].point.y});`;
    for (let i = 1; i < points.length; i++) {
      if (!points[i - 1].hascurveFrom && !points[i].hasCurveTo) {
        path += `${pathObj}.lineTo(${points[i].point.x},${points[i].point.y});`;
        //   } else if (points[i - 1].hasCurveTo && !points[i].hasCurveFrom) {
        //     path += `${pathObj}.quadraticBeizer( ${points[i - 1].curveTo.x},${
        //       points[i - 1].curveTo.y
        //     } ,${points[i].point.x},${points[i].point.y});`;
        //   } else if (!points[i - 1].hasCurveTo && points[i].hasCurveFrom) {
        //     path += `${pathObj}.quadraticBeizer( ${points[i].curveFrom.x},${
        //       points[i].curveFrom.y
        //     } ,${points[i].point.x},${points[i].point.y});`;
      } else {
        var curveArgs = {
          from: points[i - 1].hasCurveFrom
            ? points[i - 1].curveFrom
            : points[i - 1].point,
          to: points[i].hasCurveTo ? points[i].curveTo : points[i].point,
          final: points[i].point
        };
        path += `${pathObj}.cubicTo( ${curveArgs.from.x},${curveArgs.from.y} ,${
          curveArgs.to.x
        }, ${curveArgs.to.y}  ,${curveArgs.final.x},${curveArgs.final.y});`;
      }
    }
    return path;
  };

  generate(json: any): string {
    const fillColor = json.props.fill
      ? this.generateColorRGBO(json.props.fill)
      : `Color.fromRGBO(0, 0, 0, 1)`;
    const strokeColor = json.props.stroke
      ? this.generateColorRGBO(json.props.stroke)
      : `Color.fromRGBO(0, 0, 0, 1)`;

    let CustomPainter = `class Custom${capitalize(
      json.styleName
    )} extends CustomPainter {
        @override
        void paint(Canvas canvas, Size size) {

    Paint paint = new Paint()
      ..color =  ${fillColor}
      ..style = PaintingStyle.fill;
    Paint paint1 = new Paint()
      ..color = ${strokeColor}
      ..style = PaintingStyle.stroke
      ..strokeWidth = ${json.props.strokeWidth};

    Path path = new Path();
    ${this.generatePath(json.props.points, "path")}
    ${json.props.isClosed ? `path.close();` : ""}
    canvas.drawPath(path, paint);
    canvas.drawPath(path, paint1);

    }
    @override
  bool shouldRepaint(CustomPainter oldDelegate) {
    // TODO: implement shouldRepaint
    return null;
  }
}`;

    this.context.customPaintClasses.push(CustomPainter);

    let currentLayer = `CustomPaint(
            painter:  Custom${capitalize(json.styleName)}(),
          )`;

    if (json.props.style.transform) {
      if (!this.context.imports.includes("import 'dart:math';")) {
        this.context.imports.push("import 'dart:math';");
      }
      currentLayer = rotateWrap(json, currentLayer, this);
    }
    return wrapIt(json, currentLayer, this);
  }
}
