import * as Sentry from "@sentry/browser";
const packageJSON = require("../../../package.json");
const appENV = process.env.NODE_ENV;
// import { ApiSdk } from "@builderx-core/api-sdk";
import jsCookie from "js-cookie";
import { ApiSdk } from "@builderx-core/api-sdk";

import * as React from "react";
import { Session, Views } from "session";
import { DragDropService } from "./models/DragDropService";
import FileService from "file-service";
import registerContextMenu from "./services/registerContextMenu";
import ClipboardService from "./models/ClipboardService";
import ConfigurationService from "./models/ConfigurationService";
import GoogleAnalyticsService from "./models/GoogleAnalyticsService";
import UserService from "./models/UserService";
import { getAdditionalFonts } from "../assets/Fonts/AdditionalFontList";
import FontService from "./models/FontService";
import { remove, toLower, forEach } from "lodash";
import { Utils } from "utils";
import { Tooltip, Spinner, WrapperDiv } from "components-x";
import { SystemFont, ISessionPlugin } from "common-interfaces";
import {
  SessionCanvasGlue,
  JsonPatchToEventsGlue,
  SessionContextMenu,
  AuthPlugin,
  ExternalComponentsProvider,
  ExternalDesignerPluginsProvider,
  OnlineUsers,
  UserMousePointerEmitter,
  PluginPlayButton,
  WindowProvider,
  MenuProvider,
  KeyMapperProvider,
  TestPlugin
} from "session-plugins";
import { SessionEvent } from "event-manager";
import { DialogX } from "dialog-x";
const FONT_WEIGHT_MAP = Utils.getFontWeightMap();

type PropType = {
  apiSdk: ApiSdk;
  plugins?: Array<ISessionPlugin>;
  env: any;
  onPatch: (object: any, patch: any, session: Session) => any;
  onReady: (session: Session) => void;
  onCanvasMouseMove: (session: Session, event: SessionEvent) => void;
  onLayerDrag?: (session: Session, event: SessionEvent) => void;
  onLayerDragStart?: (session: Session, event: SessionEvent) => void;
  onLayerDragEnd?: (session: Session, event: SessionEvent) => void;
  // getSession: (session: Session) => void;
};

export default class BuilderXComponent extends React.Component<PropType, any> {
  session: Session;
  sharedComponentSession: Session;
  config: any;
  state = {
    ready: false
  };
  constructor(props: any) {
    super(props);
    // this.init();

    const port = 3000;
    const isDev = process.env.NODE_ENV === "development";
    this.config = {
      serverUrl: `http://localhost:${port}/`,
      bxApiUrl:
        process.env.NODE_ENV === "development"
          ? "http://pre-cloud.builderx.io/api"
          : process.env.NODE_ENV === "local"
          ? "http://pre-cloud.builderx.io/api"
          : "http://pre-cloud.builderx.io/api",
      env: isDev ? "development" : "production",
      runningContext: "web-app",
      isSharedComponentInstance: false
      // To determine in session whether it runs independently as demo or inside web-app
    };
    this.session = new Session(this.config, this.props.apiSdk, this.props.env);
  }

  componentDidMount() {
    this.init();
    this.session.eventManager.addEventListener(
      "onCanvasMouseMove",
      (e: SessionEvent) => {
        this.props.onCanvasMouseMove(this.session, e);
      }
    );
    // this.session.eventManager.addEventListener(
    //   "onLayerDrag",
    //   (e: SessionEvent) => {
    //     if (this.props.onLayerDrag) this.props.onLayerDrag(this.session, e);
    //   }
    // );

    this.session.eventManager.addEventListener(
      "onLayerDragStart",
      (e: SessionEvent) => {
        if (this.props.onLayerDragStart)
          this.props.onLayerDragStart(this.session, e);
      }
    );

    this.session.eventManager.addEventListener(
      "onLayerDragEnd",
      (e: SessionEvent) => {
        if (this.props.onLayerDragEnd)
          this.props.onLayerDragEnd(this.session, e);
      }
    );
  }

  addLocalFonts = async (fontService: FontService) => {
    if (
      this.session.platform === "Mac" ||
      this.session.platform === "Windows"
    ) {
      const fontPort: any = await fontService.getFontPort(
        this.props.env.APP_PORT_START,
        this.props.env.APP_PORT_END
      );
      if (fontPort.oldVersion) {
        this.session.setOldFontsTrayVersion(true);
      } else {
        this.session.setFontUrl(parseInt(fontPort, 10));
        let localFonts = await fontService.fetchLocalFonts();

        localFonts.forEach((localFont: SystemFont) => {
          remove(this.session.systemFonts, font => {
            return font.family === localFont.family;
          });
        });

        this.session.systemFonts = this.session.systemFonts.concat(localFonts);
      }
    }
  };

  addGoogleFonts = async (fontService: FontService) => {
    let fonts = await fontService.fetchFonts();
    this.session.systemFonts = this.session.systemFonts.concat(fonts);
  };

  init = async () => {
    // this.props.getSession(this.session);
    this.session.emitPatchCallback = this.props.onPatch;
    const clipboardService = new ClipboardService(this.session);
    const fileService = new FileService(
      this.session.before,
      this.session.after
    );
    this.session.drivers.fileService = fileService;
    this.session.drivers.userService = new UserService(this.session);

    // if (await this.session.drivers.userService.isUserLoggedIn()) {
    //   let hasTeam = false;
    //   try {
    //     hasTeam = await this.session.drivers.userService.getTeamData();
    //   } catch (err) {
    //     console.log("No team data");
    //   }
    //   if (!hasTeam) {
    //     window.location.replace(urljoin(this.props.env.WEBSITE_URL, "team"));
    //     return;
    //   }
    // }
    const configuration = new ConfigurationService(this.session);

    await configuration.fetchUserConfig();

    if (
      !configuration.get("version") &&
      configuration.get("editor.snap.snapMagnet") === 10
    ) {
      configuration.set("editor.snap.snapMagnet", 5);
    }
    configuration.set("version", "2.0");

    this.session.drivers.clipboardService = clipboardService;
    this.session.drivers.configuration = configuration;
    this.session.drivers.Sentry = Sentry;
    this.session.drivers.contextMenu = registerContextMenu(this.session);

    new DragDropService(this.session);
    const fontService = new FontService(
      this.props.apiSdk,
      this.props.env.BUILDERX_FONT_API_KEY
    );
    this.session.setPlatform();

    this.session.systemFonts = getAdditionalFonts(
      this.props.env.BUILDERX_ASSETS_URL
    );

    try {
      await this.addGoogleFonts(fontService);
      await this.addLocalFonts(fontService);
    } catch (err) {
      console.log("Error fetching local fonts", err);
    }

    this.session.systemFonts = this.session.systemFonts.filter(
      (localFont: SystemFont) => {
        if (!FONT_WEIGHT_MAP.get(toLower(localFont.style))) {
          return false;
        }
        return true;
      }
    );

    const analyticsService = new GoogleAnalyticsService(this.session);
    this.session.drivers.analyticsService = analyticsService;

    await this.session.installPlugin(new AuthPlugin(this.props.env));
    await this.session.installPlugin(new SessionCanvasGlue());
    await this.session.installPlugin(new SessionContextMenu());
    await this.session.installPlugin(new JsonPatchToEventsGlue());
    await this.session.installPlugin(new ExternalComponentsProvider());
    await this.session.installPlugin(new ExternalDesignerPluginsProvider());
    await this.session.installPlugin(new UserMousePointerEmitter());
    await this.session.installPlugin(new OnlineUsers());
    await this.session.installPlugin(new PluginPlayButton());
    await this.session.installPlugin(new WindowProvider());
    await this.session.installPlugin(new KeyMapperProvider());
    await this.session.installPlugin(new MenuProvider());
    // await this.session.installPlugin(new TestPlugin());

    this.session.createStages(this.config.isSharedComponentInstance);

    // install plugins

    if (this.props.plugins) {
      forEach(this.props.plugins, pluginObj => {
        this.session.installPlugin(pluginObj);
      });
    }
    //

    if (process.env.NODE_ENV !== "production") {
      window["session"] = this.session;
    }

    // shared component session
    const sharedComponentConfig = {
      ...this.config,
      isSharedComponentInstance: true
    };
    const sharedComponentSession = new Session(
      sharedComponentConfig,
      this.props.apiSdk,
      this.props.env
    );
    sharedComponentSession.emitPatchCallback = this.props.onPatch;
    this.sharedComponentSession = sharedComponentSession;
    const canvasGlue = new SessionCanvasGlue();
    await this.sharedComponentSession.installPlugin(canvasGlue);
    await this.sharedComponentSession.installPlugin(
      new JsonPatchToEventsGlue()
    );
    await this.sharedComponentSession.installPlugin(new SessionContextMenu());
    this.sharedComponentSession.createStages(
      sharedComponentConfig.isSharedComponentInstance
    );
    if (process.env.NODE_ENV !== "production") {
      window["sharedComponentSession"] = this.sharedComponentSession;
      window["canvasGlue"] = canvasGlue;
    }
    this.setState({ ready: true }, () => {
      this.props.onReady(this.session);
      // this.props.onReady(this.sharedComponentSession);
    });
    // this.props.onReady();
  };

  render() {
    // if (this.state.ready) {
    return (
      <div>
        {this.state.ready ? (
          <div>
            <Views
              session={this.session}
              sharedComponentSession={this.sharedComponentSession}
            />
            <Tooltip />
          </div>
        ) : (
          <WrapperDiv
            uiBackground={900}
            style={{
              position: "absolute",
              top: 0,
              bottom: 0,
              left: 0,
              right: 0,
              margin: "auto",
              textAlign: "center",
              justifyContent: "center",
              alignItems: "center",
              display: "flex"
            }}
          >
            <Spinner uiSize={"l"} color="white" />
          </WrapperDiv>
        )}
        <DialogX session={this.session} />
      </div>
    );
  }
  //   }
  //   return (

  //   );
  // }
}
