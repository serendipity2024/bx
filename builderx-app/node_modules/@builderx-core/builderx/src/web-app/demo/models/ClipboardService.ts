import { IClipboardService, ClipboardType } from "common-interfaces";
import { get, forEach } from "lodash";
import { Session, Commands } from "session";
import { ACCEPTED_IMAGE_FORMATS } from "bx-constants";
import { Utils } from "utils";

let windowNavigator: any = window.navigator;
export default class ClipboardService implements IClipboardService {
  type: ClipboardType;
  data: any;
  private session: Session;

  constructor(session: Session) {
    this.session = session;
    this.registerPasteEvent();
  }

  set = (data: any, type: ClipboardType) => {
    if (type === "layer") {
      this.type = type;
      this.data = data;
      // DOC: Clearing the clipboard
      this.nativeCopy("");
    }
  };

  get = (): { data: any; type: ClipboardType } => {
    if (
      this.type === "layer" ||
      this.type === "text" ||
      this.type === "image"
    ) {
      return {
        type: this.type,
        data: this.data
      };
    } else {
      return {
        type: "invalid",
        data: null
      };
    }
  };
  nativeCopy(content: string) {
    if (windowNavigator && windowNavigator.clipboard) {
      windowNavigator.clipboard.writeText(content).then(
        () => {
          // console.log("copied to clipboard succefully!");
        },
        () => {
          console.error("Unable to write to clipboard");
        }
      );
    } else {
      console.error("Unable to write to clipboard");
    }
  }

  nativeCut() {
    // currentWindow.webContents.cut();
  }

  nativePaste() {
    //
  }
  registerPasteEvent() {
    window.document.addEventListener("paste", async (e: ClipboardEvent) => {
      if (e.clipboardData && e.clipboardData.items.length > 0) {
        let finalClipboardItems: any = [];

        await Utils.asyncForEach(
          e.clipboardData.items as any,
          async (item: any, index: number) => {
            //
            const type = item.type;
            if (type === "text/plain") {
              item.getAsString((content: any) => {
                if (content !== "") {
                  this.session.commandManager.execute(
                    new Commands.Paste(this.session, {
                      type: "text",
                      data: content
                    })
                  );
                }
              });
            } else if (ACCEPTED_IMAGE_FORMATS.indexOf(type) !== -1) {
              let blob: File | null = item.getAsFile();

              if (blob) {
                const data = await this.session.checkImageType(blob);

                if (data) {
                  this.session.commandManager.execute(
                    new Commands.Paste(this.session, {
                      type: "image",
                      data: blob
                    })
                  );
                }
              }
            }
          }
        );
      } else if (
        e.clipboardData &&
        e.clipboardData.items.length === 0 &&
        this.data
      ) {
        this.session.commandManager.execute(new Commands.Paste(this.session));
      }
    });
  }
}
