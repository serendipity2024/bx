import { Session } from "session";
import { IUserService } from "common-interfaces";
import { Model } from "model";
import { get } from "lodash";

export default class User extends Model implements IUserService {
  isUserRegistered: boolean;
  isUserLicenceValid: boolean;
  expiryDate?: string;
  uuid?: string;
  expiresIn?: string;
  isExpired: boolean;
  email?: string;
  role?: string;
  userName?: string;
  user: any;
  newTAndCAccepted?: boolean;
  updateDownloaded: boolean;
  // tslint:disable-next-line
  last_sync?: string;
  sketchConversionCount?: number;
  session: Session;
  id: string;
  currentTeamId: string;
  currentTeamName: string | undefined;
  constructor(session: Session) {
    super();
    this.session = session;
  }
  async getTeamData() {
    return new Promise(async (resolve, reject) => {
      try {
        const response = await this.session.apiSdk.auth();
        if (!response) {
          throw new Error("Not Authenticated");
        }
        this.id = response.data.id.toString();
        this.currentTeamId = response.data.user.current_team_id.toString();
        this.session.setUserData(response.data.user);
        this.currentTeamName = response.data.user.currentTeam
          ? response.data.user.currentTeam.name
          : undefined;
        let hasTeam = get(response, "data.user.teams.length", 0);
        resolve(hasTeam);
      } catch (error) {
        console.log("in error of initial and error is ", error);
        reject(error);
      }
    });
  }
  async isUserLoggedIn() {
    try {
      const response = await this.session.apiSdk.auth();
      if (!response) {
        throw new Error("Not Authenticated");
      }
      this.id = response.data.id.toString();
      this.currentTeamId = response.data.user.current_team_id.toString();
      this.currentTeamName = response.data.user.currentTeam
        ? response.data.user.currentTeam.name
        : undefined;
      if (this.id) {
        return true;
      } else {
        return false;
      }
    } catch (error) {
      console.log("error");
      return false;
    }
    return false;
  }
  getUserData() {
    //
  }
  setInitialData() {
    //
  }

  get(key: string) {
    //
  }
  set(key: string, value: any) {
    //
  }
  setIsUserRegistered(isUserRegistered: boolean) {
    //
  }
  setIsUserLicenceValid(isUserLicenceValid: boolean) {
    //
  }
  setIsExpired(isExpired: boolean) {
    //
  }
  setExpiryDate(expiryDate: string) {
    // this.expiryDate = expiryDate;
    // this.set("expiryDate", expiryDate);
  }
  setNewTAndCAccepted(accepted: boolean) {
    // this.newTAndCAccepted = accepted;
    // this.set("newTAndCAccepted", accepted);
  }
  setExpiresIn(expiresIn?: string) {
    // this.expiresIn = expiresIn;
    // this.set("expiresIn", expiresIn);
  }
  setUuid(uuid: string) {
    // this.uuid = uuid;
    // this.set("uuid", uuid);
  }
  setSketchConversionCount(count: number) {
    // this.sketchConversionCount = count;
    // this.set("sketchConversionCount", count);
  }
  setLastSync(date: string) {
    // this.last_sync = date;
    // this.set("last_sync", date);
  }
  setEmail(email: string) {
    // this.email = email;
    // this.set("email", email);
  }
  setUserName(name: string) {
    // this.userName = name;
    // this.set("userName", name);
  }
  setUserRole(role: string) {
    // this.role = role;
    // this.set("role", role);
  }
  isRegistered(): boolean {
    return false;
  }
  isNewTermsAndConditionsAccepted(): boolean {
    // if (!this.newTAndCAccepted) {
    //   return false;
    // }
    // return this.newTAndCAccepted;
    return false;
  }
  getUpdateDownloaded() {
    // return this.updateDownloaded;
    return false;
  }
  setUpdateDownloaded(updated: boolean) {
    // this.updateDownloaded = updated;
    // this.set("updateDownloaded", updated);
  }

  verifyExpiry(resolve: any) {
    // this.updateExpiry(resolve);
    // setInterval(() => {
    //   this.updateExpiry(resolve);
    // }, 4 * 60 * 60 * 1000);
  }

  updateExpiry(resolve: any) {
    //
  }

  update(userAppVersion: string, currentVersion: string) {
    //
  }
  registerAndVerifyLicense(key: string | null, email?: string): any {
    //
  }
}
