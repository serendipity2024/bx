import * as React from "react";
import * as Sentry from "@sentry/browser";
const packageJSON = require("../../../package.json");
const appENV = process.env.NODE_ENV;
// import { apiSdk } from "@builderx-core/api-sdk";
import axios from "axios";
import { apiSdk } from "@builderx-core/api-sdk";
import { ReactCodeGen } from "@builderx-core/react-plugin";
import { ReactNativeCodeGen } from "@builderx-core/react-native-plugin";
import jsCookie from "js-cookie";
import { v4 as uuid } from "uuid";
import socketIOClient from "socket.io-client";
import BuilderXComponent from "./BuilderXComponent";
import {
  Session,
  bxConstants,
  applyPatchInBuilderX,
  designerAction,
  action,
  addPostCommandActionCallback,
  Alert,
  Commands,
  Utils
} from "../..";
import { diff } from "deep-diff";
import { find, findIndex, reverse } from "lodash";
import { SessionEvent } from "event-manager";
import { DomainLayer } from "domain-x";
import urljoin from "url-join";

class App extends React.Component {
  socket: SocketIOClient.Socket;
  tempPatches: Array<any> = [];
  patchPacketBatch: Array<any> = [];
  reconnecting: boolean = false;
  // session: Session;
  envConstants: any;
  reactCodeGen: ReactCodeGen;
  reactNativeCodeGen: ReactNativeCodeGen;
  constructor(props: any) {
    super(props);

    this.reactCodeGen = new ReactCodeGen();
    this.reactNativeCodeGen = new ReactNativeCodeGen();

    this.envConstants = {
      WEBSITE_URL:
        typeof window !== "undefined" && window["bxEnv"]
          ? window["bxEnv"].BUILDERX_WEBSITE_URL
          : String(process.env.REACT_APP_WEBSITE_URL),
      SUPPORT_URL:
        typeof window !== "undefined" && window["bxEnv"]
          ? window["bxEnv"].BUILDERX_SUPPORT_URL
          : String(process.env.REACT_APP_SUPPORT_URL),

      APP_PORT_START:
        typeof window !== "undefined" && window["bxEnv"]
          ? Number(window["bxEnv"].BUILDERX_APP_PORT_START)
          : Number(process.env.REACT_APP_APP_PORT_START),
      APP_PORT_END:
        typeof window !== "undefined" && window["bxEnv"]
          ? Number(window["bxEnv"].BUILDERX_APP_PORT_END)
          : Number(process.env.REACT_APP_APP_PORT_END),
      APP_URL:
        typeof window !== "undefined" && window["bxEnv"]
          ? window["bxEnv"].BUILDERX_APP_URL
          : String(process.env.REACT_APP_URL),

      APP_STATIC_URL:
        typeof window !== "undefined" && window["bxEnv"]
          ? window["bxEnv"].BUILDERX_APP_STATIC_URL
          : String(process.env.REACT_APP_STATIC_URL),

      APP_ENVIRONMENT:
        typeof window !== "undefined" && window["bxEnv"]
          ? window["bxEnv"].BUILDERX_APP_ENVIRONMENT
          : String(process.env.REACT_APP_ENVIRONMENT),
      BUILDERX_FONT_API_KEY:
        typeof window !== "undefined" && window["bxEnv"]
          ? window["bxEnv"].BUILDERX_FONT_API_KEY
          : String(process.env.REACT_APP_BUILDERX_FONT_API_KEY),
      BUILDERX_API: String(process.env.REACT_APP_BUILDERX_API),
      BUILDERX_DOWNLOAD_URL: String(
        process.env.REACT_APP_BUILDERX_DOWNLOAD_URL
      ),
      GA_TRACKING_ID:
        typeof window !== "undefined" && window["bxEnv"]
          ? window["bxEnv"].BUILDERX_GA_TRACKING_ID
          : String(process.env.REACT_APP_GA_TRACKING_ID),
      SENTRY_URL:
        typeof window !== "undefined" && window["bxEnv"]
          ? window["bxEnv"].BUILDERX_APP_SENTRY_DSN
          : String(process.env.REACT_APP_SENTRY_URL),
      BUILDERX_URL: String(process.env.REACT_APP_BUILDERX_URL),
      BUILDERX_ASSETS_URL:
        typeof window !== "undefined" && window["bxEnv"]
          ? window["bxEnv"].BUILDERX_ASSETS_URL
          : String(process.env.REACT_APP_ASSETS_URL),
      BACKEND_API_URL:
        typeof window !== "undefined" && window["bxEnv"]
          ? window["bxEnv"].BUILDERX_API_URL
          : process.env.NODE_ENV === "production"
          ? String(process.env.REACT_APP_BACKEND_API_URL || "")
          : String(process.env.REACT_APP_LOCAL_BACKEND_API_URL || "")
    };
    apiSdk.init({
      env: "local",
      baseUrl: this.envConstants.BACKEND_API_URL,
      accessToken: jsCookie.get("builderx-auth-token"),
      googleFontsUrl: "https://www.googleapis.com/webfonts/v1/webfonts?key="
    });
    if (appENV !== "development") {
      Sentry.init({
        dsn: this.envConstants.SENTRY_URL,
        environment: appENV,
        release: packageJSON.version
      });
    }
  }

  // componentDidMount() {}

  emitSelectLayerEvent = (session: Session, selectedLayers: any) => {
    let selectedLayerIds = selectedLayers.map((layer: DomainLayer) => {
      return layer.getFullPath();
    });
    if (selectedLayers[0] !== session.currentRootLayer) {
      if (this.socket && session.isPluginLoaded("OnlineUsers")) {
        this.socket.emit("onlineUsers.setSelectedLayers", {
          userId: session.userId,
          connectionId: session.connectionId,
          currentStageId: session.currentStage.id,
          selectedLayers: selectedLayerIds
        });
      }
    }
  };
  render() {
    return (
      <BuilderXComponent
        apiSdk={apiSdk}
        env={this.envConstants}
        plugins={[this.reactNativeCodeGen, this.reactCodeGen]}
        // getSession={session => (this.session = session)}

        onCanvasMouseMove={(session: Session, e: SessionEvent) => {
          if (this.socket) {
            this.socket.emit("onlineUsers.setCursor", {
              userId: session.userId,
              connectionId: session.connectionId,
              position: e.payload.position,
              currentStageId: session.currentStage.id
            });
          }
        }}
        onLayerDragStart={(session: Session, e: SessionEvent) => {
          if (this.socket) {
            this.emitSelectLayerEvent(session, e.payload.domainLayers);

            this.socket.emit("onlineUsers.lockChildren", {
              userId: session.userId,
              connectionId: session.connectionId,
              currentStageId: session.currentStage.id,
              lockChildrenParentLayerId: e.payload.domainLayers[0].parent
                ? e.payload.domainLayers[0].parent.getFullPath()
                : ""
            });
          }
        }}
        onLayerDragEnd={(session: Session, e: SessionEvent) => {
          if (this.socket) {
            //   this.emitSelectLayerEvent(session, e.payload.domainLayers);
            this.socket.emit("onlineUsers.lockChildren", {
              userId: session.userId,
              connectionId: session.connectionId,
              currentStageId: session.currentStage.id,
              lockChildrenParentLayerId: ""
            });
          }
        }}
        onReady={async (session: Session) => {
          const socketServerUrl =
            process.env.NODE_ENV !== "production"
              ? "http://local-socket.builderx.io"
              : this.envConstants.WEBSITE_URL;
          this.socket = socketIOClient(socketServerUrl, {
            timeout: 100000,
            query: {
              token: jsCookie.get("builderx-auth-token"),
              projectId: session.project.getProjectId(),
              connectionId: session.connectionId,
              currentStageId: session.currentStage.id
            },
            path: "/socket-server/socket.io"
          });

          this.socket.on("disconnect", (reason: any) => {
            // console.log("the socket will automatically try to reconnect");
            this.reconnecting = true;
            // session.commandManager.executeAndSkip(
            //   new Commands.SetModalRoute(session, "socketDisconnect")
            // );
          });

          this.socket.on("reconnect", (data: any) => {
            // console.log(data, "reconnect***");
            // session.commandManager.executeAndSkip(
            //   new Commands.SetModalRoute(session, "")
            // );
          });

          this.socket.on("onlineUsers.add", (data: any) => {
            if (session.isPluginLoaded("OnlineUsers")) {
              // console.log(data, "data here");
              session.executeFunction("OnlineUsers.add", { ...data });
              // setTimeout(() => {
              session.executeFunction(
                "OnlineUsers.setSelectedLayers",
                data.userId,
                data.connectionId,
                data.currentStageId,
                data.selectedLayers
              );
              // }, 5000);
            }
          });

          this.socket.on("onlineUsers.remove", (data: any) => {
            // console.log("remove @@@ - data here", data);
            if (session.isPluginLoaded("OnlineUsers")) {
              session.executeFunction("OnlineUsers.remove", data);
            }
          });

          this.socket.on("onlineUsers.setCursor", (data: any) => {
            if (session.isPluginLoaded("OnlineUsers")) {
              session.executeFunction(
                "OnlineUsers.setCursor",
                data.userId,
                data.connectionId,
                data.position,
                data.currentStageId,
                data.selectedLayers
              );
            }
          });

          this.socket.on("onlineUsers.setSelectedLayers", (data: any) => {
            // console.log("setSelectedLayers", data);
            if (session.isPluginLoaded("OnlineUsers")) {
              session.executeFunction(
                "OnlineUsers.setSelectedLayers",
                data.userId,
                data.connectionId,
                data.currentStageId,
                data.selectedLayers
              );
            }
          });

          this.socket.on("deselectAllLayers", (data: any) => {
            session.commandManager.executeAndSkip(
              new Commands.DeselectAllLayers(session)
            );
          });

          this.socket.on("onlineUsers.lockChildren", (data: any) => {
            // session.lockChildren(data.parentLayerId, data.childrenLocked);
            // session.commandManager.executeAndSkip(
            //   new Commands.DeselectAllLayers(session)
            // );

            if (session.isPluginLoaded("OnlineUsers")) {
              session.executeFunction(
                "OnlineUsers.setLockedParentLayerId",
                data.userId,
                data.connectionId,
                data.currentStageId,
                data.lockChildrenParentLayerId
              );
            }
          });

          //
          this.socket.on("loaded", () => {
            this.reconnecting = false; // "loaded" event received after reconnection means we can start accepting patches
            session.startRecordingPatches();
            if (session.domain.files.size < 1) {
              session.addNewArtboard();
              // session.stopRecordingPatches();
            }

            // session.startRecordingPatches();
            session.loadProject(true);
          });

          this.socket.on("error", (err: any) => {
            console.error(err);
            if (err.includes && err.includes("Authentication error")) {
              Alert("Authentication Failed!", "Please login again!", true)
                .then(() => {
                  jsCookie.remove("builderx-auth-token");
                  // window.parent.location.replace(
                  //   urljoin(Utils.getEnv("BUILDERX_WEBSITE_URL"), "login")
                  // );
                  Utils.redirectParentWindow(
                    urljoin(Utils.getEnv("BUILDERX_WEBSITE_URL"), "login")
                  );
                  return;
                })
                .catch(() => {
                  //
                });
            } else if (err.includes && err.includes("404")) {
              Alert(
                "Invalid Project!",
                "Either the project does not exist, or you don't have the correct access!",
                true
              )
                .then(() => {
                  // window.parent.location.replace(
                  //   urljoin(Utils.getEnv("BUILDERX_WEBSITE_URL"), "dashboard")
                  // );
                  Utils.redirectParentWindow(
                    urljoin(Utils.getEnv("BUILDERX_WEBSITE_URL"), "dashboard")
                  );
                  return;
                })
                .catch(() => {
                  //
                });
            }
          });

          // console.log("*** here in connectSocket");
          this.socket.on("patchBatch", (patchBatch: any) => {
            designerAction(() => {
              action(() => {
                if (this.reconnecting) {
                  return;
                }
                // console.log("patch received", patch);
                console.log("patch batch received **(((", patchBatch);
                console.log("tempPatches **(((", [...this.tempPatches]);
                if (
                  patchBatch.op === "snapshot" &&
                  process.env.NODE_ENV !== "production"
                ) {
                  // console.log(
                  //   diff(session.domain.toJS(), patch.value),
                  //   "snapshot dif*******"
                  // );
                } else if (session) {
                  if (patchBatch.clientId === this.socket.id) {
                    // self patch
                    const patchIndexInTemp = findIndex(
                      this.tempPatches,
                      tp => tp.batchId === patchBatch.batchId
                    );
                    if (patchIndexInTemp !== -1) {
                      console.log(
                        "Self patch received, splicing ***(((",
                        this.tempPatches[patchIndexInTemp]
                      );
                      this.tempPatches.splice(patchIndexInTemp, 1);
                    } else {
                      // designerAction(() => {
                      //   action(() => {
                      console.log(
                        "Self patch received, applying ***(((",
                        patchBatch.patches
                      );
                      patchBatch.patches.forEach((patch: any) => {
                        applyPatchInBuilderX(session, patch, session);
                        //   });
                        // });
                      });
                    }
                  } else {
                    console.log("Received nonself patch ***(((");
                    for (let i = this.tempPatches.length - 1; i >= 0; i--) {
                      // designerAction(() => {
                      //   action(() => {
                      console.log(
                        "Applying reverse ***(((",
                        this.tempPatches[i].patches
                      );
                      for (
                        let k = this.tempPatches[i].patches.length - 1;
                        k >= 0;
                        k--
                      ) {
                        const patch = this.tempPatches[i].patches[k];

                        if (patch.reverse) {
                          applyPatchInBuilderX(session, patch.reverse, session);
                        }
                      }
                      // reverse([...this.tempPatches[i].patches]).forEach(
                      //   (patch: any) => {

                      //   }
                      // );
                      //   });
                      // });
                    }
                    console.log("Emptying tempPatches ***(((");
                    this.tempPatches = [];
                    // designerAction(() => {
                    //   action(() => {
                    console.log(
                      "Applying received patches ***(((",
                      patchBatch.patches
                    );
                    patchBatch.patches.forEach((patch: any) => {
                      applyPatchInBuilderX(session, patch, session);
                    });
                    //   });
                    // });
                  }
                }
              });
            });
          });

          addPostCommandActionCallback(() => {
            if (this.patchPacketBatch.length < 1) {
              return;
            }
            const batchId = uuid();

            const tempPatches = this.patchPacketBatch
              .filter(p => p.type === "persist")
              .map(p => ({ forward: p.patch, reverse: p.reversePatch }));

            if (tempPatches.length > 0) {
              this.tempPatches.push({
                batchId: batchId,
                patches: tempPatches
              });
              console.log("Update temp patches ***(((", [...this.tempPatches]);
            }
            // this.tempPatches.push({
            //   forward: patch,
            //   reverse: reversePatch
            // });
            const patchesToBeEmitted = this.patchPacketBatch.map(p => ({
              type: p.type,
              patch: p.patch
            }));
            // setTimeout(() => {
            console.log(
              "Emitting patch batch ***(((",
              patchesToBeEmitted,
              "with batchId ",
              batchId
            );
            this.socket.emit("patchPacketBatch", {
              batchId: batchId,
              patches: patchesToBeEmitted
            });
            // }, 5000);
            this.patchPacketBatch = [];
          });
        }}
        onPatch={(object, patch, session) => {
          const patchInfo = applyPatchInBuilderX(object, patch, session);
          let returnVal: any, reversePatch: any;
          if (patchInfo) {
            ({ returnVal, reversePatch } = patchInfo);
          }

          if (
            this.socket &&
            Utils.isPersistentPatch(patch) &&
            session.recordPatches
          ) {
            console.log("Applied persistent patch ***(((", patch);
            if (
              session.currentStage.dragging ||
              patch.path.endsWith("ui/resizingType")
            ) {
              patch.patchId = this.socket.id + uuid();
              // this.tempPatches.push({
              //   forward: patch,
              //   reverse: reversePatch
              // });
              // setTimeout(() => {
              this.patchPacketBatch.push({
                type: "noPersist",
                patch,
                reversePatch
              });
              // this.socket.emit("patchPacket", { type: "noPersist", patch });
              // }, 5000);
            } else {
              patch.patchId = this.socket.id + uuid();
              // this.tempPatches.push({
              //   forward: patch,
              //   reverse: reversePatch
              // });
              // setTimeout(() => {
              this.patchPacketBatch.push({
                type: "persist",
                patch,
                reversePatch
              });
              // this.socket.emit("patchPacket", { type: "persist", patch });
              // }, 5000);
            }
          } else if (this.socket && patch.op === "crash") {
            this.socket.emit("patchPacketBatch", {
              patches: [{ type: "crash", patch }]
            });
          }

          if (this.socket && patch.path === "/selectedLayers") {
            //
            this.emitSelectLayerEvent(session, patch.value);
          }

          return returnVal;
        }}
      />
    );
  }
}
export default App;
