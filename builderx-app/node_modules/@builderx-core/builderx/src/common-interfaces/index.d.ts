import { Model } from "../model/lib";

export interface IDisposable {
  beforeDisposeCallback?: (instance: any) => void;
  disposed?: boolean;
  dispose();
  beforeDispose(beforeDisposeCallback: (instance: any) => void);
}

export interface INode<ParentType, ChildType> {
  parent: ParentType | undefined;
  children: Array<ChildType>;
  appendTo(parentNode: ParentType, index?: number);
  appendChild(childNode: ChildType, index?: number);
  remove();
  removeChild(index: number);
  getPath(node: any): string;
}

export interface IRenderer {
  onUpdateCallbacks: Array<(key: string) => void>;

  onUpdate(onUpdateCallback: (key: string) => void);
  emitUpdate(key: string);
}
export interface IEvent {
  type: string;
  payload: any;
  target?: any;
  originalEvent: any;
  manageControls?: boolean;
}
export type ResponseFile = {
  path: string;
  stats: any;
  content?: string;
  id: string;
};

export interface ILayout {
  x: number;
  y: number;
  height: number;
  width: number;
  rotation: number;
}

export interface IDelta {
  x: number;
  y: number;
}

interface IClone<T> {
  clone(): T;
}

// export type ControlsPropertyValue<T> = T extends ("enum" | "segmentedEnum")
//   ? { options: Array<string | number>; defaultValue?: string | number }
//   : T extends ("string")
//     ? { placeholder: string; defaultValue?: string }
//     : T extends "range"
//       ? { max: number; min: number; step: number; defaultValue?: number }
//       : T extends "color"
//         ? { defaultValue?: string }
//         : T extends "boolean"
//           ? { defaultValue?: boolean }
//           : T extends "number"
//             ? { placeholder: string; defaultValue?: number }
//             : null;

interface IImport {
  layerName: string;
  packageName: string;
  isDefaultImport: boolean;
  asName: string;
}

interface IProps {
  [key: string]: any;
}

interface ITemplate {
  type: string;
  import: IImport;
  props: IProps;
  innerText?: string;
  value?: string;
  children: Array<ITemplate | LiteralX>;
  styleName?: string;
  locked: boolean;
  template: ILayerTemplate;
  scopeVariables?: { [key: any]: any };
  blobURL?: string;
}

interface ILayerTemplate {
  centerVertical: boolean;
  centerHorizontal: boolean;
  repetitions?: number;
}
interface Options {
  key: string;
  value: Array<string>;
}
export interface ControlsProperty {
  title: string;
  type:
    | "string"
    | "number"
    | "range"
    | "enum"
    | "segmentedEnum"
    | "color"
    | "simpleColor"
    | "bareColor"
    | "component"
    | "renderProp"
    | "boolean"
    | "group"
    | "textArea"
    | "OrientationEditor"
    | "AlignmentEditor"
    | "ResizingTypeEditor"
    | "TextPropEditor"
    | "FlexboxEditor"
    | "CallbackEditor"
    | "MarginPaddingEditor"
    | "ShadowEditor"
    | "BorderRadiusEditor"
    | "BorderWidthEditor"
    | "LayoutEditor"
    | "FormControlEditor"
    | "ResetConditionalEditor"
    | "CustomConditionalEditor"
    | "CarouselEditor"
    | "TabViewEditor"
    | "TabStyleEditor"
    | "PathCurveTypeEditor"
    | "TouchableOpacityEditor"
    | "ScrollViewEditor"
    | "TextToTextInputEditor"
    | "ImageEditor"
    | "AccessibilityLabel"
    | "NavigationEditor"
    | "NestedEnum"
    | "DeviceTypeEditor"
    | "StatusBarEditor"
    | "LoopEditor"
    | "PickerEditor"
    | "IconEditor"
    | "shadowColor"
    | "shadowOffset"
    | "shadowOpacity"
    | "elevation";
  additionalOptions?: any;
  showForMultiple?: boolean;
  value: {
    options?: Array<string | number | Options>;
    defaultValue?: string | number | boolean | ITemplate;
    placeholder?: string;
    max?: number;
    min?: number;
    step?: number;
    nestedEnumProperty?: {
      name?: string;
      title: string;
      category: "props" | "style";
    };
  };
  propertyName?: string;
  category?: "props" | "style";
  properties?: Array<ControlsProperty>;
}

interface ComponentDefinition {
  version: string;
  template: ITemplate;
  thumbnail: string;
  name: string;
  controlsProperty: Array<ControlsProperty>;
  componentRenderDefinition: string;
  symbols?: Array<string>;
}
interface FileComponentDefinition {
  version: string;
  template: IFileTemplate;
  name: string;
  thumbnail: string;
  controlsProperty: Array<ControlsProperty>;
  componentRenderDefinition: string;
}
interface IFileTemplate {
  path?: string;
  content: string;
  version: string;
  isDirty: boolean;
  layer: ITemplate;
  props: IProps;
  type: string;
}

interface IResizingType {
  width: boolean;
  height: boolean;
  top: boolean;
  left: boolean;
  bottom: boolean;
  right: boolean;
}

export type StylePropNameType =
  | "style"
  | "contentContainerStyle"
  | "itemStyle"
  | "labelStyle"
  | "indicatorStyle"
  | "tabStyle"
  | "tabBarStyle";

type ResizingTypeAttributes =
  | "top"
  | "left"
  | "bottom"
  | "right"
  | "width"
  | "height";

export interface Font {
  family: string;
  postscriptName?: string;
  style: string;
  weight?: number;
  width?: number;
  path?: string;
  italic?: boolean;
  monospace?: boolean;
}

// type ContextMenuItemsCallback = (
//   params: ContextMenuParams,
//   browserWindow: BrowserWindow
// ) => void;

// type ContextMenuAdapter = (
//   contextMenuItemsCallback: ContextMenuItemsCallback
// ) => void;
export interface IDialog {
  getImagePath: () => Promise<any>;
  chooseFolder: () => Promise<any>;
  saveProject: () => Promise<any>;
  saveJSONFileDialog: () => Promise<any>;
  openJSONFileDialog: () => Promise<any>;
  openSketchFileDialog: () => Promise<any>;
  chooseFile: () => Promise<any>;
  chooseProjectFile: () => Promise<any>;
  chooseFolderToExport: () => Promise<any>;
  chooseFolderOrFile: () => Promise<any>;
  saveAsProject: () => Promise<any>;
}

type EnvConfig = {
  serverUrl: string;
  bxApiUrl: string;
  env: string;
  runningContext: string;
  isSharedComponentInstance: boolean;
};

export declare type onUpdateListener = (...args: Array<any>) => void;
export interface IConfiguration {
  configurations: any;
  userConfigurations: any;
  eventListenersMap: Map<string, Array<onUpdateListener>>;
  reverseMap: Map<onUpdateListener, Array<string>>;

  get: (key: string) => any;
  getAll: () => any;
  set: (key: string, value: any) => void;
  getFields(): {
    [key: string]: any;
  };
  on(properties: Array<string> | string, listener: onUpdateListener): void;
  emit(properties: Array<string> | string): void;
  off(properties: Array<string> | string, listener: onUpdateListener): void;
  saveUserConfiguration: () => void;
}

export interface IRecentProject {
  basePath: string;
  lastOpened: number;
  setBasePath: (basePath: string) => void;
  setLastOpened: (lastOpened: number) => void;
}
export interface IRecentProjects {
  recentProjectList: Map<string, IRecentProject>;
  addRecentProject: (basePath: string, lastOpened: number) => void;
  setRecentProjectList: (newRecentProjectList: any) => void;
  removeRecentProject: (basePath: string) => void;
}
export interface IFileService {
  appPath: string;
  sharedComponentsPath: string;
  path: any;
  setProjectId?: (id: string) => void;
  writeFile: (
    filePath: string,
    data: string,
    connectionId: string,
    type?: any
  ) => Promise<any>;
  readFile: (filePath: string) => Promise<string>;
  readJSONFile: (filePath: string) => Promise<string>;
  readFolderAsync: (filePath: string) => Promise<any>;
  readDirectoryAsync: (folderPath: string) => Array<string>;
  readDirectory: (folderPath: string) => Array<string>;
  getFileModifiedTimestamp: (filePath: string) => any;
  isDirectory: (filePath: string) => boolean;
  createFolder: (folderPath: string) => string;
  isFolderExists: (filePath: string) => boolean;
  getPathFromHomeDirectory: (folderPath: string) => string;
  getPath: (arrayOfPath: Array<string>) => string;
  isFileExists: (filePath: string) => Promise<boolean>;
  copyFile: (fromPath: string, toPath: string) => void;
  createTempFolder: () => string;
  moveFolder: (fromPath: string, toPath: string) => Promise<void>;
  removeFolder: (dbFileId: string, connectionId?: string) => void;
  restoreFile: (dbFileId: string) => void;
  readFolder: (projectId: string, connectionId?: string) => Promise<any[]>;
  renameProject: (projectId: string, newName: string) => void;
  resolve: (basePath: string, filePath: string) => string;
  normalize: (basePath: string) => string;
  relative: (basePath: string, filePath: string) => string;
  openFolderInFinder: (folderPath: string) => void;
  writeJSONFile: (filePath: string, data: any) => Promise<void>;
  getNewImageName: (existingRelativePath: string) => Promise<string>;
}

export interface IApiService {
  API_URL: string;
  get: (
    endPoint: string,
    params?: {
      [key: string]: any;
    },
    config?: {
      [key: string]: any;
    }
  ) => Promise<any>;
  getOne: (
    endPoint: string,
    key: string,
    params?: {
      [key: string]: any;
    },
    config?: {
      [key: string]: any;
    }
  ) => Promise<any>;
  post: (
    endPoint: string,
    params?: {
      [key: string]: any;
    },
    config?: {
      [key: string]: any;
    }
  ) => Promise<any>;
  put: (
    endPoint: string,
    params?: {
      [key: string]: any;
    },
    config?: {
      [key: string]: any;
    }
  ) => Promise<any>;
  patch: (
    endPoint: string,
    params?: {
      [key: string]: any;
    },
    config?: {
      [key: string]: any;
    }
  ) => Promise<any>;
  delete: (
    endPoint: string,
    config?: {
      [key: string]: any;
    }
  ) => Promise<any>;
}

export interface IAppUpdater {
  userService: IUserService;
  deviceDetailsService: IDeviceDetail;
  userApiService: any;
  appUpdaterIndicator: string;

  setLocalVersion: (newVersion: string) => Promise<boolean>;
  getLocalVersion: () => Promise<string>;
  getVersion: () => void;
  quitAndInstall: () => void;
  checkAndMatchVersions: () => void;
  setAppUpdaterIndicator: (value: string) => void;
  checkForUpdates: () => void;
}

export type ClipboardType = "layer" | "image" | "text" | "invalid";
export type DisplayMode = "stage" | "grid" | "preview";
export type EditorMode = "code" | "design";
export type EditorLayout = "layers" | "components" | undefined;

export interface IClipboardService {
  type: ClipboardType;
  data: any;
  set: (data: any, type: ClipboardType) => void;
  get: () => { data: any; type: ClipboardType };
  set: (data: any, type: ClipboardType) => void;
  nativeCut();
  nativeCopy(content: string);
  nativePaste();
}

export interface IDrivers {
  appLifeCycleService: IAppLifeCycleService;
  analyticsService: IAnalyticsService;
  appUpdaterService: IAppUpdater;
  contextMenu: (e: any) => Array<any>;
  init?: () => void;
  configuration: IConfiguration;
  dialog: IDialog;
  deviceDetailService: IDeviceDetail;
  fileService: IFileService;
  gradientService: IGradientService;
  offScreenRendererService: IOffScreenRendererService;
  recentProjects: IRecentProjects;
  userService: IUserService;
  clipboardService: IClipboardService;
  Sentry: any;
  robot: any;
}

export interface IOffScreenRendererService {
  showOffscreenLoader: (heading: string, subHeading: string) => void;
  showProgressOffscreenLoader: () => void;
  setContentProgressOffscreenLoader: (
    heading: string,
    subHeading: string,
    currentProgress: number
  ) => void;
  hideOffscreenLoader: () => void;
}
export interface IGradientService {
  genrateGradientImage: (
    layerId: string,
    value: any,
    gradientJS: any,
    elementDims: {
      width: number;
      height: number;
    }
  ) => void;
}

export interface IDeviceDetail extends Model {
  device: any;
  getDeviceDetails: (cb: any) => any;
  getIpAddress: (device: any) => any;
}

export interface IUserService extends Model {
  isUserRegistered: boolean;
  isUserLicenceValid: boolean;
  expiryDate?: string;
  uuid?: string;
  expiresIn?: string;
  isExpired: boolean;
  email?: string;
  role?: string;
  id?: string;
  currentTeamId?: string;
  currentTeamName?: string;
  userName?: string;
  last_sync?: string;
  sketchConversionCount?: number;
  newTAndCAccepted?: boolean;
  updateDownloaded?: boolean;
  setIsUserRegistered: (isUserRegistered: boolean) => any;
  setIsUserLicenceValid: (isUserLicenceValid: boolean) => any;
  setIsExpired: (isExpired: boolean) => any;
  setExpiryDate: (expiryDate: string) => any;
  setNewTAndCAccepted: (accepted: boolean) => any;
  setExpiresIn: (expiresIn?: string) => any;
  setUuid: (uuid: string) => any;
  setSketchConversionCount: (count: number) => any;
  setLastSync: (date: string) => any;
  setEmail: (email: string) => any;
  setUserName: (name: string) => any;
  setUserRole: (role: string) => any;
  isRegistered: () => boolean;
  getUpdateDownloaded: () => boolean;
  setUpdateDownloaded: (updated: boolean) => any;
  verifyExpiry: (resolve: any) => any;
  updateExpiry: (resolve: any) => any;
  update: (userAppVersion: string, currentVersion: string) => any;
  registerAndVerifyLicense: (key: string | null, email?: string) => any;
  isNewTermsAndConditionsAccepted: () => any;
  getUserData: () => any;
  isUserLoggedIn: () => Promise<boolean>;
  getTeamData: () => Promise<any>;
}

export interface IAppLifeCycleService extends Model {
  ipcRenderer: any;
  BrowserWindow: any;
  app: any;
  shell: any;
  remote: any;
  registerListener: () => any;
  getAppVersion: () => any;
  getAppName: () => any;
  quitApp: () => any;
  hideApp: () => any;
  exitApp: () => any;
  showApp: () => any;
  closeWindow: () => any;
  openWeb: (urlString: string) => any;
  createNewWindow: () => any;
  createNewProject: () => any;
  createNewProjectWithTutorial: () => any;
  openNewWindow: (index: string, callback: any) => any;
  getWindows: () => any;
}

export interface IAnalyticsService {
  init?: () => void;
  activities: any = [];
  // lastTenActivities: any = [];
  // getActivities: () => any;
  // recordLastTenActivities: (activityObj: ActivityObj) => any;
  // getLastTenActivities: () => [];
  // hasAnalyticsData: () => any;
  // storeAnalyticsData: (_activities: ActivityObj) => any;
  // sendAnalyticsData: () => any;
  addActivity: (activity: Activity, manual?: boolean) => any;
}

export type SystemFont = {
  path: string;
  postscriptName: string;
  family: string;
  style: string;
  weight?: number;
  width?: number;
  italic?: boolean;
  monospace?: boolean;
  type?: string;
};
export type overrideType =
  | "string"
  | "color"
  | "number"
  | "enum"
  | "boolean"
  | "navigation";

export type overrideCategory = "props" | "style" | "innerText" | "navigation";

export interface IOverrideModel {
  overrideKey: string;
  type: overrideType;
  defaultValue: any;
  category: overrideCategory;
  propertyName: string;
}

export type ExpressionX = {
  type: string;
  expression: string;
  evaluatedValue?: any;
};

export type ExpressionStatementX = {
  type: string;
  expression: LogicalExpressionX | BinaryExpressionX;
};

export type BinaryExpressionX = {
  type: string;
  operator: string;
  left: ExpressionX | any;
  right: ExpressionX | any;
};

export type LogicalExpressionX = {
  type: string;
  operator: string;
  left: any;
  right: any;
};

export type ConditionalExpressionX = {
  type: string;
  test: ExpressionX | BinaryExpressionX;
  consequent: DomainNode | any;
  alternate: DomainNode | any;
};

export type LiteralX = {
  type: string;
  value: any;
};

export type DomainNode =
  | ExpressionX
  | BinaryExpressionX
  | ConditionalExpressionX
  | LogicalExpressionX
  | ExpressionStatementX
  | LiteralX;

export interface IProject {
  defaultArtboardDirectory: string;
  defaultSymbolDirectory: string;
  defaultAssetDirectory: string;
  deviceName: string;
  deviceOrientation: "portrait" | "landscape";
  // basePath: string;
  // tempPath: string | undefined;
  missingFonts: Array<string>;
  // rulers: Map<string, Array<any>>;
}

export interface DraggedSharedComponent {
  library: any;
  class: string;
  name: string;
  height: number;
  width: number;
  external: boolean;
  symbolPath?: string;
}

export type LayerJSON = {
  type: string;
  styleName: string;
  innerText?: string | ExpressionX | ConditionalExpressionX;
  children: Array<LayerJSON> | string;
  import: Import;
  props: {};
  template: {
    centerVertical: boolean;
    centerHorizontal: boolean;
  };
  mask?: any;
  gradient?: any;
  overrides?: any;
  overrideKeys?: IOverrideModel[];
  locked?: boolean;
  navigateTo?: string;
};

export type RenderingContext = {
  rendering: "normal" | "nested";
  ancestorLayerName?: string;
  sharedComponentsPanel?: boolean;
  layerPreview?: boolean;
};
export interface IFormControl {
  type: "string" | "color" | "number" | "callback" | "icon" | "navigation";
  title: string;
  layerPath: string;
}
export interface IMutator {
  displayName: string;
  //   static updateRootData: (...arg: Array<any>) => any;
  //   static applySideEffects: (...arg: Array<any>) => any;
  //   static updateAndApplyAllSideEffects: (...arg: Array<any>) => any;
}

export interface IStatusBar {
  display: boolean;
  barStyle: "light-content" | "dark-content" | "default";
  animated: boolean;
  backgroundColor?: string;
}

export interface ISessionPlugin {
  session: Session;
  name: string;
  init: (session: Session) => void;
  activate: () => void;
  deactivate: () => void;
}

export interface ICodeEngine {
  meta: {
    name: string;
    displayName?: string;
    icon: string;
  };
  execute: (fileJSON: any, config: any) => any;
  getFiles: () => any;
  getFilesToWrite: () => Map;
}
