import * as React from "react";
import { ControlsProperty, IEvent } from "common-interfaces";
import {
  Checkbox,
  CheckboxTick,
  FormCol,
  FormRow,
  InputGroupInput,
  PropertyHeader,
  Slider,
  Text,
  WrapperDiv
} from "components-x";
import { Layer } from "domain-x";
import { Utils } from "utils";
import ColorPickerBare from "./ColorPickerBare";
import { debounce } from "lodash";
import { Session } from "session";
type propType = {
  onEvent: (event: IEvent) => void;
  layer: Layer;
  session: Session;
  property: ControlsProperty;
  robot: any;
};
export default class ColorPicker extends React.PureComponent<propType, any> {
  backgroundValueOnOpen: any;
  componentDidMount() {
    let propertyName = this.props.property.propertyName;
    if (propertyName) {
      this.props.layer.props.on(propertyName, this.onUpdate);
    }
  }
  componentDidUpdate(prevProps: propType) {
    let prevPropertyName = prevProps.property.propertyName;
    if (prevPropertyName) {
      prevProps.layer.props.off(prevPropertyName, this.onUpdate);
    }
    let propertyName = this.props.property.propertyName;
    if (propertyName) {
      this.props.layer.props.on(propertyName, this.onUpdate);
    }
  }
  componentWillUnmount() {
    let propertyName = this.props.property.propertyName;
    if (propertyName) {
      this.props.layer.props.off(propertyName, this.onUpdate);
    }
  }
  onUpdate = (key: string) => {
    this.forceUpdate();
  };

  handleFillToggle = () => {
    const propertyName = this.props.property.propertyName;
    if (propertyName) {
      let color = this.props.layer.props.getResolvedProp(propertyName);
      if (!color) {
        this.props.onEvent({
          payload: {
            key: propertyName,
            value: "rgba(230, 230, 230,1)"
          },
          type: "setProp",
          target: this.props.layer,
          originalEvent: null
        });
      } else {
        this.props.onEvent({
          payload: {
            key: propertyName
          },
          type: "removeProp",
          target: this.props.layer,
          originalEvent: null
        });
      }
    }
  };
  getLayerColor() {
    const propertyName = this.props.property.propertyName;
    if (!propertyName) {
      return null;
    }
    let propertyValue: any;
    if (this.props.property.category === "props") {
      propertyValue = this.props.layer.props.getResolvedProp(propertyName);
    } else {
      propertyValue = this.props.layer.props.getResolvedStyleAttribute(
        propertyName
      );
    }
    return propertyValue;
  }
  onChangeColor = (color: string, type: string = "") => {
    const propertyName = this.props.property.propertyName;
    this.props.onEvent({
      payload: { key: propertyName, value: color },
      type:
        this.props.property.category === "props"
          ? "setProp" + type
          : "setStyleAttribute" + type,
      target: this.props.layer,
      originalEvent: null
    });
  };
  onPickerOpen = () => {
    this.backgroundValueOnOpen = this.getLayerColor();
    this.onChangeColor(this.backgroundValueOnOpen, "AndForget");
  };
  onPickerClose = () => {
    const backgroundValue = this.getLayerColor();
    if (backgroundValue === this.backgroundValueOnOpen) {
      return;
    }
    this.onChangeColor(backgroundValue);
  };
  onChangeAlpha = (event: any, color: any, type: string) => {
    if (Utils.isHexColor(color)) {
      color = Utils.hexToRgb(color);
    }
    if (color) {
      this.props.onEvent({
        payload: {
          key: this.props.property.propertyName,
          value: Utils.getColorWithNewAlpha(color, event.target.value / 100)
        },
        type: type,
        target: this.props.layer,
        originalEvent: event
      });
    }
  };
  dummyFunction = (val?: any) => {
    return {};
  };
  render() {
    const propertyName = this.props.property.propertyName;
    if (!propertyName) {
      return null;
    }
    const propertyValue = this.getLayerColor();

    const colorAlpha = Math.round(Utils.getColorAlpha(propertyValue));
    return (
      <>
        <PropertyHeader uiSize="auto" open paddingLeft={0} className="pt-2">
          <WrapperDiv style={{ display: "flex" }}>
            <Checkbox style={{ flex: 0, paddingRight: 7 }}>
              <CheckboxTick
                noMargin
                checked={typeof propertyValue === "string"}
                onChange={this.handleFillToggle}
              />
            </Checkbox>
            <Text uiSize="m">{this.props.property.title}</Text>
          </WrapperDiv>
        </PropertyHeader>
        <FormRow key={propertyName}>
          <ColorPickerBare
            layer={this.props.layer}
            property={this.props.property}
            propertyValue={propertyValue}
            showGradient={false}
            renderType={"color"}
            removeGradient={this.dummyFunction}
            setGradient={this.dummyFunction}
            onChangeGradient={this.dummyFunction}
            rotateGradient={this.dummyFunction}
            onChangeColor={(color: any) => this.onChangeColor(color, "AndSkip")}
            onPickerClose={this.onPickerClose}
            onPickerOpen={this.onPickerOpen}
            robot={this.props.robot}
          />
          <FormCol uiSize={7}>
            <Slider
              name="bx-fill-slider"
              min={0}
              max={100}
              value={colorAlpha}
              // onChange={(event: any) =>
              //   this.onChangeAlpha(event, propertyValue)
              // }
              onChange={(e: any) => {
                this.onChangeAlpha(e, propertyValue, "setPropAndSkip");
              }}
              onMouseUp={(e: any) => {
                this.onChangeAlpha(e, propertyValue, "setProp");
              }}
              onMouseDown={(e: any) => {
                this.onChangeAlpha(e, propertyValue, "setPropAndForget");
              }}
            />
          </FormCol>
          <FormCol uiSize={2}>
            <InputGroupInput
              undo={this.props.session.commandManager.undo}
              redo={this.props.session.commandManager.redo}
              type="number"
              validator={e => {
                let val = parseFloat(e.target.value);
                return !isNaN(val) && val <= 100 && val >= 0;
              }}
              min={0}
              max={100}
              value={colorAlpha}
              // onChange={(event: any) =>
              //   this.onChangeAlpha(event, propertyValue)
              // }
              // onFocus={(e: any) =>
              //   this.onChangeAlpha(e, propertyValue, "setPropAndForget")
              // }
              // onBlur={(e: any) =>
              //   this.onChangeAlpha(e, propertyValue, "setProp")
              // }
              onChange={debounce(
                (e: any) => this.onChangeAlpha(e, propertyValue, "setProp"),
                600
              )}
            />
          </FormCol>
        </FormRow>
      </>
    );
  }
}
