import * as React from "react";
import PaddingBox from "./PaddingBox";
import { IEvent } from "common-interfaces";
import { forEach, upperFirst } from "lodash";
import { Session } from "session";
import { BoxModel } from "domain-x";
type propType = {
  title: string;
  session: Session;
  layer: any;
  onEvent: (event: IEvent) => void;
};
class PaddingBoxContainer extends React.PureComponent<propType, any> {
  constructor(props: any) {
    super(props);
  }
  onUpdate = () => {
    this.forceUpdate();
  };
  componentDidMount() {
    this.props.layer.ui.on("padding", this.onUpdate);
    this.props.layer.props.style.on(
      ["padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
      this.onUpdate
    );
  }
  componentDidUpdate(prevProps: propType) {
    prevProps.layer.ui.off("padding", this.onUpdate);
    prevProps.layer.props.style.off(
      ["padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
      this.onUpdate
    );
    this.props.layer.ui.on("padding", this.onUpdate);
    this.props.layer.props.style.on(
      ["padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
      this.onUpdate
    );
  }
  componentWillUnmount() {
    this.props.layer.ui.off("padding", this.onUpdate);
    this.props.layer.props.style.off(
      ["padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
      this.onUpdate
    );
  }

  onChangeEnd = (e: any, eventName: string) => {
    const padding: BoxModel = this.getLayerPaddingProperties();
    if (!padding) {
      return;
    }
    let paddingVal: { [key: string]: number | boolean } = {};
    if (padding.lock) {
      paddingVal = { padding: e.target.value, lock: true };
    } else {
      let allTrue = true;
      forEach(padding, (value: boolean, key: string) => {
        if (key === "lock") {
          return;
        }
        if (value) {
          paddingVal[`padding${upperFirst(key)}`] = e.target.value;
        }
        allTrue = allTrue && value;
      });
      if (allTrue) {
        paddingVal = { padding: e.target.value, lock: true };
      }
    }
    let type = "updateLayerPadding";
    if (eventName === "onChange") {
      type = "updateLayerPaddingAndSkip";
    } else if (eventName === "onMouseDown") {
      type = "updateLayerPaddingAndForget";
    }
    this.props.onEvent({
      type: type,
      payload: {
        properties: paddingVal,
        key: "padding"
      },
      target: this.props.layer,
      originalEvent: e
    });
  };

  onClickLockIcon = (e: any) => {
    const padding = this.props.layer.ui.padding;
    if (!padding) {
      return;
    }
    const value = !padding.lock;
    this.props.onEvent({
      type: "updateEditorState",
      payload: {
        key: "padding",
        properties: {
          lock: value,
          left: value,
          right: value,
          bottom: value,
          top: value
        }
      },
      target: this.props.layer,
      originalEvent: e
    });
  };

  getStyleAttribute = (propName: string) => {
    return this.props.layer.props.getResolvedStyleAttribute(propName);
  };

  getLayerPaddingProperties = () => {
    return this.props.layer.ui.padding;
  };

  getCurrentSelectedPaddingPropValue = () => {
    let paddingTop, paddingRight, paddingBottom, paddingLeft, paddingAll;
    paddingAll = this.getStyleAttribute("padding");
    paddingLeft = this.getStyleAttribute("paddingLeft");
    paddingTop = this.getStyleAttribute("paddingTop");
    paddingRight = this.getStyleAttribute("paddingRight");
    paddingBottom = this.getStyleAttribute("paddingBottom");
    const defaultValue = "0";
    const padding = this.getLayerPaddingProperties();
    if (!padding) {
      return;
    }
    if (
      (padding.top && padding.right && padding.bottom && padding.left) ||
      padding.lock
    ) {
      return paddingAll;
    }
    if (padding.top) {
      return paddingTop;
    }
    if (padding.bottom) {
      return paddingBottom;
    }
    if (padding.left) {
      return paddingLeft;
    }
    if (padding.right) {
      return paddingRight;
    }

    if (
      paddingLeft === paddingTop &&
      paddingLeft === paddingRight &&
      paddingLeft === paddingBottom
    ) {
      return paddingLeft;
    }

    if (!padding.top && !padding.right && !padding.bottom && !padding.left) {
      return defaultValue;
    }
  };

  updateEditorState = (propertyNameValue: string) => {
    const padding = this.getLayerPaddingProperties();
    if (!padding) {
      return;
    }
    let editorVal: { [key: string]: boolean } = {};
    if (propertyNameValue === "padding") {
      editorVal = { lock: true };
    } else {
      if (propertyNameValue === "paddingLeft") {
        if (!padding.left && padding.top && padding.right && padding.bottom) {
          editorVal = { lock: true, left: !padding.left };
        } else if (
          padding.left &&
          padding.top &&
          padding.right &&
          padding.bottom
        ) {
          editorVal = {
            lock: false,
            left: true,
            right: false,
            bottom: false,
            top: false
          };
        } else {
          editorVal = { lock: false, left: !padding.left };
        }
      }
      if (propertyNameValue === "paddingRight") {
        if (!padding.right && padding.top && padding.left && padding.bottom) {
          editorVal = { lock: true, right: !padding.right };
        } else if (
          padding.left &&
          padding.top &&
          padding.right &&
          padding.bottom
        ) {
          editorVal = {
            lock: false,
            left: false,
            right: true,
            bottom: false,
            top: false
          };
        } else {
          editorVal = { lock: false, right: !padding.right };
        }
      }
      if (propertyNameValue === "paddingTop") {
        if (!padding.top && padding.left && padding.right && padding.bottom) {
          editorVal = { lock: true, top: !padding.top };
        } else if (
          padding.left &&
          padding.top &&
          padding.right &&
          padding.bottom
        ) {
          editorVal = {
            lock: false,
            left: false,
            right: false,
            bottom: false,
            top: true
          };
        } else {
          editorVal = { lock: false, top: !padding.top };
        }
      }
      if (propertyNameValue === "paddingBottom") {
        if (!padding.bottom && padding.top && padding.right && padding.left) {
          editorVal = { lock: true, bottom: !padding.bottom };
        } else if (
          padding.left &&
          padding.top &&
          padding.right &&
          padding.bottom
        ) {
          editorVal = {
            lock: false,
            left: false,
            right: false,
            bottom: true,
            top: false
          };
        } else {
          editorVal = { lock: false, bottom: !padding.bottom };
        }
      }
    }
    this.props.onEvent({
      type: "updateEditorState",
      payload: {
        key: "padding",
        properties: editorVal
      },
      target: this.props.layer,
      originalEvent: null
    });
  };

  render() {
    return (
      <PaddingBox
        title={this.props.title}
        session={this.props.session}
        currentValue={this.getCurrentSelectedPaddingPropValue()}
        padding={this.props.layer.ui.padding}
        onChangeEnd={this.onChangeEnd}
        onClickLockIcon={this.onClickLockIcon}
        updateEditorState={this.updateEditorState}
      />
    );
  }
}

export default PaddingBoxContainer;
