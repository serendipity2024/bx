import * as React from "react";
import {
  FormRow,
  FormCol,
  InputGroup,
  InputGroupLeft,
  Icon,
  InputGroupRight,
  InputGroupInput,
  ButtonGroupRight,
  ButtonGroup
} from "components-x";
import { IEvent } from "common-interfaces";
import { Layer } from "domain-x";
import { isNil, get, debounce } from "lodash";
import { Session } from "session";

interface Props {
  layers: Array<Layer>;
  session: Session;
  rootLayer: Layer;
  onEvent: (event: IEvent) => void;
  getBoundingBox: () => {
    x: number;
    y: number;
    width: number;
    height: number;
    rotation: number;
  };
  getResizerHandlesForLayers: (layers: Array<Layer>) => Array<string>;
  additionalOptions?: any;
}
export default class TransformEditor extends React.PureComponent<Props, any> {
  transformInputRef: any;
  componentDidMount() {
    this.props.layers.forEach(layer => {
      layer.props.style.on("transform", this.onUpdate);
      layer.on("onDragLayer", this.onUpdateDom);
    });
  }
  componentDidUpdate(prevProps: any) {
    prevProps.layers.forEach((layer: any) => {
      layer.props.style.off("transform", this.onUpdate);
      layer.off("onDragLayer", this.onUpdateDom);
    });
    this.props.layers.forEach(layer => {
      layer.props.style.on("transform", this.onUpdate);
      layer.on("onDragLayer", this.onUpdateDom);
    });
  }

  componentWillUnmount() {
    this.props.layers.forEach(layer => {
      layer.props.style.off("transform", this.onUpdate);
      layer.off("onDragLayer", this.onUpdateDom);
    });
  }
  onUpdate = () => {
    this.forceUpdate();
  };
  onUpdateDom = (key: any) => {
    if (this.props.layers[0]) {
      const dims = this.props.layers[0].getBoundingClientRect();
      const value = dims.rotation;
      if (this.transformInputRef) {
        this.transformInputRef.value = value ? value.toFixed(0) : 0;
      }
    }
  };

  handleChange = (
    e: any,
    property: string,
    setStyleType: "" | "AndForget" | "AndSkip"
  ) => {
    let value = parseFloat(e.target.value);
    value = !isNil(value) && !isNaN(value) ? value : 0;
    value = Math.round(value);
    this.props.onEvent({
      originalEvent: e,
      payload: {
        rotation: value % 360
      },
      type: `setLayersTransform${setStyleType}`,
      target: this.props.layers
    });
  };

  resetRotation = () => {
    this.props.onEvent({
      originalEvent: null,
      payload: {
        rotation: 0
      },
      type: "setLayersTransform",
      target: this.props.layers
    });
  };
  render() {
    if (!this.props.layers) {
      return null;
    }

    const value = this.props.layers[0].getBoundingClientRect().rotation;
    const isRootLayer = this.props.layers[0] === this.props.rootLayer;
    const isDoable = true;
    return (
      <FormRow>
        <FormCol first uiSize={1}>
          <InputGroup disabled={isRootLayer || !isDoable}>
            <InputGroupLeft>
              <Icon
                onClick={this.resetRotation}
                name="icon-transform"
                size={14}
                data-tip="Reset Rotation"
                data-for="tooltip-right"
              />
            </InputGroupLeft>
            <InputGroupRight>
              <InputGroupInput
                undo={this.props.session.commandManager.undo}
                redo={this.props.session.commandManager.redo}
                type="number"
                ref={(ref: any) => {
                  this.transformInputRef = ref;
                }}
                validator={e => !isNaN(parseInt(e.target.value, 10))}
                outputProcessor={e => {
                  let val = parseInt(e.target.value, 10);
                  if (val >= 360) {
                    val = val % 360;
                  }
                  return val;
                }}
                uiSize="l"
                // onFocus={(e: any) =>
                //   this.handleChange(e, "rotate", "AndForget")
                // }
                onChange={debounce((e: any) => {
                  // let val = parseInt(e.target.value, 10);
                  // if (val >= 360) {
                  //   val = val % 360;
                  // }
                  // e.target.value = val;
                  this.handleChange(e, "rotate", "");
                }, 600)}
                // onBlur={(e: any) => {
                //   // let val = parseInt(e.target.value, 10);
                //   // if (val >= 360) {
                //   //   val = val % 360;
                //   // }
                //   // e.target.value = val;
                //   this.handleChange(e, "rotate", "");
                // }}
                disabled={isRootLayer || !isDoable}
                value={value ? value.toFixed(0) : 0}
              />
            </InputGroupRight>
          </InputGroup>
        </FormCol>
        <FormCol flex uiSize={1}>
          <ButtonGroupRight>
            <ButtonGroup uiSize="xs">
              {/* <Button
                disabled
                borderRight
                active
                uiBackground={600}
                flexible
                icon={<Icon name="flip1" size={13} />}
              />
              <Button
                disabled
                uiBackground={600}
                flexible
                icon={<Icon name="flip2" size={13} />}
              /> */}
            </ButtonGroup>
          </ButtonGroupRight>
        </FormCol>
      </FormRow>
    );
  }
}
