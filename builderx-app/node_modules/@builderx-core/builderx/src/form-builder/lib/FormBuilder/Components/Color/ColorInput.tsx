import * as React from "react";
import { ControlsProperty, IEvent, StylePropNameType } from "common-interfaces";
import { Utils } from "utils";
import {
  Checkbox,
  CheckboxLabel,
  CheckboxTick,
  FormCol,
  FormRow,
  InputGroupInput,
  PropertyHeader,
  Slider,
  Text,
  WrapperDiv
} from "components-x";
import { Layer } from "domain-x";
import ColorPickerBare from "./ColorPickerBare";
import { Gradient } from "@builderx-core/designer";
import { get, debounce } from "lodash";
import { Session } from "session";

type propType = {
  onEvent: (event: IEvent) => void;
  layer: Layer;
  property: ControlsProperty;
  checkGradientEditor?: () => boolean;
  showGradient: boolean;
  session: Session;
  uiSize: number | "s" | "m" | "l" | "xs" | "xl" | "xxs" | "xxl" | undefined;
  stylePropName: StylePropNameType;
  robot: any;
};
class ColorInput extends React.PureComponent<propType, any> {
  backgroundValueOnOpen: string;
  disablePickerClose: boolean = false;
  prevLayerData: {
    layer: Layer | undefined;
    stylePropName: StylePropNameType;
    property: ControlsProperty | undefined;
  } = { layer: undefined, stylePropName: "style", property: undefined };
  constructor(props: propType) {
    super(props);
    this.state = {
      isDisabled: false
    };
  }
  componentDidMount() {
    const stylePropName = this.props.stylePropName;
    if (this.props.property.propertyName) {
      if (this.props.property.category === "props") {
        this.props.layer.props.on(
          this.props.property.propertyName,
          this.onUpdate
        );
      } else {
        this.props.layer.props[stylePropName].on(
          this.props.property.propertyName,
          this.onUpdate
        );
      }
    }
    this.props.layer.props[stylePropName].on(
      [`backgroundColor`, `gradient`],
      this.onUpdate
    );
    this.checkDisabled();
  }
  componentDidUpdate(prevProps: propType) {
    let stylePropName = prevProps.stylePropName;
    this.checkDisabled();
    if (this.prevLayerData.layer !== prevProps.layer) {
      this.prevLayerData = {
        layer: prevProps.layer,
        stylePropName: prevProps.stylePropName,
        property: prevProps.property
      };
    }
    if (
      prevProps.layer !== this.props.layer &&
      this.props.checkGradientEditor &&
      this.props.checkGradientEditor()
    ) {
      this.closeGradientEditor();
    }
    if (prevProps.property.propertyName) {
      if (prevProps.property.category === "props") {
        prevProps.layer.props.off(
          prevProps.property.propertyName,
          this.onUpdate
        );
      } else {
        prevProps.layer.props[stylePropName].off(
          prevProps.property.propertyName,
          this.onUpdate
        );
      }
    }
    prevProps.layer.props[stylePropName].off(
      [`backgroundColor`, `gradient`],
      this.onUpdate
    );
    stylePropName = this.props.stylePropName;
    if (this.props.property.propertyName) {
      if (this.props.property.category === "props") {
        this.props.layer.props.on(
          this.props.property.propertyName,
          this.onUpdate
        );
      } else {
        this.props.layer.props[stylePropName].on(
          this.props.property.propertyName,
          this.onUpdate
        );
      }
    }
    this.props.layer.props[stylePropName].on(`backgroundColor`, this.onUpdate);
  }
  componentWillUnmount() {
    const stylePropName = this.props.stylePropName;
    if (this.props.property.propertyName) {
      if (this.props.property.category === "props") {
        this.props.layer.props.off(
          this.props.property.propertyName,
          this.onUpdate
        );
      } else {
        this.props.layer.props[stylePropName].off(
          this.props.property.propertyName,
          this.onUpdate
        );
      }
    }
    this.props.layer.props[stylePropName].off(`backgroundColor`, this.onUpdate);
  }
  onUpdate = (key: string) => {
    this.forceUpdate();
  };
  handleFillToggle = () => {
    const propertyName = this.props.property.propertyName;
    if (this.props.property.category === "style") {
      if (this.state.isDisabled) {
        this.props.onEvent({
          payload: {
            key: propertyName,
            value: "rgba(230, 230, 230,1)",
            stylePropName: this.props.stylePropName
          },
          type: "setStyleAttribute",
          target: this.props.layer,
          originalEvent: null
        });
      } else {
        let gradient = this.props.layer.props.getResolvedStyleAttribute(
          "gradient",
          this.props.stylePropName
        );
        if (gradient) {
          this.closeGradientEditor();
        }
        this.props.onEvent({
          payload: {
            key:
              this.props.property.propertyName === "backgroundColor"
                ? gradient
                  ? "gradient"
                  : "backgroundColor"
                : this.props.property.propertyName,
            stylePropName: this.props.stylePropName
          },
          type: "removeStyleAttribute",
          target: this.props.layer,
          originalEvent: null
        });
      }
    } else {
      if (this.state.isDisabled) {
        this.props.onEvent({
          payload: {
            key: propertyName,
            value: ""
          },
          type: "setProp",
          target: this.props.layer,
          originalEvent: null
        });
      } else {
        this.props.onEvent({
          payload: {
            key: propertyName
          },
          type: "removeProp",
          target: this.props.layer,
          originalEvent: null
        });
      }
    }
    this.setState({
      isDisabled: !this.state.isDisabled
    });
  };

  checkDisabled = () => {
    const propertyName = this.props.property.propertyName;
    if (!propertyName) {
      return;
    }
    let layerColor = this.props.layer.props.getResolvedStyleAttribute(
      propertyName,
      this.props.stylePropName
    );
    let gradient = this.props.layer.props.getResolvedStyleAttribute(
      "gradient",
      this.props.stylePropName
    );

    if (!layerColor && !gradient) {
      this.setState({
        isDisabled: true
      });
    } else {
      this.setState({
        isDisabled: false
      });
    }
  };

  getLayerColor(
    layer: Layer,
    stylePropName: StylePropNameType,
    property: ControlsProperty
  ) {
    const propertyName = property.propertyName;
    if (!propertyName) {
      return null;
    }
    let layerColor = layer.props.getResolvedStyleAttribute(
      propertyName,
      stylePropName
    );
    layerColor =
      layerColor !== undefined ? layerColor : property.value.defaultValue;
    return layerColor;
  }
  getBackgroundValue = (
    layer: Layer = this.props.layer,
    stylePropName: StylePropNameType = this.props.stylePropName,
    property: ControlsProperty = this.props.property
  ) => {
    let value = "";
    let type:
      | "color"
      | "LinearGradient"
      | "RadialGradient"
      | "AngularGradient" = "color";
    const layerColor = this.getLayerColor(layer, stylePropName, property);
    let gradientValue = layer.props.getResolvedStyleAttribute(
      "gradient",
      stylePropName
    );

    if (gradientValue) {
      value = gradientValue;
      type = gradientValue.gradientType;
    } else if (layerColor !== null && layerColor !== undefined) {
      value = layerColor;
      type = "color";
    } else {
      value = "rgba(230, 230, 230,1)";
      type = "color";
    }
    return { value, type };
  };
  removeGradient = () => {
    let gradient = this.props.layer.props.getResolvedStyleAttribute(
      "gradient",
      this.props.stylePropName
    );
    if (gradient) {
      this.props.onEvent({
        payload: {
          key: "gradient"
        },
        type: "removeStyleAttribute",
        target: this.props.layer,
        originalEvent: null
      });
      this.disablePickerClose = false;
      this.props.onEvent({
        payload: { key: "gradientEditor", value: "close" },
        type: "setGradientEditor",
        target: this.props.layer,
        originalEvent: null
      });
    }
    this.setState({
      lastSelected: "color"
    });
  };
  closeGradientEditor = () => {
    this.disablePickerClose = false;
    this.props.onEvent({
      payload: { key: "gradientEditor", value: "close" },
      type: "setGradientEditor",
      target: this.props.layer,
      originalEvent: null,
      manageControls: true
    });
  };
  openGradientEditor = () => {
    let gradientValue: Gradient = get(this.props.layer, "props.style.gradient");
    if (gradientValue) {
      this.props.onEvent({
        payload: { key: "gradientEditor", value: "open" },
        type: "setGradientEditor",
        target: this.props.layer,
        originalEvent: null,
        manageControls: true
      });
      this.disablePickerClose = true;
    }
  };
  setGradient = (
    gradientType: "LinearGradient" | "RadialGradient" | "AngularGradient"
  ) => {
    let gradientValue: Gradient = get(this.props.layer, "props.style.gradient");
    if (!gradientValue || gradientValue.gradientType !== gradientType) {
      gradientValue = new Gradient(
        gradientType,
        { x: 0.5, y: gradientType === "LinearGradient" ? 0 : 0.5 },
        { x: 0.5, y: 1 },
        [
          { stopColor: "#E70B0B", offset: 0 },
          { stopColor: "#EEEEEE", offset: 1 }
        ],
        0
      );
      this.props.onEvent({
        payload: {
          key: "gradient",
          value: gradientValue
        },
        type: "setStyleAttributeAndForget",
        target: this.props.layer,
        originalEvent: null,
        manageControls: true
      });
    }
    this.props.onEvent({
      payload: { key: "gradientEditor", value: "open" },
      type: "setGradientEditor",
      target: this.props.layer,
      originalEvent: null,
      manageControls: true
    });
    this.disablePickerClose = true;
    this.setState({
      lastSelected: gradientType
    });
  };
  onChangeGradient = (
    gradientObject: any,
    gradientData: any,
    from: any,
    to: any
  ) => {
    let gradientValue: Gradient = get(this.props.layer, "props.style.gradient");
    if (!gradientValue) {
      return;
    }
    let newStops: any = [];
    gradientObject.forEach((stop: any) => {
      newStops.push({ stopColor: stop.color, offset: stop.pos });
    });
    gradientValue.stops = newStops;
    this.props.onEvent({
      payload: {
        key: "gradient",
        value: gradientValue
      },
      type: "setStyleAttributeAndSkip",
      target: this.props.layer,
      originalEvent: null,
      manageControls: true
    });
    if (gradientData.isGradient && gradientData.linearGradient) {
      this.setState({
        lastSelected: "LinearGradient"
      });
    } else if (gradientData.isGradient && gradientData.radialGradient) {
      this.setState({
        lastSelected: "RadialGradient"
      });
    }
  };
  onChangeIndex = (activeIndex: number) => {
    let gradientValue: Gradient = get(this.props.layer, "props.style.gradient");
    gradientValue.activeIndex = activeIndex - 1;
    this.props.onEvent({
      payload: {
        key: "gradient",
        value: gradientValue
      },
      type: "setStyleAttributeAndSkip",
      target: this.props.layer,
      originalEvent: null,
      manageControls: true
    });
    this.onUpdate("changeIndex");
  };
  onChangeColor = (
    color: string | Gradient,
    layer?: Layer,
    stylePropName?: StylePropNameType,
    propertyName?: string | undefined,
    type?: string,
    manageControls?: boolean
  ) => {
    this.props.onEvent({
      payload: {
        key:
          color instanceof Gradient
            ? "gradient"
            : propertyName || this.props.property.propertyName,
        value: color
        // stylePropName: stylePropName || this.props.stylePropName
      },
      type: type ? type : "setStyleAttributeAndSkip",
      target: layer || this.props.layer,
      originalEvent: null,
      manageControls: color instanceof Gradient || manageControls
    });
  };
  onPickerOpen = () => {
    this.backgroundValueOnOpen = this.getBackgroundValue().value;
    this.onChangeColor(
      this.backgroundValueOnOpen,
      this.props.layer,
      this.props.stylePropName,
      this.props.property.propertyName,
      "setStyleAttributeAndForget",
      true
    );
  };
  isPickerCloseDisabled = () => {
    return this.disablePickerClose;
  };
  onPickerClose = (closeGradientEditor?: boolean) => {
    if (closeGradientEditor) {
      this.closeGradientEditor();
    }
    if (
      !this.prevLayerData.layer ||
      (this.prevLayerData.layer && !this.prevLayerData.layer.parent)
    ) {
      return;
    }
    const backgroundValue = this.getBackgroundValue(
      this.prevLayerData.layer,
      this.prevLayerData.stylePropName,
      this.prevLayerData.property
    );
    if (backgroundValue.value === this.backgroundValueOnOpen) {
      return;
    }
    if (backgroundValue.type === "color") {
      this.onChangeColor(
        backgroundValue.value,
        this.prevLayerData.layer,
        this.prevLayerData.stylePropName,
        this.prevLayerData.property
          ? this.prevLayerData.property.propertyName
          : undefined,
        "setStyleAttribute",
        true
      );
    } else if (backgroundValue.type) {
      let gradientValue: Gradient = get(
        this.prevLayerData.layer || this.props.layer,
        "props.style.gradient"
      );

      this.props.onEvent({
        payload: {
          key: "gradient",
          value: gradientValue
        },
        type: "setStyleAttribute",
        target: this.prevLayerData.layer || this.props.layer,
        originalEvent: null,
        manageControls: true
      });
    }
  };
  onChangeAlpha = (event: any, type: string) => {
    let color: any = this.getBackgroundValue(
      this.props.layer,
      this.props.stylePropName,
      this.props.property
    ).value;
    if (Utils.isHexColor(color)) {
      color = Utils.hexToRgb(color);
    }
    if (color) {
      this.props.onEvent({
        payload: {
          key: this.props.property.propertyName,
          value: Utils.getColorWithNewAlpha(color, event.target.value / 100),
          stylePropName: this.props.stylePropName
        },
        type: type,
        target: this.props.layer,
        originalEvent: event
      });
    }
  };
  rotateGradient = (angle: number) => {
    let gradientValue: Gradient = get(this.props.layer, "props.style.gradient");
    gradientValue = new Gradient(
      gradientValue.gradientType,
      gradientValue.from,
      gradientValue.to,
      gradientValue.stops,
      gradientValue.activeIndex
    );
    gradientValue.rotateGradient(angle);
    this.props.onEvent({
      payload: {
        key: "gradient",
        value: gradientValue
      },
      type: "setStyleAttribute",
      target: this.props.layer,
      originalEvent: null,
      manageControls: true
    });
  };
  render() {
    const propertyName = this.props.property.propertyName;
    const colorAlpha =
      typeof this.getBackgroundValue().value === "string"
        ? Math.round(Utils.getColorAlpha(this.getBackgroundValue().value))
        : 100;
    const showGradient =
      this.props.showGradient && this.props.layer.type === "view";
    let propertyValue = this.getBackgroundValue().value;
    const type = this.getBackgroundValue().type;
    if (
      ["LinearGradient", "RadialGradient", "AngularGradient"].includes(type)
    ) {
      propertyValue = Utils.getGradientString(
        this.getBackgroundValue().value as any
      );
    }
    return (
      <>
        <PropertyHeader uiSize="auto" open paddingLeft={0} className="pt-2">
          <WrapperDiv style={{ display: "flex" }}>
            <Checkbox style={{ flex: 0 }}>
              <CheckboxTick
                noMargin
                checked={!this.state.isDisabled}
                onChange={this.handleFillToggle}
              />
            </Checkbox>
            <CheckboxLabel>
              <Text uiSize={this.props.uiSize ? this.props.uiSize : "m"}>
                {this.props.property.title}
              </Text>
            </CheckboxLabel>
          </WrapperDiv>
        </PropertyHeader>
        <FormRow key={propertyName}>
          <FormCol first uiSize={2} contentLeft>
            <ColorPickerBare
              layer={this.props.layer}
              property={this.props.property}
              propertyValue={propertyValue}
              showGradient={showGradient}
              renderType={type}
              onPickerClose={this.onPickerClose}
              onPickerOpen={this.onPickerOpen}
              onEvent={this.props.onEvent}
              removeGradient={
                showGradient
                  ? this.removeGradient
                  : () => {
                      //
                    }
              }
              isPickerCloseDisabled={this.isPickerCloseDisabled}
              onChangeIndex={
                showGradient
                  ? this.onChangeIndex
                  : () => {
                      //
                    }
              }
              openGradientEditor={
                showGradient
                  ? this.openGradientEditor
                  : () => {
                      //
                    }
              }
              setGradient={
                showGradient
                  ? this.setGradient
                  : () => {
                      //
                    }
              }
              onChangeGradient={
                showGradient
                  ? this.onChangeGradient
                  : () => {
                      //
                    }
              }
              rotateGradient={
                showGradient
                  ? this.rotateGradient
                  : () => {
                      //
                    }
              }
              onChangeColor={this.onChangeColor}
              robot={this.props.robot}
              isGradient={
                this.props.layer.props.getResolvedStyleAttribute(
                  "gradient",
                  this.props.stylePropName
                )
                  ? true
                  : false
              }
            />
          </FormCol>
          <FormCol uiSize={7}>
            <Slider
              name="bx-fill-slider"
              min={0}
              max={100}
              disabled={typeof this.getBackgroundValue().value !== "string"}
              value={colorAlpha}
              onChange={(e: any) => {
                this.onChangeAlpha(e, "setStyleAttributeAndSkip");
              }}
              onMouseUp={(e: any) => {
                this.onChangeAlpha(e, "setStyleAttribute");
              }}
              onMouseDown={(e: any) => {
                this.onChangeAlpha(e, "setStyleAttributeAndForget");
              }}
            />
          </FormCol>
          <FormCol uiSize={2}>
            <InputGroupInput
              undo={this.props.session.commandManager.undo}
              redo={this.props.session.commandManager.redo}
              type="number"
              validator={e => {
                let val = parseFloat(e.target.value);
                return !isNaN(val) && val <= 100 && val >= 0;
              }}
              min={0}
              max={100}
              value={colorAlpha}
              // onFocus={(e: any) =>
              //   this.onChangeAlpha(e, "setStyleAttributeAndForget")
              // }
              // onBlur={(e: any) => this.onChangeAlpha(e, "setStyleAttribute")}
              onChange={debounce(
                (e: any) => this.onChangeAlpha(e, "setStyleAttribute"),
                600
              )}
            />
          </FormCol>
        </FormRow>
      </>
    );
  }
}
export default ColorInput;
