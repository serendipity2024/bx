import * as React from "react";
import {
  PropertyHeader,
  FormRow,
  FormCol,
  ColorPicker,
  Slider,
  InputGroupInput,
  InputGroup,
  InputGroupLeft,
  InputGroupRight,
  Text,
  WrapperDiv,
  Checkbox,
  CheckboxTick
} from "components-x";
import { Layer } from "domain-x";
import { IEvent } from "common-interfaces";
import { Session } from "session";
import { isNil, round, get, find, merge, debounce } from "lodash";
type propType = {
  onEvent: (event: IEvent) => void;
  layer: Layer;
  key: string;
  robot: any;
  session: Session;
  value?: any;
  properties?: Array<any>;
};
const rerenderProps = [
  "shadowOpacity",
  "shadowOffset.width",
  "shadowOffset.height",
  "shadowRadius",
  "shadowColor"
];
export default class ShadowEditor extends React.PureComponent<propType, any> {
  colorValueOnOpen: any;
  constructor(props: propType) {
    super(props);
    this.state = {
      isDisabled: false
    };
  }
  componentDidMount() {
    this.props.layer.props.style.on(rerenderProps, this.onUpdate);
  }
  componentDidUpdate(prevProps: propType) {
    prevProps.layer.props.style.off(rerenderProps, this.onUpdate);
    this.props.layer.props.style.on(rerenderProps, this.onUpdate);
  }
  componentWillUnmount() {
    this.props.layer.props.style.off(rerenderProps, this.onUpdate);
  }
  onUpdate = (key: string) => {
    this.forceUpdate();
  };

  getLayerShadow() {
    const shadowColor = this.props.layer.props.getResolvedStyleAttribute(
      "shadowColor"
    );
    const shadowRadius = this.props.layer.props.getResolvedStyleAttribute(
      "shadowRadius"
    )
      ? this.props.layer.props.getResolvedStyleAttribute("shadowRadius")
      : 0;
    const elevation = this.props.layer.props.getResolvedStyleAttribute(
      "elevation"
    );
    const shadowOpacity =
      this.props.layer.props.getResolvedStyleAttribute("shadowOpacity") !==
        undefined &&
      this.props.layer.props.getResolvedStyleAttribute("shadowOpacity") !== null
        ? this.props.layer.props.getResolvedStyleAttribute("shadowOpacity")
        : 1;

    const x = this.props.layer.props.getResolvedStyleAttribute(
      "shadowOffset.width"
    );
    const y = this.props.layer.props.getResolvedStyleAttribute(
      "shadowOffset.height"
    );

    return {
      shadowColor,
      shadowOffset: {
        width: x,
        height: y
      },
      elevation,
      shadowRadius,
      shadowOpacity
    };
  }
  getDefaultShadow() {
    return {
      shadowColor: this.getDefaultValue("shadowColor") || "rgba(0,0,0,1)",
      shadowOffset: {
        width: this.getDefaultValue("shadowOffset") || 3,
        height: this.getDefaultValue("shadowOffset") || 3
      },
      elevation: this.getDefaultValue("elevation") || 5,
      shadowOpacity: this.getDefaultValue("shadowOpacity") || 0.25,
      shadowRadius: this.getDefaultValue("shadowRadius") || 5
    };
  }
  setLayerShadow(
    shadow: any,
    property: string,
    setStyleType:
      | "setShadowAttributes"
      | "setShadowAttributesAndForget"
      | "setShadowAttributesAndSkip",
    type?: any
  ) {
    if (property === "shadowColor") {
      this.props.onEvent({
        payload: {
          ...merge(this.getDefaultShadow(), shadow),
          shadowColor: shadow.shadowColor ? shadow.shadowColor : "rgba(0,0,0,1)"
        },
        type: setStyleType,
        target: this.props.layer,
        originalEvent: null
      });
    }
    if (property === "x" || property === "y") {
      this.props.onEvent({
        payload: {
          ...merge(this.getDefaultShadow(), shadow),
          shadowOffset: {
            height: shadow.shadowOffset.height,
            width: shadow.shadowOffset.width
          }
        },
        type: setStyleType,
        target: this.props.layer,
        originalEvent: null
      });
    }
    if (property === "shadowRadius") {
      this.props.onEvent({
        payload: {
          ...merge(this.getDefaultShadow(), shadow),
          shadowRadius: !isNil(shadow.shadowRadius) ? shadow.shadowRadius : 0,
          // shadow does not work in android.
          // Set elevation to make it work in android.
          // Must be multiplied by 3 to make it look similar on both platforms.
          elevation: !isNil(shadow.shadowRadius) ? shadow.shadowRadius * 3 : 0
        },
        type: setStyleType,
        target: this.props.layer,
        originalEvent: null
      });
    }
    if (property === "shadowOpacity") {
      if (type === "slider") {
        this.props.onEvent({
          payload: {
            ...merge(this.getDefaultShadow(), shadow),
            shadowOpacity: !isNil(shadow.shadowOpacity)
              ? shadow.shadowOpacity
              : 1
          },
          type: "setShadowAttributesAndSkip",
          target: this.props.layer,
          originalEvent: null
        });
      } else {
        this.props.onEvent({
          payload: {
            ...merge(this.getDefaultShadow(), shadow),
            shadowOpacity: !isNil(shadow.shadowOpacity)
              ? shadow.shadowOpacity
              : 1
          },
          type: setStyleType,
          target: this.props.layer,
          originalEvent: null
        });
      }
    }
  }

  handleSliderChange = (e: any, property: any, eventName: string) => {
    if (typeof e === "object" && property === "shadowOpacity") {
      let type = "setShadowAttributes";
      if (eventName === "onChange") {
        type = "setShadowAttributesAndSkip";
      } else if (eventName === "onMouseDown") {
        type = "setShadowAttributesAndForget";
      }
      const shadowOpacity = parseFloat(e.target.value) / 100;
      this.props.onEvent({
        payload: {
          ...merge(this.getDefaultShadow(), this.getLayerShadow()),
          shadowOpacity: !isNil(shadowOpacity) ? shadowOpacity : 1
        },
        type: type,
        target: this.props.layer,
        originalEvent: null
      });
    }
  };
  removeShadow = () => {
    this.props.onEvent({
      type: "removeShadowAttributes",
      payload: [
        "shadowColor",
        "shadowOpacity",
        "shadowRadius",
        "elevation",
        "shadowOffset"
      ],
      target: this.props.layer,
      originalEvent: null
    });
  };
  getDefaultValue = (name: string) => {
    if (this.props.properties) {
      let property = find(
        this.props.properties,
        (obj: any) => obj.type === name
      );
      return get(property, "value.defaultValue");
    }
    return undefined;
  };
  handleChange = (
    e: any,
    property: any,
    setStyleType:
      | "setShadowAttributes"
      | "setShadowAttributesAndForget"
      | "setShadowAttributesAndSkip",
    type?: any
  ) => {
    const shadow = this.getLayerShadow();
    if (!shadow) {
      return;
    }
    if (isNil(shadow.shadowColor)) {
      this.props.onEvent({
        payload: merge(this.getDefaultShadow(), shadow),
        type: setStyleType,
        target: this.props.layer,
        originalEvent: null
      });
    } else if (typeof e === "string") {
      this.setLayerShadow(
        {
          ...shadow,
          [property]: e
        },
        property,
        setStyleType
      );
    } else if (typeof e === "object" && property === "shadowOpacity") {
      this.setLayerShadow(
        {
          ...shadow,
          [property]: parseFloat(e.target.value) / 100
        },
        property,
        setStyleType,
        type
      );
    } else if (typeof e === "object") {
      if (property === "x") {
        shadow.shadowOffset.width = parseFloat(e.target.value);
      }
      if (property === "y") {
        shadow.shadowOffset.height = parseFloat(e.target.value);
      }
      this.setLayerShadow(
        property === "x" || property === "y"
          ? shadow
          : {
              ...shadow,
              [property]: parseFloat(e.target.value)
            },
        property,
        setStyleType
      );
    }
  };

  onPickerOpen = () => {
    const shadow = this.getLayerShadow();
    this.colorValueOnOpen = shadow.shadowColor;

    this.handleChange(
      this.colorValueOnOpen,
      "shadowColor",
      "setShadowAttributesAndForget"
    );
  };
  onPickerClose = () => {
    const shadow = this.getLayerShadow();
    const colorValue = shadow.shadowColor;

    if (colorValue === this.colorValueOnOpen) {
      return;
    }
    this.handleChange(colorValue, "shadowColor", "setShadowAttributes");
  };

  closePicker(e: any) {
    if (this.state.showPicker) {
      this.setState({
        showPicker: false
      });
    }
    return false;
  }

  render() {
    const shadow = this.getLayerShadow();
    if (!shadow) {
      return null;
    }
    const shadowOpacity = shadow.shadowOpacity * 100;
    return (
      <React.Fragment>
        <PropertyHeader
          uiSize="xs"
          open
          paddingLeft={0}
          style={{ paddingTop: 5, paddingBottom: 0 }}
        >
          <WrapperDiv style={{ display: "flex" }}>
            <Checkbox style={{ flex: 0, paddingRight: 7 }}>
              <CheckboxTick
                noMargin
                checked={shadow.shadowColor}
                onChange={(e: any) => {
                  if (e.target.checked) {
                    this.handleChange(e, "shadowColor", "setShadowAttributes");
                  } else {
                    this.removeShadow();
                  }
                }}
              />
            </Checkbox>
            <Text uiSize="m">Shadow</Text>
          </WrapperDiv>
        </PropertyHeader>
        <FormRow marginTop={5}>
          <FormCol first uiSize={2}>
            <ColorPicker
              value={shadow.shadowColor}
              onChangeColor={(color: string) =>
                this.handleChange(
                  color,
                  "shadowColor",
                  "setShadowAttributesAndSkip"
                )
              }
              onPickerClose={this.onPickerClose}
              onPickerOpen={this.onPickerOpen}
              robot={this.props.robot}
            />
          </FormCol>
          <FormCol
            onClick={(e: any) => this.closePicker(e)}
            name="bx-shadow-colorPicker"
            uiSize={7}
          >
            <Slider
              min={0}
              max={100}
              name="bx-shadow-slider"
              value={shadowOpacity ? round(shadowOpacity) : 1}
              onMouseUp={(e: any) => {
                this.handleSliderChange(e, "shadowOpacity", "onMouseUp");
              }}
              onMouseDown={(e: any) => {
                this.handleSliderChange(e, "shadowOpacity", "onMouseDown");
              }}
              onChange={(e: any) => {
                this.handleSliderChange(e, "shadowOpacity", "onChange");
              }}
            />
          </FormCol>
          <FormCol uiSize={2}>
            <InputGroupInput
              undo={this.props.session.commandManager.undo}
              redo={this.props.session.commandManager.redo}
              type="number"
              min="0"
              max="100"
              validator={e => {
                let val = parseFloat(e.target.value);
                return !isNaN(val) && val <= 100 && val >= 0;
              }}
              name="bx-shadow-slider"
              value={shadowOpacity ? round(shadowOpacity) : 1}
              // onFocus={(e: any) => {
              //   if (!isNil(shadowOpacity)) {
              //     this.handleChange(
              //       e,
              //       "shadowOpacity",
              //       "setShadowAttributesAndForget"
              //     );
              //   }
              // }}
              onChange={debounce((e: any) => {
                this.handleChange(e, "shadowOpacity", "setShadowAttributes");
              }, 600)}
              // onBlur={(e: any) => {
              //   if (!isNil(shadowOpacity)) {
              //     this.handleChange(e, "shadowOpacity", "setShadowAttributes");
              //   }
              // }}
            />
          </FormCol>
        </FormRow>
        <FormRow marginTop={5}>
          <FormCol first uiSize={2}>
            <InputGroup>
              <InputGroupLeft>
                <Text uiSize="xs">X</Text>
              </InputGroupLeft>
              <InputGroupRight>
                <InputGroupInput
                  undo={this.props.session.commandManager.undo}
                  redo={this.props.session.commandManager.redo}
                  type="number"
                  validator={e => !isNaN(parseFloat(e.target.value))}
                  name="bx-shadow-left"
                  value={
                    !isNil(shadow.shadowOffset.width)
                      ? parseFloat(shadow.shadowOffset.width as any)
                      : 0
                  }
                  // onFocus={(e: any) => {
                  //   if (!isNil(shadow.shadowOffset.width)) {
                  //     this.handleChange(e, "x", "setShadowAttributesAndForget");
                  //   }
                  // }}
                  onChange={debounce((e: any) => {
                    this.handleChange(e, "x", "setShadowAttributes");
                  }, 600)}
                  // onBlur={(e: any) => {
                  //   if (!isNil(shadow.shadowOffset.width)) {
                  //     this.handleChange(e, "x", "setShadowAttributes");
                  //   }
                  // }}
                />
              </InputGroupRight>
            </InputGroup>
          </FormCol>
          <FormCol uiSize={2}>
            <InputGroup>
              <InputGroupLeft>
                <Text uiSize="xs">Y</Text>
              </InputGroupLeft>
              <InputGroupRight>
                <InputGroupInput
                  undo={this.props.session.commandManager.undo}
                  redo={this.props.session.commandManager.redo}
                  type="number"
                  name="bx-shadow-top"
                  validator={e => !isNaN(parseFloat(e.target.value))}
                  value={
                    !isNil(shadow.shadowOffset.height)
                      ? parseFloat(shadow.shadowOffset.height as any)
                      : 0
                  }
                  // onFocus={(e: any) => {
                  //   if (!isNil(shadow.shadowOffset.height)) {
                  //     this.handleChange(e, "y", "setShadowAttributesAndForget");
                  //   }
                  // }}
                  onChange={debounce((e: any) => {
                    this.handleChange(e, "y", "setShadowAttributes");
                  }, 600)}
                  // onBlur={(e: any) => {
                  //   if (!isNil(shadow.shadowOffset.height)) {
                  //     this.handleChange(e, "y", "setShadowAttributes");
                  //   }
                  // }}
                />
              </InputGroupRight>
            </InputGroup>
          </FormCol>
          <FormCol uiSize={3}>
            <InputGroup>
              <InputGroupLeft>
                <Text uiSize="xs">Blur&nbsp;</Text>
              </InputGroupLeft>
              <InputGroupRight>
                <InputGroupInput
                  undo={this.props.session.commandManager.undo}
                  redo={this.props.session.commandManager.redo}
                  type="number"
                  name="bx-shadow-radius"
                  validator={e => !isNaN(parseFloat(e.target.value))}
                  value={parseFloat(shadow.shadowRadius as any)}
                  // onFocus={(e: any) => {
                  //   if (!isNil(shadow.shadowRadius)) {
                  //     this.handleChange(
                  //       e,
                  //       "shadowRadius",
                  //       "setShadowAttributesAndForget"
                  //     );
                  //   }
                  // }}
                  onChange={debounce((e: any) => {
                    this.handleChange(e, "shadowRadius", "setShadowAttributes");
                  }, 600)}
                  // onBlur={(e: any) => {
                  //   if (!isNil(shadow.shadowRadius)) {
                  //     this.handleChange(
                  //       e,
                  //       "shadowRadius",
                  //       "setShadowAttributes"
                  //     );
                  //   }
                  // }}
                />
              </InputGroupRight>
            </InputGroup>
          </FormCol>
        </FormRow>
      </React.Fragment>
    );
  }
}
