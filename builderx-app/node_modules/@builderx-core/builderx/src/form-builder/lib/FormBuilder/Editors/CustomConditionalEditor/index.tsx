import { IEvent } from "common-interfaces";
import {
  Button,
  CustomConditionInput,
  FormCol,
  FormRow,
  Icon,
  InputGroupInput,
  Text
} from "components-x";
import { Alert } from "dialog-x";
import { File as DomainFile, Layer, DomainLayer } from "domain-x";
import { isEmpty } from "lodash";
import * as React from "react";
import { Session } from "session";
import { Utils } from "utils";

type propType = {
  layer: DomainLayer;
  onEvent: (event: IEvent) => void;
  session: Session;
  getRecordingConditions: () => { [key: string]: any };
  file: DomainFile;
};
class ConditionalEditor extends React.Component<propType, any> {
  constructor(props: any) {
    super(props);
    this.state = {
      newConditionValue: ""
    };
  }
  onUpdate = (key: string) => {
    this.forceUpdate();
  };
  componentDidMount() {
    this.props.file.on("scopeVariables", this.onUpdate);
  }
  componentDidUpdate(prevProps: propType) {
    try {
      const prevFile = prevProps.file;
      const newFile = this.props.file;
      if (newFile !== prevFile) {
        prevFile.off("scopeVariables", this.onUpdate);
        newFile.on("scopeVariables", this.onUpdate);
      }
    } catch (error) {
      console.log(error, "error in CustomConditionalEditor");
    }
  }
  componentWillUnmount() {
    this.props.file.off("scopeVariables", this.onUpdate);
  }

  handleNewConditionChange = (event: any) => {
    this.setState({ newConditionValue: event.target.value });
  };

  handleActivateCondition(key: string) {
    this.props.onEvent({
      type: "updateScopeVariable",
      payload: {
        key: key,
        value: true
      },
      originalEvent: null
    });
  }

  handleRemoveCondition(condition: string) {
    // this.props.onEvent({
    //   type: "updateScopeVariable",
    //   payload: {
    //     key: key,
    //     value:true
    //   },
    //   originalEvent: null
    // });
  }

  handleDeactivateCondition(key: string) {
    this.props.onEvent({
      type: "updateScopeVariable",
      payload: {
        key: key,
        value: false
      },
      originalEvent: null
    });
  }
  handleSubmit = (event: any) => {
    if (!Utils.validateVariableName(event.target.value)) {
      // Show Error
      Alert(
        "Variable name is invalid",
        "Only variable names are allowed as conditionals",
        true
      );
    }
    if (event.keyCode === 13 && !isEmpty(this.state.newConditionValue)) {
      try {
        // let ast = babylon.parseExpression(this.state.newConditionValue);
        // this.props.builderX.operations.layer.addCustomCondition(
        //   fileId,
        //   this.newConditionValue
        // );

        this.props.onEvent({
          type: "updateExpressionList",
          payload: {
            key: this.state.newConditionValue,
            value: []
          },
          originalEvent: null
        });
        // UpdateFileExpressionList(this.session, domainNode);

        this.setState({ newConditionValue: "" });
      } catch (e) {
        // this.props.builderX.operations.message.alert(
        //   "Invalid condition name",
        //   "The condition name is not a valid expression",
        //   ""
        // );
        console.log(e, "customConditions error");
      }
    }
  };

  getConditionalsComponent() {
    const file = this.props.layer.getFile() as DomainFile;
    const components: any[] = [];
    file.conditionalExpList.forEach(
      (value: { active: boolean; references: Layer[] }, key: string) => {
        components.push(
          <FormRow key={key}>
            <FormCol uiSize={9} first>
              <Text uiSize={"s"}>{key}</Text>
            </FormCol>
            <FormCol flex>
              <Button
                transparent
                onClick={(e: any) => {
                  this.props.onEvent({
                    type: "toggleCondition",
                    payload: value,
                    originalEvent: e,
                    target: file
                  });
                }}
              >
                <Icon
                  name={value.active ? "show_layer" : "hide_layer"}
                  size={14}
                />
              </Button>
            </FormCol>
          </FormRow>
        );
      }
    );
    return components;
  }

  recordCustomConditions(key: string, isRecording: boolean) {
    if (isRecording) {
      this.props.onEvent({
        type: "removeRecordingCondition",
        payload: {
          key: key
        },
        originalEvent: null
      });
    } else {
      this.props.onEvent({
        type: "updateRecordingConditions",
        payload: {
          key: key,
          value: true
        },
        originalEvent: null
      });
    }
  }
  shouldIgnoreExpression(expressionName: string) {
    const file = this.props.file;
    if (file) {
      if (expressionName.indexOf("this.props.") !== -1) {
        return true;
      }
    }
    return false;
  }
  render() {
    const customConditions: any = [];
    let scopeVariables = {};
    if (this.props.layer.type === "root") {
      const file = this.props.file;
      scopeVariables = file.scopeVariables;
      file.expressionList.forEach((condition: any, key: string) => {
        if (
          key !== "platform" &&
          key !== "deviceName" &&
          key !== "orientation"
        ) {
          customConditions.push({ key: key, expression: condition });
        }
      });
    }

    return (
      <>
        {customConditions &&
          customConditions.map((condition: any, index: string) => {
            // TODO: check
            if (this.shouldIgnoreExpression(condition.key)) {
              return null;
            }
            const isActive: boolean = scopeVariables[condition.key];
            const isRecording = this.props.getRecordingConditions()[
              condition.key
            ]
              ? true
              : false;
            return (
              <FormRow
                key={`custom-condition${index}`}
                style={{ paddingLeft: 0, paddingRight: 0 }}
              >
                <FormCol uiSize={1} first>
                  <Button
                    transparent
                    onClick={() => {
                      if (!isActive) {
                        this.handleActivateCondition(condition.key);
                      }
                      console.log(condition.key, isRecording, "condition.key");
                      this.recordCustomConditions(condition.key, isRecording);
                    }}
                    data-tip={
                      !isRecording
                        ? `Record for ${condition.key}`
                        : "Stop Recording"
                    }
                    data-for="tooltip-right"
                    // tooltip={
                    //   <TooltipText uiSize="m" position="right">
                    //     {!isRecording
                    //       ? `Record for ${condition.key}`
                    //       : "Stop Recording"}
                    //   </TooltipText>
                    // }
                  >
                    <Icon
                      name={isRecording ? "pause-record" : "record"}
                      size={12}
                    />
                  </Button>
                </FormCol>
                <FormCol uiSize={9}>
                  <CustomConditionInput
                    disabled={isRecording}
                    isActive={isActive}
                    onDeleteClick={() => {
                      // this.handleRemoveCondition(condition, selectedFileId);
                    }}
                    onViewClick={
                      isActive
                        ? () => {
                            this.handleDeactivateCondition(condition.key);
                          }
                        : () => {
                            this.handleActivateCondition(condition.key);
                          }
                    }
                    inputProps={{ value: condition.key }}
                  />
                </FormCol>
              </FormRow>
            );
          })}
        <FormRow style={{ paddingLeft: 0, paddingRight: 0 }}>
          <FormCol first>
            <InputGroupInput
              undo={this.props.session.commandManager.undo}
              redo={this.props.session.commandManager.redo}
              // disabled={!_.isEmpty(customConditionRecordState)}
              placeholder="Add New Condition"
              value={this.state.newConditionValue}
              onChange={this.handleNewConditionChange}
              onKeyUp={e => {
                this.handleSubmit(e);
              }}
            />
          </FormCol>
        </FormRow>
      </>
    );
  }
}

export default ConditionalEditor;
