import * as React from "react";
import MarginBox from "./MarginBox";
import { Layer, BoxModel } from "domain-x";
import { IEvent } from "common-interfaces";
import { Session } from "session";
import { forEach, upperFirst } from "lodash";
type propType = {
  title: string;
  layer: any;
  session: Session;
  onEvent: (event: IEvent) => void;
};
class MarginBoxContainer extends React.PureComponent<propType, any> {
  constructor(props: any) {
    super(props);
  }
  onUpdate = () => {
    this.forceUpdate();
  };
  componentDidMount() {
    this.props.layer.ui.on("margin", this.onUpdate);
    this.props.layer.props.style.on(
      ["margin", "marginTop", "marginRight", "marginBottom", "marginLeft"],
      this.onUpdate
    );
  }
  componentDidUpdate(prevProps: propType) {
    prevProps.layer.ui.off("margin", this.onUpdate);
    prevProps.layer.props.style.off(
      ["margin", "marginTop", "marginRight", "marginBottom", "marginLeft"],
      this.onUpdate
    );
    this.props.layer.ui.on("margin", this.onUpdate);
    this.props.layer.props.style.on(
      ["margin", "marginTop", "marginRight", "marginBottom", "marginLeft"],
      this.onUpdate
    );
  }
  componentWillUnmount() {
    this.props.layer.ui.off("margin", this.onUpdate);
    this.props.layer.props.style.off(
      ["margin", "marginTop", "marginRight", "marginBottom", "marginLeft"],
      this.onUpdate
    );
  }
  onChangeEnd = (e: any, eventName: string) => {
    const margin: BoxModel = this.getLayerMarginProperties();
    if (!margin) {
      return;
    }
    let marginVal: { [key: string]: number | boolean } = {};
    if (margin.lock) {
      marginVal = { margin: e.target.value, lock: true };
    } else {
      let allTrue = true;
      forEach(margin, (value: boolean, key: string) => {
        if (key === "lock") {
          return;
        }
        if (value) {
          marginVal[`margin${upperFirst(key)}`] = e.target.value;
        }
        allTrue = allTrue && value;
      });
      if (allTrue) {
        marginVal = { margin: e.target.value, lock: true };
      }
    }
    let type = "updateLayerMargin";
    if (eventName === "onChange") {
      type = "updateLayerMarginAndSkip";
    } else if (eventName === "onMouseDown") {
      type = "updateLayerMarginAndForget";
    }
    this.props.onEvent({
      type: type,
      payload: {
        properties: marginVal,
        key: "margin"
      },
      target: this.props.layer,
      originalEvent: e
    });
  };

  onClickLockIcon = (e: any) => {
    const margin = this.props.layer.ui.margin;
    if (!margin) {
      return;
    }
    const value = !margin.lock;
    this.props.onEvent({
      type: "updateEditorState",
      payload: {
        key: "margin",
        properties: {
          lock: value,
          left: value,
          right: value,
          bottom: value,
          top: value
        }
      },
      target: this.props.layer,
      originalEvent: e
    });
  };

  getStyleAttribute = (propName: string) => {
    return this.props.layer.props.getResolvedStyleAttribute(propName);
  };

  getLayerMarginProperties = () => {
    return this.props.layer.ui.margin;
  };

  getCurrentSelectedMarginPropValue = () => {
    let marginTop, marginRight, marginBottom, marginLeft, marginAll;
    marginAll = this.getStyleAttribute("margin");
    marginLeft = this.getStyleAttribute("marginLeft");
    marginTop = this.getStyleAttribute("marginTop");
    marginRight = this.getStyleAttribute("marginRight");
    marginBottom = this.getStyleAttribute("marginBottom");
    const defaultValue = "0";
    const margin = this.getLayerMarginProperties();
    if (!margin) {
      return;
    }
    if (
      (margin.top && margin.right && margin.bottom && margin.left) ||
      margin.lock
    ) {
      return marginAll;
    }
    if (margin.top) {
      return marginTop;
    }
    if (margin.bottom) {
      return marginBottom;
    }
    if (margin.left) {
      return marginLeft;
    }
    if (margin.right) {
      return marginRight;
    }

    if (
      marginLeft === marginTop &&
      marginLeft === marginRight &&
      marginLeft === marginBottom
    ) {
      return marginLeft;
    }

    if (!margin.top && !margin.right && !margin.bottom && !margin.left) {
      return defaultValue;
    }
  };

  updateEditorState = (propertyNameValue: string) => {
    const margin = this.getLayerMarginProperties();
    if (!margin) {
      return;
    }
    let editorVal: { [key: string]: boolean } = {};
    if (propertyNameValue === "margin") {
      editorVal = { lock: true };
    } else {
      if (propertyNameValue === "marginLeft") {
        if (!margin.left && margin.top && margin.right && margin.bottom) {
          editorVal = { lock: true, left: !margin.left };
        } else if (margin.left && margin.top && margin.right && margin.bottom) {
          editorVal = {
            lock: false,
            left: true,
            right: false,
            bottom: false,
            top: false
          };
        } else {
          editorVal = { lock: false, left: !margin.left };
        }
      }
      if (propertyNameValue === "marginRight") {
        if (!margin.right && margin.top && margin.left && margin.bottom) {
          editorVal = { lock: true, right: !margin.right };
        } else if (margin.left && margin.top && margin.right && margin.bottom) {
          editorVal = {
            lock: false,
            left: false,
            right: true,
            bottom: false,
            top: false
          };
        } else {
          editorVal = { lock: false, right: !margin.right };
        }
      }
      if (propertyNameValue === "marginTop") {
        if (!margin.top && margin.left && margin.right && margin.bottom) {
          editorVal = { lock: true, top: !margin.top };
        } else if (margin.left && margin.top && margin.right && margin.bottom) {
          editorVal = {
            lock: false,
            left: false,
            right: false,
            bottom: false,
            top: true
          };
        } else {
          editorVal = { lock: false, top: !margin.top };
        }
      }
      if (propertyNameValue === "marginBottom") {
        if (!margin.bottom && margin.top && margin.right && margin.left) {
          editorVal = { lock: true, bottom: !margin.bottom };
        } else if (margin.left && margin.top && margin.right && margin.bottom) {
          editorVal = {
            lock: false,
            left: false,
            right: false,
            bottom: true,
            top: false
          };
        } else {
          editorVal = { lock: false, bottom: !margin.bottom };
        }
      }
    }
    this.props.onEvent({
      type: "updateEditorState",
      payload: {
        key: "margin",
        properties: editorVal
      },
      target: this.props.layer,
      originalEvent: null
    });
  };
  render() {
    return (
      <MarginBox
        title={this.props.title}
        session={this.props.session}
        currentValue={this.getCurrentSelectedMarginPropValue()}
        margin={this.props.layer.ui.margin}
        onChangeEnd={this.onChangeEnd}
        onClickLockIcon={this.onClickLockIcon}
        updateEditorState={this.updateEditorState}
      />
    );
  }
}

export default MarginBoxContainer;
