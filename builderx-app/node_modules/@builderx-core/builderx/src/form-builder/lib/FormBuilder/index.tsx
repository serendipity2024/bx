import * as React from "react";
import { ControlsProperty, IEvent } from "common-interfaces";
import {
  Button,
  FormGroup,
  Icon,
  Pane,
  PropertyGroup,
  PropertyHeader,
  Text,
  Scrollbars
} from "components-x";
import { Layer, File } from "domain-x";
import { get, lowerCase } from "lodash";
import BooleanInput from "./Components/BooleanInput";
import ColorInput from "./Components/Color/ColorInput";
import ColorPicker from "./Components/Color/ColorPicker";
import ColorPickerBareWithText from "./Components/Color/ColorPickerBareWithText";
import DependantDropdownInput from "./Components/DependantDropdownInput";
import DropdownInput from "./Components/DropdownInput";
import InputField from "./Components/InputField";
import SliderInput from "./Components/SliderInput";
import CustomTextArea from "./Components/TextArea";
import AlignmentEditor from "./Editors/AlignmentEditor";
import BorderRadiusEditor from "./Editors/BorderRadiusEditor";
import BorderWidthEditor from "./Editors/BorderWidthEditor";
import CallbackEditor from "./Editors/CallbackEditor";
import CarouselEditor from "./Editors/CarouselEditor";
import ComponentEditor from "./Editors/ComponentEditor";
import CustomConditionalEditor from "./Editors/CustomConditionalEditor";
import DeviceTypeEditor from "./Editors/DeviceTypeEditor";
import FormControlsEditor from "./Editors/FormControlsEditor";
import ImageEditor from "./Editors/ImageEditor";
import LayoutEditor from "./Editors/LayoutEditor";
import LoopEditor from "./Editors/LoopEditor";
import MarginPaddingEditor from "./Editors/MarginPaddingEditor";
import NavigationEditor from "./Editors/NavigationEditor";
import OrientationEditor from "./Editors/OrientationEditor";
import PathCurveTypeEditor from "./Editors/PathCurveTypeEditor";
import PickerEditor from "./Editors/PickerEditor";
import ResetConditionalEditor from "./Editors/ResetConditionalEditor";
import ResizingTypeEditor from "./Editors/ResizingTypeEditor";
import ScrollViewEditor from "./Editors/ScrollViewEditor";
import ShadowEditor from "./Editors/ShadowEditor";
import StatusBarEditor from "./Editors/StatusBarEditor";
import TabStyleEditor from "./Editors/TabStyleEditor";
import TabViewEditor from "./Editors/TabViewEditor";
import TextPropEditor from "./Editors/TextPropEditor";
import TextToTextInputEditor from "./Editors/TextToTextInputEditor";
import TouchableOpacityEditor from "./Editors/TouchableOpacityEditor";
import IconEditor from "./Editors/IconEditor";
import ReactTooltip from "react-tooltip";
import { Utils } from "utils";
import { Session } from "session";

type propType = {
  configurations: any;
  schema: Array<ControlsProperty>;
  layers: Array<any>;
  rootLayer: Layer;
  additionalData?: any;
  onEvent: (event: IEvent) => void;
  checkGradientEditor?: () => boolean;
  tools: any;
  session: Session;
  changeToScrollViewIsDoable: any;
  robot: any;
  selectedFile: File;
  recordingConditionals: boolean;
  stageId: string;
};
export default class FormBuilder extends React.Component<propType, any> {
  componentDidMount() {
    ReactTooltip.rebuild();
    const layer = this.props.layers[0];
    if (layer && !Utils.shouldIgnoreLayer(layer.type)) {
      layer.props.style.on("flexDirection", this.onUpdate);
    }
  }
  componentDidUpdate(prevProps: propType) {
    const prevLayer = prevProps.layers[0];

    if (prevLayer && !Utils.shouldIgnoreLayer(prevLayer.type)) {
      prevLayer.props.style.off("flexDirection", this.onUpdate);
    }
    const layer = this.props.layers[0];
    if (layer && !Utils.shouldIgnoreLayer(layer.type)) {
      layer.props.style.on("flexDirection", this.onUpdate);
    }
  }
  componentWillUnmount() {
    const layer = this.props.layers[0];
    if (layer && !Utils.shouldIgnoreLayer(layer.type)) {
      layer.props.style.off("flexDirection", this.onUpdate);
    }
  }
  onUpdate = () => {
    this.forceUpdate();
  };
  getEditorConfigName = (editorName: string) => {
    switch (editorName) {
      case "NavigationEditor":
        editorName = "navigationEditor";
        break;
      case "Layout":
        editorName = "layoutEditor";
        break;
      case "Other":
        editorName = "otherPropsEditor";
        break;
      case "Overrides":
        editorName = "overrideEditor";
        break;
      case "CustomConditional":
        editorName = "customConditionalEditor";
        break;
      case "Conditional":
        editorName = "conditionalEditor";
        break;
      case "DeviceTypeEditor":
        editorName = "deviceTypeEditor";
        break;
      case "DeviceEditor":
        editorName = "deviceEditor";
        break;
      case "Activity Indicator":
        editorName = "activityIndicator";
        break;
      default:
        break;
    }
    return `editor.${editorName}.state`;
  };
  onEvent = (event: IEvent) => {
    this.props.onEvent(event);
  };
  dummyFunction = (val?: any) => {
    return {};
  };
  toggleEditor(groupName: string, groupState: boolean) {
    this.props.onEvent({
      type: "setConfig",
      payload: {
        name: this.getEditorConfigName(groupName),
        value: !groupState
      },
      originalEvent: false,
      manageControls: true
    });
  }

  willRenderChildMarginBoxContainer = (layer: Layer) => {
    const elementType = layer.getLayerElementType();
    const childrenCount = layer.getChildren().length;
    if (
      layer.type !== "text" &&
      ((childrenCount > 0 && elementType === "flex") ||
        (layer && layer.type === "flatList"))
    ) {
      return true;
    } else {
      return false;
    }
  };

  willRenderMarginPaddingBoxContainer = (layer: Layer) => {
    const position = layer.props.getResolvedStyleAttribute("position");
    if (layer.type === "root") {
      return false;
    } else if (position !== "absolute") {
      return true;
    } else {
      return false;
    }
  };

  renderFields(schema: Array<ControlsProperty>): any {
    const layers = this.props.layers as Array<Layer>;
    const layer = layers[layers.length - 1];
    return schema
      .filter(property => (layers.length > 1 ? property.showForMultiple : true))
      .map((property, index) => {
        let fieldName =
          property.title || property.propertyName || "unknown prop";

        let otherPropState = this.props.configurations[
          this.getEditorConfigName(fieldName)
        ];
        const resolveNodeValue = this.props.additionalData.resolveNodeValue;
        let childMarginBoxContainer, marginPaddingBoxContainer;

        switch (property.type) {
          case "group":
            let display = true;
            if (property.title === "Layout") {
              childMarginBoxContainer = this.willRenderChildMarginBoxContainer(
                layer
              );
              marginPaddingBoxContainer = this.willRenderMarginPaddingBoxContainer(
                layer
              );
              if (
                layer.showLayoutOptions() ||
                childMarginBoxContainer ||
                marginPaddingBoxContainer
              ) {
                display = true;
              } else {
                display = false;
              }
            }

            if (display) {
              return (
                <PropertyGroup
                  className={`app-tutorial-${lowerCase(property.title)}-editor`}
                  key={`${lowerCase(property.title)}-editor`}
                >
                  <PropertyHeader
                    uiSize="xs"
                    onClick={() => {
                      this.toggleEditor(property.title, otherPropState);
                    }}
                  >
                    <Text uiSize="xs" uppercase letterSpacing bold>
                      {property.title}
                    </Text>
                    <Button
                      transparent
                      icon={
                        <Icon
                          name={otherPropState ? "uparrow" : "downarrow"}
                          size={10}
                        />
                      }
                      uiSize="xs"
                    />
                  </PropertyHeader>
                  <FormGroup noPaddingVertical>
                    {otherPropState && property.properties ? (
                      <div className="pb-2">
                        {this.renderFields(property.properties)}
                      </div>
                    ) : null}
                  </FormGroup>
                </PropertyGroup>
              );
            } else {
              return null;
            }
            break;
          case "string":
          case "number":
            if (property.propertyName) {
              return (
                <InputField
                  key={property.propertyName}
                  resolveNodeValue={resolveNodeValue}
                  property={property}
                  layer={layer}
                  session={this.props.session}
                  onEvent={this.onEvent}
                />
              );
            }
            break;
          case "range":
            return (
              <FormGroup noPadding key={`${property.propertyName}-Wrapper`}>
                <SliderInput
                  key={property.propertyName}
                  layer={layer}
                  session={this.props.session}
                  onEvent={this.onEvent}
                  property={property}
                />
              </FormGroup>
            );
            break;
          case "textArea":
            return (
              <CustomTextArea
                key={property.propertyName}
                layer={layer}
                session={this.props.session}
                onEvent={this.onEvent}
                property={property}
              />
            );
            break;
          case "boolean":
            return (
              <BooleanInput
                key={property.propertyName}
                layer={layer}
                session={this.props.session}
                onEvent={this.onEvent}
                property={property}
              />
            );
            break;
          case "enum":
            return (
              <div className="pb-2" key={`${property.propertyName}-wrapper`}>
                <DropdownInput
                  key={property.propertyName}
                  layer={layer}
                  session={this.props.session}
                  onEvent={this.onEvent}
                  property={property}
                  propertyName={property.propertyName}
                  propertyTitle={property.title}
                  category={property.category}
                  options={property.value.options}
                  defaultValue={property.value.defaultValue}
                />
              </div>
            );
            break;
          case "NestedEnum":
            return (
              <FormGroup
                key={`${property.propertyName}-dropdown-wrapper`}
                noPaddingTop
              >
                <DependantDropdownInput
                  key={property.propertyName}
                  layer={layer}
                  session={this.props.session}
                  onEvent={this.onEvent}
                  property={property}
                />
              </FormGroup>
            );
            break;
          case "color":
            return (
              <ColorInput
                uiSize={get(property, "additionalOptions.uiOptions.size", "m")}
                key={property.propertyName}
                layer={layer}
                session={this.props.session}
                onEvent={this.onEvent}
                property={property}
                checkGradientEditor={this.props.checkGradientEditor}
                showGradient={get(
                  property,
                  "additionalOptions.showGradient",
                  true
                )}
                stylePropName={"style"}
                robot={this.props.robot}
              />
            );
            break;
          case "simpleColor":
            return (
              <ColorPicker
                key={property.propertyName}
                layer={layer}
                session={this.props.session}
                onEvent={this.onEvent}
                property={property}
                robot={this.props.robot}
              />
            );
            break;
          case "bareColor":
            return (
              <ColorPickerBareWithText
                key={property.propertyName}
                layer={layer}
                session={this.props.session}
                property={property}
                onEvent={this.onEvent}
                robot={this.props.robot}
              />
            );
          case "renderProp":
          case "component":
            return (
              <FormGroup noPaddingVertical key={property.propertyName}>
                <ComponentEditor
                  layer={layer}
                  session={this.props.session}
                  onEvent={this.onEvent}
                  property={property}
                  recordingConditionals={this.props.recordingConditionals}
                />
              </FormGroup>
            );
            break;
          case "PathCurveTypeEditor":
            return (
              <PathCurveTypeEditor
                tools={this.props.tools}
                session={this.props.session}
                key={property.type}
                onEvent={this.props.onEvent}
                pathEditorPointMode={
                  this.props.additionalData.pathEditorPointMode
                }
              />
            );
            break;
          case "OrientationEditor":
            const getBoundingBox = this.props.additionalData.getBoundingBox;
            const getResizerHandlesForLayers = this.props.additionalData
              .getResizerHandlesForLayers;
            // const resizer = this.props.additionalData.resizer;
            if (!getBoundingBox) {
              throw Error(
                "resizer model and getBoundingBox function must be supplied to orientation editor"
              );
            }
            return (
              <FormGroup noPaddingVertical key={property.type}>
                <OrientationEditor
                  layers={layers}
                  session={this.props.session}
                  rootLayer={this.props.rootLayer}
                  onEvent={this.onEvent}
                  getBoundingBox={getBoundingBox}
                  captureErrorForSentry={
                    this.props.additionalData.captureErrorForSentry
                  }
                  getResizerHandlesForLayers={getResizerHandlesForLayers}
                  // resizer={resizer}
                  additionalOptions={property.additionalOptions}
                />
              </FormGroup>
            );
            break;
          case "AlignmentEditor":
            return (
              <AlignmentEditor
                key={property.type}
                layers={layers}
                session={this.props.session}
                rootLayer={this.props.rootLayer}
                onEvent={this.onEvent}
              />
            );
            break;
          case "CallbackEditor":
            let additionalData = this.props.additionalData;
            return (
              <CallbackEditor
                property={property}
                layer={layer}
                session={this.props.session}
                key={property.type}
                onEvent={this.onEvent}
                validateCallbackPropValue={get(
                  additionalData,
                  "validateCallbackPropValue"
                )}
              />
            );
            break;
          case "TextPropEditor":
            return (
              <TextPropEditor
                getFontsList={this.props.additionalData.getFontsList}
                key={property.type}
                layer={layer}
                session={this.props.session}
                onEvent={this.onEvent}
                hideAutoToggle={
                  property.additionalOptions &&
                  property.additionalOptions.hideAutoToggle
                }
                hideAlignmentEditor={
                  property.additionalOptions &&
                  property.additionalOptions.hideAlignmentEditor
                }
                robot={this.props.robot}
              />
            );
            break;
          // case "FlexboxEditor":
          //   return (
          //     <FlexboxEditor
          //       key={property.type}
          //       layer={layer}
          //       session={this.props.session}
          //       onEvent={this.onEvent}
          //     />
          //   );
          //   break;
          case "ResizingTypeEditor":
            return (
              <FormGroup noPaddingVertical key={property.type}>
                <ResizingTypeEditor
                  layer={layer}
                  session={this.props.session}
                  onEvent={this.onEvent}
                  additionalOptions={property.additionalOptions}
                  rootLayer={this.props.rootLayer}
                />
              </FormGroup>
            );
            break;
          case "MarginPaddingEditor":
            childMarginBoxContainer = this.willRenderChildMarginBoxContainer(
              layer
            );
            marginPaddingBoxContainer = this.willRenderMarginPaddingBoxContainer(
              layer
            );

            if (childMarginBoxContainer || marginPaddingBoxContainer) {
              return (
                <MarginPaddingEditor
                  childMarginBoxContainer={childMarginBoxContainer}
                  marginBoxContainer={marginPaddingBoxContainer}
                  paddingBoxContainer={marginPaddingBoxContainer}
                  key={property.type}
                  layer={layer}
                  session={this.props.session}
                  onEvent={this.onEvent}
                />
              );
            } else {
              return null;
            }

            break;
          case "DeviceTypeEditor":
            return (
              <DeviceTypeEditor
                key={property.type}
                layer={layer}
                session={this.props.session}
                onEvent={this.onEvent}
                getRecordingConditions={
                  this.props.additionalData.getRecordingConditions
                }
                project={this.props.additionalData.project}
                file={this.props.selectedFile}
                getBoundingBox={this.props.additionalData.getBoundingBox}
              />
            );
            break;
          case "StatusBarEditor":
            return (
              <StatusBarEditor
                key={property.type}
                onEvent={this.onEvent}
                session={this.props.session}
                file={this.props.selectedFile}
                robot={this.props.robot}
              />
            );
            break;
          case "BorderRadiusEditor":
            return (
              <BorderRadiusEditor
                key={property.type}
                layer={layer}
                session={this.props.session}
                onEvent={this.onEvent}
                stylePropName={"style"}
              />
            );
            break;
          case "BorderWidthEditor":
            return (
              <BorderWidthEditor
                key={property.type}
                layer={layer}
                session={this.props.session}
                onEvent={this.onEvent}
                stylePropName={"style"}
                robot={this.props.robot}
                value={property.value}
              />
            );
            break;
          case "LayoutEditor":
            if (layer.showLayoutOptions()) {
              return (
                <LayoutEditor
                  key={property.type}
                  layer={layer}
                  session={this.props.session}
                  onEvent={this.onEvent}
                />
              );
            } else {
              return null;
            }
            break;
          case "ShadowEditor":
            return (
              <ShadowEditor
                key={property.type}
                layer={layer}
                session={this.props.session}
                onEvent={this.onEvent}
                robot={this.props.robot}
                value={property.value}
                properties={property.properties}
              />
            );

            break;
          case "FormControlEditor":
            additionalData = this.props.additionalData;
            return (
              <FormControlsEditor
                session={this.props.session}
                key={property.type}
                layer={layers[layers.length - 1]}
                onEvent={this.onEvent}
                domain={this.props.session.domain as any}
                getSelectedArtboardName={get(
                  additionalData,
                  "getSelectedArtboardName"
                )}
                getAllArtboardsName={get(additionalData, "getAllArtboardsName")}
                validateCallbackPropValue={get(
                  additionalData,
                  "validateCallbackPropValue"
                )}
                robot={this.props.robot}
              />
            );
            break;
          case "CustomConditionalEditor":
            return (
              <CustomConditionalEditor
                getRecordingConditions={
                  this.props.additionalData.getRecordingConditions
                }
                layer={layers[layers.length - 1]}
                session={this.props.session}
                onEvent={this.onEvent}
                key={property.type}
                file={this.props.selectedFile}
              />
            );
            break;
          case "ResetConditionalEditor":
            return (
              <ResetConditionalEditor
                getRecordingConditions={
                  this.props.additionalData.getRecordingConditions
                }
                layer={layers[layers.length - 1]}
                session={this.props.session}
                onEvent={this.onEvent}
                key={property.type}
              />
            );
            break;
          case "TouchableOpacityEditor":
            return (
              <FormGroup noPaddingTop key={property.type} className="pb-0">
                <TouchableOpacityEditor
                  layer={layer}
                  session={this.props.session}
                  onEvent={this.onEvent}
                  domain={this.props.session.domain as any}
                  key={`${property.type}-touchable-opacity-editor`}
                />
              </FormGroup>
            );
            break;
          case "IconEditor":
            return (
              <div className="pb-2" key={property.type}>
                <IconEditor
                  layer={layer}
                  session={this.props.session}
                  onEvent={this.onEvent}
                  domain={this.props.session.domain as any}
                  key={`${property.type}-icon-editor`}
                />
              </div>
            );
            break;
          case "TextToTextInputEditor":
            return (
              <FormGroup noPaddingTop key={property.type}>
                <TextToTextInputEditor
                  layer={layer}
                  session={this.props.session}
                  onEvent={this.onEvent}
                  key={`${property.type}-text-input-editor`}
                />
              </FormGroup>
            );
            break;
          case "ScrollViewEditor":
            return (
              <FormGroup noPaddingTop key={property.type}>
                <ScrollViewEditor
                  layer={layer}
                  session={this.props.session}
                  onEvent={this.onEvent}
                  key={`${property.type}-scroll-view-editor`}
                  changeToScrollViewIsDoable={
                    this.props.changeToScrollViewIsDoable as any
                  }
                  showEditButton={
                    this.props.stageId.includes("layer:") === false
                  }
                />
              </FormGroup>
            );
            break;
          case "ImageEditor":
            return (
              <ImageEditor
                layer={layer}
                session={this.props.session}
                onEvent={this.onEvent}
                key={property.type}
              />
            );
            break;
          case "NavigationEditor":
            additionalData = this.props.additionalData;
            return (
              <FormGroup noPaddingTop key={property.type}>
                <NavigationEditor
                  getSelectedArtboardName={get(
                    additionalData,
                    "getSelectedArtboardName"
                  )}
                  layer={layer}
                  session={this.props.session}
                  onEvent={this.onEvent}
                  getAllArtboardsName={get(
                    additionalData,
                    "getAllArtboardsName"
                  )}
                  showTitle
                />
              </FormGroup>
            );
            break;
          case "LoopEditor":
            return (
              <LoopEditor
                onEvent={this.onEvent}
                layer={layer}
                session={this.props.session}
                key={property.type}
              />
            );
            break;
          case "CarouselEditor":
            return (
              <CarouselEditor
                key={property.type}
                layer={layer}
                session={this.props.session}
                onEvent={this.onEvent}
              />
            );
            break;
          case "TabViewEditor":
            return (
              <TabViewEditor
                key={property.type}
                layer={layer}
                session={this.props.session}
                onEvent={this.onEvent}
                recordingConditionals={this.props.recordingConditionals}
              />
            );
            break;
          case "TabStyleEditor":
            return (
              <TabStyleEditor
                uiSize={get(property, "additionalOptions.uiOptions.size", "m")}
                key={property.type}
                layer={layer}
                session={this.props.session}
                onEvent={this.onEvent}
                showGradient={get(
                  property,
                  "additionalOptions.showGradient",
                  true
                )}
                robot={this.props.robot}
                recordingConditionals={this.props.recordingConditionals}
              />
            );
            break;
          case "PickerEditor":
            return (
              <PickerEditor
                key={property.type}
                layer={layer}
                session={this.props.session}
                getFontsList={this.props.additionalData.getFontsList}
                onEvent={this.onEvent}
                hideAutoToggle={
                  property.additionalOptions &&
                  property.additionalOptions.hideAutoToggle
                }
                hideAlignmentEditor={
                  property.additionalOptions &&
                  property.additionalOptions.hideAlignmentEditor
                }
                resolveNodeValue={resolveNodeValue}
                robot={this.props.robot}
              />
            );
            break;
          default:
            return null;
        }

        return null;
      });
  }
  render() {
    return (
      <Pane uiBackground={800} key={`form-builder-pane`}>
        <Scrollbars
          autoHide
          style={{
            height: "100%"
          }}
        >
          <FormGroup noPadding paddingBottom>
            {this.renderFields(this.props.schema)}
          </FormGroup>
        </Scrollbars>
      </Pane>
    );
  }
}
