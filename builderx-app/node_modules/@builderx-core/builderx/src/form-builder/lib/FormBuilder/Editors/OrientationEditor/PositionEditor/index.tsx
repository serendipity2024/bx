import * as React from "react";
import { IEvent } from "common-interfaces";
import {
  FormCol,
  FormRow,
  InputGroup,
  InputGroupInput,
  InputGroupLeft,
  InputGroupRight,
  Text
} from "components-x";
import { Session } from "session";
import { Layer } from "domain-x";
import { isNil, debounce } from "lodash";
type PositionEditorProps = {
  layers: Array<Layer>;
  session: Session;
  onEvent: (event: IEvent) => void;
  getBoundingBox: () => {
    x: number;
    y: number;
    width: number;
    height: number;
    rotation: number;
  };
  captureErrorForSentry: (err: Error) => void;
};
const renderStyles = ["top", "left", "right", "bottom"];
export default class PositionEditor extends React.PureComponent<
  PositionEditorProps,
  any
> {
  xInputVal: number;
  yInputVal: number;
  topInputRef: any;
  leftInputRef: any;
  componentDidMount() {
    this.props.layers.forEach(layer => {
      layer.props.style.on(renderStyles, this.onUpdate);
      layer.on(["onDragLayer"], this.onUpdateDom);
    });
    const boundingBox = this.props.getBoundingBox();
    this.xInputVal = boundingBox.x;
    this.yInputVal = boundingBox.y;
  }
  componentDidUpdate(prevProps: PositionEditorProps) {
    prevProps.layers.forEach(layer => {
      layer.props.style.off(renderStyles, this.onUpdate);
      layer.off(["onDragLayer"], this.onUpdateDom);
    });
    this.props.layers.forEach(layer => {
      layer.props.style.on(renderStyles, this.onUpdate);
      layer.on(["onDragLayer"], this.onUpdateDom);
    });
    const boundingBox = this.props.getBoundingBox();
    this.xInputVal = boundingBox.x;
    this.yInputVal = boundingBox.y;
  }

  componentWillUnmount() {
    this.props.layers.forEach(layer => {
      layer.props.style.off(renderStyles, this.onUpdate);
      layer.off(["onDragLayer"], this.onUpdateDom);
    });
  }

  onUpdate = (key: any) => {
    this.forceUpdate();
  };

  onUpdateDom = (key: any) => {
    let boundingBox;
    // if (this.props.layers.length === 1) {
    //   const layerOne = get(
    //     this.props.layers,
    //     "0.domainCompiledRefs.0.renderCompiledRef"
    //   );
    //   if (layerOne) {
    //     boundingBox = {
    //       x: layerOne.x,
    //       y: layerOne.y
    //     };
    //   } else {
    //     boundingBox = {
    //       x: 0,
    //       y: 0
    //     };
    //   }
    // } else {
    boundingBox = this.props.getBoundingBox();
    // }

    if (this.topInputRef) {
      this.topInputRef.value = Math.round(boundingBox.y);
    }
    if (this.leftInputRef) {
      this.leftInputRef.value = Math.round(boundingBox.x);
    }
  };

  handleChange = (axis: string, e: any, type: string) => {
    let value = parseFloat(e.target.value);
    value = !isNil(value) && !isNaN(value) ? value : 0;

    var deltaX = 0;
    var deltaY = 0;
    if (axis === "x") {
      if (!isNil(this.xInputVal)) {
        deltaX = value - this.xInputVal;
      }
      this.xInputVal = value;
    }
    if (axis === "y") {
      if (!isNil(this.yInputVal)) {
        deltaY = value - this.yInputVal;
      }
      this.yInputVal = value;
    }

    this.props.onEvent({
      originalEvent: e,
      payload: {
        dimensions: {
          ...this.props.getBoundingBox(),
          [axis]: value
        },
        deltaX: deltaX,
        deltaY: deltaY,
        handle: ["C"]
      },
      type: type,
      target: this.props.layers
    });
  };

  render() {
    const isDoable = !this.props.layers[this.props.layers.length - 1]
      .isFlexChild;
    const disabled = !this.props.layers;
    let boundingBox;
    // if (this.props.layers.length === 1) {
    //   const layerOne = get(
    //     this,
    //     "props.layers.0.domainCompiledRefs.0.renderCompiledRef",
    //     undefined
    //   );
    //   if (layerOne) {
    //     boundingBox = {
    //       x: layerOne.x,
    //       y: layerOne.y
    //     };
    //   } else {
    //     this.props.captureErrorForSentry(
    //       new Error(
    //         "Missing DCRef or RCRef for layer:: " +
    //           JSON.stringify(this.props.layers[0].toJS())
    //       )
    //     );
    //     return null;
    //   }
    // } else {
    //   boundingBox = this.props.getBoundingBox();
    // }
    boundingBox = this.props.getBoundingBox();
    return (
      <FormRow>
        <FormCol first uiSize={4}>
          <InputGroup disabled={!isDoable && !disabled}>
            <InputGroupLeft>
              <Text uiSize="xs">X</Text>
            </InputGroupLeft>
            <InputGroupRight>
              <InputGroupInput
                undo={this.props.session.commandManager.undo}
                redo={this.props.session.commandManager.redo}
                uiSize="l"
                ref={(ref: any) => {
                  this.leftInputRef = ref;
                }}
                validator={e => !isNaN(parseInt(e.target.value, 10))}
                disabled={!isDoable}
                type="number"
                value={Math.round(boundingBox.x)}
                // onChange={(e: any) => this.handleChange("x", e)}

                // onFocus={(e: any) =>
                //   this.handleChange("x", e, "moveResizeLayerAndForget")
                // }
                // onBlur={(e: any) =>
                //   this.handleChange("x", e, "moveResizeLayer")
                // }
                onChange={debounce(
                  (e: any) => this.handleChange("x", e, "moveResizeLayer"),
                  600
                )}
              />
            </InputGroupRight>
          </InputGroup>
        </FormCol>
        <FormCol uiSize={1} />
        <FormCol uiSize={4}>
          <InputGroup disabled={!isDoable && !disabled}>
            <InputGroupLeft>
              <Text uiSize="xs">Y</Text>
            </InputGroupLeft>
            <InputGroupRight>
              <InputGroupInput
                undo={this.props.session.commandManager.undo}
                redo={this.props.session.commandManager.redo}
                uiSize="l"
                ref={(ref: any) => {
                  this.topInputRef = ref;
                }}
                validator={e => !isNaN(parseInt(e.target.value, 10))}
                disabled={!isDoable}
                type="number"
                value={Math.round(boundingBox.y)}
                // onChange={(e: any) => this.handleChange("y", e)}

                // onFocus={(e: any) =>
                //   this.handleChange("y", e, "moveResizeLayerAndForget")
                // }
                // onBlur={(e: any) =>
                //   this.handleChange("y", e, "moveResizeLayer")
                // }
                onChange={debounce(
                  (e: any) => this.handleChange("y", e, "moveResizeLayer"),
                  600
                )}
              />
            </InputGroupRight>
          </InputGroup>
        </FormCol>
      </FormRow>
    );
  }
}
