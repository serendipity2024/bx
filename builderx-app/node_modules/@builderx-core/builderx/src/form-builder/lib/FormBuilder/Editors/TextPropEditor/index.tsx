import * as React from "react";
import {
  FormRow,
  FormCol,
  ColorPicker,
  InputGroup,
  InputGroupLeft,
  Icon,
  InputGroupRight,
  InputGroupInput,
  ButtonGroup,
  Button,
  SelectX
} from "components-x";
import { Layer } from "domain-x";
import TextAlignmentEditor from "../../Components/TextAlignmentEditor";
import {
  toLower,
  find,
  debounce,
  isNil,
  uniqWith,
  filter,
  capitalize
} from "lodash";
import { IEvent, Font, StylePropNameType } from "common-interfaces";
import { Utils } from "utils";
import { Session } from "session";

const FONT_WEIGHT_MAP = Utils.getFontWeightMap();
interface PropType {
  layer: Layer;
  session: Session;
  onEvent: (event: IEvent) => void;
  hideAutoToggle?: boolean;
  hideAlignmentEditor?: boolean;
  getFontsList: () => Array<Font>;
  stylePropName?: StylePropNameType;
  robot: any;
}

const rerenderProps = [
  "fontWeight",
  "fontStyle",
  "letterSpacing",
  "textDecorationLine"
];
class TextDecoration extends React.PureComponent<any, any> {
  componentDidMount() {
    let style = this.props.stylePropName || "style";
    this.props.layer.props[style].on(rerenderProps, this.onUpdate);
  }

  componentDidUpdate(prevProps: any) {
    let style = this.props.stylePropName || "style";
    prevProps.layer.props[style].off(rerenderProps, this.onUpdate);
    this.props.layer.props[style].on(rerenderProps, this.onUpdate);
  }

  componentWillUnmount() {
    let style = this.props.stylePropName || "style";
    this.props.layer.props[style].off(rerenderProps, this.onUpdate);
  }

  onUpdate = () => {
    this.forceUpdate();
  };

  render() {
    const selectedFontObj = this.props.getSelectedFontObj();
    return (
      <FormRow className="pt-2 pb-1">
        <FormCol uiSize={10} first>
          <ButtonGroup uiSize="xl">
            <Button
              className="py-2"
              active={this.props.isBold(selectedFontObj)}
              borderRight
              flexible
              icon={
                <Icon
                  active={this.props.isBold(selectedFontObj)}
                  name="bold"
                  size={12}
                />
              }
              disabled={
                !Utils.checkIfExistsStyle(
                  "bold",
                  selectedFontObj.family,
                  this.props.getFontsList()
                )
              }
              onClick={(event: any) => {
                this.props.changeToBold(selectedFontObj);
              }}
            />
            <Button
              className="py-2"
              active={this.props.isItalic(selectedFontObj)}
              flexible
              icon={
                <Icon
                  active={this.props.isItalic(selectedFontObj)}
                  name="italics"
                  size={12}
                />
              }
              borderRight
              disabled={
                !Utils.checkIfExistsStyle(
                  "italic",
                  selectedFontObj.family,
                  this.props.getFontsList()
                )
              }
              onClick={() => {
                this.props.changeToItalic(selectedFontObj);

                // this.changeToItalic();
              }}
            />
            <Button
              className="py-2"
              flexible
              active={this.props.getDecoration() === "underline"}
              borderRight
              icon={
                <Icon
                  active={this.props.getDecoration() === "underline"}
                  name="icon-underline"
                  size={12}
                />
              }
              onClick={() => {
                this.props.changeDecoration("underline");
              }}
            />

            <Button
              className="py-2"
              flexible
              active={this.props.getDecoration() === "line-through"}
              icon={
                <Icon
                  active={this.props.getDecoration() === "line-through"}
                  name="strikethrough"
                  size={12}
                />
              }
              onClick={() => {
                this.props.changeDecoration("line-through");
              }}
            />
          </ButtonGroup>
        </FormCol>
      </FormRow>
    );
  }
}

const updateArr = [
  "fontFamily",
  "fontWeight",
  "fontStyle",
  "fontSize",
  "color",
  "height",
  "width",
  "letterSpacing",
  "lineHeight",
  "textDecorationLine"
];
export default class TextPropEditor extends React.PureComponent<PropType, any> {
  oldSelectedFontFamily: string;
  oldSelectedFontStyle: string;
  oldSelectedFontWeight: string;

  debouncedFunc = debounce(
    (
      family: Font,
      weight: any,
      style: string,
      familyChange: boolean = true
    ) => {
      this.setFontPreview(family, weight, style, familyChange);
    },
    200
  );

  onUpdate = () => {
    this.forceUpdate();
  };
  backgroundValueOnOpen: any;

  constructor(props: PropType) {
    super(props);
    this.state = {
      typefaceInputValue: "",
      isTypefaceDropdownOpen: false,
      weightInputValue: ""
    };
  }

  componentDidMount() {
    let style = this.props.stylePropName || "style";
    this.props.layer.props[style].on(updateArr, this.onUpdate);
    this.oldSelectedFontFamily = this.props.layer.props.getResolvedStyleAttribute(
      "fontFamily",
      this.props.stylePropName || "style"
    );
    this.oldSelectedFontStyle = this.props.layer.props.getResolvedStyleAttribute(
      "fontStyle",
      this.props.stylePropName || "style"
    );
    this.oldSelectedFontWeight = this.props.layer.props.getResolvedStyleAttribute(
      "fontWeight",
      this.props.stylePropName || "style"
    );
  }
  componentDidUpdate(prevProps: PropType) {
    let style = this.props.stylePropName || "style";
    prevProps.layer.props[style].off(updateArr, this.onUpdate);
    this.props.layer.props[style].on(updateArr, this.onUpdate);
  }
  componentWillUnmount() {
    let style = this.props.stylePropName || "style";
    if (
      this.state.isTypefaceDropdownOpen ||
      this.state.isTextStyleDropdownOpen
    ) {
      this.props.onEvent({
        type: "setFontPreview",
        payload: {
          key: "",
          value: {
            family: this.oldSelectedFontFamily,
            style: this.oldSelectedFontStyle,
            weight: this.oldSelectedFontWeight
          },
          stylePropName: this.props.stylePropName
        },
        target: this.props.layer,
        originalEvent: null
      });

      // this.props.onEvent({
      //   type: "setFontPreview",
      //   payload: {
      //     key: "",
      //     payload: {
      //       fontFamily: this.oldSelectedFontFamily,
      //       fontStyle: this.oldSelectedFontStyle,
      //       fontWeight: this.oldSelectedFontWeight
      //     },
      //     stylePropName: this.props.stylePropName
      //   },
      //   target: this.props.layer,
      //   originalEvent: null
      // });
    }
    this.props.layer.props[style].off(updateArr, this.onUpdate);
  }

  // initializeFonts = () => {
  //   if (this.state.allFonts.length === 0) {
  //     let fontList: any = [
  //       {
  //         postscriptName: undefined,
  //         family: "System",
  //         style: "normal"
  //       }
  //     ];
  //     let fonts = this.props.getFontsList();
  //     if (fonts) {
  //       fontList = [...fontList, ...fonts];
  //     }
  //     // console.log(fonts, "fonts here");
  //     this.setState({
  //       allFonts: fontList,
  //       typefaceList: uniqWith(fontList, (a: any, b: any) => {
  //         return a && b ? a.family === b.family : false;
  //       })
  //     });
  //   }
  //   let typeface = this.props.layer.props.getResolvedStyleAttribute(
  //     "fontFamily",
  //     this.props.stylePropName || "style"
  //   );

  //   let selectedFont: Font | undefined;
  //   if (typeface) {
  //     selectedFont = find(this.state.allFonts, ["postscriptName", typeface]);
  //     if (isNil(selectedFont)) {
  //       selectedFont = find(this.state.allFonts, ["family", typeface]);
  //     }
  //     if (!isNil(selectedFont)) {
  //       this.setState({ selectedTypeFace: selectedFont });
  //     }
  //   }
  //   // console.log(selectedFont, "hello here typespa");
  // };

  getSpacing = () => {
    const { layer } = this.props;
    return {
      character: layer.props.getResolvedStyleAttribute("letterSpacing"),
      line: layer.props.getResolvedStyleAttribute("lineHeight")
      // paragraph: layer.props.getResolvedStyleAttribute("paragraphSpacing")
    };
  };

  isBold(selectedFontObj: any) {
    let fontWeight;
    if (selectedFontObj.family === "System") {
      fontWeight = selectedFontObj.weight;
    }

    fontWeight = FONT_WEIGHT_MAP.get(
      Utils.getFontVariant(selectedFontObj.weight, selectedFontObj.style)
    );
    if (fontWeight && fontWeight.displayName.indexOf("Bold") > -1) {
      return true;
    }
    return false;
  }

  isItalic = (selectedFontObj: any) => {
    const fontWeight = FONT_WEIGHT_MAP.get(
      Utils.getFontVariant(selectedFontObj.weight, selectedFontObj.style)
    );
    if (fontWeight && fontWeight.displayName.indexOf("Italic") > -1) {
      return true;
    }
    return false;
    // let weight;
    // if (
    //   this.state.selectedTypeFace.type === "system" &&
    //   this.state.fontStyle === "italic"
    // ) {
    //   return true;
    // }

    // const fontWeight = FONT_WEIGHT_MAP.get(weight + (style ? style : ""));
    // if (weight && weight.displayName.indexOf("Italic") > -1) {
    //   return true;
    // }
    // return false;

    // let selectedItem = this.state.selectedTypeFace;
    // weight = FONT_WEIGHT_MAP.get(selectedItem.style);

    // if (weight && weight.displayName.indexOf("Italic") > -1) {
    //   return true;
    // }
    return false;
  };

  getDecoration = () => {
    const { layer } = this.props;
    const decoration = layer.props.getResolvedStyleAttribute(
      "textDecorationLine"
    );
    return decoration;
  };

  changeDecoration = (value: string | undefined) => {
    if (value === this.getDecoration()) {
      value = undefined;
    }
    this.props.onEvent({
      type: "setStyleAttribute",
      payload: {
        key: "textDecorationLine",
        value: value,
        stylePropName: this.props.stylePropName
      },
      target: this.props.layer,
      originalEvent: null
    });
  };

  changeToBold = (selectedFontObj: any) => {
    const fontsList = this.props.getFontsList();
    let tempRes;
    let newDisplayName;

    let family = selectedFontObj.family;
    let fontWeight = selectedFontObj.weight;
    let fontStyle = selectedFontObj.style;

    if (selectedFontObj.family === "System") {
      if (this.isBold(selectedFontObj)) {
        fontWeight = undefined;
      } else {
        fontWeight = "bold";
      }
      family = undefined;
    } else {
      const fontWeightStyle = Utils.getFontVariant(
        "bold",
        selectedFontObj.style
      );
      if (this.isBold(selectedFontObj)) {
        const weight = FONT_WEIGHT_MAP.get(fontWeightStyle);
        const boldIndex = weight.displayName.indexOf("Bold");
        newDisplayName = weight.displayName
          .substring(boldIndex + "Bold".length)
          .trim();
      } else {
        const weight = FONT_WEIGHT_MAP.get(fontWeightStyle);
        // console.log(selectedItem.style, "hello here");
        const italicIndex = weight.displayName.indexOf("Italic");
        if (italicIndex > -1) {
          newDisplayName = "Bold " + weight.displayName.substring(italicIndex);
        } else {
          newDisplayName = "Bold";
        }
      }
      const weightMap = FONT_WEIGHT_MAP.get(newDisplayName);
      // if (this.state.selectedTypeFace.type === "system") {
      // let style;
      // if (!weightMap) {
      //   style = "normal";
      //   this.handleChangeFontWeight(style);
      // } else {
      //   style = weightMap.values[0];
      //   this.handleChangeFontWeight("bold");
      // }
      // } else {
      if (!weightMap) {
        tempRes = Utils.getDefaultTypeFace(selectedFontObj.family, fontsList);
      } else {
        tempRes = Utils.checkIfExistsStyle(
          weightMap.values[0],
          selectedFontObj.family,
          fontsList
        );
      }

      family = tempRes.family;
      fontWeight = Utils.getFontWeight(tempRes.style);
      fontStyle = Utils.getFontStyle(tempRes.style);
    }
    this.props.onEvent({
      type: "setFontPreview",
      payload: {
        key: "",
        value: {
          family: family,
          style: fontStyle,
          weight: fontWeight
        },
        stylePropName: this.props.stylePropName
      },
      target: this.props.layer,
      originalEvent: null
    });
    // this.setFontPreview(tempRes.family, fontWeight, fontStyle);

    // selectedItem = tempRes ? tempRes : selectedItem;
    // if (selectedItem) {
    // Utils.loadFont(selectedItem);

    // }
    // }
    this.setState({});
  };
  changeToItalic = (selectedFontObj: any) => {
    const fontsList = this.props.getFontsList();
    // let selectedItem = this.state.selectedTypeFace;
    let tempRes;
    let newDisplayName;

    let family = selectedFontObj.family;
    let fontWeight = selectedFontObj.weight;
    let fontStyle = selectedFontObj.style;

    if (selectedFontObj.family === "System") {
      if (this.isItalic(selectedFontObj)) {
        fontStyle = "normal";
      } else {
        fontStyle = "italic";
      }
      family = undefined;
    } else {
      const fontWeightStyle = Utils.getFontVariant(
        selectedFontObj.weight,
        "italic"
      );
      if (this.isItalic(selectedFontObj)) {
        const weight = FONT_WEIGHT_MAP.get(fontWeightStyle);
        const italicIndex = weight.displayName.indexOf("Italic");
        newDisplayName = weight.displayName.substring(0, italicIndex).trim();
      } else {
        const weight = FONT_WEIGHT_MAP.get(fontWeightStyle);
        newDisplayName = weight.displayName;
      }
      const weightMap = FONT_WEIGHT_MAP.get(newDisplayName);
      // if (this.state.selectedTypeFace.type === "system") {
      //   let style;
      //   if (this.isItalic(selectedFontObj)) {
      //     style = "normal";
      //     this.handleChangeFontStyle(style);
      //   } else {
      //     this.handleChangeFontStyle("italic");
      //   }
      // } else {
      if (!weightMap) {
        tempRes = Utils.checkIfExistsStyle(
          "normal",
          selectedFontObj.family,
          fontsList
        );
      } else {
        tempRes = Utils.checkIfExistsStyle(
          weightMap.values[0],
          selectedFontObj.family,
          fontsList
        );
      }

      fontWeight = Utils.getFontWeight(tempRes.style);
      fontStyle = Utils.getFontStyle(tempRes.style);
      family = tempRes.family;
    }

    this.props.onEvent({
      type: "setFontPreview",
      payload: {
        key: "",
        value: {
          family: family,
          style: fontStyle,
          weight: fontWeight
        },
        stylePropName: this.props.stylePropName
      },
      target: this.props.layer,
      originalEvent: null
    });
  };

  handleChangeSize = (
    size: any,
    type:
      | "setStyleAttribute"
      | "setStyleAttributeAndSkip"
      | "setStyleAttributeAndForget"
  ) => {
    if (!size) {
      size = 0;
    }
    size = parseInt(size, 10);
    this.props.onEvent({
      type: type,
      payload: {
        key: "fontSize",
        value: size < 0 ? 14 : size,
        stylePropName: this.props.stylePropName
      },
      target: this.props.layer,
      originalEvent: null
    });
  };
  // handleChangeFontWeight1 = (fontWeight: any) => {
  //   if (!fontWeight) {
  //     return;
  //   }
  //   this.setState(
  //     {
  //       fontWeight: fontWeight,
  //       selectedTypeFace: {
  //         ...this.state.selectedTypeFace,
  //         style: fontWeight
  //       }
  //     },
  //     () => {
  //       this.props.onEvent({
  //         type: "setStyleAttribute",
  //         payload: {
  //           key: "fontWeight",
  //           value: this.state.fontWeight,
  //           stylePropName: this.props.stylePropName
  //         },
  //         target: this.props.layer,
  //         originalEvent: null
  //       });
  //     }
  //   );
  // };
  handleChangeFontStyle = (fontStyle: any, type: string = "") => {
    if (!fontStyle) {
      return;
    }
    this.setState(
      {
        fontStyle: fontStyle,
        selectedTypeFace: {
          ...this.state.selectedTypeFace,
          style: fontStyle
        }
      },
      () => {
        this.props.onEvent({
          type: "setStyleAttribute" + type,
          payload: {
            key: "fontStyle",
            value: fontStyle,
            stylePropName: this.props.stylePropName
          },
          target: this.props.layer,
          originalEvent: null
        });
      }
    );
  };
  handleChangeColor = (color: string, type?: string) => {
    if (!color) {
      return;
    }
    this.props.onEvent({
      type: type ? type : "setStyleAttributeAndSkip",
      payload: {
        key: "color",
        value: color,
        stylePropName: this.props.stylePropName
      },
      target: this.props.layer,
      originalEvent: null
    });
  };

  onPickerOpen = () => {
    this.backgroundValueOnOpen = this.props.layer.props.getResolvedStyleAttribute(
      "color"
    );
    this.handleChangeColor(
      this.backgroundValueOnOpen,
      "setStyleAttributeAndForget"
    );
  };
  onPickerClose = () => {
    const backgroundValue = this.props.layer.props.getResolvedStyleAttribute(
      "color"
    );

    if (backgroundValue === this.backgroundValueOnOpen) {
      return;
    }

    this.handleChangeColor(backgroundValue, "setStyleAttribute");
  };

  handleChangeSpacing = (
    property: any,
    e: any,
    type:
      | "setStyleAttribute"
      | "setStyleAttributeAndSkip"
      | "setStyleAttributeAndForget"
  ) => {
    if (!property) {
      return;
    }
    let value = parseFloat(e.target.value);
    value = !isNil(value) && !isNaN(value) ? value : 0;
    const key = property === "character" ? "letterSpacing" : "lineHeight";
    this.props.onEvent({
      type: type,
      payload: {
        key,
        value,
        stylePropName: this.props.stylePropName
      },
      target: this.props.layer,
      originalEvent: null
    });
  };

  handleChangeTypeface = (selectedItem: any) => {
    if (!selectedItem) {
      return;
    }
    this.props.onEvent({
      type: "setStyleAttribute",
      payload: {
        key: "fontFamily",
        value: this.state.selectedTypeFace.postscriptName,
        stylePropName: this.props.stylePropName
      },
      target: this.props.layer,
      originalEvent: null
    });
    this.setState({
      oldSelectedFontStyle: this.state.selectedTypeFace
    });
  };

  getDisplayValue = (val: any) => {
    const value = FONT_WEIGHT_MAP.get(val.toString());
    return (value && value.displayName) || capitalize(val);
  };
  setFontPreview = (
    family: any,
    weight: any,
    style: any,
    familyChange: boolean = true
  ) => {
    let tempRes: any;

    const fontsList = this.props.getFontsList();
    const variant = Utils.getFontVariant(weight, style);
    // if (familyChange) {
    tempRes = find(fontsList, (o: any) => {
      if (o.family === family && o.style === variant) {
        return o;
      }
    });

    if (!tempRes) {
      tempRes = Utils.getDefaultTypeFace(family, fontsList);
    }
    if (tempRes) {
      Utils.loadFont({
        family: tempRes.family,
        style: tempRes.style
      });
    }
    let fontStyle = undefined;
    let fontWeight = undefined;
    if (tempRes) {
      fontStyle = Utils.getFontStyle(tempRes.style);
      fontWeight = tempRes.weight
        ? tempRes.weight
        : Utils.getFontWeight(tempRes.style);
    }
    this.props.onEvent({
      type: "setFontPreviewAndSkip",
      payload: {
        key: "",
        value: {
          family: family,
          style: fontStyle,
          weight: fontWeight
        },
        stylePropName: this.props.stylePropName,
        noPreserve: true
      },
      target: this.props.layer,
      originalEvent: null
    });
  };

  handleChangeFontFamily = (selectedItem: string) => {
    if (!selectedItem) {
      return;
    }
    this.props.onEvent({
      type: "setStyleAttribute",
      payload: {
        key: "fontFamily",
        value: selectedItem,
        stylePropName: this.props.stylePropName
      },
      target: this.props.layer,
      originalEvent: null
    });
    this.oldSelectedFontFamily = selectedItem;
  };

  handleChangeFontWeight = (selectedItem: string, type: string = "") => {
    if (!selectedItem) {
      return;
    }
    this.props.onEvent({
      type: "setStyleAttribute" + type,
      payload: {
        key: "fontWeight",
        value: Utils.getFontWeight(selectedItem),
        stylePropName: this.props.stylePropName
      },
      target: this.props.layer,
      originalEvent: null
    });
    this.oldSelectedFontWeight = selectedItem;
  };

  getSelectedFontObj = () => {
    let selectedFontFamily =
      this.props.layer.props.getResolvedStyleAttribute(
        "fontFamily",
        this.props.stylePropName || "style"
      ) || "System";

    let selectedFontWeight =
      this.props.layer.props.getResolvedStyleAttribute(
        "fontWeight",
        this.props.stylePropName || "style"
      ) || "regular";

    const selectedFontStyle = this.props.layer.props.getResolvedStyleAttribute(
      "fontStyle",
      this.props.stylePropName || "style"
    );

    const selectedFontObj = {
      family: selectedFontFamily,
      style: selectedFontStyle,
      weight: selectedFontWeight
    };
    return selectedFontObj;
  };
  render() {
    const { layer } = this.props;
    const fontsList = this.props.getFontsList();
    let fontFamilyList = uniqWith(fontsList, (a: any, b: any) => {
      return a && b ? a.family === b.family : false;
    }).map(font => font.family);
    fontFamilyList.unshift("System");
    const selectedFontObj = this.getSelectedFontObj();

    let weightList = filter(fontsList, (o: any) => {
      const displayName = this.getDisplayValue(o.style);
      if (displayName.indexOf("Italic") > -1) {
        return false;
      }
      return (
        o.family === (selectedFontObj.family ? selectedFontObj.family : "")
      );
    }).map(font => font.style);

    if (selectedFontObj.family === "System") {
      weightList = [
        "100",
        "200",
        "300",
        "400",
        "500",
        "600",
        "700",
        "800",
        "900"
      ];
    }
    const size = layer.props.getResolvedStyleAttribute("fontSize");
    const color = layer.props.getResolvedStyleAttribute("color");
    const spacing = this.getSpacing();
    const isAuto =
      this.props.layer.isWidthAuto && this.props.layer.isHeightAuto;
    return (
      <>
        <FormRow>
          <FormCol uiSize={10} first>
            <SelectX
              options={fontFamilyList}
              value={
                this.state.isTypefaceDropdownOpen
                  ? this.state.typefaceInputValue
                  : selectedFontObj.family
              }
              renderOption={(option: any) => option}
              renderValue={(option: any) => option}
              extractValue={(option: any) => option}
              onChange={this.handleChangeFontFamily}
              placeholder=""
              tooltip="Font Family"
              onTextChange={(text: string) => {
                if (text !== undefined) {
                  this.setState({ typefaceInputValue: text });
                }
              }}
              filter={(inputValue: string) =>
                fontFamilyList.filter((option: any) => {
                  return (
                    option &&
                    (!this.state.typefaceInputValue ||
                      toLower(option).includes(
                        toLower(this.state.typefaceInputValue)
                      ))
                  );
                })
              }
              onOpenStateChange={(isOpen: boolean) => {
                if (isOpen) {
                  this.setState({
                    isTypefaceDropdownOpen: true
                  });
                  this.oldSelectedFontFamily = selectedFontObj.family;
                } else {
                  this.setState({ isTypefaceDropdownOpen: false });
                }
              }}
              onHoverOption={(option: any) => {
                this.debouncedFunc(
                  option,
                  selectedFontObj.weight,
                  selectedFontObj.style
                );
              }}
              typeface={(family: string) => {
                return Utils.getDefaultTypeFace(family, fontsList);
              }}
            />
          </FormCol>

          <FormCol uiSize={3}>
            <InputGroupInput
              undo={this.props.session.commandManager.undo}
              redo={this.props.session.commandManager.redo}
              type="number"
              uiSize="m"
              validator={e => !isNaN(parseInt(e.target.value, 10))}
              value={!isNil(size) ? parseInt(size, 10) : 14}
              onChange={debounce(
                (e: any) =>
                  this.handleChangeSize(e.target.value, "setStyleAttribute"),
                600
              )}
              // onFocus={(e: any) =>
              //   this.handleChangeSize(
              //     e.target.value,
              //     "setStyleAttributeAndForget"
              //   )
              // }
              // onBlur={(e: any) =>
              //   this.handleChangeSize(e.target.value, "setStyleAttribute")
              // }
            />
          </FormCol>
        </FormRow>
        <FormRow>
          <SelectX
            options={weightList}
            value={
              this.state.isTextStyleDropdownOpen
                ? this.state.weightInputValue
                : this.getDisplayValue(selectedFontObj.weight)
            }
            renderOption={(option: any) => this.getDisplayValue(option)}
            renderValue={(option: any) => option}
            extractValue={(option: any) => option}
            onChange={this.handleChangeFontWeight}
            placeholder=""
            tooltip="Font Style"
            filter={(inputValue: string) =>
              weightList.filter((o: any) => {
                return (
                  !this.state.weightInputValue ||
                  toLower(this.getDisplayValue(o)).includes(
                    toLower(this.state.weightInputValue)
                  )
                );
              })
            }
            onTextChange={(text: string) => {
              if (text !== undefined) {
                this.setState({ weightInputValue: this.getDisplayValue(text) });
              }
            }}
            optionStyle={(option: any) => {
              return {
                fontWeight: option
              };
            }}
            onOpenStateChange={(isOpen: boolean) => {
              if (isOpen) {
                this.setState({ isTextStyleDropdownOpen: true });
                this.oldSelectedFontWeight = selectedFontObj.weight;
              } else {
                this.setState({ isTextStyleDropdownOpen: false });
              }
            }}
            onHoverOption={(option: any) => {
              this.debouncedFunc(
                selectedFontObj.family,
                option,
                selectedFontObj.style
              );
            }}
          />
          <FormCol uiSize={3}>
            <ColorPicker
              alignRight
              value={color}
              defaultColor="#000000"
              onChangeColor={this.handleChangeColor}
              onPickerClose={this.onPickerClose}
              onPickerOpen={this.onPickerOpen}
              robot={this.props.robot}
            />
          </FormCol>
        </FormRow>
        <FormRow />

        <TextDecoration
          {...this.props}
          isBold={this.isBold}
          getSelectedFontObj={this.getSelectedFontObj}
          getFontsList={this.props.getFontsList}
          changeToBold={this.changeToBold}
          isItalic={this.isItalic}
          changeToItalic={this.changeToItalic}
          getDecoration={this.getDecoration}
          changeDecoration={this.changeDecoration}
        />
        {!this.props.hideAlignmentEditor && (
          <TextAlignmentEditor
            layer={this.props.layer}
            onEvent={this.props.onEvent}
          />
        )}
        <FormRow className="pt-2 pb-1">
          <FormCol first>
            <InputGroup>
              <InputGroupLeft>
                <Icon name="letter-spacing" size={13} />
              </InputGroupLeft>
              <InputGroupRight paddingLeft>
                <InputGroupInput
                  undo={this.props.session.commandManager.undo}
                  redo={this.props.session.commandManager.redo}
                  type="number"
                  uiSize="m"
                  validator={e => !isNaN(parseFloat(e.target.value))}
                  value={Math.round(spacing.character || 0)}
                  // onFocus={(e: any) =>
                  //   this.handleChangeSpacing(
                  //     "character",
                  //     e,
                  //     "setStyleAttributeAndForget"
                  //   )
                  // }
                  onChange={debounce(
                    (e: any) =>
                      this.handleChangeSpacing(
                        "character",
                        e,
                        "setStyleAttribute"
                      ),
                    600
                  )}
                  // onBlur={(e: any) =>
                  //   this.handleChangeSpacing(
                  //     "character",
                  //     e,
                  //     "setStyleAttribute"
                  //   )
                  // }
                />
              </InputGroupRight>
            </InputGroup>
          </FormCol>
          <FormCol>
            <InputGroup>
              <InputGroupLeft>
                <Icon name="line-spacing" size={13} />
              </InputGroupLeft>
              <InputGroupRight paddingLeft>
                <InputGroupInput
                  undo={this.props.session.commandManager.undo}
                  redo={this.props.session.commandManager.redo}
                  uiSize="m"
                  type="number"
                  validator={e => !isNaN(parseFloat(e.target.value))}
                  value={!isNil(spacing.line) ? spacing.line : 14}
                  // onFocus={(e: any) =>
                  //   this.handleChangeSpacing(
                  //     "line",
                  //     e,
                  //     "setStyleAttributeAndForget"
                  //   )
                  // }
                  onChange={debounce(
                    (e: any) =>
                      this.handleChangeSpacing("line", e, "setStyleAttribute"),
                    600
                  )}
                  // onBlur={(e: any) =>
                  //   this.handleChangeSpacing("line", e, "setStyleAttribute")
                  // }
                />
              </InputGroupRight>
            </InputGroup>
          </FormCol>
        </FormRow>
        {this.props.layer.type !== "textInput" && !this.props.hideAutoToggle && (
          <FormRow className="py-2">
            <FormCol uiSize={10} first>
              <ButtonGroup uiSize="xs">
                <Button
                  active={isAuto}
                  borderRight
                  flexible
                  caption="Auto"
                  onClick={(event: any) => {
                    this.props.onEvent({
                      type: "changeToAuto",
                      payload: {},
                      target: this.props.layer,
                      originalEvent: event
                    });
                  }}
                />
                <Button
                  active={!isAuto}
                  flexible
                  caption="Fixed"
                  onClick={() => {
                    this.props.onEvent({
                      type: "changeToFixed",
                      payload: {},
                      target: this.props.layer,
                      originalEvent: event
                    });
                  }}
                />
              </ButtonGroup>
            </FormCol>
          </FormRow>
        )}
      </>
    );
  }
}
