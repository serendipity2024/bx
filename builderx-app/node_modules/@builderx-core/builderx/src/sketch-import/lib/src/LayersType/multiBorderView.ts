import { omit } from "lodash";
import getStyle from "./style";
import { getStyleName, getColor } from "./style/styleUtils";
import oldViewCreate from "./view";
import newViewCreate from "./NewLayers/newView";

export default async function multiBorderViewCreate(
  layers: any,
  layerIndex: number,
  frame: any,
  style: any,
  isMasked: boolean,
  scalingFactor: number,
  isAvatar: boolean,
  convertedFromSvg: boolean,
  isInSymbol: boolean,
  symbolID: string,
  sketchVersion: number,
  enableFixedStyling: boolean,
  activeBordersList: Array<any>,
  convertSvgToSymbol: boolean,
  images: Map<string, any>
) {
  if (!layers[layerIndex]) {
    return {};
  }
  const viewCreate = sketchVersion >= 52 ? newViewCreate : oldViewCreate;
  let bordersCount = activeBordersList.length;
  let dataContainer: { artboard: any; symbols: Array<any> } = {
    artboard: {},
    symbols: []
  };
  try {
    dataContainer.artboard = getViewObject(
      layers[layerIndex],
      frame,
      isMasked,
      scalingFactor,
      isAvatar,
      enableFixedStyling,
      convertedFromSvg,
      0
    );
    if (dataContainer.artboard) {
      dataContainer.artboard.props.style = omit(
        dataContainer.artboard.props.style,
        ["overflow", "backgroundColor", "borderColor", "borderWidth"]
      );
    }
    if (layers[layerIndex].isLocked) {
      dataContainer.artboard.locked = true;
    }
    for (let borderIndex = 0; borderIndex < bordersCount - 1; borderIndex++) {
      let posArr = [1 / 2, 0, 1];
      let thicknessToDeduct =
        activeBordersList[bordersCount - 1].thickness *
        posArr[activeBordersList[bordersCount - 1].position];

      let borderLayerThickness =
        activeBordersList[borderIndex].thickness *
          posArr[activeBordersList[borderIndex].position] -
        thicknessToDeduct;
      if (borderLayerThickness <= 0) {
        continue;
      }
      let childView: any = getViewObject(
        layers[layerIndex],
        layers[layerIndex].frame,
        true,
        scalingFactor,
        isAvatar,
        enableFixedStyling,
        false,
        borderLayerThickness
      );

      if (childView && childView.props) {
        childView.props.style.backgroundColor = "transparent";
        childView.props.style.borderWidth = borderLayerThickness;
        childView.props.style.borderColor = getColor(
          activeBordersList[borderIndex].color
        );
      }
      dataContainer.artboard.children.push(childView);
    }

    let mainChildView: any = await viewCreate(
      layers,
      layerIndex,
      layers[layerIndex].frame,
      style,
      false,
      true,
      scalingFactor,
      convertedFromSvg,
      isAvatar,
      isInSymbol,
      symbolID,
      sketchVersion,
      enableFixedStyling,
      convertSvgToSymbol,
      images
    );
    let tempBorderThickness =
      activeBordersList[bordersCount - 1].position === 2
        ? activeBordersList[bordersCount - 1].thickness
        : activeBordersList[bordersCount - 1].thickness / 2;
    if (mainChildView && mainChildView.props) {
      mainChildView.props.style.borderWidth = tempBorderThickness;
      mainChildView.props.style.borderColor = getColor(
        activeBordersList[bordersCount - 1].color
      );
    }
    dataContainer.artboard.children.push(mainChildView.artboard);
  } catch (error) {
    console.log("JSON read error in multiBorderView", error);
  }
  return dataContainer;
}

function getViewObject(
  layer: any,
  frame: any,
  isMasked: boolean,
  scalingFactor: number,
  isAvatar: boolean,
  enableFixedStyling: boolean,
  isBorderLayer: boolean,
  borderThickness: number
) {
  return {
    type: "view",
    locked: false,
    styleName: "borderContainer" + getStyleName(layer.name),
    import: {
      layerName: "View",
      packageName: "native",
      isDefaultImport: false
    },
    template: {
      centerVertical: false,
      centerHorizontal: false
    },
    props: {
      style: getStyle(
        layer,
        frame,
        isMasked,
        scalingFactor,
        isBorderLayer,
        isAvatar,
        enableFixedStyling,
        borderThickness
      )
    },
    children: []
  };
}
