import { isEmpty } from "lodash";
import viewCreate from "../LayersType/view";
import textCreate from "../LayersType/text";
import imageCreate from "../LayersType/image";
import symbolCreate from "../LayersType/symbolInstance";
import svgCreate from "../LayersType/svgLayer";
import SvgAsSymbolCreate from "../LayersType/SvgAsSymbol";
import multiBorderViewCreate from "../LayersType/multiBorderView";
import { getActiveBorderList } from "../LayersType/style/styleUtils";
import canConvertToAvatar from "../utils/canConvertToAvatar";
import { getMaskData } from "../utils/NameMapsStore";

export default async function oldLayerCreate(
  layers: any,
  layerIndex: any,
  frame: any,
  style: any,
  isMasked: boolean,
  scalingFactor: number,
  isInSymbol: boolean,
  symbolID: string,
  sketchVersion: number,
  enableFixedStyling: boolean,
  convertSvgToSymbol: boolean,
  images: Map<string, any>
) {
  if (!layers[layerIndex]) {
    return {};
  }
  let dataContainer: { artboard: any; symbols: Array<any> } = {
    artboard: {},
    symbols: []
  };
  let child: any = {};
  switch (layers[layerIndex]._class) {
    case "group":
      child = await viewCreate(
        layers,
        layerIndex,
        frame,
        style,
        true,
        isMasked,
        scalingFactor,
        false,
        false,
        isInSymbol,
        symbolID,
        sketchVersion,
        enableFixedStyling,
        convertSvgToSymbol,
        images
      );
      isMasked = false;
      break;
    case "text":
      child = textCreate(
        layers[layerIndex],
        frame,
        isMasked,
        scalingFactor,
        isInSymbol,
        symbolID,
        sketchVersion,
        enableFixedStyling
      );
      break;
    case "symbolInstance":
      child = symbolCreate(
        layers[layerIndex],
        frame,
        isMasked,
        scalingFactor,
        isInSymbol,
        symbolID,
        enableFixedStyling,
        false
      );
      break;
    case "bitmap": // image case
      child = await imageCreate(
        layers,
        layerIndex,
        frame,
        style,
        layers[layerIndex].image._ref,
        isMasked,
        scalingFactor,
        sketchVersion,
        enableFixedStyling,
        convertSvgToSymbol,
        images
      );
      break;
    case "shapeGroup":
      let activeBordersList: any =
        layers[layerIndex].style &&
        layers[layerIndex].style.borders &&
        layers[layerIndex].style.borders.length > 1
          ? getActiveBorderList(layers[layerIndex].style.borders)
          : [];
      if (
        layers[layerIndex].style &&
        layers[layerIndex].style.fills &&
        layers[layerIndex].style.fills.length > 0 &&
        layers[layerIndex].style.fills[0].fillType &&
        layers[layerIndex].style.fills[0].fillType === 4 &&
        layers[layerIndex].style.fills[0].image &&
        layers[layerIndex].style.fills[0].image._ref &&
        layers[layerIndex].style.fills[0].isEnabled
      ) {
        child = await imageCreate(
          layers,
          layerIndex,
          frame,
          style,
          layers[layerIndex].style.fills[0].image._ref,
          isMasked,
          scalingFactor,
          sketchVersion,
          enableFixedStyling,
          convertSvgToSymbol,
          images
        );
      } else if (
        layers[layerIndex].layers &&
        layers[layerIndex].layers.length > 0 &&
        ((layers[layerIndex].layers[0]._class === "rectangle" &&
          layers[layerIndex].layers[0].points &&
          layers[layerIndex].layers[0].points.length === 4) ||
          (layers[layerIndex].hasClippingMask &&
            canConvertToAvatar(layers[layerIndex].layers))) &&
        layers[layerIndex].layers[0].booleanOperation === -1 &&
        activeBordersList.length > 1
      ) {
        child = await multiBorderViewCreate(
          layers,
          layerIndex,
          frame,
          style,
          isMasked,
          scalingFactor,
          canConvertToAvatar(layers[layerIndex].layers),
          true,
          isInSymbol,
          symbolID,
          sketchVersion,
          enableFixedStyling,
          activeBordersList,
          convertSvgToSymbol,
          images
        );
      } else if (
        layers[layerIndex].layers &&
        layers[layerIndex].layers.length > 0 &&
        isEmpty(getMaskData().style) &&
        ((layers[layerIndex].layers[0]._class === "rectangle" &&
          ((layers[layerIndex].layers[0].points &&
            layers[layerIndex].layers[0].points.length === 4) ||
            (layers[layerIndex].layers[0].path &&
              layers[layerIndex].layers[0].path.points &&
              layers[layerIndex].layers[0].path.points.length === 4))) ||
          (layers[layerIndex].hasClippingMask &&
            canConvertToAvatar(layers[layerIndex].layers))) &&
        layers[layerIndex].layers[0].booleanOperation === -1
      ) {
        child = await viewCreate(
          layers,
          layerIndex,
          frame,
          style,
          false,
          isMasked,
          scalingFactor,
          true,
          canConvertToAvatar(layers[layerIndex].layers),
          isInSymbol,
          symbolID,
          sketchVersion,
          enableFixedStyling,
          convertSvgToSymbol,
          images
        );
      } else if (convertSvgToSymbol) {
        child = await SvgAsSymbolCreate(
          layers,
          layerIndex,
          frame,
          isMasked,
          scalingFactor,
          sketchVersion,
          enableFixedStyling
        );
      } else {
        child = await svgCreate(
          layers,
          layerIndex,
          frame,
          isMasked,
          scalingFactor,
          enableFixedStyling,
          false
        );
      }
      break;
    default:
      child = {};
      break;
  }
  if (!isEmpty(child)) {
    if (child.artboard && !isEmpty(child.artboard)) {
      dataContainer.artboard = child.artboard;
      if (child.symbols && !isEmpty(child.symbols)) {
        dataContainer.symbols = dataContainer.symbols.concat(child.symbols);
      }
    }
    if (layers[layerIndex] && layers[layerIndex].layers) {
      if (
        dataContainer.artboard &&
        !isEmpty(dataContainer.artboard) &&
        !dataContainer.artboard.children
      ) {
        dataContainer.artboard.children = [];
      }
      if (child.symbols && !isEmpty(child.symbols)) {
        dataContainer.symbols = dataContainer.symbols.concat(child.symbols);
      }
      if (
        !(
          layers[layerIndex]._class === "shapeGroup" &&
          layers[layerIndex].layers &&
          layers[layerIndex].layers.length > 0 &&
          ((layers[layerIndex].layers[0]._class === "rectangle" &&
            layers[layerIndex].layers[0].points &&
            layers[layerIndex].layers[0].points.length === 4) ||
            (layers[layerIndex].hasClippingMask &&
              canConvertToAvatar(layers[layerIndex].layers))) &&
          layers[layerIndex].layers[0].booleanOperation &&
          layers[layerIndex].layers[0].booleanOperation === -1
        )
      ) {
        for (let j = 0; j < layers[layerIndex].layers.length; j++) {
          let childLayer: any = await oldLayerCreate(
            layers[layerIndex].layers,
            j,
            layers[layerIndex].frame,
            layers[layerIndex].style,
            isMasked,
            scalingFactor,
            isInSymbol,
            symbolID,
            sketchVersion,
            enableFixedStyling,
            convertSvgToSymbol,
            images
          );
          if (
            !isEmpty(childLayer) &&
            childLayer.artboard &&
            !isEmpty(childLayer.artboard)
          ) {
            dataContainer.artboard.children.push(childLayer.artboard);
          }
          if (
            !isEmpty(childLayer) &&
            childLayer.symbols &&
            !isEmpty(childLayer.symbols)
          ) {
            dataContainer.symbols = dataContainer.symbols.concat(
              childLayer.symbols
            );
          }
          if (
            layers[layerIndex].layers[j].hasClippingMask &&
            layers[layerIndex].layers[j].layers &&
            layers[layerIndex].layers[j].layers.length > 0 &&
            ((layers[layerIndex].layers[j].layers[0]._class === "rectangle" &&
              layers[layerIndex].layers[j].layers[0].points &&
              !layers[layerIndex].layers[j].layers[0].edited) ||
              canConvertToAvatar(layers[layerIndex].layers[j].layers))
          ) {
            let tempI = j + 1;
            while (
              layers[layerIndex].layers[tempI] &&
              !layers[layerIndex].layers[tempI].shouldBreakMaskChain &&
              tempI < layers[layerIndex].layers.length
            ) {
              tempI++;
            }
            j = tempI - 1;
          }
        }
      }
    }
  }
  return dataContainer;
}
