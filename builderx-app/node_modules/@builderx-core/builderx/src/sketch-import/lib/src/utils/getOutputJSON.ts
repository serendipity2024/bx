import { isEmpty, get, concat } from "lodash";
import { getValidName } from "./";
import artboardClassCreate from "./../ParentLayers/Artboard";
import symbolClassCreate from "./../ParentLayers/Symbol";
import {
  addParentEntry,
  getSceneDims,
  registerSceneDimX,
  registerSceneDimY,
  resetLayerNameMap,
  clearSceneDims
} from "./NameMapsStore";
import { getChangedName } from "./randomNameGenerator";
import { ExtractedData, ConvertedData } from "./types";
export default async function getOutputJSON(
  extractedData: ExtractedData,
  sketchVersion: number,
  scalingFactor: number,
  convertSvgToSymbol: boolean,
  artboardsList: any,
  initialPosition: { x: number; y: number },
  existingFiles: { artboards: Array<string>; symbols: Array<string> }
) {
  if (!scalingFactor) {
    scalingFactor = 1;
  }
  resetLayerNameMap("artboard");
  clearSceneDims();
  let registerRootLayers = (pages: any) => {
    for (let index = 0; index < pages.length; index++) {
      let rootLayer = pages[index].layers;
      for (let i = 0; i < rootLayer.length; i++) {
        if (rootLayer[i]._class === "artboard") {
          // DOC: reading the artboard file and adding it to artboard file map with valid name
          let validName = getValidName(rootLayer[i].name, "artboard");
          if (existingFiles.artboards.indexOf(validName) !== -1) {
            validName = getChangedName(validName, existingFiles.artboards);
          }
          existingFiles.artboards.push(validName);
          addParentEntry("artboards", rootLayer[i].do_objectID, validName);
        } else if (rootLayer[i]._class === "symbolMaster") {
          // DOC: reading the symbol file and adding it to symbol file map with valid name
          let validName = getValidName(rootLayer[i].name, "symbol");
          if (existingFiles.symbols.indexOf(validName) !== -1) {
            validName = getChangedName(validName, existingFiles.symbols);
          }
          existingFiles.symbols.push(validName);
          addParentEntry("symbols", rootLayer[i].symbolID, validName);
        }
      }
    }
  };
  let readDir = () => {
    let outputSketchJson: ConvertedData = {
      artboards: [],
      symbols: []
    };
    return new Promise(async (resolveDir: any, reject: any) => {
      if (sketchVersion >= 43) {
        await registerRootLayers(extractedData.pages);
        try {
          // DOC: reading the symbols page first so, it gets registered in the file map and
          // can be used subsequently everywhere in artboards
          outputSketchJson.symbols = [];
          for (let index = 0; index < extractedData.pages.length; index++) {
            if (!isEmpty(extractedData.pages[index].layers)) {
              let returnedData = await readSymbolFile(
                extractedData.pages[index]
              );
              outputSketchJson.symbols = concat(
                outputSketchJson.symbols,
                returnedData
              );
            }
          }
          outputSketchJson.artboards = [];
          for (let index = 0; index < extractedData.pages.length; index++) {
            if (!isEmpty(extractedData.pages[index].layers)) {
              let returnedData: any = await readPageFile(
                extractedData.pages[index]
              );
              let artboards = get(returnedData, "convertedData.artboards");
              if (artboards) {
                outputSketchJson.artboards = concat(
                  outputSketchJson.artboards,
                  artboards
                );
              }
              let symbols = get(returnedData, "convertedData.symbols");
              if (symbols) {
                outputSketchJson.symbols = concat(
                  outputSketchJson.symbols,
                  symbols
                );
              }
            }
            if (index === extractedData.pages.length - 1) {
              resolveDir(outputSketchJson);
            }
          }
        } catch (error) {
          console.log("Conversion failed", error);
          reject("Conversion Error", `SketchVersion: ${sketchVersion}`);
        }
      } else {
        reject("Sketch Version Error", `SketchVersion: ${sketchVersion}`);
      }
    });
  };
  let readSymbolFile = (page: any) => {
    let symbolsConvertedData: Array<any> = [];
    return new Promise(async (resolveFile: any, reject: any) => {
      let rootLayer = page.layers;
      try {
        for (let i = 0; i < rootLayer.length; i++) {
          if (rootLayer[i]._class === "symbolMaster") {
            let outputData = await symbolClassCreate(
              rootLayer[i],
              scalingFactor,
              sketchVersion,
              convertSvgToSymbol,
              extractedData.images
            );
            if (
              outputData &&
              outputData.artboard &&
              !isEmpty(outputData.artboard)
            ) {
              symbolsConvertedData.push(outputData.artboard);
            }
            if (
              convertSvgToSymbol &&
              outputData.symbols &&
              !isEmpty(outputData.symbols)
            ) {
              symbolsConvertedData = concat(
                symbolsConvertedData,
                outputData.artboard
              );
            }
          }
          if (i === rootLayer.length - 1) {
            resolveFile(symbolsConvertedData);
          }
        }
      } catch (error) {
        console.log("Conversion failed", error);
        reject("Conversion Error", `SketchVersion: ${sketchVersion}`);
      }
    });
  };
  let readPageFile = (page: any) => {
    let convertedData: ConvertedData = {
      artboards: [],
      symbols: []
    };
    return new Promise(async (resolveFile: any, reject: any) => {
      try {
        let rootLayer = page.layers;
        try {
          for (let i = 0; i < rootLayer.length; i++) {
            if (
              rootLayer[i]._class === "artboard" &&
              artboardsList.includes(rootLayer[i].do_objectID) &&
              rootLayer[i].frame
            ) {
              let dims = getSceneDims();
              if (dims.y > rootLayer[i].frame.y * scalingFactor) {
                registerSceneDimY(rootLayer[i].frame.y * scalingFactor);
              }
              if (dims.x > rootLayer[i].frame.x * scalingFactor) {
                registerSceneDimX(rootLayer[i].frame.x * scalingFactor);
              }
            }
          }
          for (let i = 0; i < rootLayer.length; i++) {
            if (
              rootLayer[i]._class === "artboard" &&
              artboardsList.includes(rootLayer[i].do_objectID)
            ) {
              let outputData: any = await artboardClassCreate(
                rootLayer[i],
                scalingFactor,
                sketchVersion,
                convertSvgToSymbol,
                extractedData.images,
                initialPosition
              );
              if (outputData.artboard && !isEmpty(outputData.artboard)) {
                convertedData.artboards.push(outputData.artboard);
              }
              if (
                convertSvgToSymbol &&
                outputData.symbols &&
                !isEmpty(outputData.symbols)
              ) {
                convertedData.symbols = concat(
                  convertedData.symbols,
                  outputData.symbols
                );
              }
            }
            if (i === rootLayer.length - 1) {
              resolveFile({ convertedData });
            }
          }
        } catch (error) {
          console.log("Conversion failed", error);
          reject("Conversion Failed", `SketchVersion: ${sketchVersion}`);
        }
      } catch (error) {
        console.log("FileRead error", error);
        reject(
          "ReadFile Error, Conversion Failed",
          `SketchVersion: ${sketchVersion}`
        );
      }
    });
  };
  return new Promise(async (resolveMain: any, reject: any) => {
    try {
      if (sketchVersion < 43) {
        reject("Sketch Version Error");
      }
      const convertedData: any = await readDir();
      if (convertedData.artboards) {
        resolveMain({
          artboards: convertedData.artboards,
          symbols: convertedData.symbols
        });
      } else {
        reject("Conversion failed", `SketchVersion: ${sketchVersion}`);
      }
    } catch (error) {
      console.log("Conversion failed", error);
      reject("Conversion Error", `SketchVersion: ${sketchVersion}`);
    }
  });
}
