import { isEmpty } from "lodash";
import oldLayerCreate from "./oldLayerDispatcher";
import newLayerCreate from "./newLayerDispatcher";
import {
  resetLayerNameMap,
  addParentEntry,
  queryParentDataMap,
  resetMaskData,
  getSceneDims
} from "../utils/NameMapsStore";
import { generateName } from "../utils/randomNameGenerator";
import { getColor } from "../LayersType/style/styleUtils";

export default async function artboardClassCreate(
  artboard: any,
  scalingFactor: number,
  sketchVersion: number,
  convertSvgToSymbol: boolean,
  images: Map<string, any>,
  initialPosition: { x: number; y: number }
) {
  let dataContainer: { artboard: any; symbols: Array<any> } = {
    artboard: {},
    symbols: []
  };
  let layerCreate = sketchVersion >= 52 ? newLayerCreate : oldLayerCreate;
  let artboardName = queryParentDataMap("artboards", artboard.do_objectID);
  if (artboardName === -1) {
    artboardName = generateName();
    addParentEntry("artboards", artboard.do_objectID, artboardName);
  }
  try {
    resetMaskData();
    dataContainer.artboard = {
      name: artboardName,
      _id: artboard.do_objectID,
      path: "/src/screens/" + artboardName + ".js",
      isDirty: true,
      content: "",
      layer: {
        type: "root",
        styleName: "container",
        import: {
          layerName: "View",
          packageName: "native",
          isDefaultImport: false,
          asName: ""
        },
        children: [],
        locked: false,
        template: {
          centerVertical: false,
          centerHorizontal: false
        },
        props: {
          style: {
            backgroundColor: "white",
            flex: 1
          }
        }
      },
      props: {
        style: {
          position: "absolute",
          left:
            initialPosition.x +
            artboard.frame.x * scalingFactor -
            getSceneDims().x,
          top:
            initialPosition.y +
            artboard.frame.y * scalingFactor -
            getSceneDims().y,
          height: artboard.frame.height * scalingFactor,
          width: artboard.frame.width * scalingFactor
        }
      },
      scopeVariables: {
        deviceName: "custom",
        deviceOrientation: "portrait"
      }
    };
    if (artboard.hasBackgroundColor) {
      dataContainer.artboard.layer.props.style.backgroundColor = getColor(
        artboard.backgroundColor
      );
    }
    resetLayerNameMap("style");
    for (let i = 0; i < artboard.layers.length; i++) {
      let child: any = await layerCreate(
        artboard.layers,
        i,
        artboard.frame,
        artboard.style,
        false,
        scalingFactor,
        false,
        "",
        sketchVersion,
        false,
        convertSvgToSymbol,
        images
      );
      if (
        child &&
        !isEmpty(child) &&
        child.artboard &&
        !isEmpty(child.artboard)
      ) {
        dataContainer.artboard.layer.children.push(child.artboard);
        if (convertSvgToSymbol && child.symbols && !isEmpty(child.symbols)) {
          dataContainer.symbols = dataContainer.symbols.concat(child.symbols);
        }
      }
      // DOC: Check if layer has mask and is a view then then skip the next layers unless one breaks mask
      if (
        artboard.layers[i].hasClippingMask &&
        ((artboard.layers[i]._class === "rectangle" &&
          !artboard.layers[i].edited) ||
          (sketchVersion < 52 &&
            artboard.layers[i].layers &&
            !isEmpty(artboard.layers[i].layers) &&
            artboard.layers[i].layers[0]._class === "rectangle" &&
            !artboard.layers[i].layers[0].edited))
      ) {
        let tempI = i + 1;
        while (
          artboard.layers[tempI] &&
          !artboard.layers[tempI].shouldBreakMaskChain &&
          tempI < artboard.layers.length
        ) {
          tempI++;
        }
        i = tempI - 1;
      }
    }
  } catch (error) {
    console.log("JSON read error in Artboard", error);
  }
  return dataContainer;
}
