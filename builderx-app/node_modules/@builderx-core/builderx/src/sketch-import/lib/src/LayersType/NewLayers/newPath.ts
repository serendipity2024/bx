import { isEmpty } from "lodash";
import {
  setMaskDataPoints,
  getMaskData,
  setMaskDataFrame,
  resetMaskData
} from "../../utils/NameMapsStore";
import {
  getStyleName,
  getColor,
  getColorFill,
  getSVGStrokeWidth
} from "../style/styleUtils";
import { operateBooleanOnPointsArray } from "./../../utils/svgUtils";
import { convertPointsArray } from "conversions";

export default async function pathSVGCreate(
  layers: any,
  frame: any,
  style: any,
  scalingFactor: number,
  maskingDisplacement: any,
  parentObjId: string
) {
  if (isEmpty(layers)) {
    return {};
  }
  let child: any = {};
  let maskProp: Array<any> = [];
  if (layers[0].shouldBreakMaskChain) {
    resetMaskData();
  }
  const maskData: any = getMaskData();
  const strokeWidth = getSVGStrokeWidth(style, scalingFactor);
  const viewBox = `-${strokeWidth / 2} -${strokeWidth / 2} ${(!isEmpty(
    maskData.frame
  )
    ? maskData.frame.width
    : layers[0].frame.width) *
    scalingFactor +
    strokeWidth * 2} ${(!isEmpty(maskData.frame)
    ? maskData.frame.height
    : layers[0].frame.height) *
    scalingFactor +
    strokeWidth * 2}`;
  if (layers && layers.length === 1) {
    if (maskData.frame && !isEmpty(maskData.frame)) {
      maskingDisplacement = {
        x: layers[0].frame.x - maskData.frame.x,
        y: layers[0].frame.y - maskData.frame.y
      };
    }
    let points = convertPointsArray(
      layers[0].points,
      layers[0].frame,
      layers[0].frame,
      maskingDisplacement,
      scalingFactor
    );
    if (!isEmpty(maskData.points)) {
      maskProp = [...maskData.points];
    }
    if (layers[0].hasClippingMask) {
      setMaskDataPoints(points);
      setMaskDataFrame(layers[0].frame);
    }
    child = getPathChild(
      layers[0],
      frame,
      style,
      points,
      scalingFactor,
      parentObjId,
      viewBox
    );
  } else {
    try {
      let tempPoint: any = await operateBooleanOnPointsArray(
        layers,
        frame,
        scalingFactor,
        viewBox
      );
      let points: any = tempPoint;
      if (!isEmpty(maskData.points)) {
        maskProp = [...maskData.points];
      }
      if (layers[0].hasClippingMask) {
        setMaskDataPoints(points);
        setMaskDataFrame(layers[0].frame);
      }
      if (layers[0].shouldBreakMaskChain) {
        resetMaskData();
      }
      child = getPathChild(
        layers[0],
        frame,
        style,
        points,
        scalingFactor,
        parentObjId,
        viewBox
      );
    } catch (error) {
      console.log(error, "Path Conversion error");
      return [];
    }
  }
  if (!isEmpty(maskProp)) {
    child.mask = maskProp;
  }
  return child;
}

function getPathChild(
  layer: any,
  frame: any,
  style: any,
  points: any,
  scalingFactor: number,
  parentObjId: string,
  viewBox: string
) {
  let strokeWidth = getSVGStrokeWidth(style, scalingFactor);
  let child: any = {
    type: "path",
    locked: false,
    styleName: getStyleName(layer.name),
    import: {
      layerName: "Path",
      packageName: "react-native-svg",
      isDefaultImport: false
    },
    template: {
      centerVertical: false,
      centerHorizontal: false
    },
    props: {
      strokeWidth: strokeWidth,
      fill: getColorFill(parentObjId, style),
      stroke:
        style.borders && style.borders.length > 0 && style.borders[0].isEnabled
          ? getColor(style.borders[0].color)
          : undefined,
      viewBox,
      isClosed: layer.isClosed,
      points: points,
      style: {}
    },
    children: []
  };
  // if (layer.rotation && layer.rotation !== 0) {
  //   child.props.rotation = layer.rotation;
  // }
  if (layer.isLocked) {
    child.locked = true;
  }
  if (style && style.contextSettings && style.contextSettings.opacity) {
    child.props.fillOpacity = style.contextSettings.opacity;
    child.props.strokeOpacity = style.contextSettings.opacity;
  }
  return child;
}
