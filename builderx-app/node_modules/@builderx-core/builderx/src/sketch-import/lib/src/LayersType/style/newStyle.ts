import { pickBy, isNil } from "lodash";
import { getColor, getMaxFillIndex, getActiveBorderList } from "./styleUtils";

export default function getNewStyle(
  layer: any,
  frame: any,
  isMasked: boolean,
  scalingFactor: number,
  convertedFromSvg: boolean,
  isAvatar: boolean,
  enableFixedStyling: boolean,
  borderThickness: number
) {
  let style: any = {};
  let filteredStyles = {};
  let resizingConstraintBinary =
    layer && layer.resizingConstraint
      ? layer.resizingConstraint.toString(2)
      : "111111";
  while (resizingConstraintBinary.length < 6) {
    resizingConstraintBinary = "0" + resizingConstraintBinary;
  }
  if (convertedFromSvg && !(layer.layers && layer.layers.length)) {
    convertedFromSvg = false;
  }
  try {
    let width =
      convertedFromSvg && layer.frame
        ? layer.frame.width
        : layer.frame.width + borderThickness * 2;
    let height =
      convertedFromSvg && layer.frame
        ? layer.frame.height
        : layer.frame.height + borderThickness * 2;
    let frameWidth = frame.width * scalingFactor;
    let frameHeight = frame.height * scalingFactor;
    let top = isMasked ? layer.frame.y - frame.y : layer.frame.y;
    let left = isMasked ? layer.frame.x - frame.x : layer.frame.x;
    let bottom = isMasked
      ? frame.height - layer.frame.y - layer.frame.height - frame.y
      : frame.height - layer.frame.y - layer.frame.height;
    let right = isMasked
      ? frame.width - layer.frame.x - layer.frame.width - frame.x
      : frame.width - layer.frame.x - layer.frame.width;

    width *= scalingFactor;
    height *= scalingFactor;
    top *= scalingFactor;
    left *= scalingFactor;
    bottom *= scalingFactor;
    right *= scalingFactor;

    top -= borderThickness;
    left -= borderThickness;
    bottom -= borderThickness;
    right -= borderThickness;
    style = {
      position: "absolute",
      top: ((100 * top) / frameHeight).toFixed(2) + "%",
      left: ((100 * left) / frameWidth).toFixed(2) + "%",
      height: ((100 * height) / frameHeight).toFixed(2) + "%",
      width: ((100 * width) / frameWidth).toFixed(2) + "%",
      right: undefined,
      bottom: undefined
    };
    if (
      layer.isFlippedHorizontal ||
      layer.isFlippedVertical ||
      layer.rotation !== 0
    ) {
      style.transform = [];
    }
    if (layer.rotation && layer.rotation !== 0) {
      style.transform.push({
        rotate: (-layer.rotation).toString() + "deg"
      });
    }
    if (layer.isFlippedHorizontal) {
      style.transform.push({
        scaleX: -1
      });
    }
    if (layer.isFlippedVertical) {
      style.transform.push({
        scaleY: -1
      });
    }
    // Cases only for Top,Height and Bottom
    if (resizingConstraintBinary[0] === "0") {
      style.top = parseFloat(top.toFixed(2));
    }
    if (enableFixedStyling || resizingConstraintBinary[1] === "0") {
      style.height = parseFloat(height.toFixed(2));
    }
    if (resizingConstraintBinary[2] === "0") {
      style.bottom = parseFloat(bottom.toFixed(2));
      style.top = undefined;
    }

    if (
      resizingConstraintBinary[0] === "0" &&
      resizingConstraintBinary[2] === "0"
    ) {
      style.top = parseFloat(top.toFixed(2));
      style.height = undefined;
      style.bottom = parseFloat(bottom.toFixed(2));
    }
    if (
      resizingConstraintBinary[1] === "0" &&
      resizingConstraintBinary[2] === "0"
    ) {
      style.height = parseFloat(height.toFixed(2));
      style.bottom = parseFloat(bottom.toFixed(2));
      style.top = undefined;
    }

    // Conditions for Left, Width and Right
    if (resizingConstraintBinary[3] === "0") {
      style.left = parseFloat(left.toFixed(2));
    }
    if (resizingConstraintBinary[4] === "0") {
      style.width = parseFloat(width.toFixed(2));
    }
    if (resizingConstraintBinary[5] === "0") {
      style.right = parseFloat(right.toFixed(2));
      style.left = undefined;
    }

    if (
      resizingConstraintBinary[3] === "0" &&
      resizingConstraintBinary[5] === "0"
    ) {
      style.left = parseFloat(left.toFixed(2));
      style.width = undefined;
      style.right = parseFloat(right.toFixed(2));
    }
    if (
      resizingConstraintBinary[4] === "0" &&
      resizingConstraintBinary[5] === "0"
    ) {
      style.width = parseFloat(width.toFixed(2));
      style.right = parseFloat(right.toFixed(2));
      style.left = undefined;
    }
    if (enableFixedStyling) {
      style.left = parseFloat(left.toFixed(2));
      style.top = parseFloat(top.toFixed(2));
      style.height = parseFloat(height.toFixed(2));
      style.width = parseFloat(width.toFixed(2));
      style.right = undefined;
      style.bottom = undefined;
    }
    // #Opacity
    if (
      layer.style &&
      layer.style.contextSettings &&
      layer.style.contextSettings.opacity
    ) {
      style.opacity = layer.style.contextSettings.opacity;
    }

    // #Borders
    let activeBordersList: any =
      layer.style && layer.style.borders && layer.style.borders.length
        ? getActiveBorderList(layer.style.borders)
        : [];
    if (activeBordersList.length) {
      let tempThickness =
        activeBordersList[activeBordersList.length - 1].thickness;
      if (convertedFromSvg) {
        tempThickness *= scalingFactor;
      }
      style.borderWidth = tempThickness;
      style.borderColor = getColor(
        activeBordersList[activeBordersList.length - 1].color
      );
    }
    if (isAvatar) {
      style.borderRadius = layer.frame.width / 2 + borderThickness;
      if (borderThickness === 0) {
        style.overflow = "hidden";
      }
    } else if (
      layer.fixedRadius &&
      layer.fixedRadius !== 0 &&
      layer.points &&
      layer.points.length === 4 &&
      layer.points[0].cornerRadius === layer.points[1].cornerRadius &&
      layer.points[1].cornerRadius === layer.points[2].cornerRadius &&
      layer.points[2].cornerRadius === layer.points[3].cornerRadius
    ) {
      style.borderRadius = layer.fixedRadius;
    } else if (layer.points && layer.points.length === 4) {
      if (layer.points[0].cornerRadius !== 0) {
        style.borderTopLeftRadius = layer.points[0].cornerRadius;
      }
      if (layer.points[1].cornerRadius !== 0) {
        style.borderTopRightRadius = layer.points[1].cornerRadius;
      }
      if (layer.points[2].cornerRadius !== 0) {
        style.borderBottomRightRadius = layer.points[2].cornerRadius;
      }
      if (layer.points[3].cornerRadius !== 0) {
        style.borderBottomLeftRadius = layer.points[3].cornerRadius;
      }
    }

    // #Shadow
    if (layer.style && layer.style.shadows && layer.style.shadows.length) {
      let shadowObj = layer.style.shadows[0];
      if (shadowObj.isEnabled) {
        style.shadowColor = getColor(shadowObj.color);
        style.shadowOffset = {
          height: shadowObj.offsetY,
          width: shadowObj.offsetX
        };
        style.shadowRadius = shadowObj.blurRadius;
        style.shadowOpacity = shadowObj.contextSettings.opacity
          ? shadowObj.contextSettings.opacity
          : 1;
      }
    }
    // overflow
    if (layer.hasClippingMask && borderThickness === 0) {
      style.overflow = "hidden";
    }

    // #Color and Background Color
    if (layer.style && layer.style.fills && layer.style.fills.length) {
      let activeFillIndex = getMaxFillIndex(layer.style.fills);
      if (
        activeFillIndex !== -1 &&
        layer.style.fills[activeFillIndex] &&
        layer.style.fills[activeFillIndex].fillType === 0
      ) {
        if (layer._class === "text") {
          style.color = getColor(layer.style.fills[activeFillIndex].color);
        } else {
          style.backgroundColor = getColor(
            layer.style.fills[activeFillIndex].color
          );
        }
      } else {
        style.backgroundColor = "transparent";
      }
    } else {
      style.backgroundColor = "transparent";
    }
    if (!layer.isVisible) {
      style.display = "none";
    }
    filteredStyles = pickBy(style, (obj: any) => {
      return !isNil(obj);
    });
    if (style && style.transform) {
      filteredStyles = { ...filteredStyles, transform: style.transform };
    }
    if (style && style.shadowOffset) {
      filteredStyles = { ...filteredStyles, shadowOffset: style.shadowOffset };
    }
  } catch (error) {
    console.log("JSON read error in Style", error);
  }
  return filteredStyles;
}
