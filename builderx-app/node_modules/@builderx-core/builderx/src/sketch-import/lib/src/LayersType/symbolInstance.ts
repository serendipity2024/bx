import { isEmpty, replace, pick, forEach } from "lodash";
import {
  queryParentDataMap,
  queryOverrideData,
  hasNavigationInSymbol,
  addNavigationInSymbol
} from "../utils/NameMapsStore";
import getStyle from "./style";
import { getStyleName } from "./style/styleUtils";

export default function symbolCreate(
  layer: any,
  frame: any,
  isMasked: boolean,
  scalingFactor: number,
  isInSymbol: boolean,
  symbolID: string,
  enableFixedStyling: boolean,
  isSVGSymbolInstance: boolean
) {
  let dataContainer: { artboard: any; symbols: object[] } = {
    artboard: {},
    symbols: []
  };
  let child: any = {};
  let symbolName: string;
  try {
    if (
      isInSymbol &&
      (hasNavigationInSymbol(layer.symbolID) ||
        (layer.flow && layer.flow.destinationArtboardID))
    ) {
      addNavigationInSymbol(symbolID);
    }

    let tempSymbolName;
    if (!isSVGSymbolInstance) {
      tempSymbolName = queryParentDataMap("symbols", layer.symbolID);
    } else {
      tempSymbolName = queryParentDataMap("symbols", layer.do_objectID);
    }
    if (tempSymbolName !== -1) {
      symbolName = tempSymbolName;
    } else {
      return {};
    }
    child = {
      type: "symbol",
      styleName: getStyleName(symbolName),
      import: {
        layerName: symbolName,
        packageName: "/src/components/" + symbolName + ".js",
        isDefaultImport: true,
        asName: ""
      },
      template: {
        centerVertical: false,
        centerHorizontal: false
      },
      overrides: [],
      props: {
        style: getStyle(
          layer,
          frame,
          isMasked,
          scalingFactor,
          false,
          false,
          enableFixedStyling,
          0
        )
      },
      children: []
    };
    if (layer.isLocked) {
      child.locked = true;
    }
    if (isSVGSymbolInstance) {
      child.props.style = pick(child.props.style, [
        "position",
        "top",
        "left",
        "height",
        "width",
        "right",
        "bottom",
        "display",
        "transform"
      ]);
      child.props.style.backgroundColor = "transparent";
    }

    // TODO: uncomment after navigation is added
    // if (hasNavigationInSymbol(layer.symbolID)) {
    //   child.props.navigation = "this.props.navigation";
    // }
    // if (
    //   !isSVGSymbolInstance &&
    //   layer.overrideValues &&
    //   !isEmpty(layer.overrideValues)
    // ) {
    //   forEach(layer.overrideValues, (overrideValue: any) => {
    //     let objectId = replace(overrideValue.overrideName, "_stringValue", "");
    //     let overrideData = queryOverrideData(objectId);
    //     if (overrideData !== -1) {
    //       child.overrides[overrideData.style] = {
    //         defaultValue: overrideData.defaultValue,
    //         type: "text",
    //         value: overrideValue.value
    //       };
    //     }
    //   });
    // }

    // TODO: uncomment after navigation is added
    // if (layer.flow && layer.flow.destinationArtboardID) {
    //   if (layer.flow.destinationArtboardID === "back") {
    //     child.navigateTo = "Go Back";
    //   } else {
    //     let destinationArtboardName = queryParentDataMap(
    //       "artboards",
    //       layer.flow.destinationArtboardID
    //     );
    //     child.navigateTo =
    //       destinationArtboardName !== -1 ? destinationArtboardName : undefined;
    //   }
    // }
  } catch (error) {
    console.log("JSON read error in Symbol Instance", error);
  }
  dataContainer.artboard = child;
  return dataContainer;
}
