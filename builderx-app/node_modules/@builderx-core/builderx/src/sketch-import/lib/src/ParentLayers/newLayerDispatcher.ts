import { isEmpty } from "lodash";
import viewCreate from "../LayersType/NewLayers/newView";
import textCreate from "../LayersType/text";
import imageCreate from "../LayersType/image";
import symbolCreate from "../LayersType/symbolInstance";
import newSvgCreate from "../LayersType/NewLayers/newSvgLayer";
import svgCreate from "../LayersType/svgLayer";
import SvgAsSymbolCreate from "../LayersType/NewLayers/SvgAsSymbol";
import multiBorderViewCreate from "../LayersType/multiBorderView";
import { getActiveBorderList } from "../LayersType/style/styleUtils";
import canConvertToAvatar from "../utils/canConvertToAvatar";
import { getMaskData } from "../utils/NameMapsStore";
import svgImageCreate from "./../LayersType/svgChildren/SVGImage";

export default async function newLayerCreate(
  layers: any,
  layerIndex: any,
  frame: any,
  style: any,
  isMasked: boolean,
  scalingFactor: number,
  isInSymbol: boolean,
  symbolID: string,
  sketchVersion: number,
  enableFixedStyling: boolean,
  convertSvgToSymbol: boolean,
  images: Map<string, any>
) {
  if (!layers[layerIndex]) {
    return {};
  }
  let dataContainer: { artboard: any; symbols: Array<any> } = {
    artboard: {},
    symbols: []
  };
  let child: any = {};
  switch (layers[layerIndex]._class) {
    case "group":
      child = await viewCreate(
        layers,
        layerIndex,
        frame,
        style,
        true,
        isMasked,
        scalingFactor,
        false,
        false,
        isInSymbol,
        symbolID,
        sketchVersion,
        enableFixedStyling,
        convertSvgToSymbol,
        images
      );
      isMasked = false;
      break;
    case "text":
      child = textCreate(
        layers[layerIndex],
        frame,
        isMasked,
        scalingFactor,
        isInSymbol,
        symbolID,
        sketchVersion,
        enableFixedStyling
      );
      break;
    case "symbolInstance":
      child = symbolCreate(
        layers[layerIndex],
        frame,
        isMasked,
        scalingFactor,
        isInSymbol,
        symbolID,
        enableFixedStyling,
        false
      );
      break;
    case "bitmap": // image case
      child = await imageCreate(
        layers,
        layerIndex,
        frame,
        style,
        layers[layerIndex].image._ref,
        isMasked,
        scalingFactor,
        sketchVersion,
        enableFixedStyling,
        convertSvgToSymbol,
        images
      );
      break;
    // New case in Sketch 52, where shape group as a parent is removed
    case "oval":
    case "triangle":
    case "shapePath":
    case "star":
    case "polygon":
      if (convertSvgToSymbol) {
        child = await SvgAsSymbolCreate(
          layers,
          layerIndex,
          frame,
          isMasked,
          scalingFactor,
          sketchVersion,
          enableFixedStyling
        );
      } else if (
        layers[layerIndex] &&
        layers[layerIndex].style &&
        layers[layerIndex].style.fills &&
        layers[layerIndex].style.fills.length > 0 &&
        layers[layerIndex].style.fills[0].fillType &&
        layers[layerIndex].style.fills[0].fillType === 4 &&
        layers[layerIndex].style.fills[0].image &&
        layers[layerIndex].style.fills[0].image._ref &&
        layers[layerIndex].style.fills[0].isEnabled
      ) {
        child = await svgImageCreate(
          layers,
          layerIndex,
          frame,
          style,
          layers[layerIndex].style.fills[0].image._ref,
          isMasked,
          scalingFactor,
          sketchVersion,
          enableFixedStyling,
          convertSvgToSymbol,
          images
        );
      } else {
        child = await newSvgCreate(
          layers,
          layerIndex,
          frame,
          isMasked,
          scalingFactor,
          enableFixedStyling,
          false
        );
      }
      break;
    case "rectangle":
      let activeBordersList: any =
        layers[layerIndex] &&
        layers[layerIndex].style &&
        layers[layerIndex].style.borders &&
        layers[layerIndex].style.borders.length > 1
          ? getActiveBorderList(layers[layerIndex].style.borders)
          : [];
      if (
        layers[layerIndex] &&
        layers[layerIndex].style &&
        layers[layerIndex].style.fills &&
        layers[layerIndex].style.fills.length > 0 &&
        layers[layerIndex].style.fills[0].fillType &&
        layers[layerIndex].style.fills[0].fillType === 4 &&
        layers[layerIndex].style.fills[0].image &&
        layers[layerIndex].style.fills[0].image._ref &&
        layers[layerIndex].style.fills[0].isEnabled
      ) {
        child = await imageCreate(
          layers,
          layerIndex,
          frame,
          style,
          layers[layerIndex].style.fills[0].image._ref,
          isMasked,
          scalingFactor,
          sketchVersion,
          enableFixedStyling,
          convertSvgToSymbol,
          images
        );
      } else if (
        (!layers[layerIndex].isEdited ||
          (layers[layerIndex].hasClippingMask &&
            canConvertToAvatar(layers[layerIndex].layers))) &&
        layers[layerIndex].booleanOperation === -1 &&
        activeBordersList.length > 1
      ) {
        child = await multiBorderViewCreate(
          layers,
          layerIndex,
          frame,
          style,
          isMasked,
          scalingFactor,
          canConvertToAvatar(layers[layerIndex].layers),
          true,
          isInSymbol,
          symbolID,
          sketchVersion,
          enableFixedStyling,
          activeBordersList,
          convertSvgToSymbol,
          images
        );
      } else if (
        ((layers[layerIndex]._class === "rectangle" &&
          !layers[layerIndex].isEdited) ||
          (layers[layerIndex].hasClippingMask &&
            canConvertToAvatar([layers[layerIndex]]) &&
            layers[layerIndex].booleanOperation === -1)) &&
        isEmpty(getMaskData().style)
      ) {
        child = await viewCreate(
          layers,
          layerIndex,
          frame,
          style,
          false,
          isMasked,
          scalingFactor,
          true,
          canConvertToAvatar([layers[layerIndex]]),
          isInSymbol,
          symbolID,
          sketchVersion,
          enableFixedStyling,
          convertSvgToSymbol,
          images
        );
      } else if (convertSvgToSymbol) {
        child = await SvgAsSymbolCreate(
          layers,
          layerIndex,
          frame,
          isMasked,
          scalingFactor,
          sketchVersion,
          enableFixedStyling
        );
      } else {
        child = await newSvgCreate(
          layers,
          layerIndex,
          frame,
          isMasked,
          scalingFactor,
          enableFixedStyling,
          false
        );
      }
      break;
    case "shapeGroup":
      if (convertSvgToSymbol) {
        child = await SvgAsSymbolCreate(
          layers,
          layerIndex,
          frame,
          isMasked,
          scalingFactor,
          sketchVersion,
          enableFixedStyling
        );
      } else {
        child = await svgCreate(
          layers,
          layerIndex,
          frame,
          isMasked,
          scalingFactor,
          enableFixedStyling,
          false
        );
      }
      break;
    default:
      child = {};
      break;
  }
  if (!isEmpty(child)) {
    if (child.artboard && !isEmpty(child.artboard)) {
      dataContainer.artboard = child.artboard;
      if (child.symbols && !isEmpty(child.symbols)) {
        dataContainer.symbols = dataContainer.symbols.concat(child.symbols);
      }
    }
    if (layers[layerIndex] && layers[layerIndex].layers) {
      if (
        dataContainer.artboard &&
        !isEmpty(dataContainer.artboard) &&
        !dataContainer.artboard.children
      ) {
        dataContainer.artboard.children = [];
      }
      if (child.symbols && !isEmpty(child.symbols)) {
        dataContainer.symbols = dataContainer.symbols.concat(child.symbols);
      }
      if (
        !(
          layers[layerIndex].hasClippingMask &&
          layers[layerIndex]._class === "rectangle" &&
          !layers[layerIndex].edited
        ) &&
        layers[layerIndex].layers &&
        !(layers[layerIndex]._class === "shapeGroup")
      ) {
        for (let j = 0; j < layers[layerIndex].layers.length; j++) {
          let childLayer: any = await newLayerCreate(
            layers[layerIndex].layers,
            j,
            layers[layerIndex].frame,
            layers[layerIndex].style,
            isMasked,
            scalingFactor,
            isInSymbol,
            symbolID,
            sketchVersion,
            enableFixedStyling,
            convertSvgToSymbol,
            images
          );
          if (
            !isEmpty(childLayer) &&
            childLayer.artboard &&
            !isEmpty(childLayer.artboard)
          ) {
            dataContainer.artboard.children.push(childLayer.artboard);
          }
          if (
            !isEmpty(childLayer) &&
            childLayer.symbols &&
            !isEmpty(childLayer.symbols)
          ) {
            dataContainer.symbols = dataContainer.symbols.concat(
              childLayer.symbols
            );
          }
          if (
            layers[layerIndex].layers[j].hasClippingMask &&
            ((layers[layerIndex].layers[j]._class === "rectangle" &&
              !layers[layerIndex].layers[j].edited) ||
              (sketchVersion < 52 &&
                layers[layerIndex].layers[j].layers &&
                !isEmpty(layers[layerIndex].layers[j].layers) &&
                layers[layerIndex].layers[j].layers[0]._class === "rectangle" &&
                !layers[layerIndex].layers[j].layers[0].edited))
            // canConvertToAvatar([layers[layerIndex].layers[j]])
          ) {
            let tempI = j + 1;
            while (
              layers[layerIndex].layers[tempI] &&
              !layers[layerIndex].layers[tempI].shouldBreakMaskChain &&
              tempI < layers[layerIndex].layers.length
            ) {
              tempI++;
            }
            j = tempI - 1;
          }
        }
      }
    }
  }
  return dataContainer;
}
