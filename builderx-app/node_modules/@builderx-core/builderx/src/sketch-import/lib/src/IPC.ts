import { v4 as uuid } from "uuid";
import SketchImport from "./SketchImport";

export default class IPC {
  messageIPCQueue: any = {};
  sketchImport: SketchImport;
  worker: Worker;
  ipcQueue: any;
  id: string;

  constructor(worker: Worker) {
    this.sketchImport = new SketchImport(this);
    this.worker = worker;
  }

  executeCommand(
    command: string,
    args: Array<any> = [],
    transferables: Array<Transferable> = []
  ) {
    return new Promise((resolve, reject) => {
      if (this.worker.postMessage) {
        const messageId = uuid();
        this.worker.postMessage(
          {
            type: "command",
            messageId,
            command,
            args
          }
          // transferables
        );

        this.messageIPCQueue[messageId] = {
          resolve,
          reject
        };
      }
    });
  }
  async ipcOnMessage(event: any) {
    const message = event.data;
    if (message.type === "command") {
      try {
        const returnData = await this.sketchImport[message.command](
          ...message.args
        );

        this.worker.postMessage({
          type: "ack",
          messageId: message.messageId,
          success: true,
          data: returnData
        });
      } catch (err) {
        console.error("Sketch import error", err);
        this.worker.postMessage({
          type: "ack",
          messageId: message.messageId,
          success: false,
          error: err,
          functionName: message.command
        });
        if (process.env.NODE_ENV === "production") {
          // TODO: sentry build error
          // Sentry.captureException(err);
        }
      }
    }
    if (message.type === "ack") {
      const messageIPC = this.messageIPCQueue[message.messageId];
      if (!messageIPC) {
        return;
      }
      if (message.success) {
        messageIPC.resolve(message.data);
      } else {
        messageIPC.reject(message.error);
      }
      delete this.messageIPCQueue[message.messageId];
    }
  }
}
