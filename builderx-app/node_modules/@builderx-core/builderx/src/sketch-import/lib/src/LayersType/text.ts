import * as bplistParser from "bplist-parser";
import { Buffer } from "buffer";
import parse from "../utils/NSArchiver";
import {
  addOverrideEntry,
  addNavigationInSymbol,
  resetMaskData
} from "../utils/NameMapsStore";
import { getColor, getStyleName } from "./style/styleUtils";
import getStyle from "./style";
import { toLower, find } from "lodash";
import { getFontsList } from "../utils/FontsStore";
import { Utils } from "utils";
import { SystemFont } from "common-interfaces";

const FONT_WEIGHT_MAP = Utils.getFontWeightMap();

function normalizeFontFamily(fontFamily: string) {
  const fontsList = getFontsList();

  const font = find(fontsList, (systemFont: SystemFont) => {
    return toLower(systemFont.postscriptName) === toLower(fontFamily);
  });

  if (font) {
    return font;
  }

  // If the variation is not standard, e.g. poppins-Light,
  // find correct family name and corresponding weight variation using weight map
  const splitArr = fontFamily.split("-");
  const fontWeight = splitArr[splitArr.length - 1];

  const fontFamilyNameWithoutWeight = splitArr
    .slice(0, splitArr.length - 1)
    .join("-");
  if (fontWeight) {
    const fontWeightObj = FONT_WEIGHT_MAP.get(fontWeight);
    if (!fontWeightObj) {
      return font;
    }

    let validFont: SystemFont | undefined;
    fontWeightObj.values.forEach((value: string) => {
      if (!validFont) {
        validFont = find(fontsList, (systemFont: SystemFont) => {
          return (
            toLower(systemFont.postscriptName) ===
            toLower(fontFamilyNameWithoutWeight + "-" + value)
          );
        });
      }

      // if (fontt) {
      //   validFontFamily = fontFamilyNameWithoutWeight + "-" + value;
      // }
    });
    if (validFont) {
      return validFont;
    } else {
      return font;
    }
  }

  return font;
}

export default function textCreate(
  layer: any,
  frame: any,
  isMasked: boolean,
  scalingFactor: number,
  isInSymbol: boolean,
  symbolID: string,
  sketchVersion: number,
  enableFixedStyling: boolean
) {
  let dataContainer: { artboard: any, symbols: object[] } = {
    artboard: {},
    symbols: []
  };
  let child: any = {};
  try {
    child = {
      type: "text",
      objectId: layer.do_objectID,
      locked: false,
      styleName: getStyleName(layer.name),
      import: {
        layerName: "Text",
        packageName: "native",
        isDefaultImport: false
      },
      template: {
        centerVertical: false,
        centerHorizontal: false
      },
      props: {
        style: getStyle(
          layer,
          frame,
          isMasked,
          scalingFactor,
          false,
          false,
          enableFixedStyling,
          0
        )
      },
      children: [
        {
          type: "literal",
          value: "Type Something"
        }
      ]
    };
    if (layer.isLocked) {
      child.locked = true;
    }
    if (layer.shouldBreakMaskChain) {
      resetMaskData();
    }
    if (isInSymbol && layer.flow && layer.flow.destinationArtboardID) {
      addNavigationInSymbol(symbolID);
    }
    if (layer.textBehaviour === 0) {
      delete child.props.style["height"];
      delete child.props.style["width"];
    }
    if (sketchVersion < 50) {
      const buffer: any = Buffer.from(
        layer.attributedString.archivedAttributedString._archive,
        "base64"
      );
      const obj: any = bplistParser.parseBuffer(buffer);
      let res: any = parse(obj);
      if (res.NSString) {
        child.children[0].value = res.NSString.trim();
      }
      if (
        res.NSAttributes &&
        res.NSAttributes.MSAttributedStringColorDictionaryAttribute &&
        !child.props.style.color
      ) {
        child.props.style.color = getColor(
          res.NSAttributes.MSAttributedStringColorDictionaryAttribute
        );
      } else if (
        res.NSAttributes &&
        res.NSAttributes.NSColor &&
        res.NSAttributes.NSColor.NSRGB &&
        !child.props.style.color
      ) {
        const nscolor = Buffer.from(res.NSAttributes.NSColor.NSRGB)
          .toString()
          .trim()
          .split(/\s+/)
          .map(r => {
            const c = Math.floor(parseFloat(r) * 256);
            return c;
          })
          .join(",");
        child.props.style.color = `rgba(${nscolor},1)`;
      }
      child.props.style.backgroundColor = "transparent";
      if (layer.style) {
        if (
          layer.style.textStyle &&
          layer.style.textStyle.encodedAttributes &&
          layer.style.textStyle.encodedAttributes.NSKern
        ) {
          child.props.style.letterSpacing =
            layer.style.textStyle.encodedAttributes.NSKern * scalingFactor;
        }
      }
      if (res.NSAttributes) {
        if (res.NSAttributes.MSAttributedStringColorDictionaryAttribute) {
          child.props.style.color = getColor(
            res.NSAttributes.MSAttributedStringColorDictionaryAttribute
          );
        }
        if (
          res.NSAttributes.MSAttributedStringFontAttribute &&
          res.NSAttributes.MSAttributedStringFontAttribute
            .NSFontDescriptorAttributes &&
          res.NSAttributes.MSAttributedStringFontAttribute
            .NSFontDescriptorAttributes.NSFontSizeAttribute
        ) {
          child.props.style.fontSize =
            res.NSAttributes.MSAttributedStringFontAttribute
              .NSFontDescriptorAttributes.NSFontSizeAttribute * scalingFactor;
          const fontObj = normalizeFontFamily(
            toLower(
              res.NSAttributes.MSAttributedStringFontAttribute
                .NSFontDescriptorAttributes.NSFontNameAttribute
            )
          );

          if (fontObj) {
            child.props.style.fontFamily = fontObj.family;
            child.props.style.fontPostscriptName = fontObj.postscriptName;
            child.props.style.fontWeight = Utils.getFontWeight(fontObj.style);
            child.props.style.fontStyle = Utils.getFontStyle(fontObj.style);
          }
        }
        if (
          res.NSAttributes.NSParagraphStyle &&
          (res.NSAttributes.NSParagraphStyle.NSMaxLineHeight ||
            res.NSAttributes.NSParagraphStyle.NSMinLineHeight)
        ) {
          let val =
            res.NSAttributes.NSParagraphStyle.NSMaxLineHeight ||
            res.NSAttributes.NSParagraphStyle.NSMinLineHeight;
          val = val * scalingFactor;
          // was 1.3 bcz of relation of lineHeight
          child.props.style.lineHeight = Math.round(val);
        }
        // # Alignment
        if (
          res.NSAttributes.NSParagraphStyle &&
          res.NSAttributes.NSParagraphStyle.NSAlignment
        ) {
          let alignment = res.NSAttributes.NSParagraphStyle.NSAlignment;
          let alignArr = ["left", "right", "center", "justify"];
          child.props.style.textAlign = alignArr[alignment];
        }
        if (res.NSAttributes.NSStrikethrough) {
          child.props.style.textDecorationLine = "line-through";
        } else if (res.NSAttributes.NSUnderline) {
          child.props.style.textDecorationLine = "underline";
        }
      }
    } else {
      let attributeString = "";
      if (layer.attributedString) {
        let attribute = layer.attributedString;
        if (attribute.string) {
          attributeString = attribute.string;
          // uncomment next few lines for adding support for \n and \t,
          // if (includes(attributeString, "\n")) {
          //   attributeString = replace(
          //     attributeString,
          //     new RegExp("\n", "g"),
          //     "{'\n'}"
          //   );
          // }
          // if (includes(attributeString, "\t")) {
          //   attributeString = replace(
          //     attributeString,
          //     new RegExp("\t", "g"),
          //     "{'\t'}"
          //   );
          // }
        }
        if (
          attribute.attributes &&
          attribute.attributes.length > 0 &&
          attribute.attributes[0].attributes
        ) {
          // // lineHeight
          if (
            attribute.attributes[0].attributes.paragraphStyle &&
            (attribute.attributes[0].attributes.paragraphStyle
              .maximumLineHeight ||
              attribute.attributes[0].attributes.paragraphStyle
                .minimumLineHeight)
          ) {
            let val =
              attribute.attributes[0].attributes.paragraphStyle
                .maximumLineHeight ||
              attribute.attributes[0].attributes.paragraphStyle
                .minimumLineHeight;
            val = val * scalingFactor;
            // was 1.3 bcz of relation of lineHeight
            child.props.style.lineHeight = Math.round(val);
          }
          // // # Alignment
          if (
            attribute.attributes[0].attributes.paragraphStyle &&
            attribute.attributes[0].attributes.paragraphStyle.alignment
          ) {
            let alignment =
              attribute.attributes[0].attributes.paragraphStyle.alignment;
            let alignArr = ["left", "right", "center", "justify"];
            child.props.style.textAlign = alignArr[alignment];
          }
          // // color
          if (
            attribute.attributes[0].attributes
              .MSAttributedStringColorAttribute &&
            !child.props.style.color
          ) {
            child.props.style.color = getColor(
              attribute.attributes[0].attributes
                .MSAttributedStringColorAttribute
            );
          }
          //// font details
          if (
            attribute.attributes[0].attributes
              .MSAttributedStringFontAttribute &&
            attribute.attributes[0].attributes.MSAttributedStringFontAttribute
              .attributes
          ) {
            if (
              attribute.attributes[0].attributes.MSAttributedStringFontAttribute
                .attributes.size
            ) {
              child.props.style.fontSize =
                attribute.attributes[0].attributes
                  .MSAttributedStringFontAttribute.attributes.size *
                scalingFactor;
            }
            if (
              attribute.attributes[0].attributes.MSAttributedStringFontAttribute
                .attributes.name
            ) {
              const fontObj = normalizeFontFamily(
                toLower(
                  attribute.attributes[0].attributes
                    .MSAttributedStringFontAttribute.attributes.name
                )
              );
              if (fontObj) {
                child.props.style.fontFamily = fontObj.family;
                child.props.style.fontPostscriptName = fontObj.postscriptName;
                child.props.style.fontWeight = Utils.getFontWeight(
                  fontObj.style
                );
                child.props.style.fontStyle = Utils.getFontStyle(fontObj.style);
              }
            }
          }
          // // Text Decoration
          if (
            attribute.attributes[0].attributes.strikethroughStyle &&
            attribute.attributes[0].attributes.strikethroughStyle !== 0
          ) {
            child.props.style.textDecorationLine = "line-through";
          } else if (
            attribute.attributes[0].attributes.underlineStyle &&
            attribute.attributes[0].attributes.underlineStyle !== 0
          ) {
            child.props.style.textDecorationLine = "underline";
          }
          // // letter spacing
          if (
            attribute.attributes[0].attributes.kerning &&
            attribute.attributes[0].attributes.kerning !== 0
          ) {
            child.props.style.letterSpacing =
              attribute.attributes[0].attributes.kerning * scalingFactor;
          }
          if (
            attribute.attributes[0].attributes
              .MSAttributedStringTextTransformAttribute
          ) {
            let textAttributeList = [
              attributeString,
              attributeString.toUpperCase(),
              attributeString.toLowerCase()
            ];
            attributeString =
              textAttributeList[
                attribute.attributes[0].attributes
                  .MSAttributedStringTextTransformAttribute
              ];
          }
        }
      }
      child.children[0].value = attributeString.trim();
    }
    // TODO: uncomment after navigation is added
    // if (layer.flow && layer.flow.destinationArtboardID) {
    //   if (layer.flow.destinationArtboardID === "back") {
    //     child.navigateTo = "Go Back";
    //   } else {
    //     let destinationArtboardName = queryParentDataMap(
    //       "artboards",
    //       layer.flow.destinationArtboardID
    //     );
    //     child.navigateTo =
    //       destinationArtboardName !== -1 ? destinationArtboardName : undefined;
    //   }
    // }
    if (isInSymbol) {
      addOverrideEntry(
        layer.do_objectID,
        child.styleName,
        child.children[0].value
      );
    }
  } catch (error) {
    console.log("JSON read error in Text", error);
  }
  dataContainer.artboard = child;
  return dataContainer;
}
