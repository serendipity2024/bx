import { isEmpty, findLastIndex } from "lodash";
import newLayerCreate from "../../ParentLayers/newLayerDispatcher";
import getNewStyle from "./../style/newStyle";
import { getStyleName, getMaxFillIndex } from "./../style/styleUtils";
import { getGradientProps } from "./../style/gradient";
import canConvertToAvatar from "../../utils/canConvertToAvatar";

// import {
//   queryParentDataMap,
//   addNavigationInSymbol
// } from "../../utils/NameMapsStore";

export default async function viewCreate(
  layers: any,
  layerIndex: number,
  frame: any,
  style: any,
  isGroup: boolean,
  isMasked: boolean,
  scalingFactor: number,
  convertedFromSvg: boolean,
  isAvatar: boolean,
  isInSymbol: boolean,
  symbolID: string,
  sketchVersion: number,
  enableFixedStyling: boolean,
  convertSvgToSymbol: boolean,
  images: Map<string, any>
) {
  if (!layers[layerIndex]) {
    return {};
  }
  let dataContainer: { artboard: any; symbols: object[] } = {
    artboard: {},
    symbols: []
  };
  try {
    dataContainer.artboard = getViewObject(
      layers[layerIndex],
      frame,
      isMasked,
      scalingFactor,
      convertedFromSvg,
      isAvatar,
      enableFixedStyling
    );
    if (layers[layerIndex].isLocked) {
      dataContainer.artboard.locked = true;
    }
    if (isGroup) {
      delete dataContainer.artboard.props.style["backgroundColor"];
    }
    if (
      layers[layerIndex].style &&
      layers[layerIndex].style.fills &&
      layers[layerIndex].style.fills.length > 0
    ) {
      let lastPlainColorIndex = getMaxFillIndex(layers[layerIndex].style.fills);
      let lastGradientIndex = findLastIndex(
        layers[layerIndex].style.fills,
        function(o: any) {
          return o.isEnabled === true && o.fillType !== 0 && o.fillType !== 4;
        }
      );
      if (
        !isGroup &&
        lastGradientIndex !== -1 &&
        lastGradientIndex > lastPlainColorIndex
      ) {
        dataContainer.artboard.gradient = getGradientProps(
          layers[layerIndex].style.fills[lastGradientIndex].gradient,
          layers[layerIndex].do_objectID
        );
      }
    }
    // Logic to add the masked layer siblings as children
    if (
      layers[layerIndex].hasClippingMask &&
      (layers[layerIndex]._class === "rectangle" ||
        canConvertToAvatar([layers[layerIndex]]))
    ) {
      if (
        dataContainer.artboard.props.style &&
        dataContainer.artboard.props.style.transform
      ) {
        delete dataContainer.artboard.props.style["transform"];
      }
      for (let x = layerIndex + 1; x < layers.length; x++) {
        if (layers[x] && layers[x].shouldBreakMaskChain) {
          break;
        }
        let childLayer: any = await newLayerCreate(
          layers,
          x,
          layers[layerIndex].frame,
          style,
          true,
          scalingFactor,
          isInSymbol,
          symbolID,
          sketchVersion,
          enableFixedStyling,
          // convertedFromSvg, // was this earlier, don't know why
          convertSvgToSymbol,
          images
        );
        if (
          !isEmpty(childLayer) &&
          childLayer.artboard &&
          !isEmpty(childLayer.artboard)
        ) {
          dataContainer.artboard.children.push(childLayer.artboard);
        }
        if (
          convertSvgToSymbol &&
          !isEmpty(childLayer) &&
          childLayer.symbols &&
          !isEmpty(childLayer.symbols)
        ) {
          dataContainer.symbols = dataContainer.symbols.concat(
            childLayer.symbols
          );
        }
      }
    }

    // TODO: uncomment after overrides are added
    // if (
    //   layers[layerIndex].flow &&
    //   layers[layerIndex].flow.destinationArtboardID
    // ) {
    //   if (layers[layerIndex].flow.destinationArtboardID === "back") {
    //     dataContainer.artboard.navigateTo = "Go Back";
    //   } else {
    //     let destinationArtboardName = queryParentDataMap(
    //       "artboards",
    //       layers[layerIndex].flow.destinationArtboardID
    //     );
    //     dataContainer.artboard.navigateTo =
    //       destinationArtboardName !== -1 ? destinationArtboardName : undefined;
    //   }
    // }
  } catch (error) {
    console.log("JSON read error in View", error);
  }
  return dataContainer;
}

function getViewObject(
  layer: any,
  frame: any,
  isMasked: boolean,
  scalingFactor: number,
  convertedFromSvg: boolean,
  isAvatar: boolean,
  enableFixedStyling: boolean
) {
  return {
    type:
      layer.flow && layer.flow.destinationArtboardID
        ? "touchableOpacity"
        : "view",
    locked: false,
    styleName: getStyleName(layer.name),
    import: {
      layerName:
        layer.flow && layer.flow.destinationArtboardID
          ? "TouchableOpacity"
          : "View",
      packageName: "native",
      isDefaultImport: false
    },
    template: {
      centerVertical: false,
      centerHorizontal: false
    },
    props: {
      style: getNewStyle(
        layer,
        frame,
        isMasked,
        scalingFactor,
        convertedFromSvg,
        isAvatar,
        enableFixedStyling,
        0
      )
    },
    children: []
  };
}
