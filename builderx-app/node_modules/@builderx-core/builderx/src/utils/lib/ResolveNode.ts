import { forEach, size, isNil } from "lodash";
import {
  ExpressionStatement,
  LogicalExpression,
  BinaryExpression,
  Expression,
  LiteralNode
} from "domain-x";
import { isUndefined } from "util";
import { Transform } from "domain-x";
import { Utils } from "utils";

export function resolveBinaryTest(
  testObj: any,
  currentScopeVariables: { [key: string]: any }
) {
  let leftValue;
  let rightValue;

  if (testObj.left.type === "expression") {
    leftValue = testObj.left;
  } else if (testObj.left.type === "literal") {
    leftValue = testObj.left;
  } else {
    leftValue = testObj.left;
  }

  if (testObj.right.type === "expression") {
    rightValue = testObj.right;
  } else if (testObj.right.type === "literal") {
    rightValue = testObj.right;
  } else {
    rightValue = testObj.right;
  }

  let result = false;
  switch (testObj.operator) {
    case "===":
    case "==":
      result =
        getValue(leftValue, currentScopeVariables) ===
        getValue(rightValue, currentScopeVariables);
      break;
    case "!==":
    case "!=":
      result =
        getValue(leftValue, currentScopeVariables) !==
        getValue(rightValue, currentScopeVariables);
      break;
    case "<":
      result =
        getValue(leftValue, currentScopeVariables) <
        getValue(rightValue, currentScopeVariables);
      break;
    case ">":
      result =
        getValue(leftValue, currentScopeVariables) >
        getValue(rightValue, currentScopeVariables);
      break;
    case "<=":
      result =
        getValue(leftValue, currentScopeVariables) <=
        getValue(rightValue, currentScopeVariables);
      break;
    case ">=":
      result =
        getValue(leftValue, currentScopeVariables) >=
        getValue(rightValue, currentScopeVariables);
      break;
    default:
      break;
  }

  // console.log(
  //   result,
  //   getValue(leftValue, currentScopeVariables),
  //   getValue(rightValue, currentScopeVariables),
  //   leftValue,
  //   rightValue,
  //   "hello !!!"
  // );

  return result;
}

function getValue(node: any, currentScopeVariables: any) {
  // if (node.getValue) {
  //   return node.getValue(currentScopeVariables);
  // }

  // if (node.getValue) {
  //   return node.getValue(currentScopeVariables);
  // }

  let value = node.getValue ? node.getValue(currentScopeVariables) : node;
  if (value) {
    if (value.type === "literal") {
      return isNil(value.value) ? value : value.value;
    }

    if (value.type === "expression") {
      return currentScopeVariables[value.expression];
    }
  }

  return value;
}
export function resolveLogicalTest(
  testObj: any,
  currentScopeVariables: { [key: string]: any }
): any {
  let leftValue;
  let rightValue;

  if (testObj.left.type === "binaryExpression") {
    leftValue = resolveBinaryTest(testObj.left, currentScopeVariables);
  } else if (testObj.left.type === "logicalExpression") {
    leftValue = resolveLogicalTest(testObj.left, currentScopeVariables);
  } else if (testObj.left.type === "expression") {
    leftValue = testObj.left;
  } else if (testObj.left.type === "literal") {
    leftValue = testObj.left;
  } else {
    leftValue = testObj.left;
  }
  if (testObj.right.type === "binaryExpression") {
    rightValue = resolveBinaryTest(testObj.right, currentScopeVariables);
  } else if (testObj.right.type === "logicalExpression") {
    rightValue = resolveLogicalTest(testObj.right, currentScopeVariables);
  } else if (testObj.right.type === "expression") {
    rightValue = testObj.right;
  } else if (testObj.right.type === "literal") {
    rightValue = testObj.right;
  } else {
    rightValue = testObj.right;
  }

  let result = false;
  switch (testObj.operator) {
    case "&&":
      result =
        getValue(leftValue, currentScopeVariables) &&
        getValue(rightValue, currentScopeVariables);
      break;
    case "||":
      result =
        getValue(leftValue, currentScopeVariables) ||
        getValue(rightValue, currentScopeVariables);
      break;
    default:
      break;
  }

  let node;

  if (getValue(leftValue, currentScopeVariables) === result) {
    node = leftValue;
  } else if (getValue(rightValue, currentScopeVariables) === result) {
    node = rightValue;
  } else {
    node = result;
  }
  return node;
}

function resolveExpressionStatement(
  expressionStatement: any,
  currentScopeVariables: { [key: string]: any }
): any {
  const expression = expressionStatement.expression;

  if (
    expression.type === "binaryExpression" ||
    expression.type === "logicalExpression"
  ) {
    const resolvedTest =
      expression.type === "binaryExpression"
        ? resolveBinaryTest(expression, currentScopeVariables)
        : resolveLogicalTest(expression, currentScopeVariables);
    return resolvedTest;
  } else if (
    expression.type === "expression" ||
    expression.type === "literal"
  ) {
    return expression;
  }
  return false;
}

function resolveConditional(
  conditionalObj: any,
  currentScopeVariables: { [key: string]: any }
): any {
  const test = conditionalObj.test;
  let resolvedTest = false;
  if (test.type === "binaryExpression" || test.type === "logicalExpression") {
    resolvedTest =
      test.type === "binaryExpression"
        ? resolveBinaryTest(test, currentScopeVariables)
        : resolveLogicalTest(test, currentScopeVariables);
  } else {
    resolvedTest = getValue(test, currentScopeVariables);
  }
  if (resolvedTest) {
    if (conditionalObj.consequent.type === "literal") {
      return conditionalObj.consequent;
    } else if (conditionalObj.consequent.type === "expression") {
      return conditionalObj.consequent;
    } else if (conditionalObj.consequent.type === "conditionalExpression") {
      return resolveConditional(
        conditionalObj.consequent,
        currentScopeVariables
      );
    } else if (conditionalObj.consequent.type === "logicalExpression") {
      return resolveLogicalTest(
        conditionalObj.consequent,
        currentScopeVariables
      );
    } else if (conditionalObj.consequent.type === "binaryExpression") {
      return resolveBinaryTest(
        conditionalObj.consequent,
        currentScopeVariables
      );
    } else if (conditionalObj.consequent.type === "expressionExpression") {
      return resolveExpressionStatement(
        conditionalObj.consequent,
        currentScopeVariables
      );
    } else {
      console.log(
        conditionalObj.consequent.type,
        "case not handled in ;resolveConditional -!-!-"
      );
    }
  } else {
    if (conditionalObj.alternate.type === "literal") {
      return conditionalObj.alternate;
    } else if (conditionalObj.alternate.type === "expression") {
      return conditionalObj.alternate;
    } else if (conditionalObj.alternate.type === "conditionalExpression") {
      return resolveConditional(
        conditionalObj.alternate,
        currentScopeVariables
      );
    } else if (conditionalObj.alternate.type === "logicalExpression") {
      return resolveLogicalTest(
        conditionalObj.alternate,
        currentScopeVariables
      );
    } else if (conditionalObj.alternate.type === "binaryExpression") {
      return resolveBinaryTest(conditionalObj.alternate, currentScopeVariables);
    } else if (conditionalObj.alternate.type === "expressionExpression") {
      return resolveExpressionStatement(
        conditionalObj.alternate,
        currentScopeVariables
      );
    } else {
      console.log(
        conditionalObj.alternate.type,
        "case not handled in resolveConditional -!-!-"
      );
    }
  }
}

export function ResolveNode(
  node: any,
  currentScopeVariables: { [key: string]: any }
) {
  //

  if (
    !node ||
    !node.type ||
    node.type === "unknown" ||
    !Utils.shouldIgnoreLayer(node.type)
  ) {
    return node;
  }
  if (node.type === "conditionalExpression") {
    var resolvedConditional = resolveConditional(node, currentScopeVariables);

    return resolvedConditional;
  }

  if (node.type === "expression") {
    return node;
  }

  if (node.type === "expressionStatement") {
    var resolved = resolveExpressionStatement(node, currentScopeVariables);
    // console.log(node, currentScopeVariables, "node here ###");

    return resolved;
  }

  if (node.type === "literal") {
    return node;
  }
}

export function ResolveNodeValue(
  node: any,
  currentScopeVariables: { [key: string]: any }
) {
  //

  const resolvedNode = ResolveNode(node, currentScopeVariables);

  if (!resolvedNode || !resolvedNode.type || resolvedNode.type === "unknown") {
    return resolvedNode;
  }

  if (resolvedNode.type === "expression") {
    return currentScopeVariables[resolvedNode.expression];
  }
  if (resolvedNode.type === "expressionStatement") {
    return resolvedNode;
  }

  if (resolvedNode.type === "literal") {
    return resolvedNode.value;
  }

  if (!Utils.shouldIgnoreLayer(resolvedNode.type)) {
    return resolvedNode;
  }
}

export function ResolveLayer(
  node: any,
  currentScopeVariables: { [key: string]: any },
  shallow: boolean = true
) {
  let resolvedLayer = ResolveNode(node, currentScopeVariables);

  if (shallow) {
    const props = resolvedLayer.props;

    if (props) {
      for (let key in props) {
        if (props.hasOwnProperty(key)) {
          props[key] = ResolveNodeValue(props[key], currentScopeVariables);
        }
      }

      resolvedLayer.props = props;
      const style = props.style;

      if (style) {
        for (let key in style) {
          if (style.hasOwnProperty(key)) {
            style[key] = ResolveNodeValue(style[key], currentScopeVariables);
          }
        }
        resolvedLayer.props.style = style;
      }
    }

  }
  
  return resolvedLayer;
}
export function prepareLogicalTest(binaryTestArray: any): any {
  return {
    type: "logicalExpression",
    left: binaryTestArray[0],
    right:
      binaryTestArray.length === 2
        ? binaryTestArray[1]
        : prepareLogicalTest(binaryTestArray.splice(1)),
    operator: "&&"
  };
}

export function prepareBinaryTest(key: string, value: any) {
  return {
    type: "binaryExpression",
    left: { type: "expression", expression: key },
    right: { type: "literal", value: value },
    operator: "==="
  };
}

export function isConditionPresent(conditionalObj: any, condition: any) {
  let keys = Object.keys(condition);
  if (conditionalObj.test.type === "logicalExpression") {
    if (
      conditionalObj.test.left.type === "expression" &&
      keys.indexOf(conditionalObj.test.left.expression) > -1 &&
      conditionalObj.test.operator === "==="
    ) {
      return conditionalObj;
    } else if (
      conditionalObj.test.left.type === "binaryExpression" &&
      keys.indexOf(conditionalObj.test.left.expression) > -1 &&
      conditionalObj.test.operator === "==="
    ) {
      return conditionalObj;
    }
  }
  if (conditionalObj.test.type === "binaryExpression") {
    if (
      conditionalObj.test.left.type === "expression" &&
      keys.indexOf(conditionalObj.test.left.expression) > -1 &&
      conditionalObj.test.operator === "==="
    ) {
      return conditionalObj;
    }
  }
}

export function prepareTest(conditions: { [key: string]: any }) {
  let binaryTestArray: any = [];
  forEach(conditions, (value: any, key: string) => {
    let binaryTest;
    if (typeof value === "boolean") {
      binaryTest = {
        type: "expression",
        expression: key
      };
    } else {
      binaryTest = prepareBinaryTest(key, value);
    }
    binaryTestArray.push(binaryTest);
  });

  if (binaryTestArray.length === 1) {
    return binaryTestArray[0];
  } else {
    return prepareLogicalTest(binaryTestArray);
  }
}

export function prepareLogicalLeft(
  currentRecordingConditions: any,
  value: any,
  oldValue: any,
  key: string
): any {
  // console.log(oldValue, "hello old!@!@");
  if (
    !oldValue ||
    !oldValue.type ||
    oldValue.type === "literal" ||
    oldValue.type === "unknown" ||
    !Utils.shouldIgnoreLayer(oldValue.type)
  ) {
    if (key === "transform") {
      value = [new Transform(value[0])];
    }
    return {
      left: prepareTest(currentRecordingConditions),
      type: "logicalExpression",
      operator: "&&",
      right: {
        type: "literal",
        value: value
      }
    };
  } else {
    // console.log(oldValue, "hello olded");

    let oldLeft = oldValue.expression.left;
    return {
      left: oldLeft,
      type: "logicalExpression",
      operator: "||",
      right: prepareLogicalLeft(
        currentRecordingConditions,
        value,
        undefined,
        key
      )
    };
  }
}

export function getLogicalExpression(
  currentRecordingConditions: any,
  currentScopeVariables: any,
  value: any,
  oldValue: any,
  key: string
) {
  return {
    type: "logicalExpression",
    left: prepareLogicalLeft(currentRecordingConditions, value, oldValue, key),
    operator: "||",
    right: { type: "literal", value: ResolveNodeValue(oldValue, {}) }
  };
}
export function getConditionalJSON(
  currentRecordingConditions: any,
  currentScopeVariables: any,
  value: any,
  oldValue: any,
  key: string
) {
  // console.log(oldValue, currentRecordingConditions, value, "hello old value");
  if (typeof value === "number" && typeof oldValue === "number") {
    if (value.toFixed(0) === oldValue.toFixed(0)) {
      return value;
    }
  }
  var resultValue = value;
  if (size(currentRecordingConditions) !== 0) {
    const conditionalJSON = {
      type: "expressionStatement",
      expression: getLogicalExpression(
        currentRecordingConditions,
        currentScopeVariables,
        value,
        oldValue,
        key
      )
    };

    // if (typeof oldValue === "object") {
    resultValue = conditionalJSON;
    // } else if (oldValue.type === "conditionalExpression") {
    //   //
    // }
  }
  // console.log(resultValue, "resultValueresultValueresultValue");
  return resultValue;
}

export function matchCondition(
  oldValue: ExpressionStatement,
  currentRecordingConditions: any
) {
  const logicalExp = oldValue.expression;
  let resolveTest = false;

  if (logicalExp instanceof LogicalExpression) {
    logicalExp.traverse((node: BinaryExpression | Expression | LiteralNode) => {
      if (node instanceof BinaryExpression) {
        //
        resolveTest = resolveBinaryTest(node, currentRecordingConditions);
      } else if (node instanceof Expression) {
        //
        resolveTest = !isUndefined(currentRecordingConditions[node.expression]);
      }

      if (resolveTest) {
        //
      }
    });
  }
  return resolveTest;
}
