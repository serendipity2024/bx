import {
  camelCase,
  escape,
  upperFirst,
  map,
  get,
  forEach,
  includes,
  replace,
  isNil,
  union,
  snakeCase,
  filter,
  cloneDeep,
  findIndex,
  last
} from "lodash";
import { Session } from "session";
import { LayerJSON, SystemFont, Font, ITemplate } from "common-interfaces";
import {
  ExpressionStatement,
  Props,
  Style,
  Expression,
  LogicalExpression,
  BinaryExpression,
  File as DomainFile,
  Layer as DomainLayer
} from "domain-x";
import { isArray } from "util";
import { Gradient } from "@builderx-core/designer";
import { BX_PREVIEW_FILE_PATH } from "bx-constants";
var WebFont = typeof window !== "undefined" ? require("webfontloader") : {};
const path = require("path-browserify");

export default class Utils {
  static symbolProps: any;
  static debouncedDomToImageConverter: any;

  static asyncForEach = async (
    array: Array<any> | undefined,
    callback: any
  ) => {
    if (!array) {
      return;
    }
    for (let index = 0; index < array.length; index++) {
      await callback(array[index], index, array);
    }
  };

  static getSymbolNameFromFileId = (fileId: string) => {
    let symbolNameMatch = fileId.match(/(([^/]*))\.js$/);
    let symbolName;
    if (!symbolNameMatch) {
      symbolName = "Untitled" + Math.floor(Math.random() * 100000);
    } else {
      symbolName = upperFirst(camelCase(symbolNameMatch[1]));
    }
    return symbolName;
  };

  static getFileNameUserInput = async (
    session: Session,
    Prompt: any,
    fileName: string,
    promptMessage?: string,
    error?: string
  ) => {
    const { selectedFile } = session;
    if (!selectedFile) {
      throw new Error("No Selected File");
    }
    fileName = fileName.includes(".")
      ? fileName.substring(0, fileName.lastIndexOf("."))
      : fileName;

    let defaultDirectoryPath = selectedFile.path.substr(
      0,
      selectedFile.path.lastIndexOf("/") + 1
    );

    let newFileName: string = "";
    if (!promptMessage) {
      promptMessage = "Rename File";
    }
    await Prompt(promptMessage, "Enter file name", fileName, error).then(
      async (result: any) => {
        if (result) {
          result = result.replace(/ /g, "");
        }
        if (!result) {
          // throw new Error("No Input");
        } else if (!Utils.validateVariableName(result)) {
          newFileName = await Utils.getFileNameUserInput(
            session,
            Prompt,
            fileName,
            "Enter file name",
            Utils.isReservedKeyword(result)
              ? "* Cannot use reserved keywords"
              : Utils.startsWithNumber(result)
              ? "* First character can't be a number"
              : "* Cannot use special characters"
          );
        } else if (result.length > 0) {
          const fileId = `${defaultDirectoryPath}${upperFirst(
            camelCase(result)
          )}.js`;
          if (
            !session.domain.files.has(fileId) &&
            !session.domain.files.has(fileId.toLowerCase())
          ) {
            newFileName = upperFirst(camelCase(result));
          } else if (result !== fileName) {
            newFileName = await Utils.getFileNameUserInput(
              session,
              Prompt,
              fileName,
              "Enter file name",
              "* File name already exists"
            );
          }
        }
      }
    );
    return newFileName;
  };

  static getStyleNameUserInput = async (
    session: Session,
    Prompt: any,
    styleName: string,
    promptMessage?: string,
    error?: string
  ) => {
    let newStyleName = "";
    if (!promptMessage) {
      promptMessage = "Rename Layer";
    }
    await Prompt(promptMessage, "Enter layer name", styleName, error).then(
      async (result: any) => {
        result = result || "";

        const fileName = path.basename(session.selectedFile.path) || "";
        const componentClassName = fileName.split(".")[0] || "";
        if (!result) {
          // throw new Error("No Input");
        } else if (!Utils.validateVariableName(result)) {
          newStyleName = await Utils.getStyleNameUserInput(
            session,
            Prompt,
            styleName,
            "Rename Layer",
            Utils.isReservedKeyword(result)
              ? "* Cannot use reserved keywords"
              : Utils.startsWithNumber(result)
              ? "* First character can't be a number"
              : "* Cannot use special characters"
          );
        } else if (result.toLowerCase() === componentClassName.toLowerCase()) {
          newStyleName = await Utils.getStyleNameUserInput(
            session,
            Prompt,
            styleName,
            "Rename Layer",
            "* Layer name conflicts with file name"
          );
        } else if (result.length > 0) {
          newStyleName = result;
          const isValidName = session.selectedFile.isValidNewNameForLayer(
            newStyleName
          );
          if (!isValidName && newStyleName !== styleName) {
            newStyleName = await Utils.getStyleNameUserInput(
              session,
              Prompt,
              styleName,
              "Rename Layer",
              "* Layer name already exists"
            );
          }
        }
      }
    );
    if (newStyleName) {
      return newStyleName;
    } else {
      return styleName;
    }
  };
  static getProjectUserInput = async (
    session: Session,
    Prompt: any,
    error?: string
  ) => {
    let projectName = session.project.projectName;
    let newProjectName: string = "";
    await Prompt(
      "Rename Project",
      "Enter Project name",
      projectName,
      error
    ).then(async (result: any) => {
      const newName = result ? result.replace(/ /g, "") : result;
      if (result && newName && !Utils.validateVariableName(newName)) {
        newProjectName = await Utils.getProjectUserInput(
          session,
          Prompt,
          Utils.isReservedKeyword(result)
            ? "* Cannot use reserved keywords"
            : Utils.startsWithNumber(result)
            ? "* First character can't be a number"
            : "* Cannot use special characters"
        );
      } else if (result && newName && result.length > 0) {
        newProjectName = upperFirst(camelCase(newName));
      }
    });
    return newProjectName;
  };

  static getReactComponentFile = (fileId: string): any => {
    let className;
    if (fileId) {
      className = upperFirst(
        camelCase(
          fileId.substring(
            fileId.lastIndexOf("/") + 1,
            fileId.lastIndexOf(".js")
          )
        )
      );
    } else {
      className = "MySymbol";
    }

    return {
      path: fileId,
      isDirectory: false,
      content: "",
      isDirty: true,
      layer: {
        type: "root",
        import: {
          layerName: "View",
          packageName: "native",
          isDefaultImport: false,
          asName: ""
        },
        props: {
          style: {
            backgroundColor: {
              defaultValue: "white",
              renderValue: "white",
              conditions: []
            },
            flex: {
              defaultValue: 1,
              renderValue: 1,
              conditions: []
            }
          }
        },
        children: [],
        locked: false
      }
    };
  };

  static getNewFileName(filePath: string, files: any) {
    let newFileId = filePath + "/Untitled";
    let testFileId;

    let foundName = false;
    let untitledIndex = 0;
    while (!foundName) {
      testFileId = newFileId;
      newFileId += untitledIndex ? untitledIndex : "";

      if (files.get(newFileId + ".js")) {
        untitledIndex++;
        newFileId = testFileId;
      } else {
        foundName = true;
        newFileId = newFileId + ".js";
      }
    }

    return newFileId;
  }
  static getNewSymbolFileName(filePath: string, files: any, fileId?: string) {
    let newFileId = filePath + "/UntitledComponent";
    if (fileId) {
      let startIndex = fileId.lastIndexOf("/");
      let endIndex = fileId.lastIndexOf(".");
      newFileId = filePath + fileId.substring(startIndex, endIndex);
    }

    let testFileId;

    let foundName = false;
    let untitledIndex = 0;

    while (!foundName) {
      testFileId = newFileId;
      newFileId += untitledIndex ? untitledIndex : "";

      if (
        files.get(newFileId + ".js") ||
        files.get(newFileId.replace("/components/", "/symbols/") + ".js")
      ) {
        untitledIndex++;
        newFileId = testFileId;
      } else {
        foundName = true;
        newFileId = newFileId + ".js";
      }
    }

    return newFileId;
  }

  static getNewTabName(children: any) {
    let tabName = "Tab";
    let testFileId;

    let foundName = false;
    let untitledIndex = 0;

    const nameExists = (name: string) => {
      let exists = false;
      children.forEach((child: any) => {
        if (child.props && child.props.title.defaultValue === name) {
          exists = true;
        }
      });

      return exists;
    };

    while (!foundName) {
      testFileId = tabName;
      tabName += untitledIndex ? untitledIndex : "";

      if (nameExists(tabName)) {
        untitledIndex++;
        tabName = testFileId;
      } else {
        foundName = true;
        tabName = tabName;
      }
    }

    return tabName;
  }

  static getTIMESTAMP(): string {
    const date = new Date();
    const year = date.getFullYear();
    const month = ("0" + (date.getMonth() + 1)).substr(-2);
    const day = ("0" + date.getDate()).substr(-2);
    const hour = ("0" + date.getHours()).substr(-2);
    const minutes = ("0" + date.getMinutes()).substr(-2);
    const seconds = ("0" + date.getSeconds()).substr(-2);

    return (
      year +
      "-" +
      month +
      "-" +
      day +
      " " +
      hour +
      ":" +
      minutes +
      ":" +
      seconds
    );
  }
  static getTagNameFromJSXTag(layer: string) {
    let layerName;
    const layerNameMatch = layer.match(/^.*\<[\/\s]?(.*)[\s\S]*[\/]?\>.*$/);
    if (!layerNameMatch) {
      layerName = "Undefined";
    } else {
      layerName = layerNameMatch[1];
      layerName = layerName.split("/")[0].split(" ")[0];
    }
    return layerName;
  }

  static validateVariableName(name: string) {
    const patt = new RegExp(
      // tslint:disable-next-line:max-line-length
      /^(?!(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$)[$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc][$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc0-9\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19b0-\u19c0\u19c8\u19c9\u19d0-\u19d9\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1dc0-\u1de6\u1dfc-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f]*$/
    );

    return patt.test(name);
  }
  static startsWithNumber(name: string) {
    return name.match(/^\d/);
  }
  static isReservedKeyword(name: string) {
    const patt = new RegExp(
      // tslint:disable-next-line:max-line-length
      /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/
    );
    return patt.test(name);
  }
  static getLayerIdFromBabelPath(babelPath: string) {
    return babelPath.replace(/\[/g, ".").replace(/\]/g, "");
  }

  static randomString(length: number) {
    var text = "";
    var possible =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

    text = possible.charAt(Math.floor(Math.random() * 52));
    for (var i = 0; i < length - 1; i++) {
      text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
  }

  static getCentroid(coord: any) {
    var center = coord.reduce(
      function(point1: any, point2: any) {
        return [
          point1[0] + point2[0] / coord.length,
          point1[1] + point2[1] / coord.length
        ];
      },
      [0, 0]
    );
    return center;
  }
  static rotatePoint(point: any, angle: number, centroid: any) {
    angle = (angle * Math.PI) / 180.0;
    let newX =
      (point[0] - centroid[0]) * Math.cos(angle) -
      (point[1] - centroid[1]) * Math.sin(angle) +
      centroid[0];
    let newY =
      (point[1] - centroid[1]) * Math.cos(angle) +
      (point[0] - centroid[0]) * Math.sin(angle) +
      centroid[1];
    return [newX, newY];
  }

  static rotatePolygon(poly: any, angle: number, centroid?: any) {
    var centroid = centroid ? centroid : Utils.getCentroid(poly);
    poly.map((point: any, key: number) => {
      point = Utils.rotatePoint(point, angle, centroid);
      poly[key] = point;
    });

    return poly;
  }
  static getPointsFromBoundingBox(box: any) {
    let poly = [
      [box.x, box.y],
      [box.x + box.width, box.y],
      [box.x + box.width, box.y + box.height],
      [box.x, box.y + box.height]
    ];
    return poly;
  }
  static getMinValue(
    snappedData: any,
    originalDelta: { x: number; y: number }
  ) {
    let newSnappedData = {
      delta: { x: undefined, y: undefined },
      snappedPoint: { x: undefined, y: undefined },
      snappedToSide: [],
      type: ""
    };

    var resultDelta = snappedData.reduce((a: any, b: any) => {
      if (a.delta && b.delta) {
        if (isNil(a.delta.x) && isNil(b.delta.x)) {
          newSnappedData.delta.x = undefined;
          newSnappedData.snappedPoint.x = undefined;
        } else if (isNil(a.delta.x)) {
          newSnappedData.delta.x = b.delta.x;
          newSnappedData.snappedPoint.x = b.snappedPoint.x;
          newSnappedData.snappedToSide = union(
            newSnappedData.snappedToSide,
            b.snappedToSide
          );
          // newSnappedData.snappedToSide = b.snappedToSide;
          newSnappedData.type = b.type;
        } else if (isNil(b.delta.x)) {
          newSnappedData.delta.x = a.delta.x;
          newSnappedData.snappedPoint.x = a.snappedPoint.x;
          // newSnappedData.snappedToSide = a.snappedToSide;
          newSnappedData.snappedToSide = union(
            newSnappedData.snappedToSide,
            a.snappedToSide
          );

          newSnappedData.type = a.type;
        } else {
          if (
            Math.abs(a.delta.x - originalDelta.x) >
            Math.abs(originalDelta.x - b.delta.x)
          ) {
            newSnappedData.delta.x = b.delta.x;
            newSnappedData.snappedPoint.x = b.snappedPoint.x;
            // newSnappedData.snappedToSide = b.snappedToSide;
            newSnappedData.snappedToSide = union(
              newSnappedData.snappedToSide,
              b.snappedToSide
            );

            newSnappedData.type = b.type;
          } else {
            newSnappedData.delta.x = a.delta.x;
            newSnappedData.snappedPoint.x = a.snappedPoint.x;
            // newSnappedData.snappedToSide = a.snappedToSide;
            newSnappedData.snappedToSide = union(
              newSnappedData.snappedToSide,
              a.snappedToSide
            );

            newSnappedData.type = a.type;
          }
        }
        if (isNil(a.delta.y) && isNil(b.delta.y)) {
          newSnappedData.delta.y = undefined;
          newSnappedData.snappedPoint.y = undefined;
        } else if (isNil(a.delta.y)) {
          // newDeltaX = b.y;
          newSnappedData.delta.y = b.delta.y;
          newSnappedData.snappedPoint.y = b.snappedPoint.y;
          // newSnappedData.snappedToSide = b.snappedToSide;
          newSnappedData.snappedToSide = union(
            newSnappedData.snappedToSide,
            b.snappedToSide
          );

          newSnappedData.type = b.type;
        } else if (isNil(b.delta.y)) {
          newSnappedData.delta.y = a.delta.y;
          newSnappedData.snappedPoint.y = a.snappedPoint.y;
          // newSnappedData.snappedToSide = a.snappedToSide;
          newSnappedData.snappedToSide = union(
            newSnappedData.snappedToSide,
            a.snappedToSide
          );

          newSnappedData.type = a.type;
        } else {
          if (
            Math.abs(a.delta.y - originalDelta.y) >
            Math.abs(originalDelta.y - b.delta.y)
          ) {
            newSnappedData.delta.y = b.delta.y;
            newSnappedData.snappedPoint.y = b.snappedPoint.y;
            // newSnappedData.snappedToSide = b.snappedToSide;
            newSnappedData.snappedToSide = union(
              newSnappedData.snappedToSide,
              b.snappedToSide
            );

            newSnappedData.type = b.type;
          } else {
            newSnappedData.delta.y = a.delta.y;
            newSnappedData.snappedPoint.y = a.snappedPoint.y;
            // newSnappedData.snappedToSide = a.snappedToSide;
            newSnappedData.snappedToSide = union(
              newSnappedData.snappedToSide,
              a.snappedToSide
            );

            newSnappedData.type = a.type;
          }
        }
      }

      return newSnappedData;
    }, newSnappedData);
    return resultDelta;
  }

  static getDimensionFromPolygon(points: any) {
    let height = points[3][1] - points[0][1];
    let width = points[1][0] - points[0][0];
    let y = points[0][1];
    let x = points[0][0];

    return {
      x,
      y,
      width,
      height
    };
  }

  static middlePoint(point1: any, point2: any) {
    let newX = (point1[0] + point2[0]) / 2;
    let newY = (point1[1] + point2[1]) / 2;

    return [newX, newY];
  }

  static distance(point1: any, point2: any) {
    var a = point1[0] - point2[0];
    var b = point1[1] - point2[1];
    var c = Math.sqrt(a * a + b * b);
    return c;
  }

  // returns angle between AB and BC
  static findAngle(A: any, B: any, C: any, range: 180 | 360) {
    let AB = Math.sqrt(Math.pow(B[0] - A[0], 2) + Math.pow(B[1] - A[1], 2));
    let BC = Math.sqrt(Math.pow(B[0] - C[0], 2) + Math.pow(B[1] - C[1], 2));
    let AC = Math.sqrt(Math.pow(C[0] - A[0], 2) + Math.pow(C[1] - A[1], 2));

    let value = (BC * BC + AB * AB - AC * AC) / (2 * BC * AB);

    if (value > 1) {
      value = 1;
    }

    if (value < -1) {
      value = -1;
    }
    let angle = Math.acos(value);

    angle = (angle * 180) / Math.PI;

    if (range === 360) {
      if (C[0] < A[0]) {
        angle = 360 - angle;
      }
    }
    return angle;
  }

  static getAbsoluteRotation(poly: Array<any>) {
    var centroid = Utils.getCentroid(poly);
    let point1 = [centroid[0], centroid[1] - 2];
    let point2 = centroid;
    let point3 = Utils.middlePoint(poly[0], poly[1]);

    var angle = Utils.findAngle(point1, point2, point3, 360);

    return angle;
  }

  static removeMarginPropertiesForLayerScene(style: any) {
    delete style["margin"];
    delete style["marginTop"];
    delete style["marginLeft"];
    delete style["marginRight"];
    delete style["marginBottom"];
    return style;
  }

  static isValidTypeToPasteStyle(copiedStyleType: any, layerType: string) {
    let layerTypes = ["view", "touchableOpacity", "scrollView"];
    if (copiedStyleType === layerType) {
      return true;
    } else if (
      layerTypes.indexOf(copiedStyleType) !== -1 &&
      layerTypes.indexOf(layerType) !== -1
    ) {
      return true;
    }
    return false;
  }

  static sanitizeString(str: string) {
    str = str.replace(/[^a-z0-9 \_-]/gim, "");
    return str.trim();
  }
  static resolveLiteralNode(object: any) {
    let newObject = {};

    if (isArray(object)) {
      newObject = [];
    }
    map(object, (value: any, key: string) => {
      if (get(value, "type", "") === "literal") {
        const resolvedValue = get(value, "value");
        if (isArray(newObject)) {
          newObject.push(resolvedValue);
        } else {
          newObject[key] = resolvedValue;
        }
      } else if (get(value, "type", "") === "expression") {
        const resolvedValue = get(value, "expression");

        if (isArray(newObject)) {
          newObject.push(resolvedValue);
        } else {
          newObject[key] = resolvedValue;
        }
      } else if (typeof value === "object") {
        if (isArray(newObject)) {
          newObject.push(Utils.resolveLiteralNode(value));
        } else {
          newObject[key] = Utils.resolveLiteralNode(value);
        }
      } else {
        newObject[key] = value;
      }
    });
    return newObject;
  }

  static traverseJSON(layerJSON: LayerJSON, callback: any, layerId?: string) {
    callback(layerJSON, layerId);
    // console.log(typeof layerJSON, "addJSX1");
    if (layerJSON && typeof layerJSON.children === "object") {
      // console.log(typeof layerJSON.children, "addJSX2");
      layerJSON.children.forEach((child: LayerJSON, index: number) => {
        if (child.type !== "unknown") {
          Utils.traverseJSON(child, callback, `${layerId}.${index}`);
        }
      });
    }
  }

  static isEditableInput = () => {
    const activeElement = document.activeElement;
    if (
      activeElement &&
      (activeElement.tagName === "SELECT" ||
        activeElement.tagName === "INPUT" ||
        activeElement.tagName === "TEXTAREA" ||
        activeElement.getAttribute("contentEditable"))
    ) {
      return true;
    }
    return false;
  };

  static traverseLayerForExpressions(
    attribute: any,
    callback: (expression: Expression, key: string) => void
  ) {
    forEach(attribute, (value: any, key: string) => {
      if (!Utils.isInvalidKey(key)) {
        if (value instanceof Expression) {
          callback(value, key);
        } else if (
          value instanceof Props ||
          value instanceof Style ||
          value instanceof ExpressionStatement ||
          value instanceof LogicalExpression ||
          value instanceof BinaryExpression
        ) {
          Utils.traverseLayerForExpressions(value, callback);
        }
      }
    });
  }
  static getImageAbsPath(
    session: Session,
    projectId: string,
    imageRelPath: string
  ) {
    return `${session.envConstants.BACKEND_API_URL}file-content/${projectId}?fileName=${imageRelPath}`;
  }
  static shouldIgnoreLayer(type: string) {
    return (
      type === "unknown" ||
      type === "conditionalExpression" ||
      type === "expressionStatement" ||
      type === "binaryExpression" ||
      type === "logicalExpression" ||
      type === "literal" ||
      type === "" ||
      type === "expression"
    );
  }

  static isExpression(type: string) {
    return (
      type === "conditionalExpression" ||
      type === "expressionStatement" ||
      type === "binaryExpression" ||
      type === "logicalExpression" ||
      type === "expression"
    );
  }

  static getSelectionText() {
    var text = "";
    var activeEl: any = document.activeElement;
    var activeElTagName = activeEl ? activeEl.tagName.toLowerCase() : null;
    if (
      (activeEl && activeElTagName === "textarea") ||
      (activeElTagName === "input" &&
        /^(?:text|search|password|tel|url)$/i.test(activeEl.type) &&
        typeof activeEl.selectionStart === "number")
    ) {
      text = activeEl.value.slice(
        activeEl.selectionStart,
        activeEl.selectionEnd
      );
    } else if (window.getSelection) {
      const selectedText = window.getSelection();
      if (selectedText) {
        text = selectedText.toString();
      }
    }
    return text;
  }
  static getFontStyle(variant: string) {
    var fontVariant: string = variant.toLowerCase();
    // var variant: string = fontStyle;
    // for (var i: number = 0; i < variant.length; i++) {
    //   if (variant[i].match(/^[a-zA-Z]+$/)) {
    //     fontStyle += variant[i];
    //   }
    // }
    if (fontVariant.toLowerCase().indexOf("italic") !== -1) {
      return "italic";
    } else if (fontVariant.toLowerCase().indexOf("oblique") !== -1) {
      return "oblique";
    } else {
      return "normal";
    }
    // return fontStyle !== "regular" && fontStyle !== "" && fontStyle.length > 1
    //   ? fontStyle
    //   : "normal";
  }

  static getFontWeight(variant: string) {
    const fontVariant: string = variant.toLowerCase();
    let fontWeight = fontVariant.replace("italic", "").trim();
    fontWeight = fontWeight.replace("oblique", "").trim();

    const weights = FONT_WEIGHT_MAP.get(fontWeight);
    if (weights) {
      return weights.values[0];
    }
    return fontWeight;
  }
  static loadFont(
    selectedItem: { family: string; style: string; type?: string },
    onload?: () => void
  ) {
    if (selectedItem.type && selectedItem.type === "system") {
      WebFont.load({
        custom: { families: [selectedItem.family] },
        loading: function() {
          // console.log("loading");
        },
        active: function() {
          // console.log("active");
        },
        inactive: function() {
          // console.log("inactive");
        },
        fontloading: function(familyName: string, fvd: any) {
          // console.log("fontloading:", familyName, "fvd", fvd);
          if (onload) {
            onload();
          }
        },
        fontactive: function(familyName: string, fvd: any) {
          // console.log("fontactive:", familyName, "fvd", fvd);
        },
        fontinactive: function(familyName: string, fvd: any) {
          // console.log("fontinactive:", familyName, "fvd", fvd);
        }
      });
    } else {
      WebFont.load({
        google: { families: [selectedItem.family + ":" + selectedItem.style] },
        loading: function() {
          // console.log("loading");
        },
        active: function() {
          // console.log("active");
        },
        inactive: function() {
          // console.log("inactive");
        },
        fontloading: function(familyName: string, fvd: any) {
          // console.log("fontloading:", familyName, "fvd", fvd);
          if (onload) {
            onload();
          }
        },
        fontactive: function(familyName: string, fvd: any) {
          // console.log("fontactive:", familyName, "fvd", fvd);
        },
        fontinactive: function(familyName: string, fvd: any) {
          // console.log("fontinactive:", familyName, "fvd", fvd);
        }
      });
    }
  }

  static checkIfExistsStyle(
    fontWeightStyle: any,
    fontFamily: any,
    fontsList: Font[]
  ) {
    let tempRes;
    const weights = FONT_WEIGHT_MAP.get(fontWeightStyle);
    const styleList = [
      ...filter(fontsList, (o: any) => o.family === fontFamily)
    ];

    const found = findIndex(styleList, (font: any) => {
      if (weights) {
        if (weights.values.indexOf(font.style.toLowerCase()) > -1) {
          return true;
        }
      }

      return false;
    });
    if (found > -1) {
      if (styleList[found].family === fontFamily) {
        tempRes = styleList[found];
      }
    }

    return tempRes;
  }

  static getFontVariant(fontWeight: any, fontStyle: any) {
    const fontVariant =
      fontWeight + (fontStyle && fontStyle !== "normal" ? fontStyle : "");

    return fontVariant;
  }

  static getDefaultTypeFace = (family: string, fontsList: Font[]) => {
    const weights = FONT_WEIGHT_MAP.get("normal");

    const found = findIndex(fontsList, (font: any) => {
      if (weights && font.family === family) {
        if (weights.values.indexOf(font.style.toLowerCase()) > -1) {
          return true;
        }
      }

      return false;
    });
    let tempRes;
    // console.log(found, "hello 111");

    if (found > -1) {
      if (fontsList[found].family === family) {
        tempRes = fontsList[found];
      }
    }

    return tempRes;
  };

  static getTypeface = (
    fontFamily: string,
    fontWeight: any,
    fontStyle: any,
    fontsList: SystemFont[]
  ) => {
    let typeface: SystemFont;

    if (!fontStyle && !fontWeight) {
      typeface = Utils.getDefaultTypeFace(fontFamily, fontsList) as any;
    } else if (!fontWeight && fontStyle) {
      const defaultFontface = Utils.getDefaultTypeFace(fontFamily, fontsList);
      if (defaultFontface) {
        typeface = Utils.checkIfExistsStyle(
          Utils.getFontVariant(defaultFontface.style, fontStyle),
          fontFamily,
          fontsList
        );
      } else {
        typeface = Utils.getDefaultTypeFace(fontFamily, fontsList) as any;
      }
    } else {
      typeface = Utils.checkIfExistsStyle(
        Utils.getFontVariant(fontWeight, fontStyle),
        fontFamily,
        fontsList
      );
    }

    return typeface;
  };

  static getFontProperties(fontFamily: string) {
    let newStyle = {};
    if (fontFamily) {
      var fontPostscriptName = fontFamily;
      const arr = fontPostscriptName.split("-");
      const last = arr.pop();

      if (arr.length === 1) {
        newStyle["fontFamily"] = snakeCase(arr[0])
          .split("_")
          .join(" ");
      } else {
        newStyle["fontFamily"] = arr.join(" ");
      }

      if (last) {
        newStyle["fontStyle"] = Utils.getFontStyle(last);
        newStyle["fontWeight"] = Utils.getFontWeight(last);
      }
    }
    return newStyle;
  }

  static isMobileOrTablet() {
    var check = false;
    (function(a: any) {
      if (
        // tslint:disable-next-line: max-line-length
        /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(
          a
        ) ||
        // tslint:disable-next-line: max-line-length
        /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(
          a.substr(0, 4)
        )
      ) {
        check = true;
      }
      // var isChrome =
      //   /Chrome/.test(navigator.userAgent) &&
      //   /Google Inc/.test(navigator.vendor);
      // check = check && !isChrome;
    })(navigator.userAgent || navigator.vendor || (window as any).opera);
    return check;
  }
  static isChrome() {
    var isChrome =
      /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
    return isChrome;
  }

  static getQueryStringValue(key: string): any {
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get(key);
  }

  static getEnv(key?: string): any {
    const bxEnv = window["bxEnv"];
    if (!key) {
      return bxEnv;
    }
    return bxEnv[key];
  }

  static getFileBlob(dataURL: string, fileName: string) {
    const BASE64_MARKER = ";base64,";
    const parts = dataURL.split(BASE64_MARKER);
    const contentType = parts[0].split(":")[1];
    const raw = window.atob(parts[1]);
    const rawLength = raw.length;
    const uInt8Array = new Uint8Array(rawLength);

    for (let i = 0; i < rawLength; ++i) {
      uInt8Array[i] = raw.charCodeAt(i);
    }

    const blob = new Blob([uInt8Array], { type: "image/png" });

    return new File([blob], fileName, { type: "image/png" });
  }
  static removeContainerStyleFromCode(content: string) {
    if (content && content.replace) {
      content = content.replace(
        /\/\/ Only for displaying (artboard|symbol) in BuilderX\.[\]static containerStyle = {[\s\w:,"]*};[\s]{3}/,
        ""
      );
    }
    return content;
  }

  static santizeText(text: string) {
    let sanitizedText = text;
    if (
      text.indexOf(`{'\\n'}`) !== -1 ||
      text.indexOf(`{'\\t'}`) !== -1 ||
      text.indexOf(`{"\\n"}`) !== -1 ||
      text.indexOf(`{"\\t"}`) !== -1
    ) {
      sanitizedText = text
        .replace(/\<Text.*?\>/, "")
        .replace(/\<\s*\/\s*Text\s*\>\s*$/, "")
        .replace(/{"\\t"}/g, "\t")
        .replace(/{'\\t'}/g, "\t")
        .replace(/{"\\n"}/g, "\n")
        .replace(/{'\\n'}/g, "\n")
        .trim();
    } else {
      sanitizedText = text
        .replace(/\<Text.*?\>/, "")
        .replace(/\<\s*\/\s*Text\s*\>\s*$/, "")
        .replace(/\\t/g, "\t")
        .replace(/\\n/g, "")
        .replace(/^\n[\s]*/g, " ")
        .replace(/\n[\s]*/g, " ")
        .replace(/\n/g, "")
        // .replace(/[\s]*\n[\s]*/g, " ")
        .trim();
    }

    sanitizedText = unescape(sanitizedText);

    return sanitizedText;
  }

  static escapeTextForJSX(text: string) {
    if (typeof text === "string") {
      text = text.trim();
      text = escape(text);
      // Utils.santizeText(text);
    }
    if (includes(text, "\n")) {
      text = replace(text, new RegExp("\n", "g"), `{\"\\n"}`);
      text = replace(text, new RegExp("\t", "g"), `{\"\\t"}`);
    }

    return text;
  }

  static getRulerRelativePosition(
    selectedFile: DomainFile,
    ruler: any,
    parentCompiledLayer: any
  ) {
    let x: number | undefined = 0;
    let y: number | undefined = 0;

    if (parentCompiledLayer && selectedFile) {
      x =
        ruler.direction === "vertical"
          ? ruler.originalDistance +
            selectedFile.getBoundingClientRect().rootX -
            (parentCompiledLayer as any).rootX
          : undefined;
      y =
        ruler.direction === "vertical"
          ? undefined
          : ruler.originalDistance +
            selectedFile.getBoundingClientRect().rootY -
            (parentCompiledLayer as any).rootY;
    }

    return { x, y };
  }

  static getFontWeightMap() {
    // const thin = ["100", "thin", "hairline"];
    // const extraLight = [""]

    const synonymsList = [
      { displayName: "Thin", values: ["100", "thin", "hairline"] },
      {
        displayName: "Extra Light",
        values: [
          "200",
          "extra light",
          "extralight",
          "ultra light",
          "ultralight"
        ]
      },
      { displayName: "Light", values: ["300", "light"] },
      { displayName: "Normal", values: ["400", "normal", "regular"] },
      { displayName: "Regular", values: ["400", "normal", "regular"] },
      { displayName: "Medium", values: ["500", "medium"] },
      {
        displayName: "Semi Bold",
        values: ["600", "semi bold", "semibold", "demi bold", "demibold"]
      },
      { displayName: "Bold", values: ["700", "bold"] },
      {
        displayName: "Extra Bold",
        values: ["800", "extra bold", "extrabold", "ultra bold", "ultrabold"]
      },
      { displayName: "Black", values: ["900", "black", "heavy"] },
      {
        displayName: "Extra Black",
        values: [
          "950",
          "extra black",
          "extrablack",
          "ultra black",
          "ultrablack"
        ]
      },
      {
        displayName: "Thin Italic",
        values: [
          "100italic",
          "thin Italic",
          "thinItalic",
          "hairline Italic",
          "hairlineItalic"
        ]
      },
      {
        displayName: "Extra Light Italic",
        values: [
          "200italic",
          "extra light italic",
          "extralightitalic",
          "ultra light italic",
          "ultralightitalic"
        ]
      },

      {
        displayName: "Light Italic",
        values: ["300italic", "light italic", "lightitalic"]
      },
      {
        displayName: "Normal Italic",
        values: [
          "400italic",
          "italic",
          "normal italic",
          "normalitalic",
          "regular italic",
          "regularitalic"
        ]
      },
      {
        displayName: "Medium Italic",
        values: ["500italic", "medium italic", "mediumitalic"]
      },
      {
        displayName: "Semi Bold Italic",
        values: [
          "600italic",
          "semi bold italic",
          "semibolditalic",
          "demi bold italic",
          "demibolditalic"
        ]
      },
      {
        displayName: "Bold Italic",
        values: [
          "700italic",
          "bold italic",
          "bolditalic",
          "italic bold",
          "italicbold"
        ]
      },
      {
        displayName: "Extra Bold Italic",
        values: [
          "800italic",
          "extra bold italic",
          "extrabolditalic",
          "ultra bold italic",
          "ultrabolditalic"
        ]
      },
      {
        displayName: "Black Italic",
        values: ["900italic", "black italic", "blackitalic"]
      },
      {
        displayName: "Extra Black Italic",
        values: [
          "900italic",
          "extra black italic",
          "extrablackitalic",
          "ultra black italic",
          "ultrablackitalic"
        ]
      }
    ];

    var weightMap: any = new Map();
    synonymsList.forEach(
      (synonyms: { displayName: string; values: string[] }) => {
        synonyms.values.forEach((synonym: string) => {
          weightMap.set(synonym, synonyms);
        });
        weightMap.set(synonyms.displayName, synonyms);
      }
    );
    return weightMap;
  }

  static getLayerSceneDimensions(currentLayer: DomainLayer) {
    // if (
    //   get(currentLayer, "parent.parent.import.layerName", undefined) ===
    //   "TabView"
    // ) {
    //   const renderCompiledLayer = get(
    //     currentLayer,
    //     "parent.parent.domainCompiledRefs.0.renderCompiledRef",
    //     { width: 300, height: 300 }
    //   );
    //   return {
    //     width: renderCompiledLayer.width,
    //     height: renderCompiledLayer.height - 46
    //   };
    // }
    // if (
    //   get(currentLayer, "parent.parent.import.layerName", undefined) ===
    //   "Swiper"
    // ) {
    //   const renderCompiledLayer = get(
    //     currentLayer,
    //     "parent.domainCompiledRefs.0.renderCompiledRef",
    //     { width: 300, height: 300 }
    //   );
    //   return {
    //     width: renderCompiledLayer.width,
    //     height: renderCompiledLayer.height
    //   };
    // } else if (
    //   get(currentLayer, "parent.import.layerName", undefined) === "FlatList"
    // ) {
    //   // TODO: Heavy Jugaad, accessing 1st references
    //   const renderCompiledLayer = get(
    //     currentLayer,
    //     "domainCompiledRefs.1.renderCompiledRef",
    //     {
    //       width: 320,
    //       height: 50
    //     }
    //   );
    //   return {
    //     width: renderCompiledLayer.width,
    //     height: renderCompiledLayer.height
    //   };
    // }
    // return {
    //   width: currentLayer.domainCompiledRefs[0].renderCompiledRef.width,
    //   height: currentLayer.domainCompiledRefs[0].renderCompiledRef.height
    // };

    return {
      width: 320,
      height: 50
    };
  }

  static symbolTraverse(
    session: Session,
    symbolFile: DomainFile,
    callback: (layer: DomainFile) => void
  ) {
    // const symbolFile = session.domain.getSymbolFileFromSymbolInstance(layer);

    if (symbolFile) {
      symbolFile.layer.traverseLayers((layer: DomainLayer) => {
        if (layer.type === "symbol") {
          const childSymbolFile = session.domain.getSymbolFileFromSymbolInstance(
            layer
          );
          if (childSymbolFile) {
            Utils.symbolTraverse(session, childSymbolFile, callback);
          }
        }
      });
    }
    callback(symbolFile);
  }
  static checkIfCircularSymbol(
    session: Session,
    symbolFile: DomainFile | undefined,
    parentLayer: DomainLayer
  ) {
    if (!symbolFile || !symbolFile.layer) {
      return true;
    }
    let add = true;
    const parentFile = parentLayer.getFile();
    if (parentFile && symbolFile) {
      if (parentFile.path === symbolFile.path) {
        add = false;
      } else {
        Utils.symbolTraverse(
          session,
          symbolFile,
          (childSymbolFile: DomainFile) => {
            if (childSymbolFile !== symbolFile) {
              if (
                childSymbolFile &&
                childSymbolFile.path === parentFile.path &&
                add
              ) {
                add = false;
              }
            }
          }
        );
      }
    }

    if (!add) {
      return true;
    }

    return false;
  }

  static getDCInDomainStructure(layerJSON: any) {
    let domainLayerJSON;
    if (layerJSON.domain) {
      domainLayerJSON = layerJSON.domain;
    } else {
      domainLayerJSON = layerJSON;
    }
    if (domainLayerJSON.children) {
      domainLayerJSON.children = layerJSON.children;
    }
    if (layerJSON.rcDims) {
      domainLayerJSON.rcDims = layerJSON.rcDims;
    }

    if (layerJSON.domainType === "symbol") {
      domainLayerJSON.styleName =
        domainLayerJSON.styleName.charAt(0).toUpperCase() +
        domainLayerJSON.styleName.slice(1);
      domainLayerJSON.styleName =
        layerJSON.domainStyleName + domainLayerJSON.styleName;
    }

    if (layerJSON.children) {
      layerJSON.children.forEach((childJSON: any, index: number) => {
        layerJSON.children[index] = Utils.getDCInDomainStructure(childJSON);
      });
    }
    return domainLayerJSON;
  }
  static getGradient(gradient: any, palette?: any) {
    let colors: any = [];
    if (palette) {
      forEach(palette, (data: any, index: number) => {
        colors.push(data.color);
      });
    } else {
      forEach(gradient.stops, (data: any, index: number) => {
        colors.push(data.stopColor);
      });
    }
    let vector;
    if (gradient.to && gradient.from) {
      vector = {
        x: (gradient.to.x as number) - (gradient.from.x as number),
        y: (gradient.to.y as number) - (gradient.from.y as number)
      };
    } else {
      vector = {
        x: 0,
        y: 2
      };
    }
    const angleRad = Math.atan2(vector.y, vector.x);
    const angleDeg = (angleRad * 180) / Math.PI + 90;

    let realLocations: any = [];
    if (palette) {
      forEach(palette, (data: any, index: number) => {
        realLocations.push(data.pos);
      });
    } else {
      forEach(gradient.stops, (data: any, index: number) => {
        realLocations.push(data.offset);
      });
    }

    const colorStrings = colors
      .map(
        (color: any, i: number) =>
          `${color} ${Math.round(realLocations[i] * 100)}%`
      )
      .join(", ");

    if (gradient.gradientType && gradient.gradientType === "LinearGradient") {
      return `linear-gradient(${angleDeg}deg, ${colorStrings})`;
    } else if (
      gradient.gradientType &&
      gradient.gradientType === "RadialGradient"
    ) {
      const dist = Math.sqrt(
        (gradient.to.x - gradient.from.x) * (gradient.to.x - gradient.from.x) +
          (gradient.to.y - gradient.from.y) * (gradient.to.y - gradient.from.y)
      );
      const maxDist = Math.sqrt(
        (1 - gradient.from.x) * (1 - gradient.from.x) +
          (1 - gradient.from.y) * (1 - gradient.from.y)
      );
      const radialColorStrings = colors
        .map(
          (color: any, i: number) =>
            `${color} ${Math.round(realLocations[i] * (dist / maxDist) * 100)}%`
        )
        .join(", ");
      return `radial-gradient(circle at ${gradient.from.x * 100}% ${gradient
        .from.y * 100}%,${radialColorStrings})`;
    } else if (
      gradient.gradientType &&
      gradient.gradientType === "AngularGradient"
    ) {
      return `conic-gradient(${colorStrings})`;
    } else {
      return `linear-gradient(${angleDeg}deg, ${colorStrings})`;
    }
  }
  static isHexColor(color: string): boolean {
    return color && typeof color === "string" ? color.startsWith("#") : false;
  }

  static isRgbColor(color: string): boolean {
    return color && typeof color === "string" ? color.startsWith("rgb") : false;
  }

  static getColorWithNewAlpha(color: string, alpha: string | number) {
    alpha = Number(alpha);
    const helperIndex =
      color.split(",").length > 3
        ? color.lastIndexOf(",")
        : color.lastIndexOf(")");
    return color.substring(0, helperIndex) + `,${alpha})`;
  }

  static getColorAlpha(color: any) {
    if (color && Utils.isHexColor(color)) {
      color = Utils.hexToRgb(color);
    }
    if (color && color.split(",").length < 4) {
      return 100;
    }
    return color
      ? Number(color.substring(color.lastIndexOf(",") + 1, color.length - 1)) *
          100
      : 100;
  }
  static hexToRgb(hex: string) {
    if (!this.isHexColor(hex)) {
      return null;
    }
    const result =
      hex.length > 4
        ? /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex)
        : /^#?([a-f\d]{1})([a-f\d]{1})([a-f\d]{1})$/i.exec(hex);
    return result
      ? `rgba(${parseInt(result[1], 16).toString()},${parseInt(
          result[2],
          16
        ).toString()}, ${parseInt(result[2], 16).toString()}, 1)`
      : null;
  }

  static domainLayerTemplateFromCanvasTemplate(template: any): ITemplate {
    const newTemplate = cloneDeep(template);

    const mergedStyle = { ...newTemplate.layout, ...newTemplate.style };

    newTemplate.props.style = mergedStyle;
    delete newTemplate.style;
    delete newTemplate.layout;

    return newTemplate;
  }

  static isInvalidKey(key: any) {
    return (
      key === "eventListenersMap" ||
      key === "reverseMap" ||
      key === "disposed" ||
      key === "_parent" ||
      key === "parent"
    );
  }
  static getGradientString(gradient: Gradient, palette?: any) {
    return Utils.getGradient(gradient, palette);
  }

  static removeTrailingSlash(str: string) {
    return String(str).replace(/\/+$/, "");
  }

  static splitPatchPath(operation: any) {
    let filePath = "",
      layerPath = "",
      stageId = "",
      expressionPath = "",
      scopeVariablesPath = "",
      expressionListPath = "",
      propsStylePath = "";
    const splitPath = operation.path.split(":::");
    if (operation.path.startsWith("/domain/files")) {
      filePath = splitPath[1];
      if (splitPath[2] && splitPath[2].indexOf("/props/") === 0) {
        propsStylePath = splitPath[2];
        // layerPath = filePath;
      } else if (splitPath[2] && splitPath[2] === "/layer") {
        layerPath = filePath + ":0";
      } else if (splitPath[2] && splitPath[2].includes("/props/")) {
        const indexOfProps = splitPath[2].indexOf("/props/");
        propsStylePath = splitPath[2].slice(indexOfProps);
        layerPath =
          filePath +
          ":" +
          splitPath[2]
            .slice(1, indexOfProps)
            .replace(/\//g, ".")
            .replace("layer", 0);
      } else if (splitPath[2] && splitPath[2].includes("/selected")) {
        const indexOfSelected = splitPath[2].indexOf("/selected");
        layerPath =
          filePath +
          ":" +
          splitPath[2]
            .slice(1, indexOfSelected)
            .replace(/\//g, ".")
            .replace("layer", 0);
      } else if (splitPath[2] && splitPath[2].includes("/hovered")) {
        const indexOfHovered = splitPath[2].indexOf("/hovered");
        layerPath =
          filePath +
          ":" +
          splitPath[2]
            .slice(1, indexOfHovered)
            .replace(/\//g, ".")
            .replace("layer", 0);
      } else if (splitPath[2] && splitPath[2].includes("/locked")) {
        const indexOfLocked = splitPath[2].indexOf("/locked");
        layerPath =
          filePath +
          ":" +
          splitPath[2]
            .slice(1, indexOfLocked)
            .replace(/\//g, ".")
            .replace("layer", 0);
      } else if (splitPath[2] && splitPath[2].includes("/hidden")) {
        const indexOfHidden = splitPath[2].indexOf("/hidden");
        layerPath =
          filePath +
          ":" +
          splitPath[2]
            .slice(1, indexOfHidden)
            .replace(/\//g, ".")
            .replace("layer", 0);
      } else if (splitPath[2] && splitPath[2].includes("/collapsed")) {
        const indexOfCollapsed = splitPath[2].indexOf("/collapsed");
        layerPath =
          filePath +
          ":" +
          splitPath[2]
            .slice(1, indexOfCollapsed)
            .replace(/\//g, ".")
            .replace("layer", 0);
      } else if (splitPath[2] && splitPath[2].includes("/aspectRatio")) {
        const indexOfAspectRatio = splitPath[2].indexOf("/aspectRatio");
        layerPath =
          filePath +
          ":" +
          splitPath[2]
            .slice(1, indexOfAspectRatio)
            .replace(/\//g, ".")
            .replace("layer", 0);
      } else if (splitPath[2] && splitPath[2].includes("/value")) {
        const indexOfValue = splitPath[2].indexOf("/value");
        layerPath =
          filePath +
          ":" +
          splitPath[2]
            .slice(1, indexOfValue)
            .replace(/\//g, ".")
            .replace("layer", 0);
      } else if (splitPath[2] && splitPath[2].includes("/isResizerVisible")) {
        const indexOfIsResizerVisible = splitPath[2].indexOf(
          "/isResizerVisible"
        );
        if (splitPath[2].indexOf("/isResizerVisible") !== 0) {
          layerPath =
            filePath +
            ":" +
            splitPath[2]
              .slice(1, indexOfIsResizerVisible)
              .replace(/\//g, ".")
              .replace("layer", 0);
        }
      } else if (splitPath[2] && splitPath[2].includes("/navigateTo")) {
        const indexOfNavigateTo = splitPath[2].indexOf("/navigateTo");
        layerPath =
          filePath +
          ":" +
          splitPath[2]
            .slice(1, indexOfNavigateTo)
            .replace(/\//g, ".")
            .replace("layer", 0);
      } else if (splitPath[2] && splitPath[2].includes("/ui/resizingType")) {
        const indexOfResizingType = splitPath[2].indexOf("/ui/resizingType");
        layerPath =
          filePath +
          ":" +
          splitPath[2]
            .slice(1, indexOfResizingType)
            .replace(/\//g, ".")
            .replace("layer", 0);
      } else if (splitPath[2] && splitPath[2].includes("/styleName")) {
        const indexOfStyleName = splitPath[2].indexOf("/styleName");
        layerPath =
          filePath +
          ":" +
          splitPath[2]
            .slice(1, indexOfStyleName)
            .replace(/\//g, ".")
            .replace("layer", 0);
      } else if (splitPath[2] && splitPath[2].includes("/template")) {
        const indexOfTemplate = splitPath[2].indexOf("/template");
        layerPath =
          filePath +
          ":" +
          splitPath[2]
            .slice(1, indexOfTemplate)
            .replace(/\//g, ".")
            .replace("layer", 0);
      } else if (splitPath[2] && splitPath[2].includes("/expressionList")) {
        layerPath = "";
        expressionListPath = "/expressionList";
      } else if (splitPath[2] && splitPath[2].includes("/expression")) {
        const indexOfExpression = splitPath[2].indexOf("/expression");
        layerPath =
          filePath +
          ":" +
          splitPath[2]
            .slice(1, indexOfExpression)
            .replace(/\//g, ".")
            .replace("layer", 0);
        expressionPath = splitPath[2].slice(indexOfExpression);
      } else if (splitPath[2] && splitPath[2].includes("/isDirty")) {
        layerPath = "";
      } else if (splitPath[2] && splitPath[2].startsWith("/scopeVariables")) {
        layerPath = "";
      } else if (splitPath[2] && splitPath[2].startsWith("/formControls")) {
        layerPath = "";
      } else if (splitPath[2] && splitPath[2].includes("/scopeVariables")) {
        const indexOfScopeVariables = splitPath[2].indexOf("/scopeVariables");
        layerPath =
          filePath +
          ":" +
          splitPath[2]
            .slice(1, indexOfScopeVariables)
            .replace(/\//g, ".")
            .replace("layer", 0);
        scopeVariablesPath = splitPath[2].slice(indexOfScopeVariables);
      } else if (splitPath[2] && splitPath[2].includes("/statusBar")) {
        layerPath = "";
      } else if (splitPath[2] && !splitPath[2].includes("/props/")) {
        layerPath =
          filePath +
          ":" +
          splitPath[2]
            .slice(1)
            .replace(/\//g, ".")
            .replace("layer", 0);
      }
    } else if (
      operation.path.includes("/stages:::") ||
      operation.path.includes("/thumbnailStages:::")
    ) {
      stageId = splitPath[1];
    }
    return {
      filePath,
      propsStylePath,
      layerPath,
      stageId,
      expressionPath,
      expressionListPath,
      scopeVariablesPath
    };
  }

  static getParentLayerPathFromLayerPatch(operation: any) {
    const splitPath = operation.path.split(":::");
    let filePath, parentLayerPath;
    if (operation.path.startsWith("/domain/files")) {
      filePath = splitPath[1];
      if (splitPath[2] && splitPath[2] === "/layer") {
        parentLayerPath = filePath;
      } else {
        parentLayerPath =
          filePath +
          ":" +
          splitPath[2]
            .slice(1, splitPath[2].lastIndexOf("/children"))
            .replace(/\//g, ".")
            .replace("layer", 0);
      }
    }

    return parentLayerPath;
  }

  static resolveMapsForJsonPatch(
    operation: { op: string; path: string; value: any },
    object: any
  ) {
    const pathChunks = operation.path.split(":::");
    // if(last(pathChunks) === "") {
    //   pathChunks.splice(pathChunks.length - 1, 1);
    // }
    let modifiedPath: string = operation.path;
    let resolvedObject = object;
    if (pathChunks.length >= 3) {
      for (
        let index = 1;
        index < pathChunks.length && pathChunks.length - index >= 2;
        index = index + 2
      ) {
        const chunk = pathChunks[index];
        // const map:any = get(modifiedOperationObject, chunk.replace(/\//g, ".").slice(1));
        resolvedObject = get(
          resolvedObject,
          pathChunks[index - 1].replace(/\//g, ".").slice(1)
        );
        if (resolvedObject instanceof Map) {
          resolvedObject = resolvedObject.get(pathChunks[index]);
          modifiedPath = pathChunks.slice(index + 1).join(":::");
        }
      }
    }
    return { resolvedObject, modifiedPath };
  }

  static modifyLayerPathForJsonPatch(layerPath: string) {
    const pathChunks = layerPath.split(":");
    const filePath = pathChunks[0];
    let partialLayerPath = pathChunks[1];

    if (partialLayerPath !== undefined && partialLayerPath.startsWith("0")) {
      partialLayerPath = partialLayerPath.replace("0", "layer");
      partialLayerPath = partialLayerPath.replace(/\./g, "/");
      return filePath + ":::/" + partialLayerPath;
    } else {
      return filePath + ":::";
    }
  }

  static getValidLayerName(name: string) {
    // lowerCase first character if it is a letter
    return (
      (name[0].match(/[a-z]/i) ? name[0].toLowerCase() : name[0]) +
      name.slice(1)
    );
  }
  static isClickedOutside(event: any, domElement: any) {
    event.preventDefault();
    if (domElement && !domElement.contains(event.target)) {
      return true;
    }
    return false;
  }
  static isPersistentPatch(operation: {
    op: string;
    path: string;
    value: any;
    from?: string | undefined;
  }) {
    return (
      (operation.path.includes("/domain/files") ||
        operation.path.includes("/stages")) &&
      !operation.path.includes(BX_PREVIEW_FILE_PATH) &&
      !operation.path.endsWith("isDirty") &&
      !operation.path.endsWith("selected") &&
      !operation.path.endsWith("collapsed") &&
      !operation.path.endsWith("isResizerVisible") &&
      !operation.path.endsWith("props/gradientImage") &&
      !operation.path.includes("stageArtboards") &&
      !operation.path.endsWith("hovered")
    );
  }

  static reloadParentWindow() {
    var parent = window.parent;
    if (parent && parent.postMessage) {
      parent.postMessage({type: "builderx-reload"}, "*");
    }
  }
  static redirectParentWindow(url: string) {
    var parent = window.parent;
    if (parent && parent.postMessage) {
      parent.postMessage({tyoe: "builderx-redirect", payload: url}, "*");
    }
  }
}

const FONT_WEIGHT_MAP = Utils.getFontWeightMap();
