import ICommand from "./interfaces/ICommand";
import { remove } from "lodash";
import { action } from "model";
import { designerAction } from "@builderx-core/designer";
import { commandAction } from "src/model/lib/model";
type Info = {
  name: string;
  action: "undo" | "redo" | "execute" | "executeAndSkip" | "executeAndForget";
};
export default class CommandManager {
  undoStack: Array<ICommand> = [];
  redoStack: Array<ICommand> = [];

  currentState: number = -1;
  snapshotStack: Array<any> = [];
  history: Array<Info> = [];
  historyLimit: number = 30;
  debugMode: boolean;
  constructor(historyLimit: number = 30, debugMode: boolean = false) {
    this.historyLimit = historyLimit;
    this.debugMode = false;
  }
  execute = async (cmd: ICommand) => {
    if (
      this.debugMode &&
      window["session"] &&
      this.snapshotStack.length === 0
    ) {
      this.snapshotStack.push(window["session"].toJS());
      this.currentState++;
    }
    if (window["debug"] && window["debugLog"]) {
      window["debugLog"]("Command: " + cmd.displayName);
    }
    designerAction(() => {
      action(() => {
        commandAction(() => {
          cmd.execute();
        });
      });
    });
    this.undoStack.push(cmd);
    this.redoStack = [];
    // debugg mode

    if (!cmd.forget) {
      this.updateHistory({
        name: cmd.displayName,
        action: "execute"
      });
    }
    if (window["session"] && this.debugMode) {
      this.snapshotStack.splice(this.currentState + 1);
      this.snapshotStack.push(window["session"].toJS());
    }
    // if (this.currentState < 200) {
    this.currentState++;
    // }
  };

  executeAndSkip = async (cmd: ICommand) => {
    designerAction(() => {
      action(() => {
        commandAction(() => {
          cmd.execute();
        });
      });
    });

    // await cmd.execute();
  };

  executeAndForget = async (cmd: ICommand) => {
    cmd.forget = true;

    // designerAction(() => {
    //   action(() => {
    this.execute(cmd);
    //   });
    // });

    // await this.execute(cmd);
  };
  removeFromUndoStack = (instance: ICommand) => {
    remove(this.undoStack, instance);
  };
  removeFromRedoStack = (instance: ICommand) => {
    remove(this.redoStack, instance);
  };
  removeFromStack = (instance: ICommand) => {
    this.removeFromRedoStack(instance);
    this.removeFromUndoStack(instance);
  };
  undo = () => {
    while (this.isUndoable()) {
      let cmd = this.undoStack.pop();
      if (cmd) {
        designerAction(() => {
          action(() => {
            commandAction(() => {
              if (cmd) {
                cmd.undo();
              }
            });
          });
        });

        this.redoStack.push(cmd);
        this.updateHistory({
          name: cmd.displayName,
          action: "undo"
        });
        const nextCmd = this.undoStack[this.undoStack.length - 1];
        if (window["session"] && this.debugMode) {
          this.currentState--;
        }

        if (nextCmd && !nextCmd.forget) {
          break;
        }
      }
    }

    if (window["session"] && this.debugMode) {
      let snapshot = this.snapshotStack[this.currentState];
      // this.matchSessionSnapshot(snapshot);
    }
  };

  redo = () => {
    while (this.isRedoable()) {
      let cmd = this.redoStack.pop();
      if (cmd) {
        designerAction(() => {
          action(() => {
            commandAction(() => {
              if (cmd) {
                cmd.redo();
              }
            });
          });
        });
        this.undoStack.push(cmd);
        this.updateHistory({
          name: cmd.displayName,
          action: "redo"
        });

        if (window["session"] && this.debugMode) {
          this.currentState++;
        }
        if (!cmd.forget) {
          break;
        }
      }
    }

    if (window["session"] && this.debugMode) {
      let snapshot = this.snapshotStack[this.currentState];
      this.matchSessionSnapshot(snapshot);
    }
  };
  undoAll = () => {
    while (this.isUndoable()) {
      this.undo();
    }
  };
  redoAll = () => {
    while (this.isRedoable()) {
      this.redo();
    }
  };
  private matchSessionSnapshot(snapshot: any) {
    // let currentSnapshot = window["session"].toJS();
    // let diffMain: any = diff(
    //   currentSnapshot,
    //   snapshot,
    //   (path: any, key: any) => {
    //     switch (key) {
    //       case "path":
    //       case "name":
    //       case "isDirectory":
    //       case "isDirty":
    //       case "renderValue":
    //       case "_id":
    //       case "component":
    //       case "content":
    //       case "ui":
    //       case "id":
    //       case "data":
    //       case "layerJS":
    //       case "asName":
    //       case "activeCustomConditions":
    //       case "backgroundImage":
    //         return true;
    //       default:
    //         return false;
    //     }
    //   }
    // )
    // console.log(diffMain, "element");
    // remove(diffMain, (element: any) => {
    //   const key = element.path[element.path.length - 1];
    //   if (element.path.indexOf("scopeVariables") !== -1) {
    //     return true;
    //   } else if (element.path.indexOf("navigateTo") !== -1) {
    //     return true;
    //   } else if (
    //     element.path.indexOf("renderCompiled") === element.path.length - 2 &&
    //     (key === "height" || key === "width")
    //   ) {
    //     return true;
    //   } else if (
    //     element.path.indexOf("renderCompiled") === element.path.length - 2 &&
    //     (key === "height" || key === "width")
    //   ) {
    //     return true;
    //   } else if (element.path.indexOf("overrideKeys") !== -1) {
    //     return true;
    //   } else if (element.path.indexOf("styleName") !== -1) {
    //     return true;
    //   } else if (element.lhs === "platform") {
    //     return true;
    //   } else if (element.kind === "N") {
    //     if (element.rhs === undefined) {
    //       return true;
    //     }
    //     return true;
    //   } else if (element.kind === "E") {
    //     let lhs = element.lhs;
    //     let rhs = element.rhs;
    //     if (isNil(element.rhs) && isNil(element.lhs)) {
    //       return true;
    //     } else if (typeof lhs !== "object" && typeof rhs !== "object") {
    //       lhs = typeof lhs === "string" ? parseFloat(lhs) : lhs;
    //       rhs = typeof lhs === "string" ? parseFloat(rhs) : rhs;
    //       lhs = Math.round(lhs);
    //       rhs = Math.round(rhs);
    //       if (lhs === rhs || Math.abs(lhs - rhs) === 1) {
    //         return true;
    //       }
    //       return false;
    //     } else {
    //       return false;
    //     }
    //   } else if (element.kind === "D") {
    //     let lhs = element.lhs;
    //     if (Object.keys(lhs).length === 0) {
    //       return true;
    //     }
    //     return false;
    //   } else {
    //     return false;
    //   }
    // });
    // console.log(diffMain, "diff main");
    // if (!diffMain || diffMain.length === 0) {
    //   console.log("undo-redo tested ok");
    // } else {
    //   const errorMessage = {
    //     title: "Session undo redo out of sync",
    //     diff: diffMain
    //   };
    // console.log("undo-redo tested failed", diffMain);
    // throw new Error(JSON.stringify(errorMessage, null, 2));
    // }
  }

  isUndoable() {
    return this.undoStack.length > 0;
  }

  isRedoable() {
    return this.redoStack.length > 0;
  }
  updateHistory = (info: Info) => {
    if (this.history.length >= this.historyLimit) {
      this.history.shift();
    }
    this.history.push(info);
  };
  getHistory = () => {
    return this.history;
  };
}
