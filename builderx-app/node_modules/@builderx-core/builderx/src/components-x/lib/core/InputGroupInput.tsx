import COLORS, { secondary } from "./constants/COLORS";
import Background from "./types/BackgroundPropType";
import Size from "./types/SizePropType";
import * as classNames from "classnames";
import createComponent from "../createComponent";
import * as React from "react";
import { spaceMagnitudes } from "./constants";
import { InputX, InputProps } from "input-builderx";
import ReactDOM from "react-dom";
import { action } from "model";

interface PropType extends Background, Size {
  centered?: boolean;
  marginInput?: boolean;
  typeFile?: boolean;
  type?: string;
  noPadding?: boolean;
  disabled?: boolean;
  isDropdown?: boolean;
  isDisabled?: boolean;
  width?: string;
  noCursor?: boolean;
}
const uiSizes = {
  xxl: 20,
  xl: 18,
  l: 16,
  m: 14,
  s: 12,
  xs: 10
};

const Input = createComponent(
  `
  .inputGroupInputX {
    padding-top: ${spaceMagnitudes[1]}px;
    padding-bottom: ${spaceMagnitudes[1]}px;
    border: 1px solid transparent;
    border-bottom: 1px solid ${COLORS[500]};
    border-radius: 1px;
    outline: none;
    transition: all 0.3s ease 0s;
    text-align: none;
    margin-top: 0px;
    position: "relative";
    color: ${COLORS[300]};
    cursor:text;
    transition:all 0.3s ease 0s;
  }
  .inputGroupInputX:focus{
    border-bottom: solid 1px ${secondary[600]};
  }
  .inputGroupInputX.noCursor {
    border: none;
    color: transparent;
    text-shadow: 0 0 0 gray;
    text-align: center;

    &:focus {
        outline: none;
    }

  }
  .inputGroupInputX.noPadding {
    padding: 0px;
  }
  .inputGroupInputX.centered{
    text-align: center;
  }
  .inputGroupInputX.marginInput{
    margin-top: 20px;
  }
  .inputGroupInputX.typeFile{
    position: absolute;
    opacity: 0;
    font-size:!00px;
    left: 0;
    top: 0;
  }
  .inputGroupInputX::-webkit-outer-spin-button, .inputGroupInputX::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }
  .inputGroupInputX::-webkit-input-placeholder{
    color:${COLORS[400]};
  }
  .inputGroupInputX.uiSizeLarge::-webkit-input-placeholder{
  }
  .inputGroupInputX.disabled{
    cursor:not-allowed;
  }
  .inputGroupInputX.isDropdown
  {
    cursor:pointer;
  }

`,
  React.forwardRef(
    (
      props: PropType & React.HTMLProps<HTMLInputElement> & InputProps,
      ref: any
    ) => {
      const {
        uiBackground,
        uiSize,
        width,
        centered,
        marginInput,
        typeFile,
        noPadding,
        disabled,
        isDropdown,
        isDisabled,
        noCursor,
        ...remainingProps
      } = props;
      const className = classNames({
        inputGroupInputX: true,
        centered: centered ? true : false,
        marginInput: marginInput ? true : false,
        typeFile: typeFile ? true : false,
        noPadding: noPadding ? true : false,
        disabled: disabled ? true : false,
        isDropdown: isDropdown ? true : false,
        isDisabled: isDisabled ? true : false,
        uiSizeLarge: uiSize === "l" ? true : false,
        noCursor: noCursor ? true : false
      });
      return (
        // @ts-ignore
        <InputX
          {...remainingProps}
          {...(disabled ? { disabled: true } : {})}
          style={{
            ...remainingProps.style,
            fontFamily: "Roboto",
            background: uiBackground ? COLORS[uiBackground] : "transparent",
            width: width ? width : "100%",
            height: uiSize ? uiSizes[uiSize] * 1.8 : uiSizes["s"] * 1.8,
            fontSize: uiSize ? uiSizes[uiSize] : uiSizes["s"],
            opacity:
              disabled !== undefined && disabled ? 0.5 : isDisabled ? 0.5 : 1
          }}
          spellCheck={false}
          ref={ref}
          className={
            className +
            (remainingProps.className ? " " + remainingProps.className : "")
          }
          // onFocus={(e: any) => {
          //   if (props.onFocus) {
          //     props.onFocus(e);
          //   }
          // }}
          // onBlur={(e: any) => {
          //   if (props.onBlur) {
          //     props.onBlur(e);
          //   }
          // }}
        />
      );
    }
  )
);

class InputGroupInput extends React.Component<
  PropType &
    React.HTMLProps<HTMLInputElement> &
    InputProps & { innerRef: any; undo?: () => void; redo?: () => void },
  any
> {
  state = {
    control: false
  };
  componentDidMount() {
    const inputDom = ReactDOM.findDOMNode(this);
    if (inputDom) {
      // @ts-ignore
      Mousetrap(inputDom).bind("mod+z", e => {
        if (this.props.undo) {
          action(() => {
            // @ts-ignore
            inputDom.blur();

            // @ts-ignore
            this.props.undo();
            e.preventDefault();

            setTimeout(() => {
              // @ts-ignore
              inputDom.focus();
            });
          });
        }
      });
      // @ts-ignore
      Mousetrap(inputDom).bind("mod+shift+z", e => {
        if (this.props.redo) {
          action(() => {
            // @ts-ignore
            inputDom.blur();

            // @ts-ignore
            this.props.redo();
            e.preventDefault();

            setTimeout(() => {
              // @ts-ignore
              inputDom.focus();
            });
          });
        }
      });
      // @ts-ignore
      Mousetrap(inputDom).bind("mod+y", e => {
        if (this.props.redo) {
          action(() => {
            // @ts-ignore
            inputDom.blur();

            // @ts-ignore
            this.props.redo();
            e.preventDefault();

            setTimeout(() => {
              // @ts-ignore
              inputDom.focus();
            });
          });
        }
      });
    }
  }

  render() {
    // @ts-ignore
    return <Input ref={this.props.innerRef} {...this.props} />;
  }
}

export default React.forwardRef(
  (
    props: PropType &
      React.HTMLProps<HTMLInputElement> &
      InputProps & { undo?: () => void; redo?: () => void },
    ref
  ) => (
    // @ts-ignore
    <InputGroupInput innerRef={ref} {...props} />
  )
);
