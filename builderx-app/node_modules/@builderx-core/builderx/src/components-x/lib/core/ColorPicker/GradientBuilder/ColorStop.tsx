import * as React from "react";
import * as ReactDOM from "react-dom";
import "./ColorStop.css";
import { Utils } from "utils";

class ColorStop extends React.Component<any, any> {
  stopRef: any;
  constructor(props: any) {
    super(props);
    this.state = {
      posStart: 0,
      dragging: false
    };
  }
  componentDidMount() {
    document.addEventListener("keydown", this.handleDelete);
  }
  componentWillUnmount() {
    document.removeEventListener("keydown", this.handleDelete);
  }
  activate(pointX: any) {
    this.setState({ posStart: pointX, dragging: true });
    this.props.onActivate(this.props.stop.id);
    document.addEventListener("mousemove", this.handleMouseMove);
    document.addEventListener("mouseup", this.handleMouseUp);
  }

  deactivate() {
    this.setState({ dragging: false });
    document.removeEventListener("mousemove", this.handleMouseMove);
    document.removeEventListener("mouseup", this.handleMouseUp);
  }

  handleDelete = (e: any) => {
    if (
      !Utils.isEditableInput() &&
      e.code === "Backspace" &&
      this.props.stop.isActive
    ) {
      this.props.onDeleteColor(this.props.stop.id);
    }
  };
  handleMouseDown = (e: any) => {
    e.preventDefault();
    e.stopPropagation();
    if (!e.button) {
      this.activate(e.clientX);
    }
  };

  handleMouseMove = ({ clientX, clientY }: any) => {
    if (!this.state.dragging) {
      return;
    }
    const {
      limits,
      onDeleteColor,
      onPosChange,
      stop: { id, pos }
    } = this.props;

    try {
      // Remove stop
      const top = (ReactDOM as any).findDOMNode(this).getBoundingClientRect()
        .top;
      if (Math.abs(clientY - top) > limits.drop) {
        this.deactivate();
        onDeleteColor(id);
        return;
      }

      // Limit movements
      const offset = pos - this.state.posStart;
      const newPos = Math.max(
        Math.min(offset + clientX, limits.max),
        limits.min
      );
      this.setState({ posStart: newPos - offset });
      onPosChange({ id, pos: newPos });
    } catch (e) {
      // console.log("here", e);
    }
  };

  handleMouseUp = () => {
    this.deactivate();
  };

  render() {
    const { pos, color, isActive } = this.props.stop;
    return (
      <div
        className={isActive ? "cs active" : "cs"}
        style={{ left: pos }}
        onMouseDown={this.handleMouseDown}
        ref={c => (this.stopRef = c)}
      >
        <div style={{ backgroundColor: color }} />
      </div>
    );
  }
}

export default ColorStop;
