import * as React from "react";
import ColorStopsHolder from "./ColorStopsHolder";
import Palette from "./Palette";
import ColorPicker from "./ColorPicker";
import { round } from "lodash";
const HALF_STOP_WIDTH = 5;

const toState = (palette: any, activeId?: number) => ({
  palette: palette.map((c: any, i: any) => ({ id: i + 1, ...c })),
  activeId: activeId ? activeId : 0,
  pointX: null
});

const fromState = (palette: any) => {
  const compare = ({ pos: pos1 }: any, { pos: pos2 }: any) => pos1 - pos2;
  const sortedPalette = palette.sort(compare);
  return sortedPalette.map(({ pos, color }: any) => ({
    pos: round(pos, 3),
    color
  }));
};

class GradientBuilder extends React.Component<any, any> {
  constructor(props: any) {
    super(props);
    this.state = {
      ...toState(props.palette, props.activeId)
    };
    this.handlePosChange = this.handlePosChange.bind(this);
    this.handleAddColor = this.handleAddColor.bind(this);
    this.handleActivate = this.handleActivate.bind(this);
    this.handleDeleteColor = this.handleDeleteColor.bind(this);
    this.handleSelectColor = this.handleSelectColor.bind(this);
  }

  get width1() {
    return this.props.width + 1;
  }

  get nextId() {
    return Math.max(...this.state.palette.map((c: any) => c.id)) + 1;
  }

  get activeStop() {
    return this.state.palette.find((s: any) => s.id === this.state.activeId);
  }

  mapStateToStops = (activeId: number) => {
    const pointX = this.state.pointX;
    return this.state.palette.map((c: any) => ({
      ...c,
      pos: this.width1 * c.pos - HALF_STOP_WIDTH,
      isActive: c.id === activeId,
      pointX
    }));
  };

  get colorPicker() {
    const { children } = this.props;
    if (!this.activeStop) {
      return;
    }
    const props = {
      color: this.activeStop.color,
      onSelect: this.handleSelectColor
    };
    if (!children) {
      return <ColorPicker {...props} />;
    }
    const child = React.Children.only(children);
    return React.cloneElement(child, props);
  }

  notifyChange = (palette: any) => {
    this.props.onPaletteChange(
      fromState(palette),
      this.state.activeId,
      this.props.from,
      this.props.to
    );
  };

  handleActivate = (activeId: any) => {
    if (this.props.onChangeIndex) {
      this.props.onChangeIndex(activeId);
    }
    this.setState({ activeId });
  };

  handleDeleteColor = (id: any) => {
    if (this.state.palette.length < 3) {
      return;
    }
    const palette = this.state.palette.filter((c: any) => c.id !== id);
    const activeId = palette.reduce(
      (a: any, x: any) => (x.pos < a.pos ? x : a),
      palette[0]
    ).id;
    this.setState({ palette, activeId });
    this.notifyChange(palette);
  };

  handlePosChange = ({ id, pos }: any) => {
    const palette = this.state.palette.map((c: any) =>
      id === c.id
        ? { ...c, pos: (pos + HALF_STOP_WIDTH) / this.width1 }
        : { ...c }
    );
    this.setState({ palette });
    this.notifyChange(palette);
  };

  handleAddColor = ({ pos, pointX }: any) => {
    if (!this.activeStop) {
      return;
    }
    const color = this.activeStop.color;
    const entry = { id: this.nextId, pos: pos / this.width1, color };
    const palette = [...this.state.palette, entry];
    const temp = fromState(palette);
    let newObj = temp.find((val: any) => val.pos === round(entry.pos, 3));
    const activeId = temp.indexOf(newObj) + 1;
    this.notifyChange(palette);
    this.handleActivate(activeId);
    this.setState({ palette, pointX, activeId });
  };

  handleSelectColor = (color: any) => {
    let { palette, activeId } = this.state;
    palette = palette.map((c: any) =>
      activeId === c.id ? { ...c, color } : { ...c }
    );
    this.setState({ palette });
    this.notifyChange(palette);
  };

  componentWillReceiveProps({
    palette: next,
    activeId: nextId,
    from: from,
    to: to
  }: any) {
    const { palette: current, activeId: currentId } = this.props;
    const length = Math.min(next.length, current.length);
    for (let i = 0; i < length; i++) {
      if (
        next[i].pos !== current[i].pos ||
        next[i].color !== current[i].color
      ) {
        this.setState({ ...toState(next, nextId), activeId: nextId });
        return;
      }
    }
    if (nextId !== currentId) {
      this.setState({ activeId: nextId });
    }
  }

  render() {
    const { width, height, drop } = this.props;
    const min = -HALF_STOP_WIDTH;
    const max = this.width1 - HALF_STOP_WIDTH;
    const stops = this.mapStateToStops(this.state.activeId);
    return (
      <div>
        <div
          style={{
            position: "relative",
            left: 10
          }}
        >
          <Palette width={width} height={height} palette={this.state.palette} />
        </div>
        <div
          style={{
            position: "relative",
            left: 10
          }}
        >
          <ColorStopsHolder
            width={width}
            stops={stops}
            limits={{ min, max, drop }}
            onPosChange={this.handlePosChange}
            onAddColor={this.handleAddColor}
            onActivate={this.handleActivate}
            onDeleteColor={this.handleDeleteColor}
          />
        </div>
        {this.colorPicker}
      </div>
    );
  }
}

export default GradientBuilder;
