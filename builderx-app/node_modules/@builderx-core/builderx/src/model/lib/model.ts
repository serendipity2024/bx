import * as React from "react";
import { uniq, remove, reduce, union } from "lodash";
import { Serializable, types } from "../../serializable/lib";
import { rerendererLog, rerendererTrace } from "./rerendererLog";

export type onUpdateListener = (...args: Array<any>) => void;
let stopUpdates = false;
let actionCounter = 0;
let commandActionCounter = 0;
let noRerenderCounter = 0;
let postCommandActionCallbacks: Array<() => void> = [];

const pendingUpdates: Map<
  onUpdateListener,
  { properties: Array<string>; model: Model }
> = new Map();
export const shouldStopUpdates = (value: boolean) => {
  stopUpdates = value;
};
export const addPostCommandActionCallback = (callback: () => void) => {
  postCommandActionCallbacks.push(callback);
};

export const commandAction = (callback: any) => {
  commandActionCounter++;

  callback();

  commandActionCounter--;

  if (commandActionCounter === 0) {
    postCommandActionCallbacks.forEach(postCommandActionCallback => {
      postCommandActionCallback();
    });
  }
};

export const action = (callback: any) => {
  actionCounter++;

  callback();
  // rerendererLog("HHH^&^& action completed", pendingUpdates);
  // console.log(
  //   "HHH^&^& action completed"
  //   // JSON.stringify(pendingUpdates.values(), null, 2)
  // );

  pendingUpdates.forEach(function runListenersBatch(
    updateObject: any,
    listener: any
  ) {
    // console.log("HHH^&^& batch emit", updateObject.properties, listener);

    if (!updateObject.model.disposed && !stopUpdates) {
      listener(updateObject.properties);
    }
  });
  pendingUpdates.clear();

  actionCounter--;
};
export const noRerender = (callback: any) => {
  noRerenderCounter++;
  callback();
  noRerenderCounter--;
};

export default abstract class Model extends Serializable {
  eventListenersMap: Map<string, Array<onUpdateListener>> = new Map();
  reverseMap: Map<onUpdateListener, Array<string>> = new Map();
  disposed?: boolean = false;

  getFields(): { [key: string]: any } {
    return {
      eventListenersMap: types.ignore,
      reverseMap: types.ignore,
      disposed: types.ignore
    };
  }

  on(properties: Array<string> | string, listener: onUpdateListener) {
    if (typeof properties === "string") {
      // If a single property is received, wrap it in an Array
      properties = [properties];
    }

    properties.forEach(property => {
      const existingArrOfListeners = this.eventListenersMap.get(property);

      if (existingArrOfListeners) {
        existingArrOfListeners.push(listener);
        this.eventListenersMap.set(property, existingArrOfListeners);
      } else {
        this.eventListenersMap.set(property, [listener]);
      }
    });
    // rerendererLog(this, "^&^&this");
    let arrayOfProperties = this.reverseMap.get(listener);
    if (arrayOfProperties) {
      arrayOfProperties = arrayOfProperties.concat(properties);
      // rerendererLog(arrayOfKeys, "arrayOfKeys &*");
      this.reverseMap.set(listener, uniq(arrayOfProperties));
    } else {
      this.reverseMap.set(listener, properties);
    }
    // rerendererLog(
    //   this.watchersMap.entries(),
    //   this.reverseMap.entries(),
    //   "watch &*"
    // );
  }

  emit(properties: Array<string> | string) {
    if (noRerenderCounter > 0) {
      return;
    }
    // console.trace(properties, "propertiesproperties");
    if (properties === "*" || properties[0] === "*") {
      throw Error(
        "Emitting * is not allowed. Thodi mehnat kar k saari properties emit kar do."
      );
    }

    if (typeof properties === "string") {
      // If a single property is received, wrap it in an Array
      properties = [properties];
    }

    properties.push("*");
    rerendererLog(
      "HHH^&^& emitting ",
      properties,
      this.eventListenersMap,
      this.reverseMap
    );

    let combinedArrayOfListeners: Array<onUpdateListener> = reduce(
      properties,
      (combined: Array<onUpdateListener>, property) => {
        const existingArrOfListeners = this.eventListenersMap.get(property);
        if (existingArrOfListeners) {
          combined = union(combined, existingArrOfListeners);
        }

        return combined;
      },
      []
    );

    rerendererLog(combinedArrayOfListeners, "combinedArrayOfListeners");

    combinedArrayOfListeners.forEach((listener, index) => {
      rerendererLog("HHH^&^&  updating observer", listener);
      if (listener) {
        if (actionCounter) {
          let existingUpdateObject = pendingUpdates.get(listener);
          if (existingUpdateObject) {
            existingUpdateObject.properties = existingUpdateObject.properties.concat(
              properties
            );
            pendingUpdates.set(listener, {
              properties: uniq(existingUpdateObject.properties),
              model: this
            });
          } else {
            pendingUpdates.set(listener, {
              properties: properties as Array<string>,
              model: this
            });
          }
        } else {
          throw new Error("emitting an event outside of an action");
        }
        // listener(properties);
      }
    });
  }

  off(properties: Array<string> | string, listener: onUpdateListener) {
    // rerendererLog(observerComponent, "sufhesfbo sefu esfi ");

    if (typeof properties === "string") {
      // If a single property is received, wrap it in an Array
      properties = [properties];
    }

    properties.forEach(property => {
      const arrayOfProperties = this.reverseMap.get(listener);
      if (arrayOfProperties) {
        arrayOfProperties.forEach(key => {
          const existingArrOfListeners = this.eventListenersMap.get(key);
          if (!existingArrOfListeners) {
            return;
          }

          remove(existingArrOfListeners, n => {
            return n === listener;
          });

          if (existingArrOfListeners.length === 0) {
            this.eventListenersMap.delete(key);
          }
        });
        this.reverseMap.delete(listener);
      }
    });

    // rerendererLog(
    //   this.watchersMap.entries(),
    //   this.reverseMap.entries(),
    //   "remove &*"
    // );
  }
}
