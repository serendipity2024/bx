import { Point, Coordinate } from "./types";
import { getRadiusAdjustment } from "./pathUtils";
export default function generateSVGPath(
  pointsArray: Array<Point>,
  strokeWidthOffset: number,
  isClosed: boolean,
  viewBox: string
) {
  let generatedPath = "";
  if (!pointsArray) {
    return "";
  }
  const dims: Array<any> =
    viewBox && viewBox.split ? viewBox.split(" ") : [0, 0, 100, 100];
  const maxRadius = Math.min(dims[2] - dims[0], dims[3] - dims[1]) / 2;
  strokeWidthOffset = strokeWidthOffset <= 1 ? 0 : strokeWidthOffset / 2;
  let initialIndex = 0; // Maintains track of each shape start after combining
  let d1: Coordinate = { x: 0, y: 0 }; // Distance with radius
  for (let i = 0; i < pointsArray.length; i++) {
    if (i === initialIndex) {
      // Moving to initial points with "M"
      let xy0 = pointsArray[i].point;
      if (pointsArray[i].cornerRadius) {
        d1 = getRadiusAdjustment(pointsArray, i, i + 1, maxRadius);
      }
      let x0 = (strokeWidthOffset + xy0.x + d1.x).toFixed(2);
      let y0 = (strokeWidthOffset + xy0.y + d1.y).toFixed(2);
      generatedPath += "M" + x0 + " " + y0 + " ";
      generatedPath += getNextPathPoint(
        pointsArray,
        i,
        strokeWidthOffset,
        initialIndex,
        maxRadius
      );
    } else if (isFillerCondition(pointsArray[i])) {
      initialIndex = i + 1;
      if (i !== pointsArray.length - 1 && isFillerClosed(pointsArray[i])) {
        generatedPath += "Z ";
      }
    } else if (
      i === pointsArray.length - 1 ||
      (i !== pointsArray.length - 1 && isFillerCondition(pointsArray[i + 1]))
    ) {
      // adding additional point in the end of string
      if (
        isClosed &&
        pointsArray[i].point.x !== pointsArray[initialIndex].point.x &&
        pointsArray[i].point.y !== pointsArray[initialIndex].point.y
      ) {
        let pointTo = pointsArray[initialIndex].point;
        let radiusPoint;
        if (pointsArray[i].cornerRadius) {
          d1 = getRadiusAdjustment(pointsArray, i, initialIndex, maxRadius);
          const passedPointIndex = pointsArray[initialIndex + 1]
            ? initialIndex + 1
            : initialIndex;
          let d2 = getRadiusAdjustment(
            pointsArray,
            initialIndex,
            passedPointIndex,
            maxRadius
          );
          let px0 = (strokeWidthOffset + pointTo.x + d2.x).toFixed(2);
          let py0 = (strokeWidthOffset + pointTo.y + d2.y).toFixed(2);
          let curveFromX0 = (strokeWidthOffset + pointTo.x - d1.x / 2).toFixed(
            2
          );
          let curveFromY0 = (strokeWidthOffset + pointTo.y - d1.y / 2).toFixed(
            2
          );
          let curveToX0 = (strokeWidthOffset + pointTo.x + d2.x / 2).toFixed(2);
          let curveToY0 = (strokeWidthOffset + pointTo.y + d2.y / 2).toFixed(2);
          radiusPoint =
            "C" +
            curveFromX0 +
            " " +
            curveFromY0 +
            " " +
            curveToX0 +
            " " +
            curveToY0 +
            " " +
            px0 +
            " " +
            py0 +
            " ";
        }
        let px = (strokeWidthOffset + pointTo.x - d1.x).toFixed(2);
        let py = (strokeWidthOffset + pointTo.y - d1.y).toFixed(2);
        let curveFromPoint = pointsArray[i].curveFrom;
        let curveFromX = (strokeWidthOffset + curveFromPoint.x).toFixed(2);
        let curveFromY = (strokeWidthOffset + curveFromPoint.y).toFixed(2);
        let curveTo = pointsArray[initialIndex].curveTo;
        let curveToX = (strokeWidthOffset + curveTo.x).toFixed(2);
        let curveToY = (strokeWidthOffset + curveTo.y).toFixed(2);
        if (
          (pointsArray[initialIndex] && pointsArray[initialIndex].hasCurveTo) ||
          pointsArray[i].hasCurveFrom
        ) {
          generatedPath +=
            "C" +
            curveFromX +
            " " +
            curveFromY +
            " " +
            curveToX +
            " " +
            curveToY +
            " " +
            px +
            " " +
            py +
            " " +
            (radiusPoint || "");
        } else {
          generatedPath += "L" + px + " " + py + " " + (radiusPoint || "");
        }
      }
    } else {
      generatedPath += getNextPathPoint(
        pointsArray,
        i,
        strokeWidthOffset,
        initialIndex,
        maxRadius
      );
    }
  }
  if (isClosed) {
    generatedPath += "Z";
  }
  // console.log("*** generatedPath", generatedPath);
  return generatedPath;
}

function getNextPathPoint(
  pointsArray: Array<Point>,
  i: number,
  strokeWidthOffset: number,
  initialIndex: number,
  maxRadius: number
) {
  if (i + 1 >= pointsArray.length) {
    return "";
  }
  let nextPoint = "";
  let pointTo = pointsArray[i + 1].point;
  let d1: Coordinate = { x: 0, y: 0 };
  let radiusPoint;
  if (pointsArray[i].cornerRadius) {
    d1 = getRadiusAdjustment(pointsArray, i, i + 1, maxRadius);
    const passedPointIndex = pointsArray[i + 2] ? i + 2 : initialIndex;
    const d2 = getRadiusAdjustment(
      pointsArray,
      i + 1,
      passedPointIndex,
      maxRadius
    );
    let px0 = (strokeWidthOffset + pointTo.x + d2.x).toFixed(2);
    let py0 = (strokeWidthOffset + pointTo.y + d2.y).toFixed(2);
    let curveFromX0 = (strokeWidthOffset + pointTo.x - d1.x / 2).toFixed(2);
    let curveFromY0 = (strokeWidthOffset + pointTo.y - d1.y / 2).toFixed(2);
    let curveToX0 = (strokeWidthOffset + pointTo.x + d2.x / 2).toFixed(2);
    let curveToY0 = (strokeWidthOffset + pointTo.y + d2.y / 2).toFixed(2);
    radiusPoint =
      "C" +
      curveFromX0 +
      " " +
      curveFromY0 +
      " " +
      curveToX0 +
      " " +
      curveToY0 +
      " " +
      px0 +
      " " +
      py0 +
      " ";
  }
  let px = (strokeWidthOffset + pointTo.x - d1.x).toFixed(2);
  let py = (strokeWidthOffset + pointTo.y - d1.y).toFixed(2);

  let curveFromPoint = pointsArray[i].curveFrom;
  let curveFromX = (strokeWidthOffset + curveFromPoint.x).toFixed(2);
  let curveFromY = (strokeWidthOffset + curveFromPoint.y).toFixed(2);

  let curveTo = pointsArray[i + 1].curveTo;
  let curveToX = (strokeWidthOffset + curveTo.x).toFixed(2);
  let curveToY = (strokeWidthOffset + curveTo.y).toFixed(2);
  if (
    (pointsArray[i + 1] && pointsArray[i + 1].hasCurveTo) ||
    pointsArray[i].hasCurveFrom
  ) {
    nextPoint +=
      "C" +
      curveFromX +
      " " +
      curveFromY +
      " " +
      curveToX +
      " " +
      curveToY +
      " " +
      px +
      " " +
      py +
      " " +
      (radiusPoint || "");
  } else {
    nextPoint += "L" + px + " " + py + " " + (radiusPoint || "");
  }
  return nextPoint;
}

function isFillerCondition(point: any): boolean {
  return (
    (point.cornerRadius === 777 && point.curveMode === 777) ||
    (point.cornerRadius === 776 && point.curveMode === 776)
  );
}
function isFillerClosed(point: any): boolean {
  return point.cornerRadius === 776 && point.curveMode === 776;
}
