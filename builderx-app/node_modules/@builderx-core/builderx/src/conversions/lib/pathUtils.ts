import * as Paper from "paper";
import { getSegmentFromPoints } from "./toPaperPath";
import { Point, Coordinate } from "./types";
import getRadiusAdjustedPoints from "./getRadiusAdjustedPoints";

if (typeof document !== "undefined") {
  let canvasDOMElement = document.createElement("canvas");
  canvasDOMElement.style.position = "absolute";
  canvasDOMElement.setAttribute("height", "1000px");
  canvasDOMElement.setAttribute("width", "1000px");
  canvasDOMElement.style.top = "0px";
  canvasDOMElement.style.left = "0px";
  Paper.setup(canvasDOMElement as HTMLCanvasElement);
  Paper.settings["insertItems"] = false;
} else {
  // @ts-ignore
  Paper.setup([640, 480]);
}

function getManipulatedPath(layer: any, paperPath: any) {
  // TODO: keep this order, otherwise malfunctions
  // adds roatation
  if (layer.rotation) {
    paperPath.rotate(-layer.rotation);
  }
  // checks for flip
  if (layer.isFlippedHorizontal || layer.isFlippedVertical) {
    paperPath.scale(
      layer.isFlippedHorizontal ? -1 : 1,
      layer.isFlippedVertical ? -1 : 1
    );
  }
  paperPath.closed = layer.isClosed;
  return paperPath;
}

export function applyBooleanOpsOnPaths(
  layers: any,
  frame: any,
  scalingFactor: number,
  viewBox: string
) {
  if (!layers) {
    return [];
  }
  try {
    // to keep track of hidden layers and exclude them
    let firstValidIndex = 0;
    // check for first valid index, shapes might be hidden which are not to be counted
    while (firstValidIndex < layers.length - 1) {
      if (layers[firstValidIndex] && layers[firstValidIndex].isVisible) {
        break;
      } else if (
        firstValidIndex === layers.length - 1 &&
        layers[firstValidIndex] &&
        !layers[firstValidIndex].isVisible
      ) {
        firstValidIndex = -1;
        return [];
      } else {
        firstValidIndex++;
      }
    }
    let zeroPointInPath: any = getRadiusAdjustedPoints(
      convertPointsArrayBool(
        layers[firstValidIndex].points,
        layers[firstValidIndex].frame,
        frame,
        scalingFactor
      ),
      viewBox
    );
    const segments = getSegmentFromPoints(zeroPointInPath);
    let finalPaperPath: any = new Paper.Path(segments);
    finalPaperPath = getManipulatedPath(
      layers[firstValidIndex],
      finalPaperPath
    );
    if (firstValidIndex < layers.length - 1) {
      for (let index = firstValidIndex + 1; index < layers.length; index++) {
        if (layers[index].isVisible) {
          let pointsInPath = getRadiusAdjustedPoints(
            convertPointsArrayBool(
              layers[index].points,
              layers[index].frame,
              frame,
              scalingFactor
            ),
            viewBox
          );
          let paperPath = new Paper.Path(getSegmentFromPoints(pointsInPath));
          paperPath = getManipulatedPath(layers[index], paperPath);
          switch (layers[index].booleanOperation) {
            case 0:
              finalPaperPath = finalPaperPath.unite(paperPath);
              break;
            case 1:
              finalPaperPath = finalPaperPath.subtract(paperPath);
              break;
            case 2:
              finalPaperPath = finalPaperPath.intersect(paperPath);
              break;
            default:
              finalPaperPath = finalPaperPath.exclude(paperPath);
              break;
          }
        }
      }
    }

    return finalPaperPath.exportJSON();
  } catch (error) {
    console.log("JSON read error in Boolean Operations", error);
    return [];
    // throw new Error("JSON read error in Boolean Operations");
  }
}

function convertPointsArrayBool(
  points: any,
  frame: any,
  referenceFrame: any,
  scalingFactor: number
) {
  let newPoints = [];
  if (points && points.length > 0) {
    let pointsApplied =
      points[0].point !== points[points.length - 1].point
        ? points
        : getValidPoints(points);
    for (let i = 0; i < pointsApplied.length; i++) {
      let tempPoint: any = {};
      tempPoint.cornerRadius = pointsApplied[i].cornerRadius;
      tempPoint.curveMode = pointsApplied[i].curveMode;
      tempPoint.hasCurveTo = pointsApplied[i].hasCurveTo;
      tempPoint.hasCurveFrom = pointsApplied[i].hasCurveFrom;
      tempPoint.curveFrom = convertPointBool(
        pointsApplied[i].curveFrom,
        frame,
        referenceFrame,
        scalingFactor
      );
      tempPoint.curveTo = convertPointBool(
        pointsApplied[i].curveTo,
        frame,
        referenceFrame,
        scalingFactor
      );
      tempPoint.point = convertPointBool(
        pointsApplied[i].point,
        frame,
        referenceFrame,
        scalingFactor
      );
      newPoints.push(tempPoint);
    }
  }
  return newPoints;
}

function convertPointBool(
  point: any,
  frame: any,
  referenceFrame: any,
  scalingFactor: any
) {
  let tempP1 = point.split(",");
  let px = tempP1[0].slice(1);
  let py = tempP1[1].slice(0, -1);
  px = (px * frame.width + frame.x) * scalingFactor;
  py = (py * frame.height + frame.y) * scalingFactor;

  return {
    x: parseFloat(px.toFixed(4)),
    y: parseFloat(py.toFixed(4))
  };
}

// function to convert Sketch points json to Bx json
export function convertPointsArray(
  points: any,
  frame: any,
  referenceFrame: any,
  maskingDisplacement: any,
  scalingFactor: number
) {
  let newPoints = [];
  if (points && points.length > 0) {
    for (let i = 0; i < points.length; i++) {
      let tempPoint: any = {};
      tempPoint.cornerRadius = points[i].cornerRadius;
      tempPoint.curveMode = points[i].curveMode;
      tempPoint.hasCurveTo = points[i].hasCurveTo;
      tempPoint.hasCurveFrom = points[i].hasCurveFrom;
      tempPoint.curveFrom = convertPoint(
        points[i].curveFrom,
        frame,
        referenceFrame,
        maskingDisplacement,
        scalingFactor
      );
      tempPoint.curveTo = convertPoint(
        points[i].curveTo,
        frame,
        referenceFrame,
        maskingDisplacement,
        scalingFactor
      );
      tempPoint.point = convertPoint(
        points[i].point,
        frame,
        referenceFrame,
        maskingDisplacement,
        scalingFactor
      );
      newPoints.push(tempPoint);
    }
  }
  return newPoints;
}

function convertPoint(
  point: any,
  frame: any,
  referenceFrame: any,
  maskingDisplacement: any,
  scalingFactor: number
) {
  let tempP1 = point.split(",");
  let px = tempP1[0].slice(1);
  let py = tempP1[1].slice(0, -1);
  px =
    ((px * frame.width + maskingDisplacement.x) * frame.width * scalingFactor) /
    referenceFrame.width;
  py =
    ((py * frame.height + maskingDisplacement.y) *
      frame.height *
      scalingFactor) /
    referenceFrame.height;

  return {
    x: parseFloat(px.toFixed(4)),
    y: parseFloat(py.toFixed(4))
  };
}

function getValidPoints(points: any) {
  let newPoints = points.slice(1, points.length - 1);
  let obj = {
    _class: "curvePoint",
    cornerRadius: points[0].cornerRadius,
    curveMode: points[0].curveMode,
    curveTo: points[0].hasCurveTo
      ? points[0].curveTo
      : points[points.length - 1].curveTo,
    curveFrom: points[0].hasCurveFrom
      ? points[0].curveFrom
      : points[points.length - 1].curveFrom,
    hasCurveFrom: points[0].hasCurveFrom
      ? true
      : points[points.length - 1].hasCurveFrom,
    hasCurveTo: points[0].hasCurveTo
      ? true
      : points[points.length - 1].hasCurveTo,
    point: points[0].point
  };
  newPoints.unshift(obj);
  return newPoints;
}

export function getRadiusAdjustment(
  pointsArray: Array<Point>,
  currentIndex: number,
  nextIndex: number,
  maxRadius: number
): Coordinate {
  if (!pointsArray[currentIndex] || !pointsArray[nextIndex]) {
    return { x: 0, y: 0 };
  }
  const radius =
    maxRadius > pointsArray[currentIndex].cornerRadius
      ? pointsArray[currentIndex].cornerRadius
      : maxRadius;
  const x0 = pointsArray[currentIndex].point.x;
  const y0 = pointsArray[currentIndex].point.y;
  const x1 = pointsArray[nextIndex].point.x;
  const y1 = pointsArray[nextIndex].point.y;
  if (x1 === x0 && y1 === y0) {
    return { x: 0, y: 0 };
  } else if (x1 === x0) {
    return {
      x: 0,
      y: y1 > y0 ? radius : -radius
    };
  } else {
    let angle: any = Math.atan2(y1 - y0, x1 - x0);
    return {
      x: Math.cos(angle) * radius,
      y: Math.sin(angle) * radius
    };
  }
}
