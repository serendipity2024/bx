import { isEmpty } from "lodash";
// CAUTION: First read about SVG paths before making any changes in this file.
export default function getPointsArrayFromPath(
  path: string,
  strokeWidthOffset: number,
  isClosed: boolean
) {
  strokeWidthOffset = strokeWidthOffset <= 1 ? 0 : strokeWidthOffset / 2;
  let pointsArray: any = [];
  let pathArray: any = path.split("M"); // stores initial split path string
  let pathArray2: any = []; // storing each point in this array
  for (let i = 0; i < pathArray.length; i++) {
    pathArray2[i] = [];
    let tempPath = "";
    if (!isEmpty(pathArray)) {
      for (let j = 0; j < pathArray[i].length; j++) {
        if (pathArray[i].charAt(j) === "C" || pathArray[i].charAt(j) === "L") {
          pathArray2[i].push(tempPath.split(" "));
          tempPath = pathArray[i].charAt(j);
        } else {
          tempPath += pathArray[i].charAt(j);
        }
      }
    }
    if (tempPath !== "Z" && tempPath !== "z") {
      pathArray2[i].push(tempPath.split(" "));
    }
  }
  for (let i = 1; i < pathArray2.length; i++) {
    let tempPointsArray = [];
    for (let j = 0; j < pathArray2[i].length; j++) {
      if (
        !isEmpty(pathArray2[i]) &&
        pathArray2[i][j] &&
        !isEmpty(pathArray2[i][j]) &&
        pathArray2[i][j][0]
      ) {
        if (
          pathArray2[i][j].length > 6 ||
          (pathArray2[i][j].length > 2 && pathArray2[i][j][0].charAt(0) === "L")
        ) {
          let tempPoint = getPropsOnCondition(
            pathArray2[i],
            j,
            strokeWidthOffset
          );
          let obj = createPointObject(
            0,
            0,
            tempPoint.hasCurveFrom,
            pathArray2[i][j].length > 6,
            tempPoint.curveFromX,
            tempPoint.curveFromY,
            tempPoint.curveToX,
            tempPoint.curveToY,
            tempPoint.pointToX,
            tempPoint.pointToY
          );
          if (isClosed && j === pathArray2[i].length - 1) {
            tempPointsArray.unshift(obj);
          } else {
            tempPointsArray.push(obj);
          }
        } else {
          if (i !== 1) {
            // DOC: checking the previous shape for closed path and adding corresponding filler,
            // DOC: 776 for closed and 777 for non-closed
            let filler =
              pathArray2[i - 1] &&
              pathArray2[i - 1][pathArray2[i - 1].length - 1].length > 3 &&
              (pathArray2[i - 1][pathArray2[i - 1].length - 1][
                pathArray2[i - 1][pathArray2[i - 1].length - 1].length - 2
              ] === "Z" ||
                pathArray2[i - 1][pathArray2[i - 1].length - 1][
                  pathArray2[i - 1][pathArray2[i - 1].length - 1].length - 2
                ] === "z")
                ? 776
                : 777;
            pointsArray.push(
              createPointObject(filler, filler, true, true, 0, 0, 0, 0, 0, 0)
            );
          }
          if (
            !isClosed &&
            pathArray2[i][j][0].charAt(0) !== "C" &&
            pathArray2[i][j][0].charAt(0) !== "L"
          ) {
            let tempPoint = getPropsOnCondition(
              pathArray2[i],
              j,
              strokeWidthOffset
            );
            let obj = createPointObject(
              0,
              0,
              tempPoint.hasCurveFrom,
              pathArray2[i][j].length > 6,
              tempPoint.curveFromX,
              tempPoint.curveFromY,
              tempPoint.curveToX,
              tempPoint.curveToY,
              tempPoint.pointToX,
              tempPoint.pointToY
            );
            tempPointsArray.unshift(obj);
          }
        }
      }
    }
    pointsArray = pointsArray.concat(tempPointsArray);
  }
  return pointsArray;
}

function getPropsOnCondition(
  pathSubArray: any,
  j: number,
  strokeWidthOffset: number
) {
  let tempPoint: any = {};
  let nextIndex = j === pathSubArray.length - 1 ? 1 : j + 1;
  let hasCurveFrom =
    !isEmpty(pathSubArray) &&
    pathSubArray[nextIndex] &&
    !isEmpty(pathSubArray[nextIndex]) &&
    pathSubArray[nextIndex][0] &&
    pathSubArray[nextIndex][0].charAt(0) === "C";
  // DOC: checking whether next point has curve and setting curveFrom point acc. to that only
  if (
    !isEmpty(pathSubArray) &&
    pathSubArray[j] &&
    !isEmpty(pathSubArray[j]) &&
    pathSubArray[j][0] &&
    !isEmpty(pathSubArray[j][0])
  ) {
    if (pathSubArray[j][0].charAt(0) === "C") {
      tempPoint.hasCurveFrom = hasCurveFrom;
      tempPoint.curveFromX =
        hasCurveFrom &&
        pathSubArray[nextIndex] &&
        !isEmpty(pathSubArray[nextIndex])
          ? pathSubArray[nextIndex][0].substring(1) - strokeWidthOffset
          : pathSubArray[j][0].substring(1) - strokeWidthOffset;
      tempPoint.curveFromY =
        hasCurveFrom &&
        pathSubArray[nextIndex] &&
        !isEmpty(pathSubArray[nextIndex])
          ? pathSubArray[nextIndex][1] - strokeWidthOffset
          : pathSubArray[j][1] - strokeWidthOffset;
      tempPoint.curveToX = pathSubArray[j][2] - strokeWidthOffset;
      tempPoint.curveToY = pathSubArray[j][3] - strokeWidthOffset;
      tempPoint.pointToX = pathSubArray[j][4] - strokeWidthOffset;
      tempPoint.pointToY = pathSubArray[j][5] - strokeWidthOffset;
    } else if (pathSubArray[j][0].charAt(0) === "L") {
      tempPoint.hasCurveFrom = hasCurveFrom;
      tempPoint.curveFromX =
        hasCurveFrom &&
        pathSubArray[nextIndex] &&
        !isEmpty(pathSubArray[nextIndex])
          ? pathSubArray[nextIndex][0].substring(1) - strokeWidthOffset
          : pathSubArray[j][0].substring(1) - strokeWidthOffset;
      tempPoint.curveFromY =
        hasCurveFrom &&
        pathSubArray[nextIndex] &&
        !isEmpty(pathSubArray[nextIndex])
          ? pathSubArray[nextIndex][1] - strokeWidthOffset
          : pathSubArray[j][1] - strokeWidthOffset;

      tempPoint.curveToX = pathSubArray[j][0].substring(1) - strokeWidthOffset;
      tempPoint.curveToY = pathSubArray[j][1] - strokeWidthOffset;

      tempPoint.pointToX = pathSubArray[j][0].substring(1) - strokeWidthOffset;
      tempPoint.pointToY = pathSubArray[j][1] - strokeWidthOffset;
    } else {
      tempPoint.hasCurveFrom = true;
      tempPoint.curveFromX =
        pathSubArray[nextIndex] && !isEmpty(pathSubArray[nextIndex])
          ? pathSubArray[nextIndex][0].substring(1) - strokeWidthOffset
          : 0;
      tempPoint.curveFromY =
        pathSubArray[nextIndex] && !isEmpty(pathSubArray[nextIndex])
          ? pathSubArray[nextIndex][1] - strokeWidthOffset
          : 0;
      tempPoint.curveToX = pathSubArray[j][0] - strokeWidthOffset;
      tempPoint.curveToY = pathSubArray[j][1] - strokeWidthOffset;
      tempPoint.pointToX = pathSubArray[j][0] - strokeWidthOffset;
      tempPoint.pointToY = pathSubArray[j][1] - strokeWidthOffset;
    }
  }
  return tempPoint;
}

function createPointObject(
  cornerRadius: number,
  curveMode: number,
  hasCurveFrom: boolean,
  hasCurveTo: boolean,
  curveFromX: number,
  curveFromY: number,
  curveToX: number,
  curveToY: number,
  px: number,
  py: number
) {
  return {
    cornerRadius: cornerRadius,
    curveMode: curveMode,
    hasCurveTo: hasCurveTo,
    hasCurveFrom: hasCurveFrom,
    curveFrom: {
      x: curveFromX,
      y: curveFromY
    },
    curveTo: {
      x: curveToX,
      y: curveToY
    },
    point: {
      x: px,
      y: py
    }
  };
}
