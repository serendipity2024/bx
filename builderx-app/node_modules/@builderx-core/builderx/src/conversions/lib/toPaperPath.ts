import * as Paper from "paper";

if (typeof document !== "undefined") {
  let canvasDOMElement = document.createElement("canvas");
  canvasDOMElement.style.position = "absolute";
  canvasDOMElement.setAttribute("height", "1000px");
  canvasDOMElement.setAttribute("width", "1000px");
  canvasDOMElement.style.top = "0px";
  canvasDOMElement.style.left = "0px";
  Paper.setup(canvasDOMElement as HTMLCanvasElement);
  Paper.settings["insertItems"] = false;
} else {
  // @ts-ignore
  Paper.setup([640, 480]);
}
export function getPaperPathFromPoints(pointsInPath: any, isClosed: boolean) {
  let segments = getSegmentFromPoints(pointsInPath);
  let paperPath = new Paper.Path(segments);
  paperPath.closed = isClosed;
  return paperPath;
}

export function getSegmentFromPoints(pointsInPath: any) {
  let segments = [];
  for (let pointIndex = 0; pointIndex < pointsInPath.length; pointIndex++) {
    let handleInPoint = new Paper.Point(
      pointsInPath[pointIndex].curveTo.x - pointsInPath[pointIndex].point.x,
      pointsInPath[pointIndex].curveTo.y - pointsInPath[pointIndex].point.y
    );
    let handleOutPoint = new Paper.Point(
      pointsInPath[pointIndex].curveFrom.x - pointsInPath[pointIndex].point.x,
      pointsInPath[pointIndex].curveFrom.y - pointsInPath[pointIndex].point.y
    );
    let handleIn = pointsInPath[pointIndex].hasCurveFrom
      ? handleInPoint
      : undefined;
    let handleOut = pointsInPath[pointIndex].hasCurveTo
      ? handleOutPoint
      : undefined;
    let point = new Paper.Point(
      pointsInPath[pointIndex].point.x,
      pointsInPath[pointIndex].point.y
    );
    let segment = new Paper.Segment({
      point,
      handleIn,
      handleOut,
      radius: pointsInPath[pointIndex].Radius
    });
    segments.push(segment);
  }
  return segments;
}
