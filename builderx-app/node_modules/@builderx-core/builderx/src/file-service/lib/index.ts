import { IFileService, ResponseFile } from "common-interfaces";
import { get } from "lodash";
import * as pathUtil from "path";
const path = require("path-browserify");
import { ApiSdk } from "@builderx-core/api-sdk";

export default class FileService implements IFileService {
  appPath: "";
  sharedComponentsPath: "";
  path = {};
  projectId: string;
  dbFileId: string;
  filePath: string;
  // apiSdk: ApiSdk;
  before: () => void;
  after: () => void;
  constructor(before: () => void, after: () => void) {
    // this.apiSdk = apiSdk;
    // this.before = before;
    // this.after = after;
  }
  setProjectId(projectId: string) {
    // this.projectId = projectId;
  }
  setFilePathAndId(filePath: string, id: string) {
    // this.filePath = filePath;
    // this.dbFileId = id;
  }
  getProjectDetails = (connectionId: string = "") => {
    // return new Promise<string>((resolve: any, reject: any) => {
    //   this.apiSdk.project
    //     .get(this.projectId, connectionId)
    //     .then((response: any) => {
    //       resolve(response.data);
    //     })
    //     .catch(error => {
    //       console.log(error, "Error in fetching getProjectDetails");
    //       reject(error);
    //     });
    // });
  };
  getFilePathAndId() {
    // return { id: this.dbFileId, name: this.filePath };
  }
  writeFile(
    filePath: string,
    data: string | Blob,
    connectionId: string = "",
    type: "application/json" = "application/json"
  ): any {
    // return new Promise((resolve, reject) => {
    //   try {
    //     this.before();
    //     const projectId = this.projectId;
    //     const name = filePath;
    //     const fileContentFormData = new FormData();
    //     fileContentFormData.append("projectId", projectId);
    //     fileContentFormData.append("name", name);
    //     fileContentFormData.append("connectionId", connectionId);
    //     let blob = new Blob([data], {
    //       type: "application/javascript"
    //     });
    //     fileContentFormData.append("content", blob);
    //     fileContentFormData.append("contentType", type);
    //     let headers = { "content-type": "multipart/form-data" };
    //     this.apiSdk.fileContent
    //       .post(fileContentFormData, { headers })
    //       .then(res => {
    //         this.after();
    //         resolve(res.data.fileId);
    //       })
    //       .catch(err => {
    //         this.after();
    //         console.error(err, filePath, "writeFile failed");
    //         reject(err);
    //       });
    //   } catch (error) {
    //     this.after();
    //     console.log(error, "Error in writing files");
    //     reject(error);
    //   }
    // });
  }
  readFile = (filePath: string): any => {
    // // NOTE: not being used anywhere
    // return new Promise<string>((resolve: any, reject: any) => {
    //   this.apiSdk.files
    //     .get(filePath, this.projectId)
    //     .then(async response => {
    //       const fileId = get(response, "data.data.0.id");
    //       if (!fileId) {
    //         resolve({ content: undefined, dbFileId: undefined });
    //       }
    //       try {
    //         const fileContentResponse = await this.apiSdk.fileContent.get(
    //           fileId
    //         );
    //         const fileContent = fileContentResponse.data;
    //         resolve({ content: fileContent, dbFileId: fileId });
    //       } catch (err) {
    //         console.error("readFile failed", err);
    //         reject(err);
    //       }
    //     })
    //     .catch(err => {
    //       reject(err);
    //     });
    // });
  };
  async writeJSONFile(filePath: string, data: any): Promise<any> {
    // await this.writeFile(filePath, JSON.stringify(data));
  }
  async readJSONFile(filePath: string): Promise<any> {
    // let { content, dbFileId } = await this.readFile(filePath);
    // return typeof content === "string" ? JSON.parse(content) : content;
  }
  readFolder = (
    projectId: string,
    connectionId: string = ""
  ): /*Promise<ResponseFile[]>*/ any => {
    // return new Promise(
    //   async (resolve: (files: ResponseFile[]) => void, reject) => {
    //     try {
    //       const response = await this.apiSdk.files.get(undefined, projectId);
    //       const files: ResponseFile[] = response.data.map((file: any) => ({
    //         path: file.name,
    //         content: file.content,
    //         id: file.id,
    //         stats: {}
    //       }));
    //       resolve(files);
    //     } catch (error) {
    //       console.log("error in reading folder", error);
    //       reject(error);
    //     }
    //   }
    // );
  };
  renameProject(projectId: string, newName: string): any {
    // return new Promise<string>((resolve: any, reject: any) => {
    //   this.before();
    //   this.apiSdk.project
    //     .update(projectId, newName)
    //     .then(async response => {
    //       this.after();
    //       resolve(true);
    //     })
    //     .catch(err => {
    //       this.after();
    //       reject(err);
    //     });
    // });
  }
  removeFolder(dbFileId: string, connectionId: string = ""): any {
    // return new Promise<string>((resolve: any, reject: any) => {
    //   this.before();
    //   this.apiSdk.files
    //     .delete(dbFileId, connectionId)
    //     .then(async response => {
    //       this.after();
    //       resolve(response);
    //     })
    //     .catch(err => {
    //       this.after();
    //       reject(err);
    //     });
    // });
  }
  restoreFile = (dbFileId: string) => {
    // return new Promise<string>((resolve: any, reject: any) => {
    //   this.before();
    //   this.apiSdk.files
    //     .patch(dbFileId)
    //     .then(async response => {
    //       this.after();
    //       resolve(response);
    //     })
    //     .catch(err => {
    //       this.after();
    //       reject(err);
    //     });
    // });
  };
  getAbsolutePath(paths: string[]) {
    let fileName = paths[paths.length - 1];
    if (typeof fileName === "string") {
      if (
        fileName.indexOf("https:") !== -1 ||
        fileName.indexOf("http:") !== -1
      ) {
        return fileName;
      }
      fileName = fileName.substring(fileName.lastIndexOf("/"), fileName.length);
      paths.forEach((newPath: string, index: number) => {
        paths[index] = newPath.substring(0, newPath.lastIndexOf("/"));
        //
      });
      return pathUtil.join(...paths) + fileName;
    }
    return undefined;
  }

  getRelativePath(paths: string[]) {
    let fileName = paths[paths.length - 1];
    if (typeof fileName === "string") {
      fileName = fileName.substring(fileName.lastIndexOf("/"), fileName.length);
      paths.forEach((relPath: string, index: number) => {
        paths[index] = relPath.substring(0, relPath.lastIndexOf("/"));
      });
      let relativePath = (pathUtil as any).relative(...paths);
      if (relativePath.length === 0) {
        return `.${fileName}`;
      } else {
        return relativePath + fileName;
      }
    }
    return undefined;
  }
  pathJoin(paths: string[]) {
    return pathUtil.join(...paths);
  }
  copyFile(fromPath: string, toPath: string): any {
    //
  }
  readFolderAsync(filePath: string): any {
    //
  }
  readDirectoryAsync(folderPath: string): any {
    //
  }
  readDirectory(folderPath: string): any {
    //
  }
  getFileModifiedTimestamp(filePath: string): any {
    //
  }
  isDirectory(filePath: string): any {
    //
  }
  createFolder(folderPath: string): any {
    //
  }
  isFolderExists(filePath: string): any {
    return true;
  }
  getPathFromHomeDirectory(folderPath: string): any {
    //
  }
  getPath(arrayOfPath: Array<string>): any {
    //
  }
  isFileExists(filePath: string): any {
    // Promise<boolean>
    // try {
    //   const response = await this.apiSdk.files.exists(this.projectId, filePath);
    //   if (response.status === 200) {
    //     return true;
    //   } else {
    //     return false;
    //   }
    // } catch (error) {
    //   return false;
    // }
  }
  createTempFolder(): any {
    //
  }
  moveFolder(fromPath: string, toPath: string): any {
    //
  }
  resolve(basePath: string, filePath: string): any {
    //
  }
  normalize(basePath: string): any {
    //
  }
  relative(basePath: string, filePath: string): any {
    //
  }
  openFolderInFinder(folderPath: string): any {
    //
  }

  async getNewImageName(existingRelativePath: string) {
    // debugger;
    const existingName = path.basename(existingRelativePath);
    const existingPartialPath = existingRelativePath.substring(
      0,
      existingRelativePath.length - existingName.length
    );

    const extension = path.extname(existingName);
    const partialName = existingName.substring(
      0,
      existingName.length - extension.length
    );

    let newFileName = partialName;
    let testFileName;

    let foundName = false;
    let untitledIndex = 0;
    while (!foundName) {
      testFileName = newFileName;
      newFileName += untitledIndex ? untitledIndex : "";

      const newFileRelativePath = existingPartialPath + newFileName + extension;
      if (await this.isFileExists(newFileRelativePath)) {
        untitledIndex++;
        newFileName = testFileName;
      } else {
        foundName = true;
        newFileName = newFileName;
      }
    }
    return newFileName + extension;
  }
}
