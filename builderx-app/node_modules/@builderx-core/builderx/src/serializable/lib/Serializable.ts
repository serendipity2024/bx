import * as _ from "lodash";

export default abstract class Serializable {
  static fromJS(snapshot: any, classObject: any = undefined) {
    if (!snapshot) {
      return;
    }
    let classInstance: any = undefined;
    if (classObject) {
      classInstance = new classObject();
    } else {
      classInstance = new (this as any)();
    }

    // const fields: any = classInstance.getFields();
    const fields: any = Serializable.getAllFields(classInstance);

    _.forEach(Object.keys(snapshot), (key: any) => {
      const field = fields[key];

      if (!field) {
        // console.log(fields, "fields");
        console.warn(
          `property ${key} is not declared in fields of ${classInstance.constructor.name} `
        );
        return;
      }
      if (field.type === "ignore") {
        return;
      }
      if (_.isNil(snapshot[key])) {
        classInstance[key] = snapshot[key];
      } else if (field.type === "literal") {
        classInstance[key] = snapshot[key];
      } else if (field.type === "array") {
        if (_.isArray(snapshot[key])) {
          classInstance[key] = [];
          _.forEach(snapshot[key], (element: any) => {
            if (_.isArray(element) && field.children.type === "array") {
              console.log("case not handled -!-!- toJS Serializable");
            } else if (typeof element === "object") {
              const objectClassInstance = this.getClassInstanceFromPlainObject(
                field.children,
                element
              );
              if (objectClassInstance) {
                classInstance[key].push(objectClassInstance);
              }
            } else if (field.children.type === "literal") {
              classInstance[key].push(element);
            } else {
              console.log("case not handled -!-!- toJS Serializable");
            }
          });
        } else if (typeof snapshot[key] === "object") {
          // console.log("type declared array but got object");
          console.log("case not handled -!-!- Serializable");
        } else if (classInstance[key]) {
          // console.log("type declared array but got literal");
          classInstance[key] = snapshot[key];
        }
      } else if (field.type === "map") {
        classInstance[key] = new Map();
        _.forEach(snapshot[key], (value: any, mapKey: string) => {
          if (field.valueType === "literal") {
            classInstance[key].set(mapKey, value);
          } else if (field.valueType.type === "array") {
            let valueArray: any[] = [];
            _.forEach(value, (element: any) => {
              if (_.isArray(element) && value.children.type === "array") {
                console.log("case not handled -!-!- toJS Serializable");
              } else if (typeof element === "object") {
                const objectClassInstance = this.getClassInstanceFromPlainObject(
                  field.valueType.children,
                  element
                );
                if (objectClassInstance) {
                  valueArray.push(objectClassInstance);
                }
              } else if (value.children.type === "literal") {
                valueArray.push(element);
              } else {
                console.log("case not handled -!-!- toJS Serializable");
              }
            });
            classInstance[key].set(mapKey, valueArray);
          } else if (typeof value === "object") {
            const valueClassInstance = this.getClassInstanceFromPlainObject(
              field.valueType,
              value
            );
            classInstance[key].set(mapKey, valueClassInstance);
          }
        });
      } else {
        classInstance[key] = this.getClassInstanceFromPlainObject(
          field,
          snapshot[key]
        );
      }
    });
    return classInstance;
  }

  static getAllFields = (instance: any, fields = {}): any => {
    if (instance && instance.getFields) {
      const newFields = { ...instance.getFields(), ...fields };
      // Object.assign(fields, instance.getFields());
      const superInstance = Object.getPrototypeOf(instance);

      return Serializable.getAllFields(superInstance, newFields);
    } else {
      return fields;
    }
  };

  // static getAllFields = (instance: any, fields = {}): any => {
  //   if (instance && instance.getFields) {
  //     const newFields = { ...instance.getFields(), ...fields };
  //     // Object.assign(fields, instance.getFields());
  //     const superFields = instance.getSuperFields();
  //     console.log(superFields, "superFields");
  //     return newFields;
  //     // return Serializable.getAllFields(superInstance, newFields);
  //   } else {
  //     return fields;
  //   }
  // };

  // getSuperFields() {
  //   // @ts-ignore
  //   console.log(super());
  //   // @ts-ignore
  //   return super.getFields();
  // }

  static getClassInstanceFromPlainObject(classObject: any, snapshot: any) {
    if (classObject.fromJS) {
      return classObject.fromJS(snapshot);
    } else {
      throw new Error(
        `${classObject.constructor.name} is not extended from Serializable`
      );
    }
  }

  abstract getFields(): { [key: string]: any };
  toJS(shallow: boolean = false) {
    const fields = Serializable.getAllFields(this);
    // console.log(fields, "All Fields from JS");
    if (!fields) {
      throw new Error("fileds are undefiend");
    }
    let ret = {};

    if (shallow) {
      delete fields.children;
    }
    _.forEach(fields, (value: any, key: any) => {
      if (value.type === "ignore") {
        return;
      }
      if (!value) {
        throw new Error(`type of ${key} is not defined`);
      }
      if (value) {
        if (value.type === "array") {
          if (_.isArray(this[key])) {
            ret[key] = [];
            _.forEach(this[key], (element: any) => {
              if (_.isArray(element) && value.children.type === "array") {
                console.log("case not handled -!-!- toJS Serializable");
              } else if (typeof element === "object") {
                const object = this.getPlainObjectFromClassInstance(element);
                if (object) {
                  ret[key].push(object);
                }
              } else if (value.children.type === "literal") {
                ret[key].push(element);
              } else {
                console.log("case not handled -!-!- toJS Serializable");
              }
            });
          } else if (typeof this[key] === "object") {
            // console.log("type declared array but got object");
            ret[key] = this.getPlainObjectFromClassInstance(this[key]);
          } else {
            // console.log("type declared array but got literal");
            ret[key] = this[key];
          }
        } else if (value.type === "map") {
          ret[key] = this.MapToPOJO(this[key]);
        } else if (value.type === "literal") {
          ret[key] = this[key];
        } else {
          ret[key] = this.getPlainObjectFromClassInstance(this[key]);
        }
      }
      // else {
      //   ret[key] = undefined;
      // }
    });
    return _.omitBy(ret, _.isNil);
  }

  getPlainObjectFromClassInstance(object: any) {
    if (object) {
      if (object.toJS) {
        return object.toJS();
      } else {
        throw new Error(
          `${object.constructor.name} is not extended from Serializable`
        );
      }
    } else {
      return undefined;
    }
  }
  MapToPOJO(mapInstance: Map<any, any>) {
    const result: any = {};
    if (mapInstance) {
      mapInstance.forEach((value: any, key: any) => {
        var valuePlainArray: any[] = [];
        if (_.isArray(value)) {
          _.forEach(value, (element: any) => {
            const object = this.getPlainObjectFromClassInstance(element);
            if (object) {
              valuePlainArray.push(object);
            }
          });
          result[key] = valuePlainArray;
        } else {
          result[key] = this.getPlainObjectFromClassInstance(value);
        }
      });
    }
    return result;
  }
}

const literal = {
  type: "literal",
  children: null
};

const array = function(type: any) {
  return {
    type: "array",
    children: type
  };
};
const map = function(keyType: any, valueType: any) {
  return {
    type: "map",
    keyType: keyType,
    valueType: valueType
  };
};
const ignore = {
  type: "ignore",
  children: null
};

export const types = {
  literal,
  array,
  map,
  ignore
};
