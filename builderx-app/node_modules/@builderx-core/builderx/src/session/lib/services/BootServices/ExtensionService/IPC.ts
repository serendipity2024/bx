import { v4 as uuid } from "uuid";
import { EnvConfig } from "common-interfaces";
// import * as SocketIOClient from "socket.io-client";
// import * as _ from "lodash";
// import AST from "./AST";

// const ast = new AST();
export default class IPC {
  messageIPCQueue: any = {};
  callbackList: any = {};
  worker: Worker;
  shouldExecuteCommands: boolean;
  envConfig: EnvConfig;
  batching: boolean = false;
  commandBatch: any[] = [];
  constructor(worker: Worker, envConfig: EnvConfig) {
    this.worker = worker;
    this.envConfig = envConfig;
    this.shouldExecuteCommands = true;
    this.worker.addEventListener("message", async (event: any) => {
      const message = event.data;
      if (message.type === "command") {
        try {
          // TODO: This case is not handled yet
          if (this.callbackList[message.command]) {
            const returnData = await this.callbackList[message.command](
              ...message.args
            );
            // TODO: Refactor message format for socket.io communicaion to use
            // socket event name instead of message.type
            this.worker.postMessage({
              type: "ack",
              messageId: message.messageId,
              success: true,
              data: returnData
            });
          } else {
            throw new Error("Wrong command");
          }
        } catch (err) {
          console.log(err, "error in IPC");
          this.worker.postMessage({
            type: "ack",
            messageId: message.messageId,
            success: false,
            error: err
          });
          throw err;
        }
      }

      if (message.type === "ack") {
        if (!message.success) {
          // console.log(message, "message.error");
          throw message.error;
        }
        // //console.log("@@ messageQueue", this.messageIPCQueue, message);
        const messageIPC = this.messageIPCQueue[message.messageId];

        if (messageIPC) {
          if (message.success) {
            messageIPC.resolve(message.data);
          } else {
            // throw new Error(message.error);
            messageIPC.reject(message.error);
          }
        }

        // //console.log(this.messageIPCQueue, "@@&& wahdq");

        delete this.messageIPCQueue[message.messageId];
      }
    });
  }

  startBatch = () => {
    this.batching = true;
  };
  endBatch = () => {
    this.batching = false;
    return new Promise((resolve, reject) => {
      const messageId = uuid();
      this.worker.postMessage({
        type: "batch",
        messageId,
        batch: this.commandBatch
      });
      this.messageIPCQueue[messageId] = {
        resolve,
        reject
      };
      this.commandBatch = [];
    });
  };
  executeCommand = (
    command: string,
    args: Array<any> = [],
    transferables: Array<Transferable> = []
  ) => {
    // TODO: hasbinary wala error yaha se debug hogaaaaa
    if (!this.shouldExecuteCommands) {
      return;
    }

    return new Promise((resolve, reject) => {
      if (this.batching) {
        this.commandBatch.push({
          command,
          args
        });
        resolve();
        return;
      }
      // if (command === "saveFile") {
      // console.log("saveTime @@@ executeComand &*(", command, args);
      // }
      const messageId = uuid();
      this.worker.postMessage(
        {
          type: "command",
          messageId,
          command,
          args
        },
        transferables
      );
      this.messageIPCQueue[messageId] = {
        resolve,
        reject
      };
    });
  };

  registerCallback = (callback: any, name: string) => {
    // //console.log(callback, name, "registerCallback");
    if (this.envConfig.isSharedComponentInstance) {
      this.callbackList[name] = (...args: any[]) => {
        //
      };
    } else {
      this.callbackList[name] = callback;
    }
  };

  setShouldExecuteCommands(variable: boolean) {
    this.shouldExecuteCommands = variable;
  }
  handshake = (settings: any) => {
    return this.executeCommand("handshake", [settings]);
  };
  openFile = (filePath: string): any => {
    return this.executeCommand("openFile", [filePath]);
  };
  getFileJSON = (filePath: string): any => {
    return this.executeCommand("getFileJSON", [filePath]);
  };
  dispatchUpdatedCode = (filePath: string): any => {
    return this.executeCommand("dispatchUpdatedCode", [filePath]);
  };
  shouldSendUpdatedCode = (updatedCode: boolean) => {
    return this.executeCommand("shouldSendUpdatedCode", [updatedCode]);
  };
  onChangeCodeUpdate = (filePath: string, newCode: string) => {
    // //console.log(updatedCode, "update");
    return this.executeCommand("onChangeCodeUpdate", [filePath, newCode]);
  };
  killProcess = async (exitCode: number) => {
    await this.executeCommand("killProcess", [exitCode]);
  };
  getMissingFontsList = () => {
    // return this.executeCommand("getMissingFontsList", []);
  };
}
