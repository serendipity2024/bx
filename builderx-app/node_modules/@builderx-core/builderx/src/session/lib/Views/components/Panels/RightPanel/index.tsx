import * as React from "react";
import { FormBuilder } from "form-builder";
import { IEvent } from "common-interfaces";
import SetStyleAttribute from "../../../../Commands/Style/SetStyleAttribute";
import { Session } from "../../../../models/Session";
import SymbolComponentDefinition from "../../../../componentJSON/SymbolInstance";
import SymbolRootLayerDefinition from "../../../../componentJSON/SymbolRootLayer";
import RootComponentDefinition from "../../../../componentJSON/Root";
import FileComponentDefinition from "../../../../componentJSON/File";
import SymbolFileComponentDefinition from "../../../../componentJSON/SymbolFile";
import { ICommand } from "command-manager";
import FillLayer from "../../../../Commands/Layout/FillLayer";
import FixLayer from "../../../../Commands/Layout/FixLayer";
import SetPercent from "../../../../Commands/Layout/SetPercent";
import SetAuto from "../../../../Commands/Layout/SetAuto";
import ChangeToAbsolute from "../../../../Commands/Layout/ChangeToAbsolute";
// import ChangeToFlex from "../../../../Commands/Layout/ChangeToFlex";
import RemoveStyleAttribute from "../../../../Commands/Style/RemoveStyleAttribute";
import AlignSelectedLayers from "../../../../Commands/Layout/AlignSelectedLayers";
import SetLayerAuto from "../../../../Commands/Layout/SetAuto";
import UpdateMarginEditorState from "../../../../Commands/Editor/UpdateMarginEditorState";
import UpdateLayerProperties from "../../../../Commands/Layout/UpdateLayerProperties";
import UpdateLayerChildProperties from "../../../../Commands/Layout/UpdateLayerChildProperties";
import ToggleResizingType from "../../../../Commands/Layout/ToggleResizingType";
import SplitView from "../../../../Commands/Layout/SplitView";
import SetLayerDimensions from "../../../../Commands/Layer/SetLayerDimensions";
import SetOverride from "../../../../Commands/Layer/Overrides/SetOverride";
import {
  Layer as DomainLayer,
  TabContentDefinition
  // Expression
} from "domain-x";
import SetConfig from "../../../../Commands/Workspace/SetConfig";
import { isArray, forEach, cloneDeep, isEmpty, get, size } from "lodash";
import SetProp from "../../../../Commands/Prop/SetProp";
import DisconnectSelectedPathPoint from "../../../../Commands/Path/DisconnectSelectedPathPoint";
import StraightenSelectedPathPoint from "../../../../Commands/Path/StraightenSelectedPathPoint";
import ChangeToTouchableOpacity from "../../../../../lib/Commands/Layer/ChangeToTouchableOpacity";
import ChangeToTextInput from "../../../../../lib/Commands/Layer/ChangeToTextInput";
import ChangeToScrollView from "../../../../../lib/Commands/Layer/ChangeToScrollView";
import ChangeImage from "../../../../../lib/Commands/Image/ChangeImage";
import SetLayersTransform from "../../../../Commands/Layer/SetLayersTransform";
import { File as DomainFile } from "domain-x";
import SetNavigationRoute from "../../../../Commands/Layer/SetNavigationRoute";
import RemoveProp from "../../../../Commands/Prop/RemoveProp";
import SetFontProperties from "../../../../Commands/Layer/SetFontProperties";
import { loadThirdPartyComponent } from "domain-x";
import AddLayer from "../../../../Commands/Layer/AddLayer";
import ToggleCondition from "../../../../Commands/Conditionals/ToggleCondition";
import SelectLayers from "../../../../Commands/Session/SelectLayers";
import RemoveLayer from "../../../../Commands/Layer/RemoveLayer";
import UpdateRecordingConditions from "../../../../Commands/Conditionals/UpdateRecordingConditions";
import UpdateFileScopeVariables from "../../../../Commands/File/UpdateFileScopeVariables";
import SetDeviceName from "../../../../Commands/Project/SetDeviceName";
import SetDeviceOrientation from "../../../../Commands/Project/SetDeviceOrientation";
import { ResolveNodeValue } from "utils";
import ResetConditionals from "../../../../Commands/Conditionals/ResetConditionals";
// import ChangeScene from "./../../../../Commands/Scene/ChangeScene";
import CreateLoop from "../../../../Commands/Layer/CreateLoop";
import SetRepetitions from "../../../../Commands/Layer/SetRepetitions";

import RemoveLoop from "../../../../Commands/Layer/RemoveLoop";
// import { UpdateFileExpressionList } from "../../../../Commands/CommandServices/UpdateFileExpressionList";
import { action } from "model";
import RemoveRecordingCondition from "../../../../Commands/Conditionals/RemoveRecordingCondition";
import SetFontFamily from "../../../../Commands/Layer/SetFontFamily";
import MoveResizeLayer from "../../../../Commands/Layer/MoveResizeLayer";
import { GradientEditorEvent } from "@builderx-core/designer";
import { CreateStageForDomain } from "../../../../Commands";
import SetStatusBar from "../../../../Commands/File/SetStatusBar";
import SetShadowAttributes from "../../../../Commands/Style/SetShadowAttributes";
import RemoveShadowAttributes from "../../../../Commands/Style/RemoveShadowAttributes";
import UnlockAspectRatio from "../../../../Commands/Layer/UnlockAspectRatio";
import LockAspectRatio from "../../../../Commands/Layer/LockAspectRatio";

const path = require("path");
type propType = {
  session: Session;
};

class RightPanel extends React.PureComponent<propType, any> {
  prevSelectedFile: DomainFile;
  componentDidMount() {
    this.props.session.on(["selectedLayers", "selectedFile"], this.onUpdate);
    this.props.session.selectedFile.on("isResizable", this.onUpdate);
    this.props.session.currentStage.tools.on("pathEditorData", this.onUpdate);
    this.props.session.drivers.configuration.on("*", this.onUpdate);
    this.props.session.on("projectLock", this.onUpdate);
    this.prevSelectedFile = this.props.session.selectedFile;
  }
  onUpdate = () => {
    this.forceUpdate();
  };
  componentWillUnmount() {
    this.props.session.off(["selectedLayers", "selectedFile"], this.onUpdate);
    this.props.session.selectedFile.on("isResizable", this.onUpdate);
    this.props.session.currentStage.tools.off("pathEditorData", this.onUpdate);
    this.props.session.drivers.configuration.off("*", this.onUpdate);
    this.props.session.off("projectLock", this.onUpdate);
  }
  componentDidUpdate() {
    if (this.prevSelectedFile !== this.props.session.selectedFile) {
      this.prevSelectedFile.off("isResizable", this.onUpdate);
      this.props.session.selectedFile.on("isResizable", this.onUpdate);
      this.prevSelectedFile = this.props.session.selectedFile;
    }
  }
  onEvent = (event: IEvent) => {
    if (this.props.session.readonly) {
      return;
    }
    if (!event.manageControls) {
      this.props.session.temporarilyHideResizer();
    }
    action(() => {
      const { payload, type, target } = event;
      let command: ICommand | undefined = undefined;
      switch (type) {
        case "editScrollView":
          this.props.session.commandManager.execute(
            new CreateStageForDomain(
              this.props.session,
              target,
              `layer:${target.getFullPath()}`
            )
          );
          break;
        case "setConfig":
          command = new SetConfig(
            this.props.session,
            event.payload.name,
            event.payload.value
          );
          this.props.session.commandManager.executeAndSkip(command);
          break;
        case "updateEditorState":
          command = new UpdateMarginEditorState(
            this.props.session,
            target,
            payload
          );
          this.props.session.commandManager.executeAndSkip(command);
          break;
        case "updateLayerBorderRadiusAndSkip":
        case "updateLayerBorderWidthAndSkip":
        case "updateLayerPaddingAndSkip":
        case "updateLayerMarginAndSkip":
          this.props.session.commandManager.executeAndSkip(
            new UpdateLayerProperties(
              this.props.session,
              target,
              payload.properties,
              payload.key,
              payload.stylePropName
            )
          );
          break;
        case "updateLayerBorderRadiusAndForget":
        case "updateLayerBorderWidthAndForget":
        case "updateLayerPaddingAndForget":
        case "updateLayerMarginAndForget":
          this.props.session.commandManager.executeAndForget(
            new UpdateLayerProperties(
              this.props.session,
              target,
              payload.properties,
              payload.key,
              payload.stylePropName
            )
          );
          break;
        case "updateLayerBorderRadius":
        case "updateLayerBorderWidth":
        case "updateLayerPadding":
        case "updateLayerMargin":
          this.props.session.commandManager.execute(
            new UpdateLayerProperties(
              this.props.session,
              target,
              payload.properties,
              payload.key,
              payload.stylePropName
            )
          );
          break;
        case "updateLayerChildMarginAndSkip":
          command = new UpdateLayerChildProperties(
            this.props.session,
            target,
            payload.properties,
            payload.key
          );
          this.props.session.commandManager.executeAndSkip(command);
          break;
        case "updateLayerChildMarginAndForget":
          command = new UpdateLayerChildProperties(
            this.props.session,
            target,
            payload.properties,
            payload.key
          );
          this.props.session.commandManager.executeAndForget(command);
          break;
        case "updateLayerChildMargin":
          command = new UpdateLayerChildProperties(
            this.props.session,
            target,
            payload.properties,
            payload.key
          );
          this.props.session.commandManager.execute(command);
          break;
        // case "changeToFlex":
        //   command = new ChangeToFlex(this.props.session, target);
        //   this.props.session.commandManager.execute(command);
        //   break;
        case "changeToAbsolute":
          command = new ChangeToAbsolute(this.props.session, target, false);
          this.props.session.commandManager.execute(command);
          break;
        case "changeToAuto":
          command = new SetAuto(this.props.session, target, "width");
          this.props.session.commandManager.executeAndForget(command);
          command = new SetAuto(this.props.session, target, "height");
          this.props.session.commandManager.execute(command);
          break;
        case "changeToFixed":
          command = new FixLayer(this.props.session, target, "width");
          this.props.session.commandManager.executeAndForget(command);
          command = new FixLayer(this.props.session, target, "height");
          this.props.session.commandManager.execute(command);
          break;
        case "setFill":
          forEach(target, (layer: DomainLayer, index: number) => {
            command = new FillLayer(this.props.session, layer, payload.key);
            if (index === target.length - 1) {
              this.props.session.commandManager.execute(command);
            } else {
              this.props.session.commandManager.executeAndForget(command);
            }
          });
          break;
        case "setFixed":
          forEach(target, (layer: DomainLayer, index: number) => {
            command = new FixLayer(this.props.session, layer, payload.key);
            if (index === target.length - 1) {
              this.props.session.commandManager.execute(command);
            } else {
              this.props.session.commandManager.executeAndForget(command);
            }
          });
          break;
        case "setPercent":
          forEach(target, (layer: DomainLayer, index: number) => {
            command = new SetPercent(this.props.session, layer, payload.key);
            if (index === target.length - 1) {
              this.props.session.commandManager.execute(command);
            } else {
              this.props.session.commandManager.executeAndForget(command);
            }
          });
          break;
        case "alignElement":
          command = new AlignSelectedLayers(
            this.props.session,
            target[0],
            payload
          );
          this.props.session.commandManager.execute(command);
          break;
        case "toggleResizingType":
          command = new ToggleResizingType(this.props.session, target, payload);
          this.props.session.commandManager.execute(command);
          break;
        case "unlockAspectRatio":
          this.props.session.commandManager.execute(
            new UnlockAspectRatio(this.props.session, target)
          );
          break;
        case "lockAspectRatio":
          this.props.session.commandManager.execute(
            new LockAspectRatio(this.props.session, target)
          );
          break;
        case "setAuto":
          command = new SetLayerAuto(
            this.props.session,
            target[0],
            payload.key
          );
          this.props.session.commandManager.execute(command);

          break;
        case "splitView":
          command = new SplitView(
            this.props.session,
            target,
            payload.direction
          );
          this.props.session.commandManager.execute(command);
          break;
        case "setProp":
          command = new SetProp(
            this.props.session,
            target,
            payload.key,
            payload.value,
            true,
            payload.propType
          );
          this.props.session.commandManager.execute(command);
          break;
        case "setPropAndSkip":
          command = new SetProp(
            this.props.session,
            target,
            payload.key,
            payload.value,
            true,
            payload.propType
          );
          this.props.session.commandManager.executeAndSkip(command);
          break;
        case "setPropAndForget":
          command = new SetProp(
            this.props.session,
            target,
            payload.key,
            payload.value,
            true,
            payload.propType
          );
          this.props.session.commandManager.executeAndForget(command);
          break;
        case "setFontPreview":
          command = new SetFontProperties(
            this.props.session,
            target,
            payload.key,
            payload.value,
            payload.stylePropName,
            payload.noPreserve
          );
          this.props.session.commandManager.execute(command);
          break;
        case "setFontPreviewAndSkip":
          command = new SetFontProperties(
            this.props.session,
            target,
            payload.key,
            payload.value,
            payload.stylePropName,
            payload.noPreserve
          );
          this.props.session.commandManager.executeAndSkip(command);
          break;
        case "setFontPreviewAndForget":
          command = new SetFontProperties(
            this.props.session,
            target,
            payload.key,
            payload.value,
            payload.stylePropName,
            payload.noPreserve
          );
          this.props.session.commandManager.executeAndForget(command);
          break;
        case "removeProp":
          command = new RemoveProp(this.props.session, target, payload.key);
          this.props.session.commandManager.execute(command);

          break;
        case "removePropAndSkip":
          command = new RemoveProp(this.props.session, target, payload.key);
          this.props.session.commandManager.executeAndSkip(command);
          break;
        case "setStyleAttribute":
          command = new SetStyleAttribute(
            this.props.session,
            target,
            payload.key,
            payload.value,
            payload.stylePropName
          );
          let fontKeys = [
            "fontSize",
            "fontWeight",
            "fontStyle",
            "color",
            "letterSpacing",
            "lineHeight",
            "fontFamily"
          ];
          if (fontKeys.includes(payload.key) && target.type === "text") {
            let styleProp = {};
            styleProp[payload.key] = payload.value;
            this.props.session.setLastUsedFontStyles(styleProp);
          }
          if (fontKeys.includes(payload.key) && target.type === "icon") {
            let styleProp = {};
            styleProp[payload.key] = payload.value;
            this.props.session.setLastUsedIconStyles(styleProp);
          }
          this.props.session.commandManager.execute(command);

          break;
        case "setStyleAttributeAndSkip":
          command = new SetStyleAttribute(
            this.props.session,
            target,
            payload.key,
            payload.value,
            payload.stylePropName
          );
          this.props.session.commandManager.executeAndSkip(command);
          break;
        case "setStyleAttributeAndForget":
          command = new SetStyleAttribute(
            this.props.session,
            target,
            payload.key,
            payload.value,
            payload.stylePropName
          );
          this.props.session.commandManager.executeAndForget(command);
          break;
        case "setShadowAttributes":
          this.props.session.commandManager.execute(
            new SetShadowAttributes(this.props.session, target, payload)
          );
          break;
        case "setShadowAttributesAndSkip":
          this.props.session.commandManager.executeAndSkip(
            new SetShadowAttributes(this.props.session, target, payload)
          );
          break;
        case "setShadowAttributesAndForget":
          this.props.session.commandManager.executeAndForget(
            new SetShadowAttributes(this.props.session, target, payload)
          );
          break;
        case "removeShadowAttributes":
          this.props.session.commandManager.execute(
            new RemoveShadowAttributes(this.props.session, target, payload)
          );
          break;
        case "setShadowOffset":
          command = new SetStyleAttribute(
            this.props.session,
            target,
            payload.key,
            payload.value
          );
          this.props.session.commandManager.execute(command);
          break;

        case "setShadowOffsetAndForget":
          command = new SetStyleAttribute(
            this.props.session,
            target,
            payload.key,
            payload.value
          );
          this.props.session.commandManager.executeAndForget(command);
          break;

        case "removeStyleAttribute":
          command = new RemoveStyleAttribute(
            this.props.session,
            target,
            payload.key,
            payload.stylePropName
          );
          this.props.session.commandManager.execute(command);
          break;
        case "setGradientEditor":
          this.props.session.currentStage.canvas.dispatchEvent(
            `GradientEditor.${payload.value}`,
            new GradientEditorEvent(`GradientEditor.${payload.value}`, target)
          );
          if (payload.value === "open") {
            this.props.session.permanentlyHideResizer();
          }
          break;

        case "setLayerDimensions":
          let currentTargetLayer = target;
          if (isArray(target)) {
            if (target.length > 1) {
              // Insert code here
              break;
            } else {
              currentTargetLayer = target[0];
            }
          }
          command = new SetLayerDimensions(
            this.props.session,
            currentTargetLayer,
            payload.dimensions
          );
          this.props.session.commandManager.execute(command);
          break;
        case "setLayersTransform":
          command = new SetLayersTransform(
            this.props.session,
            target,
            payload.rotation
          );
          this.props.session.commandManager.execute(command);
          break;
        case "setLayersTransformAndSkip":
          command = new SetLayersTransform(
            this.props.session,
            target,
            payload.rotation
          );
          this.props.session.commandManager.executeAndSkip(command);
          break;
        case "setLayersTransformAndForget":
          command = new SetLayersTransform(
            this.props.session,
            target,
            payload.rotation
          );
          this.props.session.commandManager.executeAndForget(command);
          break;
        case "moveResizeLayer":
          command = new MoveResizeLayer(
            this.props.session,
            target,
            [],
            payload,
            "RightPanelContext"
          );
          this.props.session.commandManager.execute(command);
          break;
        case "moveResizeLayerAndSkip":
          command = new MoveResizeLayer(
            this.props.session,
            target,
            [],
            payload,
            "RightPanelContext"
          );
          this.props.session.commandManager.executeAndSkip(command);
          break;
        case "moveResizeLayerAndForget":
          command = new MoveResizeLayer(
            this.props.session,
            target,
            [],
            payload,
            "RightPanelContext"
          );
          this.props.session.commandManager.executeAndForget(command);
          break;
        case "changeToTouchableOpacity":
          command = new ChangeToTouchableOpacity(
            this.props.session,
            target,
            payload.isTouchableOpacity
          );
          this.props.session.commandManager.execute(command);
          break;
        case "changeToTextInput":
          command = new ChangeToTextInput(
            this.props.session,
            target,
            payload.isEditable
          );
          this.props.session.commandManager.execute(command);
          break;
        case "changeToScrollView":
          command = new ChangeToScrollView(
            this.props.session,
            target,
            payload.isScrollView
          );
          this.props.session.commandManager.execute(command);
          break;
        case "setOverrideAndForget":
          this.props.session.commandManager.executeAndForget(
            new SetOverride(
              this.props.session,
              target,
              payload.key,
              payload.value,
              payload.propType
            )
          );
          break;
        case "setOverrideAndSkip":
          this.props.session.commandManager.executeAndSkip(
            new SetOverride(
              this.props.session,
              target,
              payload.key,
              payload.value,
              payload.propType
            )
          );
          break;
        case "setOverride":
          this.props.session.commandManager.execute(
            new SetOverride(
              this.props.session,
              target,
              payload.key,
              payload.value,
              payload.propType
            )
          );
          break;
        case "disconnectSelectedPathPoint":
          this.props.session.commandManager.executeAndSkip(
            new DisconnectSelectedPathPoint(this.props.session)
          );
          break;
        case "straightenSelectedPathPoint":
          this.props.session.commandManager.executeAndSkip(
            new StraightenSelectedPathPoint(this.props.session)
          );
          break;
        case "openImageExplorer":
          action(() => {
            this.props.session
              .checkImageType(payload.files[0])
              .then(result => {
                //
                this.props.session.commandManager.execute(
                  new ChangeImage(this.props.session, target, result)
                );
              })
              .catch(err => {
                this.props.session.notificationManager.notifyError(
                  "Invalid file format. Use .png, .jpg, .gif or .sketch",
                  "File format"
                );
              });
          });
          break;
        case "setNavigationRoute":
          this.props.session.commandManager.execute(
            new SetNavigationRoute(this.props.session, target, payload)
          );
          break;
        case "toggleComponent":
          {
            if (!target.props[payload.key]) {
              this.props.session.commandManager.execute(
                new AddLayer(
                  this.props.session,
                  target,
                  payload.value,
                  `props.${payload.key}`
                )
              );
              this.props.session.commandManager.executeAndSkip(
                new SelectLayers(this.props.session, [target])
              );
            } else {
              this.props.session.commandManager.execute(
                new RemoveLayer(
                  this.props.session,
                  get(target, `props.${payload.key}`)
                )
              );
            }
          }
          break;
        case "editComponent":
          // this.props.session.commandManager.execute(
          //   new ChangeScene(
          //     this.props.session,
          //     target.props[payload.key],
          //     `layer:${}`
          //   )
          // );
          break;
        case "toggleCondition":
          this.props.session.commandManager.execute(
            new ToggleCondition(this.props.session, target, payload)
          );
          break;
        case "setFontFamily":
          this.props.session.commandManager.execute(
            new SetFontFamily(this.props.session, target, payload)
          );
          break;
        case "addCarouselSlide":
          {
            const ViewDefinition = this.props.session.currentStage.canvas.getComponentDefinition(
              "view"
            );
            let viewLayerJSON = cloneDeep(ViewDefinition.template);
            viewLayerJSON.props.style = {
              flex: 1,
              backgroundColor: "#009688"
            };

            this.props.session.commandManager.execute(
              new AddLayer(this.props.session, target, viewLayerJSON)
            );
            this.props.session.commandManager.executeAndSkip(
              new SelectLayers(this.props.session, [target])
            );
          }
          break;
        case "removeCarouselSlide":
        case "removeTab":
          if (
            target.children &&
            !isEmpty(target.children) &&
            target.children[payload]
          ) {
            this.props.session.commandManager.execute(
              new RemoveLayer(this.props.session, target.children[payload])
            );
            this.props.session.commandManager.executeAndSkip(
              new SelectLayers(this.props.session, [target])
            );
          }
          break;
        case "addTab":
          {
            let tabContentLayerJson = cloneDeep(TabContentDefinition.template);
            tabContentLayerJson.props.title =
              tabContentLayerJson.props.title.slice(
                0,
                tabContentLayerJson.props.title.length - 1
              ) +
              (target.children.length + 1);

            this.props.session.commandManager.execute(
              new AddLayer(this.props.session, target, tabContentLayerJson)
            );
            this.props.session.commandManager.executeAndSkip(
              new SelectLayers(this.props.session, [target])
            );
          }
          break;
        case "editCarouselSlide":
        case "editTab":
          // this.props.session.commandManager.execute(
          //   new ChangeScene(this.props.session, target, "layer")
          // );
          break;
        case "updateRecordingConditions":
          this.props.session.commandManager.executeAndSkip(
            new UpdateRecordingConditions(
              this.props.session,
              payload.key,
              payload.value
            )
          );
          break;
        case "removeRecordingCondition":
          this.props.session.commandManager.executeAndSkip(
            new RemoveRecordingCondition(this.props.session, payload.key)
          );
          break;
        case "updateScopeVariable":
          this.props.session.commandManager.executeAndForget(
            new UpdateFileScopeVariables(this.props.session, {
              [payload.key]: payload.value
            })
          );
          break;
        case "updateExpressionList":
          // UpdateFileExpressionList(
          //   this.props.session,
          //   new Expression({
          //     type: "expression",
          //     expression: payload.key
          //   })
          // );

          // this.props.session.commandManager.executeAndSkip(
          //   new UpdateFileScopeVariables(this.props.session, {
          //     [payload.key]: payload.value
          //   })
          // );
          break;
        case "setDeviceName":
          this.props.session.commandManager.execute(
            new SetDeviceName(this.props.session, payload)
          );
          break;
        case "setDeviceOrientation":
          this.props.session.commandManager.execute(
            new SetDeviceOrientation(this.props.session, payload)
          );
          break;
        case "resetConditions":
          this.props.session.commandManager.execute(
            new ResetConditionals(this.props.session, target)
          );
          break;
        case "setStatusBar":
          this.props.session.commandManager.execute(
            new SetStatusBar(this.props.session, target, payload)
          );
          break;

        case "toggleLoop":
          if (target.parent && target.parent.type === "loop") {
            this.props.session.commandManager.execute(
              new RemoveLoop(this.props.session, target)
            );
          } else {
            this.props.session.commandManager.execute(
              new CreateLoop(this.props.session, target)
            );
          }
          break;
        case "setRepetitions":
          this.props.session.commandManager.execute(
            new SetRepetitions(this.props.session, target, payload.value)
          );
          break;
        // case "activateFormControl":
        //   this.props.session.commandManager.executeAndSkip(
        //     new ActivateFormControl(this.props.session, target, payload)
        //   );
        //   break;
        default:
          break;
      }
      let targetLayer = target;
      if (isArray(target)) {
        targetLayer = target[0];
      }
    });
  };
  getAllArtboardsName = () => {
    // return new Promise<string>(async (resolve: any, reject: any) => {
    const artboardsNames = new Array();
    this.props.session.domain.files.forEach((file: DomainFile) => {
      const filePath = file.path;
      if (!file.isSymbol()) {
        const name = path.basename(filePath, ".js");
        artboardsNames.push({ name, isDrawer: false });
      }
      // else if (file.isDrawer) {
      //   artboardsNames.push({ name: "Drawer", isDrawer: file.isDrawer });
      // }
    });
    artboardsNames.push({ name: "Go Back", isDrawer: false });
    return artboardsNames;
  };
  getSelectedArtboardName = () => {
    const selectedLayers = this.props.session.getLayersFromSelectedLayerCollection();
    let name = "";
    if (selectedLayers[0]) {
      name = (selectedLayers[0] as any).navigateTo || "";
    }
    return name;
  };
  getBoundingBoxWRTParent = () => {
    const layers = this.props.session.getLayersFromSelectedLayerCollection();
    let boundingBox = this.props.session.getBoundingBox(layers);
    return boundingBox;
  };
  resolveNodeValue = (node: any) => {
    const resolvedNode = ResolveNodeValue(
      node,
      this.props.session.selectedFile
        ? this.props.session.selectedFile.scopeVariables
        : {}
    );
    return resolvedNode;
  };
  private getLayerControlsProperty(layerType: string) {
    return this.props.session.currentStage.canvas.getComponentDefinition(
      layerType
    ).controlsProperty;
  }
  render() {
    const selectedLayers = this.props.session.getLayersFromSelectedLayerCollection();
    let selectedLayer: DomainLayer | DomainFile =
      selectedLayers[selectedLayers.length - 1];
    let formBuilderSchema = null;
    // if (
    //   this.props.session.selectedFile &&
    //   this.props.session.selectedFile.isResizerVisible
    // ) {
    //   selectedLayer = this.props.session.selectedFile;
    // }
    const isSymbolFile = this.props.session.selectedFile
      ? this.props.session.selectedFile.isSymbol()
      : false;
    if (!selectedLayer) {
      return null;
    }
    switch (selectedLayer.type) {
      case "file":
        if (isSymbolFile) {
          formBuilderSchema = SymbolFileComponentDefinition.controlsProperty;
        } else {
          formBuilderSchema = FileComponentDefinition.controlsProperty;
        }

        break;
      case "root":
        if (isSymbolFile) {
          formBuilderSchema = SymbolRootLayerDefinition.controlsProperty;
        } else {
          formBuilderSchema = RootComponentDefinition.controlsProperty;
        }
        break;
      case "view":
      case "text":
      case "textInput":
      case "ellipse":
      case "icon":
      case "slider":
      case "mapView":
      case "path":
      case "switch":
      case "activityIndicator":
      case "touchableOpacity":
      case "scrollView":
      case "image":
        formBuilderSchema = this.getLayerControlsProperty(selectedLayer.type);
        break;
      case "symbol":
        formBuilderSchema = SymbolComponentDefinition.controlsProperty;
        break;
        break;
      case "thirdParty":
        if (selectedLayer instanceof DomainLayer) {
          let thirdPartyComp = loadThirdPartyComponent(
            selectedLayer.import.layerName
          );
          if (thirdPartyComp) {
            formBuilderSchema = thirdPartyComp.controlsProperty;
          }
        }
        break;
      default:
        return null;
    }
    if (!formBuilderSchema) {
      return null;
    }
    return (
      <>
        <FormBuilder
          session={this.props.session}
          configurations={
            this.props.session.drivers.configuration.configurations
          }
          schema={formBuilderSchema}
          stageId={this.props.session.currentStage.id}
          additionalData={{
            getBoundingBox: this.getBoundingBoxWRTParent,
            resolveNodeValue: this.resolveNodeValue,
            getResizerHandlesForLayers: this.props.session
              .getResizerHandlesForLayers,
            pathEditorPointMode: this.props.session.currentStage.tools
              .pathEditorData
              ? this.props.session.currentStage.tools.pathEditorData.pointMode
              : "",

            getFontsList: this.props.session.getFontsList,
            getSelectedArtboardName: this.getSelectedArtboardName,
            getAllArtboardsName: this.getAllArtboardsName,
            validateCallbackPropValue: this.props.session
              .validateCallbackPropValue,
            getRecordingConditions: this.props.session.getRecordingConditions,
            project: this.props.session.project,
            captureErrorForSentry: this.props.session.captureErrorForSentry
          }}
          layers={
            selectedLayer instanceof DomainFile
              ? [selectedLayer.layer]
              : selectedLayers
          }
          rootLayer={this.props.session.currentRootLayer}
          selectedFile={this.props.session.selectedFile}
          onEvent={this.onEvent}
          checkGradientEditor={() => {
            return this.props.session.currentStage.canvas.executeFunction(
              "GradientEditor.isOpen"
            );
          }}
          changeToScrollViewIsDoable={
            this.props.session.changeToScrollViewIsDoable
          }
          tools={this.props.session.currentStage.tools}
          robot={this.props.session.drivers.robot}
          recordingConditionals={
            size(this.props.session.currentStage.recordingConditions) !== 0
          }
        />
      </>
    );
  }
}
export default RightPanel;
