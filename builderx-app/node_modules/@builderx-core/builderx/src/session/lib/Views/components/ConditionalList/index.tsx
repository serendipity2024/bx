import * as React from "react";
import * as _ from "lodash";
import { RecordingAlert, Icon, Text } from "components-x";
import { Session } from "../../../models/Session";
import Stage from "../../../models/Stage";
import { capitalize } from "lodash";
import ClearRecordingConditions from "../../../Commands/Conditionals/ClearRecordingConditions";
import { action } from "model";

export default class ConditionalList extends React.Component<
  { session: Session },
  any
> {
  prevStage: Stage;
  componentDidMount() {
    this.props.session.currentStage.on(["recordingConditions"], this.onUpdate);

    let stage = this.props.session.stages.get(
      this.props.session.currentStage.id
    );
    if (stage) {
      this.prevStage = stage;
    }
  }
  componentWillUnmount() {
    this.props.session.currentStage.off(["recordingConditions"], this.onUpdate);
  }
  onUpdate = () => {
    this.forceUpdate();
  };

  componentDidUpdate(prevProps: any) {
    if (this.prevStage !== this.props.session.currentStage) {
      this.prevStage.off(["recordingConditions"], this.onUpdate);
      this.props.session.currentStage.on(
        ["recordingConditions"],
        this.onUpdate
      );
      let stage = this.props.session.stages.get(
        this.props.session.currentStage.id
      );
      if (stage) {
        this.prevStage = stage;
      }
    }
  }
  getText(): string {
    let returnValue = "";
    let conditionsArray: Array<any> = [];
    const recordingCondition = this.props.session.getRecordingConditions();
    // const recordingRawCondition = self.builderX.workspace.getRecordingCondition(
    //   "rawCondition"
    // );

    _.values(recordingCondition).forEach(val => {
      if (!_.isNil(val)) {
        if (typeof val === "string") {
          conditionsArray.push(val);
        } else {
          conditionsArray.push("Custom Conditions");
        }
      }
    });
    if (conditionsArray.length > 0) {
      if (conditionsArray.length > 1) {
        conditionsArray.splice(-1, 0, "&");
      }
      returnValue = "Recording for " + conditionsArray.join(" ");
    }
    return returnValue;
  }

  unsetAllRecordingCondition = () => {
    action(() => {
      this.props.session.commandManager.executeAndSkip(
        new ClearRecordingConditions(this.props.session)
      );
    });
  };
  render() {
    const textVal = this.getText();
    if (textVal !== "") {
      return (
        <RecordingAlert onClick={this.unsetAllRecordingCondition}>
          <Icon name={"pause-record"} size={12} marginRight={true} />
          <Text uiSize="s" uiColor={"0"} inline>
            {textVal}
          </Text>
        </RecordingAlert>
      );
    } else {
      return null;
    }
  }
}
