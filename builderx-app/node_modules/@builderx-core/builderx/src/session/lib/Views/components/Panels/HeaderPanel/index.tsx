import * as React from "react";
import WindowMenu from "../../Toolbars/WindowMenu";
import { Grid, Col } from "components-x";
import { Session, applyPatchInBuilderX } from "../../../../models/Session";
import { times } from "lodash";
import { designerAction } from "@builderx-core/designer";
import { action } from "model";
import { Prompt } from "dialog-x";
import ExternalComponentsRenderer from "../../ExternalComponentsRenderer";
type propType = {
  session: Session;
};
export default class HeaderLeftPanel extends React.PureComponent<
  propType,
  any
> {
  componentDidMount() {
    this.props.session.on("currentStage", this.onUpdate);
  }
  onUpdate = () => {
    this.forceUpdate();
  };
  componentWillUnmount() {
    this.props.session.off("currentStage", this.onUpdate);
  }

  applyReversePatch = () => {
    const reversePatches: any[] = window["reversePatches"];

    const lastPatch: any = reversePatches.pop();
    if (!lastPatch) {
      return;
    }

    console.log("applying reverse patch", lastPatch);

    designerAction(() => {
      action(() => {
        applyPatchInBuilderX(
          lastPatch.object,
          lastPatch.operation,
          this.props.session,
          true
        );
      });
    });
    const lastForwardPatch = window["forwardPatches"].pop();
    window["forwardPatchesRedoStack"].push(lastForwardPatch);
  };

  applyForwardPatch = () => {
    const forwardPatchesRedoStack: any[] = window["forwardPatchesRedoStack"];

    const lastPatch: any = forwardPatchesRedoStack.pop();
    if (!lastPatch) {
      return;
    }

    console.log("applying forward patch", lastPatch);

    designerAction(() => {
      action(() => {
        applyPatchInBuilderX(
          lastPatch.object,
          lastPatch.operation,
          this.props.session,
          false
        );
      });
    });
  };

  jumpToPatch = async () => {
    const forwardPatchesRedoStack: any[] = window["forwardPatchesRedoStack"];
    const forwardPatches: any[] = window["forwardPatches"];

    let patchIndex: any = await Prompt(
      "Enter patch number:",
      "Min: 0, Max: " +
        (forwardPatches.length + forwardPatchesRedoStack.length - 1) +
        ", Current: " +
        (forwardPatches.length - 1),
      "0"
    );

    if (patchIndex) {
      patchIndex = parseInt(patchIndex as string, 10);
      const currentIndex = forwardPatches.length - 1;

      if (patchIndex > currentIndex) {
        const jumpBy = patchIndex - currentIndex;

        times(jumpBy, () => {
          this.applyForwardPatch();
        });
      } else if (patchIndex < currentIndex) {
        const jumpBy = currentIndex - patchIndex;

        times(jumpBy, () => {
          this.applyReversePatch();
        });
      }
    }

    // const lastPatch: any = forwardPatchesRedoStack.pop();
    // if (!lastPatch) {
    //   return;
    // }

    // designerAction(() => {
    //   action(() => {
    //     applyPatchInBuilderX(
    //       lastPatch.object,
    //       lastPatch.operation,
    //       this.props.session,
    //       false
    //     );
    //   });
    // });
  };

  render() {
    return (
      <Grid>
        <Col>
          <WindowMenu
            session={this.props.session}
            currentStage={this.props.session.currentStage}
          />
          <ExternalComponentsRenderer
            session={this.props.session}
            placement="header-panel-left"
          />
          {/* <Button onClick={this.applyReversePatch}>Reverse</Button>
          <Button onClick={this.applyForwardPatch}>Forward</Button>
          <Button onClick={this.jumpToPatch}>Jump to patch</Button> */}
          {/* <Button onClick={() => window["applyStoredPatches"]()}>
            Apply stored patches
          </Button> */}
        </Col>
      </Grid>
    );
  }
}
