import * as React from "react";
import { IEvent } from "common-interfaces";
import { LayerPanel } from "layer-panel";
import { Session } from "../../../../models/Session";
import { Scrollbars, PropertyGroup } from "components-x";
import SetStyleName from "../../../../Commands/Layer/SetStyleName";
import SharedComponentPanel from "../SharedComponentPanel";
import RemoveDragHoveredForAllLayers from "../../../../Commands/Session/RemoveDragHoveredForAllLayers";
import RemoveHoveredForAllLayers from "../../../../Commands/Session/RemoveHoveredForAllLayers";
import SelectLayers from "../../../../Commands/Session/SelectLayers";
import DeselectLayer from "../../../../Commands/Session/DeselectLayer";
import SetHoveredLayers from "../../../../Commands/Session/SetHoveredLayers";
import RemoveHoveredLayer from "../../../../Commands/Session/RemoveHoveredLayer";
import SetDragHoveredLayer from "../../../../Commands/Session/SetDragHoveredLayer";
// import ChangeSceneToSymbol from "../../../../Commands/Scene/ChangeSceneToSymbol";
import SetLayerCollapse from "../../../../Commands/Panels/LayerPanel/SetLayerCollapse";
import SetLayerHide from "../../../../Commands/Panels/LayerPanel/SetLayerHide";
import SetLayerLock from "../../../../Commands/Panels/LayerPanel/SetLayerLock";
import Stage from "../../../../models/Stage";
import { isEmpty, get, uniq } from "lodash";
import { action } from "model";
import { CAN_MOVE_LAYER_INSIDE } from "bx-constants";
import { Utils } from "utils";
import { Prompt } from "dialog-x";
import { MoveLayer, SetCurrentStage } from "../../../../Commands";
import { SessionEvent } from "event-manager";
import RemoveSymbol from "../../../../Commands/Symbols/RemoveSymbol";
// import { SessionCanvasGlue } from "session-plugins";

type propType = {
  session: Session;
  sharedComponentSession: Session;
  sizePanel?: any;
  showCodeEditor?: any;
  togglePanel?: any;
};
const nodeHeight = 37;

class LeftPanel extends React.PureComponent<
  propType,
  {
    panelState: "file" | "shared" | "code" | "";
    filePanel: boolean;
    codeEditorSize: any;
  }
> {
  prevStage: Stage;
  sharedComponentsSession: Session;
  layerPanelScrollbarRef: any;
  constructor(props: any) {
    super(props);
    this.state = {
      panelState: "shared",
      filePanel: true,
      codeEditorSize: undefined
    };
    // const config = {
    //   ...props.session.envConfig,
    //   isSharedComponentInstance: true
    // };
    this.sharedComponentsSession = this.props.sharedComponentSession;

    // const sessionCanvasGlue = new SessionCanvasGlue();
    // this.sharedComponentsSession.installPlugin();

    // if (process.env.NODE_ENV !== "production") {
    //   window["sharedComponentsSession"] = this.sharedComponentsSession;
    // }
  }
  componentDidMount() {
    this.initSharedComponentsSession();
    this.props.session.on(
      [
        "selectedLayers",
        "dragHoveredInsideLayers",
        "dragHoveredBeforeLayers",
        "dragHoveredAfterLayers",
        "hoveredLayers",
        "currentStage",
        "currentRootLayer",
        "selectedFile",
        "editorLayout"
      ],
      this.onUpdate
    );
    // this.props.session.on("selectedLayers", this.setScrollPosition);
    let stage = this.props.session.stages.get(
      this.props.session.currentStage.id
    );
    if (stage) {
      this.prevStage = stage;
    }

    this.props.session.on("projectLock", this.onUpdate);
  }
  initSharedComponentsSession() {
    this.sharedComponentsSession.drivers = this.props.session.drivers;
  }
  onUpdate = (key: string) => {
    this.forceUpdate();
  };
  setScrollPosition = () => {
    if (
      this.layerPanelScrollbarRef &&
      this.props.session.getLayersFromSelectedLayerCollection().length === 1
    ) {
      let layerPos = this.getNodePositionInPanel(
        this.props.session.getLayersFromSelectedLayerCollection()[0]
      );
      let currentTop = this.layerPanelScrollbarRef.getScrollTop();
      let clientHeight = this.layerPanelScrollbarRef.getClientHeight();
      if (
        layerPos < currentTop ||
        layerPos > currentTop + clientHeight - nodeHeight
      ) {
        this.layerPanelScrollbarRef.scrollTop(layerPos);
      }
    }
  };
  manageScroll = (layer: any) => {
    // if (this.layerPanelScrollbarRef && layer) {
    //   let layerPos = this.getNodePositionInPanel(layer);
    //   let currentTop = this.layerPanelScrollbarRef.getScrollTop();
    //   let clientHeight = this.layerPanelScrollbarRef.getClientHeight();
    //   let scrollHeight = this.layerPanelScrollbarRef.getScrollHeight();
    //   // add conditions hererererer
    //   console.log(
    //     "*** currentTop,",
    //     layerPos,
    //     currentTop,
    //     clientHeight,
    //     clientHeight / 10,
    //     (clientHeight * 9) / 10
    //   );
    //   if (layerPos < currentTop + clientHeight / 20) {
    //     console.log("*** scroll up");
    //   } else if (layerPos > currentTop + (clientHeight * 17) / 20) {
    //     console.log("*** scroll down");
    //   }
    //   // this.layerPanelScrollbarRef.scrollTop(layerPos);
    // }
  };
  getNodeTopInPanel(
    node: any,
    nodeToFind: any
  ): { height: number; found: boolean } {
    if (
      !nodeToFind ||
      !node ||
      get(node, "children.length", 0) === 0 ||
      node === nodeToFind
    ) {
      return { height: 0, found: false };
    }
    let found = false;
    let height = 0;
    for (let i = node.children.length - 1; i >= 0; i--) {
      if (node.children[i] === nodeToFind || found) {
        found = true;
        break;
      } else if (node.children[i] && node.children[i].type !== "literal") {
        let obj: { height: number; found: boolean } = this.getNodeTopInPanel(
          node.children[i],
          nodeToFind
        );
        found = obj.found;
        height += nodeHeight + obj.height;
      }
    }
    return { height, found };
  }
  getNodePositionInPanel(node: any) {
    const rootLayer = this.props.session.currentRootLayer;
    return this.getNodeTopInPanel(rootLayer, node).height;
  }
  componentDidUpdate() {
    const session = this.props.session;
    if (this.prevStage !== session.currentStage) {
      // this.prevStage.renderCompiled.off(
      //   ["fileName", "toggleProp", "selectedFile"],
      //   this.onUpdate
      // );
      // session.currentStage.renderCompiled.on(
      //   ["fileName", "toggleProp", "selectedFile"],
      //   this.onUpdate
      // );
      let stage = session.stages.get(session.currentStage.id);
      if (stage) {
        this.prevStage = stage;
      }
    }
  }

  componentWillUnmount() {
    this.props.session.off(
      [
        "selectedLayers",
        "dragHoveredInsideLayers",
        "dragHoveredBeforeLayers",
        "dragHoveredAfterLayers",
        "hoveredLayers",
        "currentStage",
        "currentRootLayer",
        "selectedFile",
        "editorLayout"
      ],
      this.onUpdate
    );
    // this.props.session.off("selectedLayers", this.setScrollPosition);
    this.props.session.off("projectLock", this.onUpdate);
  }
  checkForCenteredLayer = (alreadySelected: any, tempSelectLayer: any) => {
    // DOC: check if layer is center snapped and then skip it and compare its parent
    let isTempSelectedLayerCentered =
      get(tempSelectLayer, "template.centerHorizontal", undefined) ||
      get(tempSelectLayer, "template.centerVertical", undefined);
    let isAlreadySelectedCentered =
      (!isEmpty(alreadySelected) &&
        get(alreadySelected[0], "template.centerHorizontal", undefined)) ||
      get(alreadySelected[0], "template.centerVertical", undefined);
    let alreadySelectedParent = !isEmpty(alreadySelected)
      ? alreadySelected[0].getOwnCanvasRef().parent
      : undefined;
    let tempSelectedParent = !isEmpty(tempSelectLayer)
      ? tempSelectLayer.getOwnCanvasRef().parent
      : undefined;
    // DOC: matching both layers for center, then use centered one's parent to match
    return (
      (isTempSelectedLayerCentered &&
        alreadySelectedParent === tempSelectedParent.parent) ||
      (isAlreadySelectedCentered &&
        alreadySelectedParent.parent === tempSelectedParent) ||
      (isTempSelectedLayerCentered &&
        isAlreadySelectedCentered &&
        alreadySelectedParent.parent === tempSelectedParent.parent)
    );
  };
  handleLayerPanelEvents = async (event: IEvent) => {
    if (this.props.session.readonly) {
      return;
    }
    action(async () => {
      let { session } = this.props;
      let { type, payload } = event;
      switch (type) {
        case "onDragEnd":
          session.commandManager.executeAndSkip(
            new RemoveDragHoveredForAllLayers(session)
          );
          session.commandManager.executeAndSkip(
            new RemoveHoveredForAllLayers(session)
          );
          break;
        case "moveLayer":
          let { fromParent, toParent, fromIndex, toIndex } = payload;
          if (CAN_MOVE_LAYER_INSIDE.indexOf(toParent.type) !== -1) {
            // session.commandManager.execute(
            //   new MoveLayer(session, fromParent, toParent, fromIndex, toIndex)
            // );
            // session.commandManager.executeAndSkip(
            //   new GeneratePreviewAndSelectLayer(session, session.getLayersFromSelectedLayerCollection())
            // );
            session.commandManager.execute(
              new MoveLayer(session, fromParent, toParent, fromIndex, toIndex)
            );
            session.commandManager.executeAndSkip(
              new RemoveDragHoveredForAllLayers(session)
            );
            session.commandManager.executeAndSkip(
              new RemoveHoveredForAllLayers(session)
            );
          }
          break;
        case "onClick":
          if (session.keyboardService.getCurrentKey().indexOf("meta") !== -1) {
            let tempSelectLayer = payload.layer;
            if (
              session
                .getLayersFromSelectedLayerCollection()
                .indexOf(tempSelectLayer) === -1
            ) {
              // select if not present in selectedLayers
              let alreadySelected = [
                ...session.getLayersFromSelectedLayerCollection()
              ];
              if (
                isEmpty(alreadySelected) ||
                (!isEmpty(alreadySelected) &&
                  alreadySelected[0].getOwnCanvasRef() &&
                  tempSelectLayer &&
                  tempSelectLayer.getOwnCanvasRef() &&
                  (alreadySelected[0].getOwnCanvasRef().parent ===
                    tempSelectLayer.getOwnCanvasRef().parent ||
                    this.checkForCenteredLayer(
                      alreadySelected,
                      tempSelectLayer
                    )))
              ) {
                alreadySelected.push(tempSelectLayer);
                session.commandManager.executeAndSkip(
                  new SelectLayers(session, alreadySelected, true)
                );
              } else {
                // just select the layer if selected layers is empty
                session.commandManager.executeAndSkip(
                  new SelectLayers(session, [tempSelectLayer], true)
                );
              }
            } else {
              // unselect if already selected
              session.commandManager.executeAndSkip(
                new DeselectLayer(session, tempSelectLayer)
              );
            }
          } else if (
            session.keyboardService.getCurrentKey().indexOf("shift") !== -1
          ) {
            // DOC: Case for shift, checking if both have same parent and selecting all layers between them
            let alreadySelected = [
              ...session.getLayersFromSelectedLayerCollection()
            ];
            if (isEmpty(alreadySelected)) {
              session.commandManager.executeAndSkip(
                new SelectLayers(session, [payload.layer], true)
              );
            } else {
              let layerToMatch = alreadySelected[0];
              if (layerToMatch.parent === payload.layer.parent) {
                let indexOfLayerToMatch = layerToMatch.parent.children.indexOf(
                  layerToMatch
                );
                let indexOfCurrentLayer = payload.layer.parent.children.indexOf(
                  payload.layer
                );
                let newLayersToSelect = layerToMatch.parent.children.slice(
                  Math.min(indexOfLayerToMatch, indexOfCurrentLayer),
                  Math.max(indexOfLayerToMatch, indexOfCurrentLayer) + 1
                );
                session.commandManager.executeAndSkip(
                  new SelectLayers(
                    session,
                    uniq([...alreadySelected, ...newLayersToSelect]),
                    true
                  )
                );
              } else {
                session.commandManager.executeAndSkip(
                  new SelectLayers(session, [payload.layer], true)
                );
              }
            }
          } else {
            session.commandManager.executeAndSkip(
              new SelectLayers(session, [payload.layer], true)
            );
          }
          break;
        case "onContextMenu":
          if (payload.tab === "layer") {
            session.commandManager.executeAndSkip(
              new SelectLayers(session, [payload.layer])
            );
            session.commandManager.executeAndSkip(
              new SetHoveredLayers(session, [payload.layer])
            );
          }
          if (!session.readonly) {
            session.eventManager.dispatchEvent(
              "contextmenu",
              new SessionEvent("contextmenu", {
                originalEvent: event.originalEvent,
                hotspotData: { area: "left-panel", tab: payload.tab },
                payload:
                  payload.tab === "components"
                    ? session.domain.getFileFromFileId(payload.file)
                    : payload
              })
            );
          }
          break;
        case "onMouseEnter":
          session.commandManager.executeAndSkip(
            new SetHoveredLayers(session, [payload.layer])
          );
          break;
        case "onMouseLeave":
          session.commandManager.executeAndSkip(
            new RemoveHoveredLayer(session, payload.layer)
          );
          break;
        case "onHover":
          session.commandManager.executeAndSkip(
            new SetHoveredLayers(session, [payload.layer])
          );
          break;
        case "onDragHover":
          this.manageScroll(payload.layer);
          session.commandManager.executeAndSkip(
            new SetDragHoveredLayer(session, payload.layer, payload.position)
          );
          break;
        case "onDoubleClick":
          if (payload.layer.type !== "conditionalExpression") {
            const newStyleName = await Utils.getStyleNameUserInput(
              this.props.session,
              Prompt,
              payload.layer.styleName
            );
            if (typeof newStyleName === "string") {
              action(() => {
                session.commandManager.execute(
                  new SetStyleName(session, payload.layer, newStyleName, false)
                );
              });
            }
          }
          break;
        case "toggleCollapse":
          const layerCollapsed = payload.collapsed;
          session.commandManager.execute(
            new SetLayerCollapse(session, payload, !layerCollapsed)
          );
          break;

        case "toggleLock":
          const layerLocked = payload.locked;
          session.commandManager.execute(
            new SetLayerLock(session, payload, !layerLocked)
          );
          break;

        case "toggleHide":
          const layerHidden = payload.hidden;
          session.commandManager.execute(
            new SetLayerHide(session, payload, !layerHidden)
          );
          break;
        case "changeSceneToSymbol":
          session.commandManager.execute(new SetCurrentStage(session, payload));
          break;
        case "deleteSymbol":
          const file = session.domain.getFileFromFileId(payload);
          session.commandManager.execute(new RemoveSymbol(session, file));
          break;
        default:
          break;
      }
    });
  };

  maximize() {
    window.resizeTo(screen.width, screen.height);
    window.moveTo(0, 0);
  }
  togglePanel = (panelState: "file" | "shared" | "code" | "") => {
    this.setState({ panelState });
  };
  render() {
    const rootLayer = this.props.session.currentRootLayer;
    if (!rootLayer || !this.props.session.selectedFile) {
      return null;
    }
    return (
      <PropertyGroup noBorder style={{ height: "99%", paddingTop: 6 }}>
        <Scrollbars
          data-cypress-id="left-expandable-layers-components"
          autoHide
          style={{
            height: "100%",
            display:
              this.props.session.editorLayout.current === "layers"
                ? "flex"
                : "none"
          }}
          ref={(c: any) => (this.layerPanelScrollbarRef = c)}
        >
          <LayerPanel
            active={this.props.session.editorLayout.current === "layers"}
            layer={rootLayer as any}
            onEvent={this.handleLayerPanelEvents}
          />
        </Scrollbars>
        <div
          style={{
            height: "100%",
            display:
              this.props.session.editorLayout.current === "components"
                ? "flex"
                : "none"
          }}
        >
          <SharedComponentPanel
            sharedComponentsSession={this.sharedComponentsSession}
            session={this.props.session}
            editor={false}
            togglePanel={this.togglePanel}
            open={this.state.panelState === "shared"}
            onEvent={this.handleLayerPanelEvents}
          />
        </div>
      </PropertyGroup>
    );
  }
}
export default LeftPanel;
