import { IMutator } from "common-interfaces";
import { cloneDeep, isNil, forEach, merge, camelCase, get, set } from "lodash";
import { Session } from "../models/Session";
import { DeviceStore } from "bx-constants";

import { ResolveNode, ResolveNodeValue, Utils } from "utils";

import UpdateFileExpressionListMutator from "./UpdateFileExpressionListMutator";
// import { Layer as CompiledLayer } from "@builderx-core/designer";

function CreateConditionalExpression(
  session: Session,
  parent: any,
  path: any,
  json: any
) {
  // const node = new ConditionalExpression(session);
  const node = session.emitPatch({
    op: "replace",
    path: `/domain/files:::${Utils.modifyLayerPathForJsonPatch(
      parent.getFullPath()
    )}/${path.replace(/\./g, "/")}`,
    value: {
      type: "class",
      className: "ConditionalExpression",
      value: json
    }
  });
  // debugger;
  // node.parent = parent;
  // if (node.parent instanceof DomainLayer && !replace) {
  //   const index = parseInt(key.replace("children.", ""), 10);
  //   node.parent.appendChild(node, index);
  // } else {
  // set(parent, path, node);
  // } // create test

  if (json.test.type === "expression") {
    CreateExpressionNode(session, node, "test", json.test);
  } else if (json.test.type === "binaryExpression") {
    CreateBinaryExpression(session, node, "test", json.test);
  } else if (json.test.type === "logicalExpression") {
    CreateLogicalExpression(session, node, "test", json.test);
  }

  if (json.alternate.type === "expression") {
    CreateExpressionNode(session, node, "alternate", json.alternate);
  } else if (json.alternate.type === "binaryExpression") {
    CreateBinaryExpression(session, node, "alternate", json.alternate);
  } else if (json.alternate.type === "logicalExpression") {
    CreateLogicalExpression(session, node, "alternate", json.alternate);
  } else if (json.alternate.type === "literal") {
    CreateLiteralNode(session, node, "alternate", json.alternate);
  } else if (json.alternate.type === "conditionalExpression") {
    CreateConditionalExpression(session, node, "alternate", json.alternate);
  }
  if (json.consequent.type === "expression") {
    CreateExpressionNode(session, node, "consequent", json.consequent);
  } else if (json.consequent.type === "binaryExpression") {
    CreateBinaryExpression(session, node, "consequent", json.consequent);
  } else if (json.consequent.type === "logicalExpression") {
    CreateLogicalExpression(session, node, "consequent", json.consequent);
  } else if (json.consequent.type === "literal") {
    CreateLiteralNode(session, node, "consequent", json.consequent);
  } else if (json.consequent.type === "conditionalExpression") {
    CreateConditionalExpression(session, node, "consequent", json.consequent);
  }
}

function CreateExpressionStatementNode(
  session: Session,
  parent: any,
  path: any,
  json: any
) {
  //

  const node = session.emitPatch({
    op: "replace",
    path: `/domain/files:::${Utils.modifyLayerPathForJsonPatch(
      parent.getFullPath()
    )}/${path.replace(/\./g, "/")}`,
    value: {
      type: "class",
      className: "ExpressionStatement",
      value: json
    }
  });

  // const node = new ExpressionStatement(json, session);

  // node.parent = parent;
  // if (node.parent instanceof DomainLayer && !replace) {
  //   const index = parseInt(key.replace("children.", ""), 10);
  //   node.parent.appendChild(node, index);
  // } else {
  // set(parent, path, node);
  // }

  if (json.expression.type === "binaryExpression") {
    CreateBinaryExpression(session, node, "expression", json.expression);
  } else if (json.expression.type === "logicalExpression") {
    CreateLogicalExpression(session, node, "expression", json.expression);
  } else if (json.expression.type === "expression") {
    CreateExpressionNode(session, node, "expression", json.expression);
  } else if (json.expression.type === "literal") {
    CreateLiteralNode(session, node, "expression", json.expression);
  }
}

function CreateExpressionNode(
  session: Session,
  parent: any,
  path: any,
  json: any
) {
  const domainNode = session.emitPatch({
    op: "replace",
    path: `/domain/files:::${Utils.modifyLayerPathForJsonPatch(
      parent.getFullPath()
    )}/${path.replace(/\./g, "/")}`,
    value: {
      type: "class",
      className: "Expression",
      value: json
    }
  });
  const file = parent.getFile();
  // const domainNode = new Expression(json, session);
  // domainNode.parent = parent;
  UpdateFileExpressionListMutator(session, domainNode, file.path);
  // set(parent, path, domainNode);
}

function CreateBinaryExpression(
  session: Session,
  parent: any,
  path: any,
  json: any
) {
  // const node = new BinaryExpression(json, session);

  // console.log("hello binary", node, parent, key);

  const node = session.emitPatch({
    op: "replace",
    path: `/domain/files:::${Utils.modifyLayerPathForJsonPatch(
      parent.getFullPath()
    )}/${path.replace(/\./g, "/")}`,
    value: {
      type: "class",
      className: "BinaryExpression",
      value: json
    }
  });

  // node.parent = parent;

  if (json.left.type === "expression") {
    CreateExpressionNode(session, node, "left", json.left);
  } else if (json.left.type === "literal") {
    CreateLiteralNode(session, node, "left", json.left);
  } else if (json.left.type) {
    throw new Error("unsupported type => " + json.left.type);
  } else {
    // node.left = json.left;
    session.emitPatch({
      op: "replace",
      path: `/domain/files:::${Utils.modifyLayerPathForJsonPatch(
        node.getFullPath()
      )}/left`,
      value: json.left
    });
  }
  if (json.right.type === "expression") {
    CreateExpressionNode(session, node, "right", json.right);
  } else if (json.right.type === "literal") {
    CreateLiteralNode(session, node, "right", json.right);
  } else if (json.right.type) {
    throw new Error("unsupported type => " + json.right.type);
  } else {
    // node.right = json.right;
    session.emitPatch({
      op: "replace",
      path: `/domain/files:::${Utils.modifyLayerPathForJsonPatch(
        node.getFullPath()
      )}/right`,
      value: json.right
    });
  }
  // set(parent, path, node);
}

function CreateLogicalExpression(
  session: Session,
  parent: any,
  path: any,
  json: any
) {
  const node = session.emitPatch({
    op: "replace",
    path: `/domain/files:::${Utils.modifyLayerPathForJsonPatch(
      parent.getFullPath()
    )}/${path.replace(/\./g, "/")}`,
    value: {
      type: "class",
      className: "LogicalExpression",
      value: json
    }
  });
  // const node = new LogicalExpression(json, session);
  // node.parent = parent;

  if (json.left.type === "binaryExpression") {
    CreateBinaryExpression(session, node, "left", json.left);
  } else if (json.left.type === "expression") {
    CreateExpressionNode(session, node, "left", json.left);
  } else if (json.left.type === "logicalExpression") {
    CreateLogicalExpression(session, node, "left", json.left);
  } else if (json.left.type === "expression") {
    CreateExpressionNode(session, node, "left", json.left);
  } else if (json.left.type === "literal") {
    CreateLiteralNode(session, node, "left", json.left);
  } else if (json.left.type) {
    throw new Error("unsupported type => " + json.left.type);
  } else {
    // node.left = json.left;
    session.emitPatch({
      op: "replace",
      path: `/domain/files:::${Utils.modifyLayerPathForJsonPatch(
        node.getFullPath()
      )}/left`,
      value: json.left
    });
  }
  if (json.right.type === "binaryExpression") {
    CreateBinaryExpression(session, node, "right", json.right);
  } else if (json.right.type === "expression") {
    CreateExpressionNode(session, node, "right", json.right);
  } else if (json.right.type === "logicalExpression") {
    CreateLogicalExpression(session, node, "right", json.right);
  } else if (json.right.type === "literal") {
    CreateLiteralNode(session, node, "right", json.right);
  } else if (json.right.type) {
    throw new Error("unsupported type => " + json.right.type);
  } else {
    // node.right = json.right;
    session.emitPatch({
      op: "replace",
      path: `/domain/files:::${Utils.modifyLayerPathForJsonPatch(
        node.getFullPath()
      )}/right`,
      value: json.right
    });
  }
  // set(parent, path, node);
}

function CreateLiteralNode(
  session: Session,
  parent: any,
  path: any,
  json: any
) {
  // this.currentRecordingConditions = this.session.getRecordingConditions();

  const oldJSON = cloneDeep(json);

  const domainNode = session.emitPatch({
    op: "replace",
    path: `/domain/files:::${Utils.modifyLayerPathForJsonPatch(
      parent.getFullPath()
    )}/${path.replace(/\./g, "/")}`,
    value: {
      type: "class",
      className: "LiteralNode",
      value: json
    }
  });

  // let domainNode = new LiteralNode(json, session);
  // set(parent, path, domainNode);
  // domainNode.parent = parent;

  if (
    get(oldJSON, "value.type") &&
    (get(oldJSON, "value.type") === "unknown" ||
      !Utils.shouldIgnoreLayer(oldJSON.value.type))
  ) {
    CreateDomainNode(session, domainNode, "value", oldJSON.value);

    // domainNode.value = DomainLayerFactory.createDomainLayer(oldJSON.value);
    // // TODO: jugaad
    // if (oldJSON.value.type === "text") {
    //   domainNode.value.children[0] = DomainLayerFactory.createDomainLayer(
    //     oldJSON.value.children[0]
    //   );
    //   domainNode.value.children[0].parent = domainNode.value;
    // }
  }

  // if (get(domainNode, "value.type")) {
  //   // TODO: heavy-jugaad
  //   // this.session.commandManager.executeAndSkip(
  //   //   new ClearRecordingConditions(this.session)
  //   // );
  //   // clear recording condition
  //   domainNode.value._parent = domainNode;
  //   if (!Utils.shouldIgnoreLayer(domainNode.value.type)) {
  //     // this.session.currentStage.recordingConditions = {};

  //     SetAllPropsService(
  //       session,
  //       domainNode.value.getFullPath(),
  //       oldJSON.value.props
  //     );

  //     // add condition after set prop
  //     // this.session.currentStage.recordingConditions = this.currentRecordingConditions;
  //   }
  //   // forEach(this.currentRecordingConditions, (value: any, key: any) => {
  //   //   this.session.commandManager.executeAndSkip(
  //   //     new UpdateRecordingConditions(this.session, key, value)
  //   //   );
  //   // });
  // }
}
function CreateDomainNode(session: Session, parent: any, path: any, json: any) {
  const valueType = get(json, "type", undefined);
  if (valueType === "conditionalExpression") {
    CreateConditionalExpression(session, parent, path, json);
  } else if (valueType === "expressionStatement") {
    CreateExpressionStatementNode(session, parent, path, json);
  } else if (valueType === "expression") {
    CreateExpressionNode(session, parent, path, json);
  } else if (valueType === "literal") {
    CreateLiteralNode(session, parent, path, json);
  } else if (valueType) {
    // const node = new DomainLayer(json, session);

    const node = session.emitPatch({
      op: "replace",
      path: `/domain/files:::${Utils.modifyLayerPathForJsonPatch(
        parent.getFullPath()
      )}/${path.replace(/\./g, "/")}`,
      value: {
        type: "class",
        className: "DomainLayer",
        value: json
      }
    });

    // set(parent, path, node);
    // node.parent = parent;
    if (json.children && json.children.length > 0) {
      forEach(json.children, (child: any, index: number) => {
        CreateDomainNode(session, node, `children.${index}`, child);
      });
    }
  }
}
export default function CreateExpressionNodeMutator(
  session: Session,
  layer: any,
  path: string, // props.style //props
  key: string,
  json: any,
  oldJson?: any
) {
  if (!layer) {
    return;
  }
  let targetObject: any = layer;
  if (path) {
    targetObject = get(layer, path);
  }

  // if (Array.isArray(targetObject)) {
  //   targetObject = targetObject[0] ? targetObject[0].parent : layer;
  //   key = `children.${key}`;
  // }

  if (json.type) {
    CreateDomainNode(session, targetObject, key, json);
  } else {
    let oldJSONNode = ResolveNode(oldJson, session.selectedFile.scopeVariables);

    // expression check
    if (oldJSONNode.type === "expression") {
      // oldJSONNode.expression = json;
      session.emitPatch({
        op: "replace",
        path: `/domain/files:::${Utils.modifyLayerPathForJsonPatch(
          oldJSONNode.getFullPath()
        )}/expression`,
        value: json
      });
    } else {
      // oldJSONNode.value = json;
      session.emitPatch({
        op: "replace",
        path: `/domain/files:::${Utils.modifyLayerPathForJsonPatch(
          oldJSONNode.getFullPath()
        )}/value`,
        value: json
      });
    }

    CreateDomainNode(session, targetObject, key, oldJson);
  }
  // const property = get(layer, path);
  // if (property && property.emit) {
  //   property.emit(key);
  // }
  // const event = new SessionEvent("createExpressionNode", {
  //   layer,
  //   path,
  //   key
  // });

  // session.eventManager.dispatchEvent("createExpressionNode", event);
}
