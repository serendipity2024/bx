import { CommandManager } from "command-manager";
import {
  DraggedSharedComponent,
  EnvConfig,
  IDrivers,
  SystemFont,
  DisplayMode,
  ISessionPlugin,
  ICodeEngine
} from "common-interfaces";
import { Alert, ProgressIndicatorDialog } from "dialog-x";
import {
  Domain,
  File,
  Layer as DomainLayer,
  Layer,
  LayerNode,
  File as DomainFile,
  LiteralNode,
  LogicalExpression,
  ConditionalExpression,
  ExpressionStatement,
  Expression,
  BinaryExpression,
  Style,
  Import,
  FormControl,
  ResizingType,
  LayerCollection
} from "domain-x";
import {
  forEach,
  get,
  intersection,
  isNil,
  omitBy,
  findLast,
  reverse,
  set,
  last,
  find
} from "lodash";
import jsCookie from "js-cookie";
import { action, Model, noRerender } from "model";
import { types } from "serializable";
import { isArray } from "util";
import { Utils } from "utils";
import socketIOClient from "socket.io-client";
import { v4 as uuid } from "uuid";
import {
  AddSymbolFromJS,
  LoadProject,
  PlaceArtboardsToCenter,
  DisplayEditButton,
  RemoveArtboard,
  SetModalRoute,
  SetPageRoute,
  AddNewArtboard,
  RemoveLayer,
  AddLayer,
  SelectFile,
  SetStyleAttribute,
  DeselectAllLayers,
  SelectLayers,
  SetLastEditedBy,
  ChangeDisplayMode,
  AddStage,
  SetCurrentStage,
  FocusArtboard,
  AddImage
} from "../../Commands";

import ProcessingFile from "../../Commands/File/ProcessingFile";
import SetFileCode from "../../Commands/CommandServices/SetFileCode";
import AddMissingFonts from "../../Commands/Layer/AddMissingFonts";
import AutoSaveProject from "../../Commands/Workspace/AutoSaveProject";
import AnalyticsApiService from "../../services/ApiService/AnalyticsApiService";
import BaseApiService from "../../services/ApiService/BaseApiService";
import UserApiService from "../../services/ApiService/UserApiService";
import ExtensionService from "../../services/BootServices/ExtensionService";
import IPC from "../../services/BootServices/ExtensionService/IPC";
import CommandKeyMapperService from "../../services/CommandKeyMapperService";
import Configuration from "../../services/DummyConfigurationService";
import GlobalStateService from "../../services/GlobalStateService";
import KeyboardService from "../../services/KeyboardService";
import KeyMapper from "../../services/KeyMapper";
// import { ApiSdk } from "@builderx-core/api-sdk";
import NotificationManager from "../../services/NotificationManager";

import {
  AnalyticsService,
  AppLifecycleService,
  AppUpdaterService,
  ClipboardService,
  DeviceDetailService,
  Dialog,
  FileService,
  GradientService,
  OffScreenRendererService,
  RecentProjects,
  Robotjs,
  Sentry,
  UserService
} from "../../services/Utils/DummyClasses";
import WindowService from "../../services/WindowService";
import PageRouter from "../PageRouter";
import SetRequestCounter from "./../../Commands/Session/SetRequestCounter";
import Project from "../Project";
import Stage from "../Stage";
import { Dimension, EnvConstants } from "../types";
import Viewport from "../Viewport";
import Feedback from "./../Feedback";
import Router from "./../Router";
import { BX_PREVIEW_FILE_PATH, LAYER_TYPES } from "bx-constants";
import { EditorLayout } from "../EditorLayout";
import LockProject from "../../Commands/Session/LockProject";
import ShowCodeEditor from "../../Commands/Session/ShowCodeEditor";
import md5 from "blueimp-md5";
import { SetAllPropsService } from "../../Commands/CommandServices/SetAllPropsService";
import { EventManager, SessionEvent } from "event-manager";
import FunctionRegistry from "../FunctionRegistry";
import urljoin from "url-join";
// import PluginService from "../../services/PluginService";
import { applyOperation, Operation } from "fast-json-patch";

import { diff } from "deep-diff";

import CLASS_MAP from "./CLASS_MAP";
import { designerAction } from "@builderx-core/designer";
import CodeEngine from "code-engine";
import { smartFlex } from "smart-flex";
import imageType from "image-type";
import { ApiSdk } from "@builderx-core/api-sdk";
import { bxConstants } from "src";
import StageArtboard from "../StageArtboard";

window["reversePatches"] = [];
window["forwardPatches"] = [];
window["forwardPatchesRedoStack"] = [];

const localStorage = window["localStorage"];
const path = require("path");

const dummyDrivers: IDrivers = {
  configuration: new Configuration(),
  recentProjects: new RecentProjects(),
  fileService: new FileService(),
  dialog: new Dialog(),
  contextMenu: (e: any) => [],
  analyticsService: new AnalyticsService(),
  userService: new UserService(),
  offScreenRendererService: new OffScreenRendererService(),
  deviceDetailService: new DeviceDetailService(),
  appUpdaterService: new AppUpdaterService(),
  appLifeCycleService: new AppLifecycleService(),
  gradientService: new GradientService(),
  clipboardService: new ClipboardService(),
  Sentry: new Sentry(),
  robot: new Robotjs()
};
export class Session extends Model {
  private plugins = new Map<string, ISessionPlugin>();
  private _functionRegistry: FunctionRegistry = new FunctionRegistry();
  readonly: boolean = false;
  domain = new Domain();
  stages: Map<string, Stage> = new Map();
  thumbnailStages: Map<string, Stage> = new Map();
  assetsMap: Map<
    string,
    {
      file: any;
      refs: Array<Layer>;
    }
  > = new Map();
  currentStage: Stage;
  previousStageData: {
    currentLayer: Layer | undefined;
    currentFile: File | undefined;
    layerSelectedInArtboard: Layer | undefined;
  };
  selectedLayers: Array<LayerCollection> = [];
  selectedNodes: Array<LayerNode<Layer | File, Layer>> = [];
  hoveredLayers: Array<Layer> = [];
  dragHoveredInsideLayers: Array<Layer> = [];
  dragHoveredInsideParent: Layer | undefined;
  dragHoveredBeforeLayers: Array<Layer> = [];
  dragHoveredAfterLayers: Array<Layer> = [];
  emitPatchCallback: (object: any, patch: any, session: Session) => any;
  keyMapper: KeyMapper;
  keyboardService = new KeyboardService();
  commandKeyMapperService: CommandKeyMapperService;
  windowService: WindowService;
  contextMenuItemCreators: Array<(e: any) => any> = [];
  // contextMenuService: ContextMenuService;
  notificationManager = new NotificationManager();
  extensionService: ExtensionService;
  // pluginService: PluginService;
  userApiService: UserApiService;
  analyticsApiService: AnalyticsApiService;
  globalStateService = new GlobalStateService();
  selectedFile: File;
  commandManager: CommandManager;
  editorLayout: EditorLayout;
  // configuration: IConfigurationService;
  // recentProjectService: IRecentProjectService;
  AstModule: IPC;
  viewport = new Viewport();
  currentRootLayer: Layer;
  project = new Project(this);
  pageRouter = new PageRouter();
  modalRouter = new Router();
  eventManager = new EventManager();
  unresolvedSymbolInstances: Array<{
    domainLayer: Layer;
    dummyDomainLayer: Layer;
    compiledParentLayer: any;
  }> = [];
  // dialogDriver: DialogAdapter;
  envConfig: EnvConfig;
  isNewProject: boolean;
  user: any;
  userId: string;
  // projectId: string;
  // drivers: IDrivers;
  feedback: Feedback;
  systemFonts: SystemFont[];
  autoSaveProjectOnInterval: any;
  autoSaveDisabled: boolean = true;
  importingSketchFile: boolean = false;
  isRetrievedFromBackup: boolean = false;
  isCrashed: boolean = false;
  selectedSharedComponent?: DraggedSharedComponent;
  private driversInstance: IDrivers;
  connectionId: string;
  showCodeEditor: boolean;
  dirtyFiles: Array<File>;
  authToken: string | undefined;
  networkRequestCounter: number;
  astNetworkRequestCounter: number;
  isSaving: boolean = false;
  hasWarning: boolean = false;
  oldFontsTrayVersion: boolean = false;
  debugTools: {
    reveseRefData: boolean;
  };
  displayMode: DisplayMode = "stage";
  editorMode: string = "code";
  codeEngine: IPC;
  fontUrl: string;
  platform: "Mac" | "Windows" | "Linux";
  codeEngineName: string;
  currentFileCode: string;
  shouldUpdateCode: boolean = true;
  smartFlex: boolean;
  sessionHash: string;
  editButton: boolean = false;
  resizing: boolean = false;
  recordPatches: boolean = false;
  lastUsedIconStyles: any = {};
  lastUsedFontStyles: any = {};
  existingFilesJSON: any = {};
  fileIdsToBeDeleted: Array<any> = [];
  apiSdk: ApiSdk;
  envConstants: EnvConstants;
  onPatchStartCallbacks: Array<(operation: any) => () => void> = [];
  socket: any;
  codeEngines: Array<ICodeEngine> = [];
  hideResizerTimeout: any;
  lastTenPatches: Array<any> = [];
  getFields() {
    return {
      domain: Domain,
      stages: types.map(types.literal, Stage),
      currentStage: Stage
      // previousStageData: {
      //   currentLayer: Layer | undefined;
      //   currentFile: File | undefined;
      //   layerSelectedInArtboard: Layer | undefined;
      // }
    };
  }
  constructor(config: EnvConfig, apiSdk: ApiSdk, envConstants: EnvConstants) {
    super();
    this.apiSdk = apiSdk;
    this.dirtyFiles = [];
    this.networkRequestCounter = 0;
    this.astNetworkRequestCounter = 0;
    this.editorLayout = new EditorLayout();
    this.commandManager = new CommandManager(
      100,
      !config.isSharedComponentInstance && config.env === "development"
    );

    this.debugTools = { reveseRefData: false };
    this.systemFonts = [];
    this.envConfig = config;
    this.envConstants = envConstants;
    let sessionId = sessionStorage.getItem("connectionId");

    if (!sessionId) {
      sessionId = uuid();
      sessionStorage.setItem("connectionId", sessionId);
    }

    this.connectionId = sessionId;

    this.authToken = jsCookie.get("builderx-auth-token");
    this.initServices();
    // if (!config.isSharedComponentInstance) {
    this.extensionService = new ExtensionService(
      this.envConfig,
      this.connectionId
    );
    // this.pluginService = new PluginService(this);
    this.initCodeEngine(config);
    this.initAstModule(config);
    this.initSketchImport(config);
    this.analyticsApiService = new AnalyticsApiService(this.envConfig);
    if (!config.isSharedComponentInstance) {
      this.selectCodeEngine("react-native");
    }
    this.smartFlex = true;
    // this.smartFlex = process.env.NODE_ENV !== "production" ? true : false;
    // this.codeEngine.selectCodeEngine("react-native");
  }

  before = () => {
    this.commandManager.executeAndSkip(new SetRequestCounter(this, "+"));
  };
  after = () => {
    this.commandManager.executeAndSkip(new SetRequestCounter(this, "-"));
  };

  addCodeEngine(codeEngine: ICodeEngine) {
    action(() => {
      this.codeEngines.push(codeEngine);
      this.emit("addCodeEngine");
    });
  }
  addContextMenuItemCreator(fn: (data: any) => any) {
    this.contextMenuItemCreators.push(fn);
  }
  clearContextMenuItemCreators() {
    this.contextMenuItemCreators = [];
  }
  setCurrentFileCode = (code: string) => {
    this.currentFileCode = code;
    action(() => {
      this.emit("currentFileCode");
    });
  };
  loadProject(ready: boolean) {
    // if (ready) {

    this.commandManager.executeAndSkip(new LoadProject(this));

    // }
    // this.projectReady = ready;
    // if (ready) {
    //   if (this.getAllFileNames().artboards.length === 0) {
    //     this.commandManager.executeAndSkip(
    //       new AddNewArtboard(this, undefined, "artboard")
    //     );
    //   }
    // }
  }
  startRecordingPatches() {
    this.recordPatches = true;
  }
  stopRecordingPatches() {
    this.recordPatches = false;
  }
  addNewArtboard = () => {
    this.commandManager.executeAndSkip(
      new AddNewArtboard(this, undefined, "artboard")
    );
  };
  setShouldUpdateCode = (code: boolean) => {
    this.shouldUpdateCode = code;
    action(() => {
      this.emit("shouldUpdateCode");
    });
  };
  setSmartFlex = (value: boolean) => {
    this.smartFlex = value;
  };
  setIsSaving = (saving: boolean) => {
    this.isSaving = saving;
  };
  setEditorMode = (value: any) => {
    if (value.mode && value.mode === "design_code") {
      this.editorMode = "code";
    } else {
      this.editorMode = "design";
    }
  };
  setHasWarning = (hasIt: boolean) => {
    this.hasWarning = hasIt;
  };
  setOldFontsTrayVersion = (hasIt: boolean) => {
    this.oldFontsTrayVersion = hasIt;
  };
  setFontUrl = (port: number) => {
    if (port) {
      this.fontUrl = `http://localhost:${port}/`;
      // Reinitialise ApiSdk to update fontUrl
      this.apiSdk.init({
        localFontsUrl: this.fontUrl,
        accessToken: jsCookie.get("builderx-auth-token")
      });
      // this.AstModule.executeCommand("setFontUrl", [this.fontUrl]);
    }
  };
  setPlatform = () => {
    const macosPlatforms = ["Macintosh", "MacIntel", "MacPPC", "Mac68K"];
    const winPlatforms = ["Win32", "Win16"];
    if (navigator && macosPlatforms.includes(navigator.platform)) {
      this.platform = "Mac";
    }
    if (navigator && winPlatforms.includes(navigator.platform)) {
      this.platform = "Windows";
    }
  };
  setAstNetworkRequestCounter = (astNetworkRequestCounter: number) => {
    if (
      !isNil(astNetworkRequestCounter) &&
      typeof astNetworkRequestCounter === "number"
    ) {
      this.commandManager.executeAndSkip(
        new SetRequestCounter(
          this,
          undefined,
          Number(astNetworkRequestCounter) || 0
        )
      );
    }
  };

  restoreToBeDeletedFile = (dbFileId: string) => {
    const index = this.fileIdsToBeDeleted.indexOf(dbFileId);
    if (index > -1) {
      this.fileIdsToBeDeleted.splice(index, 1);
    }
  };
  addFileIdToBeDeleted = (dbFileId: string) => {
    if (this.fileIdsToBeDeleted.indexOf(dbFileId) === -1) {
      this.fileIdsToBeDeleted.push(dbFileId);
    }
  };
  private initAstModule(config: EnvConfig) {
    if (!config.isSharedComponentInstance) {
      // this.autoSaveProjectOnInterval = this.autoSaveProject(true);
      if (process.env.NODE_ENV === "production") {
        this.registerErrorHandler();
      }
    }
  }
  private initServices() {
    this.previousStageData = {
      currentLayer: undefined,
      currentFile: undefined,
      layerSelectedInArtboard: undefined
    };
    this.userApiService = new UserApiService(
      new BaseApiService(this.envConfig)
    );
    this.analyticsApiService = new AnalyticsApiService(this.envConfig);
  }

  createStages(isSharedComponentInstance: boolean) {
    if (!isSharedComponentInstance) {
      this.commandManager.executeAndSkip(new AddStage(this, "artboard"));
      this.commandManager.executeAndSkip(new SetCurrentStage(this, "artboard"));
    } else {
      // TODO: heavy jugaad
      this.commandManager.executeAndSkip(new AddStage(this, "teststage"));
      const stage = this.stages.get("teststage");
      if (stage) {
        this.currentStage = stage;
      }
    }
  }
  temporarilyHideResizer = () => {
    clearTimeout(this.hideResizerTimeout);
    this.currentStage.canvas.executeFunction("ResizerRenderer.hide");
    this.hideResizerTimeout = setTimeout(() => {
      this.currentStage.canvas.executeFunction("ResizerRenderer.show");
    }, 1000);
  };
  permanentlyHideResizer = () => {
    clearTimeout(this.hideResizerTimeout);
    this.currentStage.canvas.executeFunction("ResizerRenderer.hide");
  };
  setProgressIndicator(
    heading: string,
    text: string,
    value: number,
    loaderOnly?: boolean,
    close?: boolean
  ) {
    ProgressIndicatorDialog(heading, text, value, loaderOnly, close);
  }
  private initSketchImport(config: EnvConfig) {
    const SketchImport = this.extensionService.extensionsIPC.get(
      "SketchImport"
    );
    if (SketchImport) {
      SketchImport.executeCommand("handshake", [
        {
          settings: this.project.toJS(),
          serverUrl: config.serverUrl
        }
      ]);
      SketchImport.registerCallback(
        this.addArtboardFromJS,
        "addArtboardFromJS"
      );
      SketchImport.registerCallback(this.addSymbolFromJS, "addSymbolFromJS");
      SketchImport.registerCallback(
        this.setProgressIndicator,
        "setProgressIndicator"
      );
    }
  }
  private initCodeEngine(config: EnvConfig) {
    const codeEngine = this.extensionService.extensionsIPC.get("CodeEngine");
    if (codeEngine) {
      this.codeEngine = codeEngine;
      codeEngine.executeCommand("handshake", [
        {
          settings: this.project.toJS(),
          serverUrl: config.serverUrl
        }
      ]);
      this.codeEngine.executeCommand("selectCodeEngine", ["react-native"]);
      this.codeEngine.registerCallback(
        this.captureErrorForSentry,
        "captureErrorForSentry"
      );
    }
  }
  get drivers(): IDrivers {
    if (this.driversInstance) {
      return this.driversInstance;
    } else {
      return dummyDrivers;
    }
  }

  set drivers(drivers: IDrivers) {
    this.driversInstance = drivers;
  }

  get selectedCodeEngine(): ICodeEngine | undefined {
    const codeEngine = find(this.codeEngines, codeEngine => {
      return codeEngine.meta.name === this.codeEngineName;
    });

    return codeEngine;
  }

  notifyError = () => {
    // action(() => {
    //   this.commandManager.executeAndSkip(
    //     new NotifyError(this, "Something is wrong in the code.", "Invaild Code")
    //   );
    // });
  };

  getFontsList = () => {
    return this.systemFonts;
  };

  addAssetToMap = (
    assetFile: any,
    missingAssetFile: boolean = false,
    fallbackPath?: string
  ) => {
    const asset = {
      file: assetFile,
      refs: [],
      missing: missingAssetFile,
      fallbackPath
    };
    this.assetsMap.set(assetFile.path, asset);
  };

  assetExists = (assetPath: string) => {
    const asset = this.assetsMap.get(assetPath);
    if (asset) {
      return true;
    }
    return false;
  };
  getNewImageName = (existingRelativePath: any) => {
    const existingName = path.basename(existingRelativePath);
    const existingPartialPath = existingRelativePath.substring(
      0,
      existingRelativePath.length - existingName.length
    );

    const extension = path.extname(existingName);
    const partialName = existingName.substring(
      0,
      existingName.length - extension.length
    );

    let newFileName = partialName;
    let testFileName;

    let foundName = false;
    let untitledIndex = 0;
    while (!foundName) {
      testFileName = newFileName;
      newFileName += untitledIndex ? untitledIndex : "";

      const newFileRelativePath = existingPartialPath + newFileName + extension;
      if (this.assetExists(newFileRelativePath)) {
        untitledIndex++;
        newFileName = testFileName;
      } else {
        foundName = true;
        newFileName = newFileName;
      }
      // console.log(newFileName + extension, "here()()) while newFileName");
      // if (files.get(newFileName + ".js")) {
      //   untitledIndex++;
      //   newFileName = testFileName;
      // } else {
      //   foundName = true;
      //   newFileName = newFileName + ".js";
      // }
    }
    // console.log(newFileName + extension, "here()())");
    return newFileName + extension;
  };

  checkImageType = async (file: Blob) => {
    return new Promise(async (resolve, reject) => {
      try {
        const fileReader = new FileReader();
        fileReader.onload = async (e: any) => {
          console.log(e.target.result);
          const imageFileType = imageType(e.target.result);

          if (
            // isFileImage(draggedFile)
            imageFileType &&
            [
              "image/png",
              "image/gif",
              "image/jpg",
              "image/jpeg",
              "image/webp"
            ].includes(imageFileType.mime)
          ) {
            resolve(file);
          } else {
            console.log("in error of initial and error is ");
            reject();
          }
        };
        fileReader.readAsArrayBuffer(file);
      } catch (error) {
        console.log("in error of initial and error is ", error);
        reject(error);
      }
    });
  };
  removeFileFromWatcher = (fileId: string) => {
    const file = this.domain.files.get(fileId);
    if (file) {
      this.commandManager
        .executeAndSkip(new RemoveArtboard(this, file))
        .catch(() => {
          //
        });
    }
  };
  autoSaveProject = (firstRun?: boolean) => {
    return setInterval(() => {
      if (!this.readonly) {
        action(async () => {
          this.commandManager.executeAndSkip(new AutoSaveProject(this));
        });
      }
      // console.error("*********************************");
      // console.error("auto save disabled. please enable");
    }, 10000);
  };

  setSketchImportProgress = (importing: boolean) => {
    this.importingSketchFile = importing;
  };

  shouldDisableAutoSave = (value: boolean) => {
    this.autoSaveDisabled = value;
  };
  registerErrorHandler = () => {
    window.onerror = (...args: any[]) => {
      this.errorHandlerAndReporter(...args);
    };

    (window as any).onunhandledrejection = (err: any, promise: any) => {
      this.errorHandlerAndReporter(
        err,
        undefined,
        null,
        null,
        err.reason,
        true
      );
    };
  };

  getAllFileNames = () => {
    let fileNames: { artboards: Array<string>; symbols: Array<string> } = {
      artboards: [],
      symbols: []
    };
    this.domain.files.forEach((file: File) => {
      const filePath = file.path;
      let tempArr = filePath.split("/");
      let name = tempArr[tempArr.length - 1];
      name = name.slice(0, -3);
      if (file.isSymbol()) {
        fileNames.symbols.push(name);
      } else if (!file.isSymbol() && filePath !== BX_PREVIEW_FILE_PATH) {
        fileNames.artboards.push(name);
      }
    });
    return fileNames;
  };
  errorHandlerAndReporter = (
    message?: any,
    source?: any,
    lineno?: any,
    colno?: any,
    error?: any,
    unhandledPromise?: boolean
  ) => {
    // debugger;
    try {
      console.log(
        message,
        source,
        lineno,
        colno,
        error,
        unhandledPromise,
        "errorHandlerAndReporter"
      );
      // Do not save crash info if there is no project open
      if (this.domain.files.size < 1) {
        return;
      }
      // write here to save a state of lastCrashedProject path
      this.domain.setAllFilesIsDirty(false);
      const filePath: string = this.drivers.configuration.get(
        "crash.path.for.project"
      );
      // console.log(filePath, "filePath errorHandlerAndReporter");
      // here save the tempFolderPath builderX["last.crashed.project.path"]
      if (filePath && typeof filePath === "string") {
        this.drivers.configuration.set("last.crashed.project.path", filePath);
      } else if (filePath && isArray(filePath) && filePath[0]) {
        this.drivers.configuration.set(
          "last.crashed.project.path",
          filePath[0]
        );
      }
      if (
        this.drivers.userService.email === "himanshu@geekyants.com" ||
        this.drivers.userService.email === "suraj@geekyants.com" ||
        this.drivers.userService.email === "ankur@geekyants.com" ||
        this.drivers.userService.email === "rishabj@geekyants.com" ||
        this.drivers.userService.email === "chhabindra@geekyants.com"
      ) {
        alert(
          JSON.stringify(
            message,
            ["message", "arguments", "type", "name", "reason"],
            2
          ) + "has been sent to Sentry"
        );
      }
    } catch (error) {
      error = error;
    } finally {
      if (
        this.envConfig.runningContext === "session" &&
        this.pageRouter.currentRoute === "startScreen"
      ) {
        return;
      }

      this.captureErrorForSentry(error);

      Alert(
        "Something went wrong!",
        "No worries, we will try to recover your project.",
        true
      )
        .then(() => {
          // clearInterval(this.autoSaveProjectOnInterval);
          this.domain.setAllFilesIsDirty(false);
          this.isCrashed = true;
          Utils.reloadParentWindow();
        })
        .catch(() => {
          //
        });
    }
  };
  bootCheck = async () => {
    await this.verifyUser();
  };
  verifyUser = async () => {
    const router = this.pageRouter;
    this.openBuilderX(router);
    return;
  };

  openNew = (router: any) => {
    this.commandManager
      .executeAndSkip(new SetPageRoute(this, "startScreen"))
      .catch(() => {
        //
      });
  };
  alert = (
    subject: string,
    message: string,
    nonDismissible: boolean = false,
    confirmBtnText: string = "Reload"
  ) => {
    return Alert(subject, message, nonDismissible, confirmBtnText);
  };
  openProject = (router: any) => {
    const lastCrashedProjectPath: string = this.drivers.configuration.get(
      "last.crashed.project.path"
    );
    if (
      lastCrashedProjectPath &&
      lastCrashedProjectPath !== "" &&
      !isNil(lastCrashedProjectPath) &&
      typeof lastCrashedProjectPath === "string"
    ) {
      // this.commandManager.executeAndSkip(
      //   new OpenCrashedProject(this, lastCrashedProjectPath)
      // );

      this.commandManager
        .executeAndSkip(new SetModalRoute(this, "recoverCrash"))
        .catch(() => {
          //
        });
    } else {
      this.openNew(router);
    }
    //   }
    // });
  };
  openBuilderX = (
    router: { currentRoute: string; previousRoute: string | null } & {
      changeRoute(currentRoute: string): void;
      setPreviousRoute(route: string | null): void;
    } & { readonly $treenode?: any }
  ) => {
    if (
      router.currentRoute === "init" ||
      router.currentRoute === "error/expired"
    ) {
      router.setPreviousRoute("startScreen");
    } else {
      router.setPreviousRoute(router.currentRoute);
    }
    // check for existing and new project
    // setInterval(() => {
    //   this.verifyLicense();
    // }, 300000);
    // const projectPath: string = configurationService.get(
    //   "last.crashed.project.path"
    // );
    // console.log(projectPath, "path(()) getting");
    // if (projectPath) {
    //   // router.changeRoute("startScreen");
    //   // this.builderX.workspace.modalRouter.changeRoute("recoverCrash");
    //   // this.builderX.workspace.modalRouter.setRouteInfo(projectPath);

    //   router.changeRoute("startScreen"); // Hide init spinner because off screen spinner
    //   // this.builderX.openExistingProject(projectPath, true);
    //   // this.builderX.openExistingProject(projectPath, crashed);
    // } else {
    this.openProject(router);
    // }
    // this.builderX.user.setUpdateDownloaded(false);
    // this.builderX.checkAndMatchVersions();
    // this.builderX.checkForUpdates();
  };
  throwErrorResponse = (error: any, session: any) => {
    const parsedJSON = typeof error === "string" ? JSON.parse(error) : error;
    const responseStatus = get(parsedJSON, "response.status");

    session.commandManager.executeAndSkip(new SetPageRoute(session, "blank"));

    switch (responseStatus) {
      case 401:
        localStorage.setItem(
          "redirect_url",
          urljoin(Utils.getEnv("BUILDERX_APP_URL"), Utils.getEnv("PROJECT_ID"))
        );
        Alert("Authentication Failed!", "Please login again!", true)
          .then(() => {
            jsCookie.remove("builderx-auth-token");
            Utils.redirectParentWindow(
              urljoin(Utils.getEnv("BUILDERX_WEBSITE_URL"), "login")
            );
            // window.parent.location.replace(
            //   urljoin(Utils.getEnv("BUILDERX_WEBSITE_URL"), "login")
            // );
            return;
          })
          .catch(() => {
            //
          });
        break;
      case 402:
        localStorage.setItem(
          "redirect_url",
          urljoin(Utils.getEnv("BUILDERX_APP_URL"), Utils.getEnv("PROJECT_ID"))
        );
        Alert(
          "Trial Expired!",
          "Your copy of BuilderX is not activated and its trial period has expired. Please get a licence.",
          true,
          "Go to Pricing"
        ).then(() => {
          window.open(urljoin(this.envConstants.WEBSITE_URL, "pricing"));
        });
        break;
      case 403:
        Alert("Authorisation Failed!", "Please check for permissions!", true)
          .then(() => {
            Utils.redirectParentWindow(
              urljoin(Utils.getEnv("BUILDERX_WEBSITE_URL"), "login")
            );
            // window.parent.location.replace(
            //   urljoin(Utils.getEnv("BUILDERX_WEBSITE_URL"), "login")
            // );
            return;
          })
          .catch(() => {
            //
          });
        break;
      case 404:
        // alert("kdfkjslkdjflksjdflksdf");
        // .then(() => {
        //   window.location.replace(this.envConstants.WEBSITE_URL);
        //   return;
        // })
        // .catch(() => {
        //   //
        // });
        Alert(
          "Invalid Project!",
          "Either the project does not exist, or you don't have the correct access!",
          true
        )
          .then(() => {
            Utils.redirectParentWindow(
              urljoin(Utils.getEnv("BUILDERX_WEBSITE_URL"), "dashboard")
            );
            // window.parent.location.replace(
            //   urljoin(Utils.getEnv("BUILDERX_WEBSITE_URL"), "dashboard")
            // );
            return;
          })
          .catch(() => {
            //
          });
        break;
      case 429:
        Alert(
          "Too Many Requests!",
          "Please try reloading the app after some time or try with some other internet connection!",
          true
        )
          .then(() => {
            // window.parent.location.reload();
            Utils.reloadParentWindow();
            return;
          })
          .catch(() => {
            //
          });
        break;
      default:
        console.error(error);
        Alert(
          "Something Went Wrong!",
          "Please try reloading. If the problem persists, please contact support!",
          true,
          "Contact Support"
        )
          .then(() => {
            window.open(this.envConstants.SUPPORT_URL);
            return;
          })
          .catch(() => {
            //
          });
        break;
    }
  };
  setDomainFileId = (filePath: string, dbFileId: string) => {
    const currentFile: File | undefined = this.domain.files.get(filePath);
    if (currentFile) {
      currentFile.setFileId(dbFileId);
    }
  };
  addArtboardFromJS = (
    fileJSON: any,
    shouldRepositionArtboard: boolean = true,
    shouldGenerateCode: boolean = false
  ) => {
    return new Promise((resolve, reject) => {
      if (!fileJSON) {
        resolve();
        return;
      }
      action(() => {
        if (shouldRepositionArtboard) {
          let position = this.getNewArtboardPosition();
          fileJSON.props.style.left = position.fileLeft;
          fileJSON.props.style.top = position.fileTop;
        }
        this.commandManager
          .executeAndSkip(new AddMissingFonts(this, fileJSON))
          .catch(err => {
            console.log("error while adding missing fonts", err);
            //
          });
        this.commandManager
          .executeAndSkip(new AddNewArtboard(this, fileJSON, "artboard", false))
          .catch(err => {
            console.log("error while adding artboard", err);
            //
          });
        // });
        if (!shouldGenerateCode) {
          this.commandManager
            .executeAndSkip(new ProcessingFile(this, fileJSON.path, false))
            .catch(err => {
              console.log("error ", err);
              //
            });
        }

        resolve(true);
      });
    });
  };
  addSymbolFromJS = (fileJSON: any, shouldGenerateCode: boolean = false) => {
    return new Promise((resolve, reject) => {
      if (!fileJSON) {
        resolve();
        return;
      }
      action(() => {
        this.commandManager
          .executeAndSkip(new AddMissingFonts(this, fileJSON))
          .catch(err => {
            console.log("error while adding missing fonts", err);
            //
          });

        const symbolFile = this.domain.files.get(fileJSON.path);

        // Symbol may get added by resolvesymbolinstace function while resolving dependency
        if (!symbolFile) {
          this.commandManager
            .executeAndSkip(new AddSymbolFromJS(this, fileJSON))
            .catch(err => {
              console.log("error while adding symbol file", err);
              //
            });
        }

        if (!shouldGenerateCode) {
          this.commandManager
            .executeAndSkip(new ProcessingFile(this, fileJSON.path, false))
            .catch(err => {
              console.log("error ", err);
              //
            });
        }

        resolve(true);
      });
    });
  };
  getLayersFromSelectedLayerCollection = (): Array<Layer> => {
    let layers: Array<Layer> = [];
    if (this.selectedLayers.length) {
      layers = this.selectedLayers[0].layers;
    }
    return layers;
  };
  getSelectedFile = (): File | undefined => {
    return this.selectedFile;
  };

  getSelectedLayerPaths = (): Array<string> => {
    let selectedLayerPaths: any = [];
    this.getLayersFromSelectedLayerCollection().forEach((layer: Layer) => {
      selectedLayerPaths.push(layer.getFullPath());
    });
    return selectedLayerPaths;
  };

  // setUserServiceDriver(userServiceDriver: IUserService) {
  //   this.drivers.userService = userServiceDriver;
  //   this.bootCheck();
  // }
  setCurrentStage = (stageId: string) => {
    const stage = this.stages.get(stageId);

    if (stage) {
      if (this.currentStage) {
        this.currentStage.canvasContainerDom.style.display = "none";
      }
      if (stage.canvasContainerDom) {
        stage.canvasContainerDom.style.display = "block";
      }
      this.currentStage = stage;
      // stage.renderCompiled.activatePaperScope();
    }
  };
  setUserData = (data: any) => {
    this.user = data;
  };
  setUserId = (userId: any) => {
    this.userId = userId;
  };
  setCurrentRootLayer = (layer: Layer) => {
    this.currentRootLayer = layer;
  };
  setIsNewProject = (isNewProject: boolean) => {
    this.isNewProject = isNewProject;
  };
  setProjectId = (projectId: string) => {
    this.project.setProjectId(projectId);
    if (this.drivers.fileService.setProjectId) {
      this.drivers.fileService.setProjectId(projectId);
    }
  };

  setHeader(file: any) {
    const compiledFile = file.getOwnCanvasRef() as any;
    let dimensions = compiledFile.computeYogaNode();

    this.commandManager.executeAndSkip(
      new SetStyleAttribute(this, file.header, "left", dimensions.left)
    );

    this.commandManager.executeAndSkip(
      new SetStyleAttribute(this, file.header, "top", dimensions.top - 20)
    );
    this.commandManager.executeAndSkip(
      new SetStyleAttribute(this, file.header, "height", 20)
    );

    this.commandManager.executeAndSkip(
      new SetStyleAttribute(this, file.header, "width", dimensions.width)
    );
  }

  isLockedChildren(layerId: string) {
    //
    //

    if (this.isPluginLoaded("OnlineUsers")) {
      let locked: any = [];
      const onlineUsers = this.executeFunction("OnlineUsers.get");

      onlineUsers.forEach((onlineUser: any) => {
        if (onlineUser.lockedParentLayerId === layerId) {
          locked.push(true);
        }
      });

      if (locked.length > 0) {
        return true;
      }
    }

    return false;
  }
  executeEvent = (data: any) => {
    const selectedFilePath = get(this, "selectedFile.path", "");

    this.globalStateService.setDirty = false;
    this.globalStateService.setDimensions = false;

    let currentFile: File | undefined;
    let selectedFile;
    if (data.action === "remove") {
      action(() => {
        currentFile = this.domain.files.get(data.name);

        if (currentFile) {
          if (this.displayMode !== "preview") {
            this.commandManager.executeAndSkip(
              new RemoveArtboard(this, currentFile)
            );
          } else {
            this.commandManager.executeAndSkip(
              new RemoveArtboard(this, currentFile)
            );
            this.commandManager.executeAndSkip(
              new ChangeDisplayMode(this, "stage")
            );
          }
        }
      });
    } else if (data.content) {
      let fileJSON = JSON.parse(data.content);
      currentFile = this.domain.files.get(fileJSON.path);

      console.log(fileJSON, "file json here");
      if (currentFile) {
        action(() => {
          this.commandManager.executeAndSkip(new DeselectAllLayers(this));

          if (this.displayMode !== "preview") {
            SetAllPropsService(
              this,
              (currentFile as DomainFile).getFullPath(),
              fileJSON.props
            );

            // this.commandManager.executeAndSkip(
            //   new PlaceArtboardsToCenter(this, false, false)
            // );
          } else {
            noRerender(() => {
              SetAllPropsService(
                this,
                (currentFile as DomainFile).getFullPath(),
                fileJSON.props
              );
              // this.commandManager.executeAndSkip(
              //   new PlaceArtboardsToCenter(this, false, false)
              // );
            });
          }

          const fakeChildren = [
            ...reverse((currentFile as DomainFile).layer.children)
          ];
          forEach(fakeChildren, child => {
            if (child) {
              this.commandManager.executeAndSkip(new RemoveLayer(this, child));
            }
          });

          // forEach(file.layer.children, child => {
          //   if (child) {
          //     this.commandManager.executeAndSkip(
          //       new RemoveLayer(this, child)
          //     );
          //   }
          // });

          forEach(fileJSON.layer.children, child => {
            this.commandManager.executeAndSkip(
              new AddLayer(this, (currentFile as DomainFile).layer, child)
            );
          });

          this.commandManager.executeAndSkip(
            new SelectFile(this, currentFile as DomainFile)
          );
        });
      } else {
        if (
          fileJSON.path.includes("/src/symbols") ||
          fileJSON.path.includes("/src/components")
        ) {
          // add symbol
          this.addSymbolFromJS(fileJSON);
        } else {
          // add file
          this.addArtboardFromJS(fileJSON);
        }
      }
      action(() => {
        selectedFile = this.domain.files.get(selectedFilePath);

        if (selectedFile) {
          this.commandManager.executeAndSkip(
            new SelectFile(this, selectedFile)
          );

          this.commandManager.executeAndSkip(
            new SelectLayers(this, [selectedFile.layer])
          );
        }
      });
    }
    this.globalStateService.setDirty = true;
    this.globalStateService.setDimensions = true;
    selectedFile = this.domain.files.get(selectedFilePath);
  };

  connectSocketIO = () => {
    // this.socket = socketIOClient("http://localhost:4000", { timeout: 100000 });
    // console.log("*** here in connectSocket");
    // this.socket.on("patch", (patch: any) => {
    //   console.log("*** patch received", patch);
    //   if (patch.op === "snapshot" && process.env.NODE_ENV !== "production") {
    //     console.log(
    //       diff(this.domain.toJS(), patch.value),
    //       "snapshot dif*******"
    //     );
    //   } else {
    //     designerAction(() => {
    //       action(() => {
    //         this.applyPatchNew(this, patch);
    //       });
    //     });
    //   }
    // });
    // socket.on("poll init", (response: any) => {
    //   console.log("*** poll init response", response);
    // });
    // socket.on("poll", (response: any) => {
    //   console.log("*** poll response", response);
    // });
  };
  connectRealtimeIO = () => {
    // // TODO: Data to be inserted here
    // const io = this.apiSdk.poll.connect(
    //   `${this.envConstants.BACKEND_API_URL}/poll`,
    //   {
    //     project_id: this.project.projectId,
    //     session_id: this.connectionId
    //   },
    //   {
    //     headers: {
    //       Accept: "application/json",
    //       ["X-BuilderX-Auth-Token"]: this.authToken
    //     }
    //   }
    // );
    // io.on("poll", (response: any) => {
    //   if (!this.readonly) {
    //     const storedFiles = response.data.files;
    //     this.domain.files.forEach((fileObj: any, pathIn: string) => {
    //       if (pathIn === BX_PREVIEW_FILE_PATH) {
    //         return;
    //       }
    //       let fileJSON = fileObj.toJS();
    //       fileJSON = JSON.stringify(fileJSON);
    //       const fileMD5 = md5(fileJSON);
    //       const storedFile = get(storedFiles, pathIn);
    //       // if (!storedFile || storedFile !== fileMD5) {
    //       //   action(() => {});
    //       // }
    //     });
    //   }
    //   if (response.data.project.session) {
    //     this.displayEditButton(false);
    //     this.setLastEditedBy(response.data.project.session);
    //     if (response.data.project.session.session_id !== this.connectionId) {
    //       this.lockProject(response.data.project.session);
    //     }
    //   } else {
    //     if (this.readonly) {
    //       this.displayEditButton(true);
    //       this.setLastEditedBy(undefined);
    //     }
    //   }
    //   this.project.setConnectedSessions(response.data.sessions);
    //   action(() => {
    //     forEach(response.data.messages, res => {
    //       this.executeEvent(res);
    //     });
    //   });
    //   forEach(response.data.messages, res => {
    //     let currentFile = this.domain.files.get(res.name);
    //     if (currentFile) {
    //       // if (currentFile) {
    //       //   setAndComputeSelf(this, [currentFile], () => {});
    //       // }
    //     }
    //   });
    // });
    // //
  };

  getResizerHandlesForLayers = (layers: Array<any>) => {
    // if (
    //   self.workspace.persist.currentScene.id !== "symbol" &&
    //   self.workspace.persist.currentScene.id !== "artboards" &&
    //   self.workspace.persist.currentScene.id !== "flatList" &&
    //   layerId ===
    //   self.workspace.persist.currentScene.editAreas[0].rootLayerId
    // ) {
    //   return [];
    // }
    // let isSymbolRootLayer = self.workspace.persist.domain.isSymbolRootLayer(
    //   layerId
    // );
    // add ROTATE handle when symbol root is selected
    // if (isSymbolRootLayer) {
    //   return [
    //     "T",
    //     "B",
    //     "R",
    //     "L",
    //     "BL",
    //     "BR",
    //     "TR",
    //     "TL"
    //   ];
    // }
    // add all handles except ROTATE handle when icon is selected

    let handles: any = ["T", "B", "R", "L", "BL", "BR", "TR", "TL", "ROTATE"];
    if (layers.length === 0) {
      return [];
    }
    layers.forEach((layer: Layer) => {
      if (layer.type === "icon" || layer.type === "switch") {
        handles = intersection(handles, ["ROTATE"]);
      }
      const isLayerAbsolute = !isNil(
        layer.props.getResolvedStyleAttribute("position")
      );
      const isAutoHeight = layer.isHeightAuto;
      const isAutoWidth = layer.isWidthAuto;
      let handlesForAutoOrAbs = this.getHandlesForAutoOrAbsoluteLayer(
        isAutoHeight,
        isAutoWidth
      );

      if (isLayerAbsolute) {
        handles = intersection(handles, handlesForAutoOrAbs);
      } else {
        const handlesForFill = this.getHandlesForFill(layer);
        let handlesHere = intersection(handlesForAutoOrAbs, handlesForFill);
        handles = intersection(handles, handlesHere);
      }
    });

    return handles;
  };

  getHandlesForFill = (layer: Layer) => {
    let handlesForFill: Array<string> = [];
    const isFillWidth = layer.isWidthFill;
    const isFillHeight = layer.isHeightFill;
    let flexSiblings: Array<Layer> = [];
    if (layer.type !== "root") {
      flexSiblings = layer.getSiblingsWithFlex();
    }
    if (flexSiblings.length === 0) {
      handlesForFill = this.getHandlesForFlexLayer(isFillHeight, isFillWidth);
    } else if (layer.parent) {
      const layerParent = layer.parent as Layer;

      const parentFlexDirection = layerParent.props.getResolvedStyleAttribute(
        "flexDirection"
      );
      handlesForFill = this.getHandlesForFlexLayerWithSiblings(
        layer,
        parentFlexDirection,
        isFillHeight,
        isFillWidth
      );
    }
    return handlesForFill;
  };
  getHandlesForAutoOrAbsoluteLayer = (
    isAutoHeight: boolean,
    isAutoWidth: boolean
  ) => {
    if (isAutoHeight && isAutoWidth) {
      return ["ROTATE"];
    } else if (isAutoHeight) {
      return ["ROTATE", "L", "R"];
    } else if (isAutoWidth) {
      return ["ROTATE", "T", "B"];
    } else {
      return ["ROTATE", "T", "B", "R", "L", "BL", "BR", "TR", "TL"];
    }
  };
  getHandlesForFlexLayer = (isFillHeight: boolean, isFillWidth: boolean) => {
    if (isFillHeight && isFillWidth) {
      return [];
    } else if (isFillHeight) {
      return ["L", "R"];
    } else if (isFillWidth) {
      return ["T", "B"];
    } else {
      return ["T", "B", "R", "L", "BL", "BR", "TR", "TL", "ROTATE"];
    }
  };
  getHandlesForFlexLayerWithSiblings = (
    layer: Layer,
    parentFlexDirection: string,
    isFillHeight: boolean,
    isFillWidth: boolean
  ) => {
    if (parentFlexDirection === "row") {
      if (isFillHeight) {
        // if fill Width and fill Height or only fill Height
        return this.getResizerHandlesLayout(layer, parentFlexDirection);
      } else if (isFillWidth) {
        let resizer = this.getResizerHandlesLayout(layer, parentFlexDirection);
        return resizer.concat(["T", "B"]);
      } else {
        return ["T", "B", "R", "L", "BL", "BR", "TR", "TL", "ROTATE"];
      }
    } else {
      // column
      if (isFillWidth) {
        // if fill Width and fill Height or only fill Height
        return this.getResizerHandlesLayout(layer, parentFlexDirection);
      } else if (isFillHeight) {
        let resizer = this.getResizerHandlesLayout(layer, parentFlexDirection);
        return resizer.concat(["L", "R"]);
      } else {
        return ["T", "B", "R", "L", "BL", "BR", "TR", "TL", "ROTATE"];
      }
    }
  };
  getResizerHandlesLayout = (layer: Layer, parentFlexDirection: string) => {
    let parentLayer = layer.parent as Layer;
    let handles: any = [];
    const childrenLength = parentLayer.getChildren().length;
    parentLayer.forEachChild((childLayer: Layer, index: number) => {
      if (childLayer === layer) {
        // first
        if (index === 0) {
          if (parentFlexDirection === "row") {
            handles.push("R");
          } else {
            handles.push("B");
          }
        } else if (index === childrenLength - 1) {
          // last
          if (parentFlexDirection === "row") {
            handles.push("L");
          } else {
            handles.push("T");
          }
        } else {
          // middle
          if (parentFlexDirection === "row") {
            handles.push("R");
            handles.push("L");
          } else {
            handles.push("B");
            handles.push("T");
          }
        }
      }
    });
    return handles;
  };
  cloneProject = () => {
    return new Promise((resolve: any, reject: any) => {
      //   this.drivers.analyticsService.addActivity(
      //     {
      //       name: `clone.template.${this.project.projectName}`,
      //       path: "",
      //       category: "app/command"
      //     },
      //     true
      //   );
      //   this.apiSdk.project
      //     .clone(this.project.projectId)
      //     .then((resp: any) => {
      //       if (resp.data.id) {
      //         window.location.href = `${this.envConstants.APP_URL}/${resp.data.id}`;
      //         resolve();
      //       } else {
      //         reject();
      //       }
      //     })
      //     .catch((error: any) => {
      //       this.notificationManager.notifyError(
      //         "",
      //         "There is some issue in cloning this template. Please try again."
      //       );
      //       console.log("error in cloning project", error);
      //       reject();
      //     });
    });
  };
  getDimensions = (dims: Dimension, container: any) => {
    let x = dims.x ? dims.x : 0;
    let y = dims.y ? dims.y : 0;
    let width = dims.width ? dims.width : 0;
    let height = dims.height ? dims.height : 0;
    let containerWidth = container.width;
    let containerHeight = container.height;
    let dimensions: any = {
      left: { percent: undefined, number: undefined },
      right: { percent: undefined, number: undefined },
      top: { percent: undefined, number: undefined },
      bottom: { percent: undefined, number: undefined },
      width: { percent: undefined, number: undefined },
      height: { percent: undefined, number: undefined }
    };
    dimensions.left.number = x;
    dimensions.left.percent =
      Math.round((dimensions.left.number / containerWidth) * 100 * 100) / 100 +
      "%";
    dimensions.right.number = containerWidth - (x + width);
    dimensions.right.percent =
      Math.round((dimensions.right.number / containerWidth) * 100 * 100) / 100 +
      "%";
    dimensions.width.number = width;
    dimensions.width.percent =
      Math.round((dimensions.width.number / containerWidth) * 100 * 100) / 100 +
      "%";
    dimensions.top.number = y;
    dimensions.top.percent =
      Math.round((dimensions.top.number / containerHeight) * 100 * 100) / 100 +
      "%";
    dimensions.bottom.number = containerHeight - (y + height);
    dimensions.bottom.percent =
      Math.round((dimensions.bottom.number / containerHeight) * 100 * 100) /
        100 +
      "%";
    dimensions.height.number = height;
    dimensions.height.percent =
      Math.round((dimensions.height.number / containerHeight) * 100 * 100) /
        100 +
      "%";
    return dimensions;
  };
  disableForScrollViewRoot = () => {
    return (
      this.currentStage.id.includes("layer:") &&
      this.currentRootLayer.type === "scrollView" &&
      this.getLayersFromSelectedLayerCollection()[0] === this.currentRootLayer
    );
  };
  createGroupFromSelectedLayersIsDoable = (layerName?: string): any => {
    // TODO: uncomment after conditionals
    // if (this.isRecordingForAnyCondition()) {
    //   return false;
    // }

    if (
      this.selectedFile &&
      this.selectedFile.layer instanceof Layer &&
      this.getLayersFromSelectedLayerCollection().indexOf(
        this.selectedFile.layer
      ) > -1
    ) {
      return false;
    }
    let isDoable: boolean = true;

    if (this.selectedLayers.length < 1) {
      return false;
    }

    if (this.selectedLayers.length === 1) {
      const layer = this.getLayersFromSelectedLayerCollection()[0];

      if (layerName && get(layer, "import.layerName") === layerName) {
        return false;
      }
    }
    isDoable = this.isLayersHaveSameParent(
      this.getLayersFromSelectedLayerCollection()
    );
    return isDoable;
  };
  unGroupFromSelectedLayersIsDoable = () => {
    // TODO: uncomment after conditionals
    // if (this.isRecordingForAnyCondition()) {
    //   return false;
    // }

    if (
      this.selectedFile &&
      this.selectedFile.layer instanceof Layer &&
      this.getLayersFromSelectedLayerCollection().indexOf(
        this.selectedFile.layer
      ) > -1
    ) {
      return false;
    }
    let isDoable: boolean = true;

    if (this.selectedLayers.length < 1) {
      return false;
    }
    if (
      this.getLayersFromSelectedLayerCollection()[0].type === "text" ||
      Utils.shouldIgnoreLayer(
        this.getLayersFromSelectedLayerCollection()[0].type
      )
    ) {
      return false;
    }
    if (
      this.getLayersFromSelectedLayerCollection()[0].getChildren().length === 0
    ) {
      return false;
    }
    isDoable = this.isLayersHaveSameParent(
      this.getLayersFromSelectedLayerCollection()
    );

    return isDoable;
  };
  createSymbolFromSelectedLayersIsDoable = (): any => {
    // TODO: uncomment after conditionals
    // if (this.isRecordingForAnyCondition()) {
    //   return false;
    // }
    if (
      this.selectedLayers.length === 1 &&
      this.getLayersFromSelectedLayerCollection()[0].type === "symbol"
    ) {
      return false;
    }

    if (
      this.selectedFile &&
      this.selectedFile.layer instanceof Layer &&
      this.getLayersFromSelectedLayerCollection().indexOf(
        this.selectedFile.layer
      ) > -1
    ) {
      return false;
    }

    let isDoable: boolean = true;

    if (this.selectedLayers.length < 1) {
      return false;
    }
    isDoable = this.isLayersHaveSameParent(
      this.getLayersFromSelectedLayerCollection()
    );

    return isDoable;
  };
  isLayersHaveSameParent = (layers: Layer[]): boolean => {
    let isSameParent = true;
    forEach(this.selectedLayers, (layer: any, index: any): any => {
      if (parseInt(index, 10) > 0) {
        const prevLayerParent = this.selectedLayers[parseInt(index, 10) - 1]
          .parent;
        const currentParentLayerId = this.selectedLayers[parseInt(index, 10)]
          .parent;

        if (currentParentLayerId !== prevLayerParent) {
          isSameParent = isSameParent && false;
        }
      } else {
        isSameParent = isSameParent && true;
      }
    });
    return isSameParent;
  };
  getBoundingBox = (layers: Array<Layer>, withoutRotation: boolean = false) => {
    let newLayers: any = [];
    layers.map((l: Layer) => {
      if (l) {
        newLayers.push(l.getOwnCanvasRef());
      }
    });
    return this.currentStage.canvas.getBoundingBoxWRTParent(
      newLayers,
      withoutRotation
    );
  };

  getAbsoluteBoundingBox = (
    layers: Array<Layer>,
    withoutRotation: boolean = false
  ) => {
    let newLayers: any = [];
    layers.map((l: Layer) => {
      if (l) {
        newLayers.push(l.getOwnCanvasRef());
      }
    });
    return this.currentStage.canvas.getBoundingBox(newLayers, withoutRotation);
  };

  isLayerValidForSelection = (layer: any) => {
    let isValid = false;
    if (layer.domainCompiledRef.domainRef instanceof DomainLayer) {
      let rootLayer = layer.domainCompiledRef.domainRef.getRootLayer(
        this.currentRootLayer
      );
      if (rootLayer) {
        const currentFile = rootLayer.parent;
        if (
          (currentFile &&
            currentFile instanceof File &&
            currentFile.isArtboard()) ||
          rootLayer === this.currentRootLayer
        ) {
          isValid = true;
        }
        const ancestorScrollView = this.getLayerAncestor(
          layer.domainCompiledRef.domainRef,
          "scrollView"
        );
        if (ancestorScrollView && ancestorScrollView !== rootLayer) {
          isValid = false;
        }
      }
    }
    return isValid;
  };
  pickValidLayer = (eventName: "onClick" | "onDoubleClick" = "onClick") => {
    // let selectedDepth = 1;
    // let selectedLayer: Layer | undefined = !isEmpty(this.selectedLayers)
    //   ? this.selectedLayers[0]
    //   : undefined;
    // // let onLayersRC = this.currentStage.renderCompiled.onLayers;
    // let validLayers: any = [];
    // const renderCompiledLayer = get(
    //   selectedLayer,
    //   "domainCompiledRefs.0.renderCompiledRef"
    // );
    // selectedDepth = renderCompiledLayer
    //   ? renderCompiledLayer.getDepth() || 1
    //   : 1;
    // const parent = get(
    //   selectedLayer,
    //   "domainCompiledRefs.0.renderCompiledRef.parent",
    //   undefined
    // );
    // let onLayers: any[] = [];
    // // check if file layer exists
    // forEach(onLayersRC, (layer: any) => {
    //   if (layer.type === "fileHeader") {
    //     onLayers.push(layer);
    //   } else {
    //     const fileRender = layer.getFile();
    //     if (onLayersRC.indexOf(fileRender) > -1) {
    //       onLayers.push(layer);
    //     }
    //   }
    // });
    // if (!isEmpty(onLayers)) {
    //   onLayers.map((layer: any) => {
    //     if (layer.domainCompiledRef.type === "fileHeader") {
    //       validLayers.push(layer);
    //     }
    //     if (!this.isLayerValidForSelection(layer)) {
    //       return;
    //     }
    //     if (
    //       !selectedLayer &&
    //       !(this.selectedFile && this.selectedFile.isResizerVisible)
    //     ) {
    //       return;
    //     }
    //     if (this.shouldIgnoreLayer(layer.domainCompiledRef.domainRef)) {
    //       return;
    //     }
    //     let layerDepth = layer.getDepth();
    //     if (eventName === "onClick") {
    //       if (
    //         layerDepth === 2 ||
    //         (selectedLayer &&
    //           layerDepth > 0 &&
    //           (layerDepth < selectedDepth ||
    //             (layerDepth === selectedDepth &&
    //               parent &&
    //               layer.parent &&
    //               (parent === layer.parent || layerDepth === 1)))) ||
    //         (layerDepth > 0 && layerDepth <= selectedDepth)
    //       ) {
    //         validLayers.push(layer);
    //       }
    //     } else if (eventName === "onDoubleClick") {
    //       if (selectedLayer) {
    //         if (layerDepth > 1 && layerDepth > selectedDepth) {
    //           validLayers.push(layer);
    //         }
    //       } else {
    //         if (layerDepth > 1 && layerDepth <= selectedDepth + 1) {
    //           validLayers.push(layer);
    //         }
    //       }
    //     }
    //   });
    // }
    // return validLayers;
  };
  shouldIgnoreLayer = (layer: Layer): boolean => {
    if (!layer || !layer.parent) {
      return true;
    }

    if (
      layer.parent &&
      layer.parent instanceof Layer &&
      this.isLayerAncestor(layer, "scrollView") &&
      this.isLayerAncestor(layer.parent, "scrollView")
    ) {
      return true;
    }
    if (
      layer.parent &&
      layer.parent instanceof Layer &&
      this.isLayerAncestor(layer.parent, "symbol")
    ) {
      return true;
    }
    return false;
  };
  isLayerAncestor = (layer: Layer, ancestorType: string): boolean => {
    if (layer === this.currentRootLayer) {
      return false;
    } else if (layer.type === ancestorType) {
      return true;
    } else if (layer.parent && layer.parent instanceof Layer) {
      return this.isLayerAncestor(layer.parent, ancestorType);
    } else {
      return false;
    }
  };

  getLayerAncestor = (layer: Layer, ancestorType: string) => {
    // return immediate ancestor layer of a type
    return layer.parent && layer.parent instanceof Layer
      ? this.isLayerAncestor(layer.parent, ancestorType)
      : null;
  };
  getFileHeaderLayer = (layers: any[]) => {
    return findLast(layers, (layer: any) => layer.type === "fileHeader");
  };
  changeToScrollViewIsDoable = (layer: Layer): boolean => {
    if (!layer) {
      return false;
    }

    if (layer === this.currentRootLayer) {
      return false;
    }
    if (layer && (layer.type === "view" || layer.type === "scrollView")) {
      return true;
    }
    return false;
  };
  getNewArtboardPosition = () => {
    const position = this.currentStage.canvas.executeFunction(
      "getNewArtboardPosition"
    );
    return {
      left: position.left,
      top: position.top,
      fileTop: position.artTop,
      fileLeft: position.artLeft
    };
  };

  getPreviousButtonPosition = () => {
    let files: any = []; // this.currentStage.renderCompiled.getChildren();
    let left = Number.MIN_VALUE;
    let fileLeft = Number.MIN_VALUE;
    let fileTop = Number.MIN_VALUE;
    let top = Number.MIN_VALUE;
    const zoom = this.currentStage.tools.zoom;
    forEach(files, (file: any) => {
      if (file.type === "fileHeader") {
        return;
      }
      const fileMinX = file.x;
      const fileMidY = file.y + file.height / 2;
      if (left < fileMinX) {
        left = fileMinX;
        top = fileMidY;
        fileTop = file.y;
      }
    });
    fileLeft = left - 150;
    left = left * zoom - 150;
    top = top * zoom - 40;
    return { left, top, fileTop, fileLeft };
  };

  calculateZoom = () => {
    let contentSize = this.currentStage.canvas.getBoundingBox(
      this.currentStage.canvas.children
    );

    if (this.displayMode !== "stage") {
      contentSize = this.selectedFile.getBoundingClientRect();
    }
    let viewport = this.currentStage.canvas.getViewport();

    let zoom = 1;

    let newSize = Math.max(contentSize.width, contentSize.height);

    const viewportAR = viewport.width / viewport.height;

    if (viewportAR > 1) {
      // height = width;
      zoom = viewport.height / (newSize + 100);
    } else {
      zoom = viewport.width / (newSize + 100);
    }
    return zoom;
  };
  placeArtboardsToCenter = () => {
    this.commandManager
      .executeAndSkip(new PlaceArtboardsToCenter(this))
      .catch(() => {
        //
      });
  };
  displayEditButton = (value: boolean) => {
    this.commandManager
      .executeAndSkip(new DisplayEditButton(this, value))
      .catch(() => {
        //
      });
  };

  lockProject = (data: any) => {
    this.commandManager.executeAndSkip(new SetLastEditedBy(this, data));
    this.commandManager.executeAndSkip(new LockProject(this));
    this.commandManager.executeAndSkip(new ShowCodeEditor(this));

    // this.commandManager.executeAndSkip(
    //   new GeneratePreviewAndSelectLayer(this, this.selectedLayers)
    // );
    // this.commandManager
    //       .executeAndSkip(new ProcessingFile(this, fileJSON.path, false))
    //       .catch(() => {
    //         //
    //       });
  };

  setLastEditedBy = (data: any) => {
    this.commandManager.executeAndSkip(new SetLastEditedBy(this, data));
  };

  validateCallbackPropValue = async (value: string) => {
    // action(async () => {
    // const result = await this.AstModule.executeCommand(
    //   "validateCallbackPropValue",
    //   [value]
    // );
    // if (result) {
    //   return { message: result };
    // } else {
    //   return result;
    // }
    // });
  };
  getNewFilePath = (type: "artboard" | "symbol", suggested?: string) => {
    let probableName = suggested ? suggested : "Untitled";
    let oldNameWithTrimmedIndex = probableName.replace(
      probableName.replace(/^\D+/g, ""),
      ""
    );
    let newFileId = path.join(
      this.project.defaultArtboardDirectory,
      oldNameWithTrimmedIndex
    );
    if (type === "symbol") {
      newFileId = path.join(
        this.project.defaultSymbolDirectory,
        "UntitledSymbol"
      );
    }
    let testFileId;
    let foundName = false;
    let existingIndex = parseInt(probableName.replace(/^\D+/g, ""), 10);
    let artboardNameIndex = isNaN(existingIndex) ? 0 : existingIndex;
    while (!foundName) {
      testFileId = newFileId;
      newFileId += artboardNameIndex ? artboardNameIndex : "";
      if (this.domain.files.get(newFileId + ".js")) {
        artboardNameIndex++;
        newFileId = testFileId;
      } else {
        foundName = true;
        newFileId = newFileId + ".js";
      }
    }
    return newFileId;
  };
  processingFile = (fileId: string, flag: boolean) => {
    this.commandManager
      .executeAndSkip(new ProcessingFile(this, fileId, flag))
      .catch(() => {
        //
      });
  };

  getRecordingConditions = () => {
    const recordingConditions = this.currentStage.recordingConditions;
    return omitBy(recordingConditions, isNil);
  };
  getFileScopeVariables = () => {
    if (this.selectedFile) {
      return this.selectedFile.scopeVariables;
    }
    return {};
  };

  selectCodeEngine = (codeEngineName: string) => {
    action(() => {
      this.codeEngineName = codeEngineName;
      this.codeEngine.executeCommand("selectCodeEngine", [codeEngineName]);
      if (this.showCodeEditor) {
        SetFileCode(this);
      }
      this.emit("codeEngine");
    });
  };
  getFileCode = (file: File): Promise<string> => {
    let fileJSON;
    // @ts-ignore
    if (this.codeEngineName === "html") {
      const originalDCFileJSON: any = file.getOwnCanvasRef().toJS();
      originalDCFileJSON.layer = Utils.getDCInDomainStructure(
        originalDCFileJSON.layer
      );

      fileJSON = {
        ...originalDCFileJSON.domain,
        layer: originalDCFileJSON.layer
      };
    } else {
      fileJSON = file.toJS();
    }

    // if (
    //   this.codeEngineName === "react" ||
    //   this.codeEngineName === "react-native"
    // ) {
    //   return this.codeEngine.executeCommand("getFileCode", [
    //     fileJSON,
    //     {
    //       isPreviewFile: file.path === BX_PREVIEW_FILE_PATH,
    //       convertToFlex: this.smartFlex
    //     }
    //   ]) as Promise<string>;
    // } else {
    const externalEngine = find(this.codeEngines, codeEngine => {
      return codeEngine.meta.name === this.codeEngineName;
    });

    let code: any = "";

    if (externalEngine) {
      let fileJSON = file.toJS();
      if (this.smartFlex) {
        fileJSON = smartFlex(fileJSON as any);
      }
      code = externalEngine.execute(fileJSON, {
        isPreviewFile: file.path === BX_PREVIEW_FILE_PATH,
        convertToFlex: this.smartFlex
      }) as Promise<string>;
    }
    return new Promise(function(resolve, reject) {
      resolve(code);
    });
    // }
  };

  setLastUsedFontStyles = (style: any) => {
    this.lastUsedFontStyles = { ...this.lastUsedFontStyles, ...style };
  };
  setLastUsedIconStyles = (style: any) => {
    this.lastUsedIconStyles = { ...this.lastUsedIconStyles, ...style };
  };

  captureErrorForSentry = (error: Error) => {
    // TODO: sentry build error
    this.drivers.Sentry.configureScope((scope: any) => {
      scope.setExtra(
        "commandHistory",
        JSON.stringify(this.commandManager.getHistory(), null, 2)
      );
      scope.setExtra(
        "lastTenPatches",
        JSON.stringify(this.lastTenPatches, null, 2)
      );
      scope.setTag("editor_mode", this.readonly ? "read-only" : "edit");
    });

    // TODO: sentry build error

    this.drivers.Sentry.withScope((scope: any) => {
      scope.setExtra(
        "SelectedFileId",
        this.selectedFile ? this.selectedFile.path : null
      );
      scope.setExtra(
        "EditorMode",
        this.readonly ? "read-only mode" : "edit mode"
      );
      console.log(error, "errorerrorerrorerror");
      this.drivers.Sentry.captureException(
        error ? error : new Error("unknown error")
      );
    });

    this.emitPatch({
      op: "crash",
      error: error ? error.message : "",
      path: ""
    });

    // console.error(err);
    // this.drivers.Sentry.captureException(
    //   err ? err : { message: "unknown error" }
    // );
  };

  getFileFromLayerPath = (layerPath: string) => {
    let filePath = layerPath;
    if (layerPath.indexOf(":") === -1) {
      filePath = layerPath;
    } else {
      filePath = layerPath.split(":")[0];
    }
    const file = this.domain.files.get(filePath);
    return file;
  };

  getLayerFromLayerPath = (layerPath: string) => {
    const file = this.getFileFromLayerPath(layerPath);
    if (!file) {
      return undefined;
    } else {
      const layer = file.getLayerFromPath(layerPath);
      return layer;
    }
    return file;
  };

  async installPlugin(plugin: ISessionPlugin) {
    this.plugins.set(plugin.name, plugin);
    await plugin.init(this);
    await plugin.activate();
  }

  addFunction(
    name: string,
    callback: (session: Session, ...args: any[]) => any
  ) {
    this._functionRegistry.addFunction(name, callback);
  }

  executeFunction(name: string, ...args: any[]): any {
    return this._functionRegistry.executeFunction(name, this, ...args);
  }
  isPluginLoaded(name: string) {
    return this.plugins.has(name);
  }
  applyOperation = (operation: any) => {
    try {
      return this.executeFunction("applyOperation", operation);
    } catch (err) {
      console.error("Error while executing function applyOperation.");
      this.captureErrorForSentry(err);
    }
  };

  emitPatch = (operation: any) => {
    // // this.applyPatchNew(sessionClone, operation);
    // const returnVal = this.applyPatchNew(this, operation);
    // if (
    //   this.socket &&
    //   (operation.path.includes("/domain/files") ||
    //     operation.path.includes("/stages")) &&
    //   !operation.path.includes(BX_PREVIEW_FILE_PATH) &&
    //   !operation.path.endsWith("isDirty") &&
    //   !operation.path.endsWith("selected") &&
    //   !operation.path.endsWith("collapsed") &&
    //   !operation.path.endsWith("isResizerVisible") &&
    //   !operation.path.endsWith("props/gradientImage") &&
    //   !operation.path.includes("stageArtboards") &&
    //   !operation.path.endsWith("hovered")
    // ) {
    //   this.socket.emit("patch", operation);
    // }
    // return returnVal;

    // Attach layer uuid for layer operations
    const { layerPath } = Utils.splitPatchPath(operation);
    if (layerPath) {
      const layer = this.getLayerFromLayerPath(layerPath);

      if (layer) {
        operation.layerUuid = layer.id;
      }
    }

    return this.emitPatchCallback(this, operation, this);
  };

  onPatch(callback: (operation: any) => () => void) {
    this.onPatchStartCallbacks.push(callback);
  }
}

export function applyPatchInBuilderX(
  object: any,
  operation: { op: string; path: string; value: any; from?: string },
  session: Session,
  reverse: boolean = false
) {
  if (operation.op === "crash") {
    return;
  }
  session.lastTenPatches.push(operation);
  if (session.lastTenPatches.length > 10) {
    session.lastTenPatches.shift();
  }
  // if (Utils.isPersistentPatch(operation) && session.currentStage && !session.currentStage.dragging) {
  //   console.log("applying op *()*()*** ", operation);
  // }
  if (!reverse) {
    if (session.recordPatches && Utils.isPersistentPatch(operation)) {
      window["forwardPatches"].push({ operation, object });
    }
  }
  if (
    operation.op === "add" &&
    operation.value &&
    operation.value.type === "class" &&
    operation.value.className === "DomainLayer" &&
    (Object.keys(operation.value.value.props).length > 0 ||
      (operation.value.value.children &&
        operation.value.value.children.length > 0))
  ) {
    const parentLayerPath = Utils.getParentLayerPathFromLayerPatch(operation);

    if (parentLayerPath) {
      const parentLayer = session.getLayerFromLayerPath(parentLayerPath);

      if (parentLayer) {
        let layerIndex: any = operation.path.slice(
          operation.path.lastIndexOf("/") + 1
        );

        layerIndex = layerIndex === "-" ? undefined : layerIndex;
        session.stopRecordingPatches();
        session.commandManager.executeAndSkip(
          new AddLayer(session, parentLayer, operation.value.value, layerIndex)
        );
        session.startRecordingPatches();
      }
      return;
    }
  }
  if (
    operation.op === "add" &&
    operation.value &&
    operation.value.type === "class" &&
    operation.value.className === "DomainFile" &&
    operation.value.value.props &&
    Object.keys(operation.value.value.props).length > 0 &&
    Object.keys(operation.value.value.props.style).length > 0
  ) {
    session.stopRecordingPatches();

    if (
      operation.value.value.path.includes("/src/symbols") ||
      operation.value.value.path.includes("/src/components")
    ) {
      session.commandManager.executeAndSkip(
        new AddSymbolFromJS(session, operation.value.value)
      );
    } else {
      session.commandManager.executeAndSkip(
        new AddNewArtboard(session, operation.value.value, "artboard", false)
      );
    }
    session.startRecordingPatches();
    return;
  }
  if (
    operation.op === "add" &&
    operation.value &&
    operation.value.type === "file" &&
    operation.value.layer
  ) {
    session.stopRecordingPatches();

    if (
      operation.value.path.includes("/src/symbols") ||
      operation.value.path.includes("/src/components")
    ) {
      session.commandManager.executeAndSkip(
        new AddSymbolFromJS(session, operation.value)
      );
    } else {
      session.commandManager.executeAndSkip(
        new AddNewArtboard(session, operation.value, "artboard", false)
      );
    }
    session.startRecordingPatches();
    return;
  }

  const onPatchCallbacks = session.onPatchStartCallbacks.map(callback => {
    return callback(operation);
  });

  let returnVal: any;
  let reversePatch: any;
  // if (window["recordPatches"]) {
  //   window["patches"].push({ object: object, operation });
  // }

  // if (this.socket) {
  //   this.socket.emit("patch", operation);
  // }

  let resolvedObject = object,
    modifiedPath = operation.path,
    modifiedValue = operation.value;

  ({ resolvedObject, modifiedPath } = Utils.resolveMapsForJsonPatch(
    operation,
    object
  ));

  if (
    operation.value &&
    operation.value.type === "class" &&
    operation.value.className
  ) {
    let args: any[] = [];
    switch (operation.value.className) {
      case "DomainFile":
        args = [operation.value.value, session];
        break;
      case "DomainLayer":
        args = [operation.value.value, session];
        break;
      case "LiteralNode":
        args = [operation.value.value, session];
        break;
      case "LogicalExpression":
        args = [operation.value.value, session];
        break;
      case "ConditionalExpression":
        args = [session];
        break;
      case "ExpressionStatement":
        args = [operation.value.value, session];
        break;
      case "Expression":
        args = [operation.value.value, session];
        break;
      case "BinaryExpression":
        args = [operation.value.value, session];
        break;
      case "StageArtboard":
        args = [session];
        break;
      case "Stage":
        const stageId = last(operation.path.split(":::"));
        args = [stageId, session];
        break;
      case "Style":
        args = [];
        break;
      case "Import":
        args = [operation.value.value];
        break;
      case "FormControl":
        args = [
          operation.value.value.type,
          operation.value.value.title,
          operation.value.value.layer
        ];
        break;
      case "ResizingType":
        args = [operation.value.value];
        break;
      case "CommandKeyMapperService":
        args = [session];
        break;
      case "Map":
        args = [];
        break;
    }

    modifiedValue = new CLASS_MAP[operation.value.className](...args);

    returnVal = modifiedValue;
  }

  if (modifiedPath.includes(":::")) {
    const patchInfo: any = {};
    const pathChunks = modifiedPath.split(":::");

    if (pathChunks.length !== 2) {
      throw new Error("Something went wrong while parsing json path");
    }

    const map = get(
      resolvedObject,
      // convert path /abc/xyz/pqr to lodash get compliant abc.xyz.pqr
      pathChunks[0].replace(/\//g, ".").slice(1)
    );
    if (operation.op === "add") {
      map.set(pathChunks[1], modifiedValue);
    } else if (operation.op === "remove") {
      patchInfo.removed = map.get(pathChunks[1]);
      map.delete(pathChunks[1]);
    } else if (operation.op === "move" && operation.from) {
      const fromPathChunks = operation.from.split(":::");
      const object = map.get(fromPathChunks[1]);
      map.delete(fromPathChunks[1]);
      map.set(pathChunks[1], object);
    }
    if (!reverse) {
      if (session.recordPatches && Utils.isPersistentPatch(operation)) {
        reversePatch = getReversePatch(operation, object, patchInfo);
        // console.log("real reverse op *()*()*** ", reversePatch);
        window["reversePatches"].push({
          operation: reversePatch,
          object: object
        });
      }
    }
  } else {
    const patchInfo = applyOperation(resolvedObject, {
      ...operation,
      value: modifiedValue,
      path: modifiedPath
    } as Operation);
    if (!reverse) {
      if (session.recordPatches && Utils.isPersistentPatch(operation)) {
        // console.log("applied op ", {
        //   ...operation,
        //   value: modifiedValue,
        //   path: modifiedPath
        // });
        // console.log("possible reverse op *()*()*** ", patchInfo);

        reversePatch = getReversePatch(operation, object, patchInfo);
        // console.log("real reverse op *()*()*** ", reversePatch);
        window["reversePatches"].push({
          operation: reversePatch,
          object: object
        });
      }
    }
  }

  onPatchCallbacks.forEach(callback => {
    callback();
  });

  return { returnVal, reversePatch };
}

function getReversePatch(patch: any, object: any, patchInfo: any) {
  let oldValue;
  if (patchInfo.removed && patchInfo.removed instanceof DomainFile) {
    oldValue = {
      type: "class",
      className: "DomainFile",
      value: patchInfo.removed.toJS()
    };
  } else if (patchInfo.removed && patchInfo.removed instanceof DomainLayer) {
    oldValue = {
      type: "class",
      className: "DomainLayer",
      value: patchInfo.removed.toJS()
    };
  } else if (patchInfo.removed && patchInfo.removed instanceof LiteralNode) {
    oldValue = {
      type: "class",
      className: "LiteralNode",
      value: patchInfo.removed.toJS()
    };
  } else if (
    patchInfo.removed &&
    patchInfo.removed instanceof LogicalExpression
  ) {
    oldValue = {
      type: "class",
      className: "LogicalExpression",
      value: patchInfo.removed.toJS()
    };
  } else if (
    patchInfo.removed &&
    patchInfo.removed instanceof ConditionalExpression
  ) {
    oldValue = {
      type: "class",
      className: "ConditionalExpression",
      value: patchInfo.removed.toJS()
    };
  } else if (
    patchInfo.removed &&
    patchInfo.removed instanceof ExpressionStatement
  ) {
    oldValue = {
      type: "class",
      className: "ExpressionStatement",
      value: patchInfo.removed.toJS()
    };
  } else if (patchInfo.removed && patchInfo.removed instanceof Expression) {
    oldValue = {
      type: "class",
      className: "Expression",
      value: patchInfo.removed.toJS()
    };
  } else if (
    patchInfo.removed &&
    patchInfo.removed instanceof BinaryExpression
  ) {
    oldValue = {
      type: "class",
      className: "BinaryExpression",
      value: patchInfo.removed.toJS()
    };
  } else if (patchInfo.removed && patchInfo.removed instanceof StageArtboard) {
    oldValue = {
      type: "class",
      className: "StageArtboard",
      rootLayerId: patchInfo.removed.rootLayerId,
      filePath: patchInfo.removed.path
    };
  } else if (patchInfo.removed && patchInfo.removed instanceof Stage) {
    oldValue = patchInfo.removed;
  } else if (patchInfo.removed && patchInfo.removed instanceof Style) {
    oldValue = {
      type: "class",
      className: "Style"
    };
  } else if (patchInfo.removed && patchInfo.removed instanceof Import) {
    oldValue = {
      type: "class",
      className: "Import",
      value: patchInfo.removed.toJS()
    };
  } else if (patchInfo.removed && patchInfo.removed instanceof FormControl) {
    oldValue = {
      type: "class",
      className: "FormControl",
      value: {
        type: patchInfo.removed.type,
        title: patchInfo.removed.title,
        layer: patchInfo.removed.layerPath
      }
    };
  } else if (patchInfo.removed && patchInfo.removed instanceof ResizingType) {
    oldValue = {
      type: "class",
      className: "ResizingType",
      value: {}
    };
  } else if (
    patchInfo.removed &&
    patchInfo.removed instanceof CommandKeyMapperService
  ) {
    oldValue = {
      type: "class",
      className: "CommandKeyMapperService"
    };
  } else if (patchInfo.removed && patchInfo.removed instanceof Map) {
    oldValue = {
      type: "class",
      className: "Map"
    };
  } else {
    oldValue = patchInfo.removed;
  }

  const reversePatch: any = {};
  if (patch.op === "add") {
    reversePatch.op = "remove";
    reversePatch.path = patch.path;

    if (patch.path.endsWith("/-")) {
      reversePatch.path = patch.path.replace(/\/\-$/, "/" + patchInfo.index);
    }
  } else if (patch.op === "replace") {
    // const oldValue = patchInfo.removed;
    reversePatch.op = "replace";
    reversePatch.path = patch.path;
    reversePatch.value = oldValue;
  } else if (patch.op === "remove") {
    // const oldValue = patchInfo.removed;
    reversePatch.op = "add";
    reversePatch.path = patch.path;
    reversePatch.value = oldValue;
  } else if (patch.op === "move") {
    reversePatch.op = "move";
    reversePatch.from = patch.path;
    reversePatch.path = patch.from;
  }

  return reversePatch;
}
