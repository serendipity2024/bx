import Tools from "../Tools";
import { Model } from "model";
import { types } from "serializable";
import { Canvas, IPosition } from "@builderx-core/designer";
import { Session } from "../Session";
import { SelectLayers, DeselectLayer } from "../../Commands";
import StageArtboard from "../StageArtboard";
import { get, isEmpty } from "lodash";
import * as ReactDOM from "react-dom";
window["ReactDOM"] = ReactDOM;
export default class Stage extends Model {
  id: string;
  tools: Tools;
  canvas: Canvas;
  canvasContainerDom: HTMLDivElement;
  domainCompiled: any;
  stageArtboards: Array<StageArtboard>;
  recordingConditions: { [key: string]: any };
  dragging: boolean = false;
  stageA: boolean = false;

  getFields() {
    return {
      id: types.literal
    };
  }
  constructor(id: string, session: Session) {
    super();
    this.recordingConditions = {};
    this.stageArtboards = [];
    this.id = id;
    const renderCompiledData = {
      x: 0,
      y: 0,
      width: 1000,
      height: 1000,
      children: []
    };
    const resizerData = { x: 0, y: 0, width: 0, height: 0, rotation: 0 };
    const drawData = {
      type: "view",
      renderCompiledWidth: renderCompiledData.width,
      renderCompiledHeight: renderCompiledData.height
    };
    const mouseRectData = {
      renderCompiledWidth: renderCompiledData.width,
      renderCompiledHeight: renderCompiledData.height
    };

    const sharedComponentsGhostData = {
      renderCompiledWidth: renderCompiledData.width,
      renderCompiledHeight: renderCompiledData.height
    };

    const snapLineHorizontalData = {
      y: 0,
      x: 0,
      direction: "horizontal",
      length: 0,
      displayValue: false
    };
    const snapLineVerticalData = {
      y: 0,
      x: 0,
      direction: "vertical",
      length: 0,
      displayValue: false
    };

    this.tools = new Tools(
      resizerData,
      mouseRectData,
      snapLineHorizontalData,
      snapLineVerticalData,
      drawData,
      sharedComponentsGhostData
    );

    // set up canvas
    // this.setupStageDesigner();
    //
    //
    this.canvasContainerDom = document.createElement("div");
    this.canvasContainerDom.style.visibility = "hidden";
    // this.canvasContainerDom.style.width = "1000px";
    // this.canvasContainerDom.style.display = "1000px";

    // this.setupStageDesigner(session);
    const stageContainerDom = document.querySelector(".stage-container");
    if (stageContainerDom) {
      stageContainerDom.children[0].appendChild(this.canvasContainerDom);
    } else {
      document.body.appendChild(this.canvasContainerDom);
    }
  }

  checkForCenteredLayer = (alreadySelected: any, tempSelectLayer: any) => {
    // DOC: check if layer is center snapped and then skip it and compare its parent
    let isTempSelectedLayerCentered =
      get(tempSelectLayer, "template.centerHorizontal", undefined) ||
      get(tempSelectLayer, "template.centerVertical", undefined);
    let isAlreadySelectedCentered =
      (!isEmpty(alreadySelected) &&
        get(alreadySelected[0], "template.centerHorizontal", undefined)) ||
      get(alreadySelected[0], "template.centerVertical", undefined);
    let alreadySelectedParent = !isEmpty(alreadySelected)
      ? alreadySelected[0].getOwnCanvasRef().parent
      : undefined;
    let tempSelectedParent = !isEmpty(tempSelectLayer)
      ? tempSelectLayer.getOwnCanvasRef().parent
      : undefined;
    // DOC: matching both layers for center, then use centered one's parent to match
    return (
      (isTempSelectedLayerCentered &&
        alreadySelectedParent === tempSelectedParent.parent) ||
      (isAlreadySelectedCentered &&
        alreadySelectedParent.parent === tempSelectedParent) ||
      (isTempSelectedLayerCentered &&
        isAlreadySelectedCentered &&
        alreadySelectedParent.parent === tempSelectedParent.parent)
    );
  };
  performShiftClick = (session: Session, domainRef: any) => {
    let tempSelectLayer = domainRef;
    const unResizeFile =
      session.selectedFile && session.selectedFile.isResizerVisible;
    if (
      session
        .getLayersFromSelectedLayerCollection()
        .indexOf(tempSelectLayer) === -1
    ) {
      // select if not present in selectedLayers
      let alreadySelected = [...session.getLayersFromSelectedLayerCollection()];
      if (
        isEmpty(alreadySelected) ||
        (!isEmpty(alreadySelected) &&
          tempSelectLayer &&
          (alreadySelected[0].getOwnCanvasRef().parent ===
            tempSelectLayer.getOwnCanvasRef().parent ||
            this.checkForCenteredLayer(alreadySelected, tempSelectLayer)))
      ) {
        alreadySelected.push(tempSelectLayer);
        session.commandManager.executeAndSkip(
          // TODO: Change to GeneratePreviewAndSelectLayer
          new SelectLayers(session, alreadySelected, unResizeFile)
        );
      } else {
        // just select the layer if selected layers is empty
        session.commandManager.executeAndSkip(
          // TODO: Change to GeneratePreviewAndSelectLayer
          new SelectLayers(session, [tempSelectLayer], unResizeFile)
        );
      }

      // ********************
      // Shift + click deselect already selected,
      // Doesn't work for the first time in nested children
    } else {
      // unselect if already selected
      session.commandManager.executeAndSkip(
        new DeselectLayer(session, tempSelectLayer)
      );
    }
  };
}
