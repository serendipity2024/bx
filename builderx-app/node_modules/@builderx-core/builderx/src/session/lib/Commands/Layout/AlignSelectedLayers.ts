import { Layer as DomainLayer, Layer } from "domain-x";
import { Session } from "../../models/Session";
import { ICommand } from "command-manager";
import { isNil, size, minBy, maxBy, forEach } from "lodash";
import SetStyleAttributeMutator from "../../Mutators/SetStyleAttributeMutator";
import RemoveStyleAttributeMutator from "../../Mutators/RemoveStyleAttributeMutator";
import CreateGroupService from "./../CommandServices/CreateGroup";
import { Utils } from "utils";
import { SetAllStyleService } from "../CommandServices/SetAllStyleService";
import { SetLayerDimensionsService } from "../CommandServices/SetLayerDimensions";
import ChangeToFlexService from "../CommandServices/ChangeToFlex";
import SelectLayersService from "../CommandServices/SelectLayersService";
import ResetStyleService from "../CommandServices/ResetStyleService";
import { SetCenterWrapperMutator } from "../../Mutators";
import ChangeToAbsolute from "../CommandServices/ChangeToAbsolute";
import SetResizingTypeMutator from "../../Mutators/SetResizingTypeMutator";

export default class AlignSelectedLayers implements ICommand {
  displayName = "AlignSelectedLayers";
  private selectedLayers: Array<DomainLayer>;
  private selectedLayersPaths: Array<string> = new Array();
  private session: Session;
  private alignType: string;
  private domainLayerPath: string;
  private wrapperLayerPath: string;
  private oldStyles: any = {};
  private oldCenterTemplate: any = {};
  private ungroup: any = false;

  constructor(session: Session, domainLayer: DomainLayer, alignType: string) {
    this.session = session;
    this.alignType = alignType;
    this.selectedLayers = [...session.getLayersFromSelectedLayerCollection()];

    this.selectedLayers.forEach((selectedLayer: DomainLayer) => {
      let layerPath = selectedLayer.getFullPath();
      this.selectedLayersPaths.push(layerPath);
      this.oldStyles[layerPath] = selectedLayer.props.style.toJS();
      this.oldCenterTemplate[layerPath] = selectedLayer.template.toJS();
      selectedLayer.children.forEach((selectedLayerChild: DomainLayer) => {
        if (selectedLayerChild.props && selectedLayerChild.props.style) {
          layerPath = selectedLayerChild.getFullPath();
          this.oldStyles[layerPath] = selectedLayerChild.props.style.toJS();
          this.oldCenterTemplate[
            layerPath
          ] = selectedLayerChild.template.toJS();
        }
      });
    });

    this.domainLayerPath = domainLayer.getPath(undefined, true);
  }

  execute() {
    this.alignSelectedElements(
      this.alignType,
      this.domainLayerPath,
      this.selectedLayersPaths
    );
    this.session.drivers.analyticsService.addActivity(
      {
        name: `align.selected.layers`,
        path: "",
        category: "app/command"
      },
      true
    );
  }
  undo() {
    this.session.drivers.analyticsService.addActivity(
      {
        name: `undo.align.selected.layers`,
        path: "",
        category: "app/command"
      },
      true
    );

    if (
      this.alignType === "distribute-horizontal" ||
      this.alignType === "distribute-vertical"
    ) {
      ChangeToAbsolute(this.session, this.wrapperLayerPath, this.ungroup);
    }
    this.selectedLayersPaths.forEach(layerPath => {
      ResetStyleService(this.session, layerPath);
      SetAllStyleService(this.session, layerPath, this.oldStyles[layerPath]);
      if (this.oldCenterTemplate[layerPath]) {
        SetCenterWrapperMutator(this.session, layerPath, {
          vertical: this.oldCenterTemplate[layerPath].centerVertical,
          horizontal: this.oldCenterTemplate[layerPath].centerHorizontal
        });
      }
      const selectedLayer = this.session.getLayerFromLayerPath(layerPath);
      if (selectedLayer) {
        selectedLayer.children.forEach((selectedLayerChild: DomainLayer) => {
          if (selectedLayerChild.props && selectedLayerChild.props.style) {
            const childPath = selectedLayerChild.getFullPath();
            ResetStyleService(this.session, childPath);
            SetAllStyleService(
              this.session,
              childPath,
              this.oldStyles[childPath]
            );
            if (this.oldCenterTemplate[childPath]) {
              SetCenterWrapperMutator(this.session, childPath, {
                vertical: this.oldCenterTemplate[childPath].centerVertical,
                horizontal: this.oldCenterTemplate[childPath].centerHorizontal
              });
            }
          }
        });
      }
    });
  }
  redo() {
    this.session.drivers.analyticsService.addActivity(
      {
        name: `redo.align.selected.layers`,
        path: "",
        category: "app/command"
      },
      true
    );
    this.alignSelectedElements(
      this.alignType,
      this.domainLayerPath,
      this.selectedLayersPaths
    );
  }

  private alignSelectedElements(
    position: string,
    lastSelectedLayerPath: string,
    selectedLayersPath: Array<string>
  ) {
    const lastSelectedLayer = this.session.getLayerFromLayerPath(
      lastSelectedLayerPath
    );
    let selectedLayers: any[] = [];

    forEach(selectedLayersPath, layerPath => {
      selectedLayers.push(this.session.getLayerFromLayerPath(layerPath));
    });

    const parentLayer = lastSelectedLayer.parent as Layer;
    const parentElementType =
      parentLayer && parentLayer.getLayerElementType
        ? parentLayer.getLayerElementType()
        : undefined;
    if (parentElementType === "flex") {
      this.alignByFlex(position, selectedLayers);
    } else {
      this.alignByPosition(position, selectedLayers);
    }
  }

  private getWrapperLayer() {
    if (this.selectedLayersPaths.length === 1) {
      this.ungroup = false;
      this.wrapperLayerPath = this.selectedLayersPaths[0];
      return this.session.getLayerFromLayerPath(this.selectedLayersPaths[0]);
    }

    this.ungroup = true;
    const wrapperLayer = CreateGroupService(
      this.session,
      this.selectedLayersPaths
    );

    // let wrappedParent: DomainLayer = get(this.selectedLayers, "0.parent");

    this.wrapperLayerPath = wrapperLayer.getFullPath();
    return wrapperLayer;
  }

  private alignByFlex = (position: string, selectedLayers: Array<Layer>) => {
    switch (position) {
      case "align-left":
        selectedLayers.forEach(layer => {
          SetStyleAttributeMutator(
            this.session,
            layer.getFullPath(),
            "alignSelf",
            "flex-start"
          );
        });
        break;
      case "align-horizontally-center":
        selectedLayers.forEach(layer => {
          SetStyleAttributeMutator(
            this.session,
            layer.getFullPath(),
            "alignSelf",
            "center"
          );
        });
        break;
      case "align-right":
        selectedLayers.forEach(layer => {
          SetStyleAttributeMutator(
            this.session,
            layer.getFullPath(),
            "alignSelf",
            "flex-end"
          );
        });
        break;
      case "align-top":
        selectedLayers.forEach(layer => {
          SetStyleAttributeMutator(
            this.session,
            layer.getFullPath(),
            "alignSelf",
            "flex-start"
          );
        });
        break;
      case "align-vertically-center":
        selectedLayers.forEach(layer => {
          SetStyleAttributeMutator(
            this.session,
            layer.getFullPath(),
            "alignSelf",
            "center"
          );
        });
        break;
      case "align-bottom":
        selectedLayers.forEach(layer => {
          SetStyleAttributeMutator(
            this.session,
            layer.getFullPath(),
            "alignSelf",
            "flex-end"
          );
        });
        break;
      case "distribute-horizontal":
        this.distributeHorizontal();
        break;
      case "distribute-vertical":
        this.distributeVertical();
        break;
      case "stack-horizontal":
        this.distributeHorizontal(true);

        break;
      case "stack-vertical":
        this.distributeVertical(true);
        break;
      default:
        break;
    }
  };
  private distributeHorizontal = (stack?: boolean) => {
    let wrapperLayer = this.getWrapperLayer();
    SetStyleAttributeMutator(
      this.session,
      wrapperLayer.getFullPath(),
      "flexDirection",
      "row"
    );

    if (stack) {
      RemoveStyleAttributeMutator(
        this.session,
        wrapperLayer.getFullPath(),
        "justifyContent"
      );
    } else {
      SetStyleAttributeMutator(
        this.session,
        wrapperLayer.getFullPath(),
        "justifyContent",
        "space-between"
      );
    }

    ChangeToFlexService(this.session, wrapperLayer.getFullPath());
    SelectLayersService(this.session, [wrapperLayer.getFullPath()]);
  };

  private distributeVertical = (stack?: boolean) => {
    let wrapperLayer = this.getWrapperLayer();
    SetStyleAttributeMutator(
      this.session,
      wrapperLayer.getFullPath(),
      "flexDirection",
      "column"
    );

    if (stack) {
      RemoveStyleAttributeMutator(
        this.session,
        wrapperLayer.getFullPath(),
        "justifyContent"
      );
    } else {
      SetStyleAttributeMutator(
        this.session,
        wrapperLayer.getFullPath(),
        "justifyContent",
        "space-between"
      );
    }

    ChangeToFlexService(this.session, wrapperLayer.getFullPath());

    SelectLayersService(this.session, [wrapperLayer.getFullPath()]);
  };

  private alignByPosition = (
    position: string,
    selectedLayers: Array<Layer>
  ) => {
    const isMultiple = selectedLayers.length > 1;
    let boundingBox = this.session.getBoundingBox(selectedLayers);
    const domainFile = selectedLayers[0].getFile();
    if (!domainFile) {
      return;
    }

    const parentElement = selectedLayers[0].parent as Layer;
    const minXLayer = minBy(selectedLayers, (layer: DomainLayer) => {
      const canvasLayer = this.session.executeFunction(
        "getOwnCanvasRef",
        layer,
        this.session.currentStage.canvas
      );
      return canvasLayer.getBoundingClientRect().x;
    });
    const maxXLayer = maxBy(selectedLayers, (layer: DomainLayer) => {
      const canvasLayer = this.session.executeFunction(
        "getOwnCanvasRef",
        layer,
        this.session.currentStage.canvas
      );

      return (
        canvasLayer.getBoundingClientRect().x +
        canvasLayer.getBoundingClientRect().width
      );
    });
    const minYLayer = minBy(selectedLayers, (layer: DomainLayer) => {
      const canvasLayer = this.session.executeFunction(
        "getOwnCanvasRef",
        layer,
        this.session.currentStage.canvas
      );
      return canvasLayer.getBoundingClientRect().y;
    });
    const maxYLayer = maxBy(selectedLayers, (layer: DomainLayer) => {
      const canvasLayer = this.session.executeFunction(
        "getOwnCanvasRef",
        layer,
        this.session.currentStage.canvas
      );
      return (
        canvasLayer.getBoundingClientRect().y +
        canvasLayer.getBoundingClientRect().height
      );
    });
    let minX: any;
    let minY: any;
    let maxX: any;
    let maxY: any;

    if (minXLayer) {
      const minXCanvasLayer = this.session.executeFunction(
        "getOwnCanvasRef",
        minXLayer,
        this.session.currentStage.canvas
      );
      minX = minXCanvasLayer.getBoundingClientRect().x;
    } else {
      minX = boundingBox.x;
    }
    if (minYLayer) {
      const minYCanvasLayer = this.session.executeFunction(
        "getOwnCanvasRef",
        minYLayer,
        this.session.currentStage.canvas
      );
      minY = minYCanvasLayer.getBoundingClientRect().y;
    } else {
      minY = boundingBox.y;
    }
    if (maxXLayer) {
      const maxXCanvasLayer = this.session.executeFunction(
        "getOwnCanvasRef",
        minYLayer,
        this.session.currentStage.canvas
      );

      maxX =
        maxXCanvasLayer.getBoundingClientRect().x +
        maxXCanvasLayer.getBoundingClientRect().width;
    } else {
      maxX = boundingBox.width;
    }
    if (maxYLayer) {
      const maxYCanvasLayer = this.session.executeFunction(
        "getOwnCanvasRef",
        minYLayer,
        this.session.currentStage.canvas
      );

      maxY =
        maxYCanvasLayer.getBoundingClientRect().y +
        maxYCanvasLayer.getBoundingClientRect().height;
    } else {
      maxY = boundingBox.height;
    }
    switch (position) {
      case "align-left":
        this.selectedLayersPaths.forEach((layerPath, index: number) => {
          const layer = this.session.getLayerFromLayerPath(layerPath);
          if (!layer) {
            return;
          }
          SetCenterWrapperMutator(this.session, layerPath, {
            vertical: layer.template.centerVertical,
            horizontal: false
          });

          const parentCompiledLayer = layer.parent.getOwnCanvasRef();
          const parentRenderCompiledLayer = parentCompiledLayer.getBoundingClientRect();
          const compiledLayer = layer.getOwnCanvasRef();
          const leftOffset = isMultiple ? minX : 0;
          const width = compiledLayer.getBoundingClientRect().width;
          const y = compiledLayer.getBoundingClientRect().y;
          SetStyleAttributeMutator(
            this.session,
            layer.getFullPath(),
            "left",
            leftOffset
          );

          let originalWidth = layer.props.getResolvedStyleAttribute("width");
          if (!isNil(originalWidth)) {
            RemoveStyleAttributeMutator(
              this.session,
              layer.getFullPath(),
              "right"
            );
          }

          SetLayerDimensionsService(this.session, layerPath, {
            x: leftOffset,
            y,
            width: width,
            height: compiledLayer.getBoundingClientRect().height,
            rotation: compiledLayer.getBoundingClientRect().rotation
          });
        });
        break;
      case "align-horizontally-center":
        if (this.selectedLayersPaths.length === 1) {
          const layer: Layer = this.session.getLayerFromLayerPath(
            this.selectedLayersPaths[0]
          );

          if (!layer) {
            return;
          }

          const compiledLayer = layer.getOwnCanvasRef();
          const width = compiledLayer.getBoundingClientRect().width;
          const parentCompiledLayer = parentElement.getOwnCanvasRef();
          const leftOffset =
            (parentCompiledLayer.getBoundingClientRect().width - width) / 2;
          const recordingCondition = this.session.getRecordingConditions();
          const abstractedTargetLayer = layer.getAbstractedLayer();

          if (
            layer.isWidthFill ||
            size(recordingCondition) > 0 ||
            Utils.shouldIgnoreLayer(abstractedTargetLayer.type)
          ) {
            const layout = compiledLayer.convertLayerDimensions({
              x: leftOffset,
              y: compiledLayer.getBoundingClientRect().y,
              width: width,
              height: compiledLayer.getBoundingClientRect().height,
              rotation: compiledLayer.getBoundingClientRect().rotation
            });

            SetAllStyleService(this.session, layer.getFullPath(), {
              ...layout
            });
          } else {
            if (layer && layer.template && !layer.template.centerHorizontal) {
              SetCenterWrapperMutator(
                this.session,
                this.selectedLayersPaths[0],
                {
                  vertical: layer.template.centerVertical,
                  horizontal: true
                }
              );
            }
          }
        } else {
          this.selectedLayersPaths.forEach(layerPath => {
            const selectedLayer = this.session.getLayerFromLayerPath(layerPath);
            SetCenterWrapperMutator(this.session, layerPath, {
              vertical: false,
              horizontal: false
            });

            const compiledLayer = selectedLayer.getOwnCanvasRef();

            const renderCompiledLayer = compiledLayer.getBoundingClientRect();

            const parentCompiledLayer = selectedLayer.parent.getOwnCanvasRef();
            const parentRenderCompiledLayer = parentCompiledLayer.getBoundingClientRect();

            if (renderCompiledLayer && parentRenderCompiledLayer) {
              const newX =
                boundingBox.x +
                (boundingBox.width - renderCompiledLayer.width) / 2;

              SetLayerDimensionsService(this.session, layerPath, {
                x: newX,
                y: renderCompiledLayer.y,
                width: renderCompiledLayer.width,
                height: renderCompiledLayer.height,
                rotation: renderCompiledLayer.rotation
              });
            }
          });
        }

        break;
      case "align-right":
        this.selectedLayersPaths.forEach((layerPath, index: number) => {
          const layer = this.session.getLayerFromLayerPath(layerPath);

          if (!layer) {
            return;
          }

          const compiledLayer = this.session.executeFunction(
            "getOwnCanvasRef",
            layer,
            this.session.currentStage.canvas
          );
          const y = compiledLayer.getBoundingClientRect().y;
          SetCenterWrapperMutator(this.session, this.domainLayerPath, {
            vertical: layer.template.centerVertical,
            horizontal: false
          });
          SetStyleAttributeMutator(
            this.session,
            layer.getFullPath(),
            "right",
            0
          );

          const width = compiledLayer.getBoundingClientRect().width;
          let originalWidth = layer.props.getResolvedStyleAttribute("width");
          if (!isNil(originalWidth)) {
            RemoveStyleAttributeMutator(
              this.session,
              layer.getFullPath(),
              "left"
            );
          }

          const parentCompiledLayer = this.session.executeFunction(
            "getOwnCanvasRef",
            layer.parent,
            this.session.currentStage.canvas
          );
          const parentRenderCompiledLayer = parentCompiledLayer.getBoundingClientRect();
          const leftOffset = isMultiple
            ? minX + (maxX - minX - width)
            : parentRenderCompiledLayer.width - width;

          SetLayerDimensionsService(this.session, layerPath, {
            x: leftOffset,
            width: width,
            y,
            height: compiledLayer.getBoundingClientRect().height,
            rotation: compiledLayer.getBoundingClientRect().rotation
          });
        });
        break;
      case "align-top":
        this.selectedLayersPaths.forEach((layerPath, index: number) => {
          const layer = this.session.getLayerFromLayerPath(layerPath);

          if (!layer) {
            return;
          }
          var layerObjT = layer;

          const compiledLayer = this.session.executeFunction(
            "getOwnCanvasRef",
            layerObjT,
            this.session.currentStage.canvas
          );
          const parentCompiledLayer = this.session.executeFunction(
            "getOwnCanvasRef",
            layer.parent,
            this.session.currentStage.canvas
          );

          const parentRenderCompiledLayer = parentCompiledLayer.getBoundingClientRect();
          const topOffset = isMultiple ? minY : 0;
          let newHeight = compiledLayer.getBoundingClientRect().height;
          const x = compiledLayer.getBoundingClientRect().x;
          SetCenterWrapperMutator(this.session, this.domainLayerPath, {
            horizontal: layer.template.centerHorizontal,
            vertical: false
          });

          SetStyleAttributeMutator(
            this.session,
            layer.getFullPath(),
            "top",
            topOffset
          );

          let originalHeight = layer.props.getResolvedStyleAttribute("height");
          if (!isNil(originalHeight)) {
            RemoveStyleAttributeMutator(
              this.session,
              layer.getFullPath(),
              "bottom"
            );
          }

          if (!layerObjT) {
            return;
          }

          SetLayerDimensionsService(this.session, layerPath, {
            y: topOffset,
            x: x,
            height: newHeight,
            width: compiledLayer.getBoundingClientRect().width,
            rotation: compiledLayer.getBoundingClientRect().rotation
          });
        });
        break;
      case "align-vertically-center":
        if (this.selectedLayersPaths.length === 1) {
          const layer: Layer = this.session.getLayerFromLayerPath(
            this.selectedLayersPaths[0]
          );

          if (!layer) {
            return;
          }

          const compiledLayer = layer.getOwnCanvasRef();

          const height = compiledLayer.getBoundingClientRect().height;

          const parentCompiledLayer = parentElement.getOwnCanvasRef();

          const topOffset =
            (parentCompiledLayer.getBoundingClientRect().height - height) / 2;
          const recordingCondition = this.session.getRecordingConditions();
          const abstractedTargetLayer = layer.getAbstractedLayer();

          if (
            layer.isHeightFill ||
            size(recordingCondition) > 0 ||
            Utils.shouldIgnoreLayer(abstractedTargetLayer.type)
          ) {
            SetLayerDimensionsService(this.session, layer.getFullPath(), {
              y: topOffset,
              x: compiledLayer.getBoundingClientRect().x,
              width: compiledLayer.getBoundingClientRect().width,
              height: height,
              rotation: compiledLayer.getBoundingClientRect().rotation
            });
          } else {
            if (layer && layer.template && !layer.template.centerVertical) {
              SetCenterWrapperMutator(this.session, this.domainLayerPath, {
                horizontal: layer.template.centerHorizontal,
                vertical: true
              });
            }
          }
        } else {
          this.selectedLayersPaths.forEach(layerPath => {
            const layer = this.session.getLayerFromLayerPath(layerPath);

            SetCenterWrapperMutator(this.session, layerPath, {
              vertical: false,
              horizontal: false
            });

            const compiledLayer = this.session.executeFunction(
              "getOwnCanvasRef",
              layer,
              this.session.currentStage.canvas
            );

            const renderCompiledLayer = compiledLayer.getBoundingClientRect();

            const parentCompiledLayer = this.session.executeFunction(
              "getOwnCanvasRef",
              layer.parent,
              this.session.currentStage.canvas
            );

            const parentRenderCompiledLayer = parentCompiledLayer.getBoundingClientRect();

            if (renderCompiledLayer && parentRenderCompiledLayer) {
              const newY =
                boundingBox.y +
                (boundingBox.height - renderCompiledLayer.height) / 2;

              SetLayerDimensionsService(this.session, layer.getFullPath(), {
                x: renderCompiledLayer.x,
                y: newY,
                width: renderCompiledLayer.width,
                height: renderCompiledLayer.height,
                rotation: renderCompiledLayer.rotation
              });
            }
          });
        }
        break;
      case "align-bottom":
        this.selectedLayersPaths.forEach((layerPath, index: number) => {
          const layer = this.session.getLayerFromLayerPath(layerPath);

          if (!layer) {
            return;
          }
          var layerObjB = layer;

          const compiledLayer = this.session.executeFunction(
            "getOwnCanvasRef",
            layerObjB,
            this.session.currentStage.canvas
          );
          const x = compiledLayer.getBoundingClientRect().x;
          const height = compiledLayer.getBoundingClientRect().height;
          SetCenterWrapperMutator(this.session, this.domainLayerPath, {
            horizontal: layer.template.centerHorizontal,
            vertical: false
          });

          SetStyleAttributeMutator(
            this.session,
            layer.getFullPath(),
            "bottom",
            0
          );

          let originalHeight = layer.props.getResolvedStyleAttribute("height");
          if (!isNil(originalHeight)) {
            RemoveStyleAttributeMutator(
              this.session,
              layer.getFullPath(),
              "top"
            );
          }

          const parentCompiledLayer = this.session.executeFunction(
            "getOwnCanvasRef",
            layer.parent,
            this.session.currentStage.canvas
          );
          const parentRenderCompiledLayer = parentCompiledLayer.getBoundingClientRect();
          const topOffset = isMultiple
            ? minY + (maxY - minY - height)
            : parentCompiledLayer.getBoundingClientRect().height - height;
          SetLayerDimensionsService(this.session, layerObjB.getFullPath(), {
            y: topOffset,
            height: height,
            x,
            width: compiledLayer.getBoundingClientRect().width,
            rotation: compiledLayer.getBoundingClientRect().rotation
          });
        });
        break;

      case "distribute-horizontal":
        this.distributeHorizontal();
        break;
      case "distribute-vertical":
        this.distributeVertical();
        break;

      case "stack-horizontal":
        this.distributeHorizontal(true);

        break;
      case "stack-vertical":
        this.distributeVertical(true);
        break;
      default:
        break;
    }

    selectedLayers.forEach((layer, index: number) => {
      // layer.ui.setResizingType(layer.props.style.toJS());
      SetResizingTypeMutator(
        this.session,
        layer.getFullPath(),
        layer.props.style.toJS()
      );
      layer.ui.emit("resizingType");
    });
  };
}
