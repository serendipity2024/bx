import { ICommand } from "command-manager";
import { Session } from "session";
import * as JSZip from "jszip";
import * as pathUtil from "path";
import { File as DomainFile } from "domain-x";
import { saveAs } from "utils";
import { isNil, forEach, find } from "lodash";
import FindExternalReferencesInFile from "../CommandServices/FindExtenalReferencesInFIle";
import { BX_PREVIEW_FILE_PATH, ExpoFiles, CRAFiles } from "bx-constants";
// import { NotifySuccess } from "..";
import { AddFontAndImageFiles } from "../CommandServices/AddFontAndImageFiles";
import { DownloadReadmeDialog } from "dialog-x";
import notifySuccessService from "../CommandServices/NotifySuccess";
import NotifyError from "../CommandServices/NotifyError";

export default class ExportLayers implements ICommand {
  private session: Session;
  private file: DomainFile;
  private previewFilePath: string;
  displayName: string = "ExportLayers";
  constructor(session: Session, file: DomainFile) {
    this.session = session;
    this.file = file;
    this.previewFilePath = file.path;
  }
  async execute() {
    if (!this.file) {
      const previewFile: any = this.session.domain.files.get(
        BX_PREVIEW_FILE_PATH
      );
      if (!previewFile) {
        return;
      }
      this.file = previewFile;
      this.previewFilePath = previewFile.path;
    }
    const references = FindExternalReferencesInFile(this.session, this.file);
    references.push({
      type: "file",
      path: this.previewFilePath
    });

    if (references) {
      await this.zipFiles(references);
    }
    this.session.drivers.analyticsService.addActivity(
      {
        name: `export.layer`,
        category: "app/command"
      },
      true
    );
  }
  undo() {
    //
  }
  redo() {
    //
  }

  async zipFiles(references: any[]) {
    // return new Promise((resolve, reject) => {

    // })
    const promises: any = [];
    var zip = new JSZip().folder("Component");

    const originalFunction = zip.file;
    zip.file = (...args: any[]) => {
      // args[0] = args[0].replace(/[\/\*\|\:\<\>\?\"\\]/gi, "_");
      args[0] = args[0].replace(/^\//, "");

      return originalFunction.apply(zip, args);
    };

    references.forEach(async (reference: { type: string; path: string }) => {
      const promise = new Promise(async (resolve, reject) => {
        if (reference.type === "file") {
          let filePath: any = reference.path;
          const file = this.session.domain.files.get(filePath);
          if (file) {
            if (this.previewFilePath === BX_PREVIEW_FILE_PATH) {
              filePath =
                filePath === BX_PREVIEW_FILE_PATH ? "/index.js" : filePath;
              filePath = filePath.replace("/src/", "/");
            }
            let newContent = await this.session.getFileCode(file);
            if (!isNil(newContent)) {
              filePath = filePath.replace("/symbols/", "/components/");
              if (this.session.codeEngineName === "flutter") {
                zip.file(filePath.replace(".js", ".dart"), newContent);
              } else {
                zip.file(filePath, newContent);
              }
            }
            resolve();
          } else {
            resolve();
          }
        } else {
          resolve();
        }
      });
      promises.push(promise);
    });
    try {
      await Promise.all(promises);
    } catch (err) {
      console.error(err);
    }

    if (this.previewFilePath !== BX_PREVIEW_FILE_PATH) {
      const fileName = pathUtil.basename(
        this.previewFilePath,
        pathUtil.extname(this.previewFilePath)
      );
      zip.file(
        "/index.js",
        `export { default as ${fileName} } from ".${this.previewFilePath}";`
      );
    }

    if (this.session.envConfig.env === "development") {
      let assets: string[] = [];
      // references.forEach((reference: { type: string; path: string }) => {
      //   if (reference.type === "font") {
      //     this.session.assetsMap.forEach((value: any, key: string) => {
      //       const name = pathUtil.basename(key, pathUtil.extname(key));
      //       if (name === reference.path) {
      //         if (this.previewFilePath === BX_PREVIEW_FILE_PATH) {
      //           key = key.replace("/src/", "/");
      //         }
      //         assets.push(key);
      //       }
      //     });
      //   }
      // });
      const response: any = await this.session.codeEngine.executeCommand(
        "getIndexWithFont",
        [assets]
      );
      forEach(response, (file: any) => {
        zip.file(file.path, file.content);
      });
    }

    const codeEngine = this.session.selectedCodeEngine;

    if (!codeEngine) {
      this.session.notificationManager.notifyError(
        "Error occured",
        "No code engine found"
      );
      return;
    }

    zip.file("/README.md", codeEngine.getFiles().componentReadme);

    await AddFontAndImageFiles(
      this.session,
      references,
      zip,
      this.previewFilePath
    );

    zip.generateAsync({ type: "blob" }).then((content: any) => {
      saveAs(content, "Component.zip");

      // this.session.commandManager.executeAndSkip(
      notifySuccessService(
        this.session,
        "Component exported successfully",
        `You might need to add some external packages to run component. Please refer README.md file for reference.`
      );
      // );
      DownloadReadmeDialog(this.session.codeEngineName, "component");
    });
  }
}
