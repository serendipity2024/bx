import { ICommand } from "command-manager";
import { Session } from "session";
import * as JSZip from "jszip";
import * as pathUtils from "path";
import { saveAs } from "utils";
import urljoin from "url-join";
import { BX_PREVIEW_FILE_PATH } from "bx-constants";
import { File as DomainFile, Layer } from "domain-x";
import { GenerateGradient } from "../CommandServices/GenerateGradient";
import { ExpoFiles, CRAFiles } from "bx-constants";
import { ProgressIndicatorDialog, DownloadReadmeDialog } from "dialog-x";
import { forEach, get } from "lodash";
import FindExternalReferencesInFile from "../CommandServices/FindExtenalReferencesInFIle";
import { AddFontAndImageFiles } from "../CommandServices/AddFontAndImageFiles";
// import { NotifyError } from "..";
import notifyErrorService from "../CommandServices/NotifyError";
import notifySuccessService from "../CommandServices/NotifySuccess";
import { ICodeEngine } from "common-interfaces";

export default class DownloadProject implements ICommand {
  private session: Session;
  displayName: string = "DownloadProject";
  constructor(session: Session) {
    this.session = session;
  }
  execute() {
    ProgressIndicatorDialog(
      "Downloading Project",
      "Please wait while we are downloading the files",
      2
    );
    const hideLoader = () => {
      ProgressIndicatorDialog(
        "Downloading Project",
        "Please wait while we are downloading the files",
        5,
        false,
        true
      );
    };

    const downloadError = (err: Error) => {
      hideLoader();
      this.session.captureErrorForSentry(err);
      notifyErrorService(
        this.session,
        "Project download error",
        `Oops! There was some error while downloading the project.
    Please contact support@builderx.io if this keeps happening.`
      );
    };
    var zip = new JSZip().folder(this.session.project.projectName || "Project");
    const originalFunction = zip.file;
    zip.file = (...args: any[]) => {
      // args[0] = args[0].replace(/[\/\*\|\:\<\>\?\"\\]/gi, "_");
      args[0] = args[0].replace(/^\//, "");

      return originalFunction.apply(zip, args);
    };
    let promises: any[] = [];
    const allReferences: any[] = [];

    this.session.domain.files.forEach((file: DomainFile, path) => {
      if (file.isArtboard() && file.path !== BX_PREVIEW_FILE_PATH) {
        const compiledFile = file.getOwnCanvasRef();
        if (compiledFile) {
          compiledFile.setChildrenLayout(compiledFile);
        }
        file.setCalculatedDims(true);
      }
    });

    this.session.domain.files.forEach((file: DomainFile, path) => {
      if (file.isSymbol() && file.path !== BX_PREVIEW_FILE_PATH) {
        const compiledFile = file.getOwnCanvasRef();
        if (compiledFile) {
          compiledFile.setChildrenLayout(compiledFile);
        }
        file.setCalculatedDims(true);
      }
    });
    this.session.domain.files.forEach((file: DomainFile, path) => {
      path = path.replace("/symbols/", "/components/");
      const references = FindExternalReferencesInFile(this.session, file);
      allReferences.push(...references);
      const promise = new Promise(async (resolve, reject) => {
        let content = await this.session.getFileCode(file);
        zip.file(path, content);

        try {
          await ProcessGradients(this.session, file, zip);
          await AddFontAndImageFiles(this.session, references, zip, path);
        } catch (err) {
          reject(err);
        }
        resolve(true);
        // .then(() => {
        //   resolve(true);
        // })
        // .catch(() => {
        //   resolve(true);
        // });
      });
      promises.push(promise);
    });

    this.session.assetsMap.forEach((asset, key: string) => {
      const promise = new Promise((resolve, reject) => {
        this.fetchBlobFile(asset.file)
          .then((file: any) => {
            if (file) {
              zip.file(key, file);
            }
            resolve(true);
          })
          .catch(err => {
            reject(err);
          });
      });
      promises.push(promise);
    });
    Promise.all(promises)
      .then(() => {
        const codeEngine = this.session.selectedCodeEngine;

        if (!codeEngine) {
          this.session.notificationManager.notifyError(
            "Error occured",
            "No code engine found"
          );
          return;
        }

        this.writeFiles(zip, codeEngine);

        // codeEngine.writeFiles(zip);
        // if (this.session.codeEngineName === "react-native") {
        //   this.writeExpoFiles(zip, codeEngine);
        // } else if (this.session.codeEngineName === "react") {
        // } else if (this.session.codeEngineName === "flutter") {
        //   // TODO: flutter project files
        // }
        const files = this.session.getAllFileNames();
        let assets: string[] = [];
        let missingAssets: any[] = [];
        this.session.assetsMap.forEach((value: any, key: string) => {
          if (
            key.indexOf("fonts") !== -1 ||
            key.endsWith(".ttf") ||
            key.endsWith(".otf")
          ) {
            if (value.missing) {
              missingAssets.push(value);
            } else {
              assets.push(key);
            }
          }
        });

        const response = this.session.codeEngine.executeCommand("getAppFiles", [
          { artboards: files.artboards, assets, missingAssets }
        ]);

        if (response) {
          response
            .then((appFiles: { path: string; content: string }[]) => {
              forEach(
                appFiles,
                async (appFile: { path: string; content: string }) => {
                  zip.file(appFile.path, appFile.content);
                }
              );

              zip
                .generateAsync({ type: "blob" })
                .then((content: any) => {
                  hideLoader();
                  saveAs(
                    content,
                    `${this.session.project.projectName || "Project"}.zip`
                  );

                  notifySuccessService(
                    this.session,
                    "Project downloaded successfully",
                    missingAssets.length === 0
                      ? "Please refer README.md file to run the project"
                      : `Some fonts couldn't be found on your system.
            To know more, click ⚠️ icon next to project name. Please refer README.md file to run the project.`
                  );
                  // this.session.commandManager.executeAndSkip(
                  //   new NotifySuccess(
                  //     this.session,
                  //     missingAssets.length === 0
                  //       ? "Please refer README.md file to run the project"
                  //       : `Some fonts couldn't be found on your system.
                  // To know more, click ⚠️ icon next to project name. Please refer README.md file to run the project.`,
                  //     "Project downloaded successfully"
                  //   )
                  // );
                  DownloadReadmeDialog(this.session.codeEngineName, "project");
                })
                .catch(err => {
                  downloadError(err);
                });
            })
            .catch(err => {
              downloadError(err);
            });
        }
      })
      .catch(err => {
        downloadError(err);
      });

    this.session.drivers.analyticsService.addActivity(
      {
        name: `download.project`,
        category: "app/command"
      },
      true
    );
  }
  async fetchBlobFile(asset: { path: string; blob: any }) {
    try {
      let fileBlob = asset.blob;
      const fileURL = urljoin(
        this.session.envConstants.BACKEND_API_URL,
        "get-files-content",
        `${this.session.project.projectId}?fileName=${asset.path}`
      );
      if (!fileBlob) {
        // fileBlob = await this.session.apiSdk.raw.getBlob(fileURL, {
        //   responseType: "blob"
        // });
        // fileBlob = fileBlob.data;
      }
      var file = new File([fileBlob], pathUtils.basename(fileURL), {
        type: fileBlob.type
      });

      return file;
    } catch (err) {
      console.log(err, "fetchBlobFile", asset.path);
      return undefined;
    }
  }

  undo() {
    //
  }
  redo() {
    //
  }

  writeFiles(zip: JSZip, codeEngine: ICodeEngine) {
    const files = codeEngine.getFilesToWrite();
    files.forEach((file: any, path: any) => {
      zip.file(path, file.content, file.config);
    });
  }
}

async function ProcessGradients(
  session: Session,
  file: DomainFile,
  zip: JSZip
) {
  return new Promise((resolve: any, reject: any) => {
    let promises: any = [];
    file.layer.traverseLayers(async (domainLayer: Layer) => {
      if (
        domainLayer.type === "view" &&
        domainLayer.props.getResolvedStyleAttribute("gradient")
      ) {
        const promise = new Promise((resolveNested: any, rejectNested: any) => {
          GenerateGradient(session, domainLayer)
            .then((response: any) => {
              if (typeof response === "object") {
                zip.file(response.path, response.gradientBlob);
                resolveNested(true);
              } else {
                rejectNested("Unable to generate gradient image");
              }
            })
            .catch((err: any) => {
              rejectNested(err);
            });
        });
        promises.push(promise);
      }
    });

    Promise.all(promises)
      .then((response: any) => {
        resolve(true);
      })
      .catch((err: any) => {
        reject(err);
      });
  });
}
