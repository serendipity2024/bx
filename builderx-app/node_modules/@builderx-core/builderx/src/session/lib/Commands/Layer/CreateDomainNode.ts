import { ICommand } from "command-manager";
import { Session } from "../../models/Session";
import { Expression, LiteralNode } from "domain-x";
import { set, forEach, get } from "lodash";
import { ExpressionStatement } from "domain-x";
import CreateBinaryExpression from "./CreateBinaryExpression";
import CreateExpressionNode from "./CreateExpressionNode";
import CreateLogicalExpression from "./CreateLogicalExpression";
import { ResolveNode, ResolveNodeValue } from "utils";
import CreateConditionalExpression from "./CreateConditionalExpression";
import CreateExpressionStatementNode from "./CreateExpressionStatementNode";
import CreateLiteralNode from "./CreateLiteralNode";

export default class CreateDomainNode implements ICommand {
  displayName = "CreateDomainNode";
  private session: Session;
  private JSON: any;
  private parent: any;
  private key: string;
  private property?: string;
  private resolveDomainCompile: boolean;
  private replace: boolean;
  constructor(
    session: Session,
    parent: any,
    key: string,
    JSON: any,
    property?: string,
    resolveDomainCompile: boolean = true,
    replace: boolean = false
  ) {
    this.session = session;
    this.JSON = JSON;
    this.parent = parent;
    this.key = key;
    this.property = property;
    this.resolveDomainCompile = resolveDomainCompile;
    this.replace = replace;
  }

  execute() {
    const valueType = get(this.JSON, "type", undefined);
    if (valueType === "conditionalExpression") {
      this.session.commandManager.executeAndSkip(
        new CreateConditionalExpression(
          this.session,
          this.parent,
          this.key,
          this.JSON,
          this.property,
          this.resolveDomainCompile,
          this.replace
        )
      );
    } else if (valueType === "expressionStatement") {
      this.session.commandManager.executeAndSkip(
        new CreateExpressionStatementNode(
          this.session,
          this.parent,
          this.key,
          this.JSON,
          this.property,
          this.resolveDomainCompile,
          this.replace
        )
      );
    } else if (valueType === "expression") {
      this.session.commandManager.executeAndSkip(
        new CreateExpressionNode(
          this.session,
          this.parent,
          this.key,
          this.JSON,
          this.property
        )
      );
    } else if (valueType === "literal") {
      this.session.commandManager.executeAndSkip(
        new CreateLiteralNode(this.session, this.parent, this.key, this.JSON)
      );
    } else if (valueType) {
      // const node = DomainLayerFactory.createDomainLayer(this.JSON);
      // set(this.parent, this.key, node);
      // node.parent = this.parent;
      // if (this.JSON.children && this.JSON.children.length > 0) {
      //   forEach(this.JSON.children, (child: any, index: number) => {
      //     this.session.commandManager.executeAndSkip(
      //       new CreateDomainNode(this.session, node, `children.${index}`, child)
      //     );
      //   });
      // }
    }
  }
  undo() {
    //
  }
  redo() {
    //
  }
}
