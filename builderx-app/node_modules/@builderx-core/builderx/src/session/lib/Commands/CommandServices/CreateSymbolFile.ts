import { Session } from "../../models/Session";
import { Layer, DomainLayer } from "domain-x";
import { isNil, cloneDeep, forEach, omit, pick, camelCase, get } from "lodash";
import { CommandManager } from "command-manager";
// import AddSymbolFromJS from "../Symbols/AddSymbolFromJS";
import { ResolveNodeValue, Utils } from "utils";
// import WrapFlexLayers from "../Layer/WrapFlexLayers";
import SymbolInstanceTemplate from "../../componentJSON/SymbolInstance";
// import WrapLayers from "../Layer/WrapLayers";
import wrapLayersService from "../CommandServices/WrapLayers";
import wrapFlexLayersService from "../CommandServices/WrapFlexLayers";
import * as path from "path";
// import SetAllProps from "../Prop/SetAllProps";
import FileTemplate from "../../componentJSON/SymbolFile";
import { SetAllPropsService } from "./SetAllPropsService";
import { AddSymbolFromJsService } from "./AddSymbolFromJsService";
import createService from ".";
import {
  SetCenterWrapperMutator,
  SetStyleAttributeMutator
} from "../../Mutators";
// import RemoveLoop from "../Layer/RemoveLoop";

export const CreateSymbolFile = createService(
  "CreateSymbolFile",
  (
    session: Session,
    domainLayersPath: string[],
    domainParentLayerPath: string,
    symbolFileId: string,
    shouldEmitUpdates: boolean = true,
    isPreviewSymbol: boolean = false
  ) => {
    const fileJSON = cloneDeep(FileTemplate.template);
    let noWrapper: boolean = false;

    let domainLayers: Array<DomainLayer> = [];

    domainLayersPath.forEach(layerPath => {
      domainLayers.push(session.getLayerFromLayerPath(layerPath));
    });

    let domainParentLayer = session.getLayerFromLayerPath(
      domainParentLayerPath
    );
    // get first layer index
    let firstLayerIndex: any = undefined;
    domainLayers.forEach((layer: any) => {
      const index = layer.findIndexInParent();
      if (firstLayerIndex === undefined || firstLayerIndex > index) {
        firstLayerIndex = index;
      }
      return index;
    });
    if (isNil(firstLayerIndex)) {
      return {};
    }
    // decide whether to add wrapper or not
    // decide whether wrapper will be flex or not

    if (domainLayers.length === 1) {
      const layer = domainLayers[0];

      if (
        (layer.type === "view" && get(layer, "props.style").get("gradient")) ||
        (layer.type === "scrollView" && !isPreviewSymbol)
      ) {
        noWrapper = false;
      } else if (
        layer.type === "view" ||
        layer.type === "scrollView" ||
        layer.type === "touchableOpacity" ||
        layer.type === "root"
      ) {
        noWrapper = true;
      } else {
        //
      }

      // fileJSON.layer.props.style.backgroundColor = layer.props.getResolvedStyleAttribute(
      //   "backgroundColor"
      // );
    }
    // if (!noWrapper) {
    if (!isPreviewSymbol) {
      // setAndComputeDescendants(session, [domainParentLayer], () => {
      domainLayers.forEach((layer: Layer) => {
        // removeCenterWrapperService(session, layer);
        SetCenterWrapperMutator(session, layer.getFullPath(), {
          vertical: false,
          horizontal: false
        });
        // commandManager.executeAndSkip(new RemoveLoop(session, layer));
      });
      // });
    }
    // decide whether wrapper is position absolute or not
    let isAbsolute = false;
    domainLayers.forEach((layer: Layer) => {
      if (isAbsolute) {
        return;
      }
      isAbsolute = layer.props.getResolvedStyleAttribute("position")
        ? true
        : false;
    });
    let wrapperLayer: any;

    if (noWrapper) {
      wrapperLayer = domainLayers[0];
      fileJSON.layer.import = wrapperLayer.import.toJS
        ? wrapperLayer.import.toJS()
        : wrapperLayer.import;
    } else if (isAbsolute) {
      wrapperLayer = wrapLayersService(session, domainLayers);
      // commandManager.execute(new WrapLayers(session, domainLayers));
      // wrapperLayer = domainParentLayer.getChildren()[firstLayerIndex];
    } else {
      wrapperLayer = wrapFlexLayersService(session, domainLayers);
      // commandManager.execute(new WrapFlexLayers(session, domainLayers));
      // wrapperLayer = domainParentLayer.getChildren()[firstLayerIndex];
    }
    const boundingBox = session.getBoundingBox([wrapperLayer]);
    let style = fileJSON.props.style;
    style["top"] = boundingBox.y;
    style["left"] = boundingBox.x;
    style["width"] = boundingBox.width;
    style["height"] = boundingBox.height;

    if (symbolFileId) {
      fileJSON.path = symbolFileId;
    } else {
      fileJSON.path = session.getNewFilePath("symbol");
    }
    AddSymbolFromJsService(session, fileJSON);
    const symbolFile = session.domain.files.get(fileJSON.path as any);
    if (!symbolFile) {
      return {};
    }
    let template = cloneDeep(SymbolInstanceTemplate.template);
    template.import.packageName = symbolFile.path;
    template.import.layerName = path.basename(symbolFile.path, ".js");

    template.styleName = camelCase(template.import.layerName);
    template.props.style = {};

    const selectedFileScopeVariables = session.selectedFile
      ? session.selectedFile.scopeVariables
      : {};
    if (!isPreviewSymbol) {
      forEach(wrapperLayer.props.style.toJS(), (value: any, key: string) => {
        if (!Utils.isInvalidKey(key)) {
          // wrapperLayer.props.style.set(
          //   key,
          //   ResolveNodeValue(value, selectedFileScopeVariables)
          // );

          SetStyleAttributeMutator(
            session,
            wrapperLayer.getFullPath(),
            key,
            ResolveNodeValue(value, selectedFileScopeVariables)
          );
        }
      });
    }
    const wrapperLayerProps = wrapperLayer.props.toJS();
    const innerPositionStyleAttrs = [
      "position",
      "top",
      "left",
      "bottom",
      "right",
      "height",
      "width",
      "flex",
      "alignSelf",
      "transform"
    ];
    let outerPositionStyleAttrs = [
      "position",
      "top",
      "left",
      "bottom",
      "right",
      "height",
      "width",
      "flex",
      "alignSelf"
      // "backgroundColor"
    ];

    if (noWrapper) {
      outerPositionStyleAttrs.push("transform");
    }
    const innerStyles: any = omit(
      wrapperLayerProps.style,
      innerPositionStyleAttrs
    );
    const outerStyles: any = pick(
      wrapperLayerProps.style,
      outerPositionStyleAttrs
    );
    template.props.style = outerStyles;
    wrapperLayerProps.style = innerStyles;

    if (isPreviewSymbol) {
      wrapperLayerProps.style.width = boundingBox.width;
      wrapperLayerProps.style.height = boundingBox.height;
    }
    // set symbol root layer flex 1
    // wrapperLayerProps.style.flex = 1;
    // symbolFile.layer.props.setAllProps(wrapperLayerProps);

    SetAllPropsService(
      session,
      symbolFile.layer.getFullPath(),
      wrapperLayerProps
    );

    let symbolInstance;
    if (domainParentLayer.type === "file") {
      symbolInstance = domainParentLayer.layer;
    } else {
      symbolInstance = domainParentLayer.children[firstLayerIndex] as Layer;
    }

    // symbolFile.layer.props.setAllStyle(wrapperLayerProps.style);
    // session.AstModule.setShouldExecuteCommands(true);
    return {
      symbolInstance,
      template,
      wrapperLayer,
      symbolFile,
      noWrapper,
      layerIndex: firstLayerIndex
    };
  }
);
