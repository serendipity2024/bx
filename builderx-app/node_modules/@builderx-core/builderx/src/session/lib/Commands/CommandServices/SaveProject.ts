import { Session } from "../../models/Session";
import { File as DomainFile } from "domain-x";
import { action } from "model";
import { BX_PREVIEW_FILE_PATH } from "bx-constants";
import { forEach } from "lodash";
import createService from ".";
import { SetFileDirtyMutator } from "../../Mutators";
import SetDbFileIdMutator from "../../Mutators/SetDbFileIdMutator";

const SaveProject = createService("SaveProject", (session: Session) => {
  // return new Promise(async (resolve, reject) => {
  //   try {
  //     const isProjectSaved = await saveProj(session);
  //     if (!isProjectSaved) {
  //       resolve(false);
  //     }
  //     if (session.isNewProject) {
  //       session.setIsNewProject(false);
  //     }
  //     resolve(true);
  //   } catch (error) {
  //     console.log(error, "Error in SaveProject");
  //   }
  // });
});
export default SaveProject;
function saveFile(session: Session, file: DomainFile, promises: any) {
  if (file.path === BX_PREVIEW_FILE_PATH) {
    return;
  }
  if (file.isDirty) {
    SetFileDirtyMutator(session, file.path, false);

    promises.push(
      new Promise((resolveSaveFile, rejectSaveFile) => {
        let fileData = file.toJS() as any;
        let savedFile = session.drivers.fileService.writeFile(
          file.path,
          JSON.stringify(fileData),
          session.connectionId
        );
        if (savedFile) {
          savedFile
            .then(result => {
              if (!file.dbFileId && result) {
                SetDbFileIdMutator(session, file.path, result);
              }
              resolveSaveFile(true);
            })
            .catch(err => {
              action(() => {
                SetFileDirtyMutator(session, file.path, false);
              });
              session.notificationManager.notifyError(
                "",
                "Couldn't save " + file.path
              );
              resolveSaveFile(true);
            });
        } else {
          action(() => {
            SetFileDirtyMutator(session, file.path, true);
          });
          session.notificationManager.notifyError(
            "",
            "Couldn't save " + file.path
          );
          resolveSaveFile(true);
        }
      })
    );
  }
}

async function saveProj(session: Session) {
  const filesToBeDeleted = session.fileIdsToBeDeleted;
  forEach(filesToBeDeleted, async (fileId: any, index) => {
    try {
      await session.drivers.fileService.removeFolder(
        fileId,
        session.connectionId
      );
      // session.fileIdsToBeDeleted.splice(index, 1);
      // action(() => {
      //   session.emit("fileIdsToBeDeleted");
      // });
    } catch (err) {
      //
    } finally {
      session.fileIdsToBeDeleted.splice(index, 1);
      action(() => {
        session.emit("fileIdsToBeDeleted");
      });
    }
  });

  return new Promise(async (resolve, reject) => {
    action(async () => {
      const notificationManager = session.notificationManager;
      session.drivers.offScreenRendererService.showOffscreenLoader(
        "Saving Project",
        "Please wait ..."
      );

      var promises: any[] = [];
      session.domain.files.forEach((file: DomainFile) => {
        if (!file.isArtboard()) {
          saveFile(session, file, promises);
        }
      });
      session.domain.files.forEach((file: DomainFile) => {
        if (file.isArtboard()) {
          saveFile(session, file, promises);
        }
      });
      try {
        await Promise.all(promises);
        resolve(true);
      } catch (err) {
        session.drivers.Sentry.captureException(err);
        resolve(false);
      }
    });
  });
}
