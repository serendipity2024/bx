import { Layer, DomainLayer } from "domain-x";
import { Session } from "../../models/Session";
import { ICommand } from "command-manager";
import { forEach, get, map, round } from "lodash";
import {
  computeOrientationWithDeltaMultiple,
  computeOrientationWithDelta,
  ModelUtils
} from "@builderx-core/designer";
import { FixLayer } from "..";
import { SetLayerDimensionsService } from "../CommandServices/SetLayerDimensions";
import { SetAllScopeVariablesService } from "../CommandServices/SetAllScopeVariablesService";

export default class MoveResizeLayer implements ICommand {
  displayName = "MoveResizeLayer";
  session: Session;
  currentLayers: any;
  layoutElementArray: any;
  payload: any;
  context: string;
  handle?: any;
  eventType?: string;
  snapPoints?: any;
  boundingBox?: any;
  isHover?: boolean;
  oldDimensions: {
    x: number;
    y: number;
    width: number;
    height: number;
    rotation: number;
  }[];
  constructor(
    session: Session,
    currentLayers: [DomainLayer],
    layoutElementArray: any,
    payload: any,
    context: string,
    handle?: any,
    eventType?: string,
    snapPoints?: any,
    boundingBox?: any,
    isHover?: boolean
  ) {
    this.session = session;
    this.currentLayers = currentLayers;
    this.layoutElementArray = layoutElementArray;
    this.payload = payload;
    this.handle = handle;
    this.eventType = eventType;
    this.snapPoints = snapPoints;
    this.boundingBox = boundingBox;
    this.context = context;
    this.isHover = isHover;
    this.oldDimensions = map(currentLayers, layer => {
      const oldDims = layer.getBoundingClientRect();

      return {
        x: oldDims.x,
        y: oldDims.y,
        width: oldDims.width,
        height: oldDims.height,
        rotation: oldDims.rotation
      };
    });
  }
  execute() {
    if (this.context === "RightPanelContext") {
      this.executeForRightPanel();
    }
  }
  undo() {
    forEach(this.currentLayers, (layer, index) => {
      SetLayerDimensionsService(
        this.session,
        layer.getFullPath(),
        this.oldDimensions[index]
      );
    });
  }
  redo() {
    if (this.context === "RightPanelContext") {
      this.executeForRightPanel();
    }
  }

  private isFlexChild(currentLayers: any) {
    let isFlexChild = false;
    forEach(currentLayers, currentLayer => {
      if (
        currentLayer.renderCompiledLayer.domainCompiledRef.domainRef.isFlexChild
      ) {
        isFlexChild = true;
      }
    });
    return isFlexChild;
  }

  private dragLayoutIsDoable(handle: string, domainLayer: Layer) {
    const position = domainLayer.props.getResolvedStyleAttribute("position");
    // TODO: implement this condition after symbols are done
    // workspace.persist.domain.isSymbolRootLayer(this.selectedLayers[0]
    return (
      ((handle.indexOf("B") > -1 || handle.indexOf("T") > -1) &&
        position !== "absolute" &&
        domainLayer.isHeightFill) ||
      ((handle.indexOf("L") > -1 || handle.indexOf("R") > -1) &&
        position !== "absolute" &&
        domainLayer.isWidthFill)
    );
  }

  private setFixedLayer(layer: Layer) {
    if (
      ((layer.isFlexChild && layer.isWidthFill) ||
        layer.widthMode === "auto") &&
      get(this.payload, "deltaX", 0) !== 0
    ) {
      this.session.commandManager.execute(
        new FixLayer(this.session, layer, "width")
      );
    }
    if (
      ((layer.isFlexChild && layer.isHeightFill) ||
        layer.heightMode === "auto") &&
      get(this.payload, "deltaY", 0) !== 0
    ) {
      this.session.commandManager.execute(
        new FixLayer(this.session, layer, "height")
      );
    }
  }
  private executeForRightPanel() {
    let { deltaX, deltaY } = this.payload;
    deltaY = Math.round(deltaY);
    deltaX = Math.round(deltaX);
    if (this.currentLayers.length === 1) {
      let rotateDelta = ModelUtils.rotatePoint([deltaX, deltaY], 360, [0, 0]);
      deltaX = rotateDelta[0];
      deltaY = rotateDelta[1];
    }
    let deltaInput = {
      x: deltaX,
      y: deltaY
    };

    if (this.currentLayers.length === 1) {
      let currentLayer = this.currentLayers[0];
      const dimensions = currentLayer.getBoundingClientRect();
      let currentLayerDimension = {
        x: dimensions.x,
        y: dimensions.y,
        width: dimensions.width,
        height: dimensions.height,
        rotation: dimensions.rotation,
        rootX: dimensions.rootX,
        rootY: dimensions.rootY
      };

      let boundingBoxDimensions = computeOrientationWithDelta(
        currentLayerDimension,
        deltaInput,
        this.payload.handle
      );
      this.setFixedLayer(currentLayer);
      boundingBoxDimensions = adjustDimsWithAspectRatio(
        currentLayer,
        deltaInput,
        boundingBoxDimensions
      );
      SetLayerDimensionsService(
        this.session,
        currentLayer.getFullPath(),
        boundingBoxDimensions
      );

      if (currentLayer && currentLayer.type === "file") {
        if (
          this.oldDimensions[0].width !== boundingBoxDimensions.width ||
          this.oldDimensions[0].height !== boundingBoxDimensions.height
        ) {
          // this.oldDeviceName = this.session.selectedFile.scopeVariables.deviceName;
          SetAllScopeVariablesService(this.session, currentLayer.path, {
            ...this.session.selectedFile.scopeVariables,
            deviceName: "custom"
          });
        }
      }
    } else if (this.currentLayers.length > 0) {
      let boundingBox = {
        ...this.session.getBoundingBox(this.currentLayers)
      };
      boundingBox.width = boundingBox.width;
      boundingBox.height = boundingBox.height;
      boundingBox.x = boundingBox.x;
      boundingBox.y = boundingBox.y;
      forEach(this.currentLayers, (currentLayerInLoop: Layer) => {
        let renderCompiledDims = currentLayerInLoop.getBoundingClientRect();
        this.setFixedLayer(currentLayerInLoop);
        let currentLayerDimension = {
          x: renderCompiledDims.x,
          y: renderCompiledDims.y,
          width: renderCompiledDims.width,
          height: renderCompiledDims.height,
          rotation: renderCompiledDims.rotation,
          rootX: renderCompiledDims.rootX,
          rootY: renderCompiledDims.rootY
        };

        const points = ModelUtils.getPointsFromBoundingBox(
          currentLayerDimension,
          0
        );
        let boundingBoxDimensions = computeOrientationWithDeltaMultiple(
          currentLayerDimension,
          deltaInput,
          this.payload.handle,
          { ...boundingBox },
          points
        );
        boundingBoxDimensions = adjustDimsWithAspectRatio(
          currentLayerInLoop,
          deltaInput,
          boundingBoxDimensions
        );
        SetLayerDimensionsService(
          this.session,
          currentLayerInLoop.getFullPath(),
          boundingBoxDimensions
        );
      });
    }
  }
}

function adjustDimsWithAspectRatio(layer: Layer, deltaInput: any, dims: any) {
  if (layer.aspectRatio) {
    if (round(deltaInput.y, 3)) {
      dims.width = dims.height * layer.aspectRatio;
    } else if (round(deltaInput.x, 3)) {
      dims.height = dims.width / layer.aspectRatio;
    }
  }
  return dims;
}
