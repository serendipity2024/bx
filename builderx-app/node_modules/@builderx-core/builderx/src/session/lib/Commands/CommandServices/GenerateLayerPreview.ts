import { Session } from "../../models/Session";
import { noRerender } from "model";
import { Layer } from "domain-x";
import { BX_PREVIEW_FILE_PATH } from "bx-constants";
import { ILayerTemplate } from "common-interfaces";
import clearRecordingConditionsService from "../CommandServices/ClearRecordingConditions";
import { CreateSymbolFile } from "../CommandServices/CreateSymbolFile";
import { forEach, cloneDeep } from "lodash";
import ungroupService from "../CommandServices/Ungroup";
import selectFileService from "../CommandServices/SelectFile";
import updateRecordingConditionsService from "../CommandServices/UpdateRecordingConditions";
import createService from ".";
import { AddLayerService } from "./AddLayerService";
import SelectLayersService from "./SelectLayersService";
import SetFileCode from "./SetFileCode";
import RemoveStageMutator from "../../Mutators/RemoveStageMutator";
import UpdatePreviewStage from "./UpdatePreviewStage";
import { updateStatusBar } from "src/session-plugins/lib/plugins/SessionCanvasGlue/Glues/SetStatusBarGlue";

const GenerateLayerPreview = createService(
  "generateLayerPreview",
  (session: Session, domainLayersPath: Array<string>) => {
    try {
      session.globalStateService.previewGeneration = true;
      let domainParentLayer: Layer;
      let domainLayersTemplates: ILayerTemplate[];
      let domainLayers = domainLayersPath.map(dlp =>
        session.getLayerFromLayerPath(dlp)
      );
      // noRerender(() => {
      session.shouldDisableAutoSave(true);

      if (shouldGeneratePreview(session, domainLayers)) {
        domainParentLayer = domainLayers[0].parent as Layer;
        if (domainParentLayer.type === "loop") {
          domainLayers = [domainParentLayer];
          domainParentLayer = domainParentLayer.parent;
        }
      }
      const file = session.domain.files.get(BX_PREVIEW_FILE_PATH);
      if (file) {
        noRerender(() => {
          // removeArtboardService(session, file.path, BX_PREVIEW_FILE_PATH);

          RemoveStageMutator(session, BX_PREVIEW_FILE_PATH);

          // removeCurrentStageRef(session, file.layer, true);
        });
      }
      domainLayersTemplates = [];
      domainLayers.forEach((layer: Layer) => {
        domainLayersTemplates.push(layer.template.toJS() as ILayerTemplate);
      });

      session.shouldDisableAutoSave(false);

      session.shouldDisableAutoSave(true);
      const selectedFile = session.selectedFile;
      let symbolFile: any = selectedFile;
      let filePath = BX_PREVIEW_FILE_PATH;
      if (shouldGeneratePreview(session, domainLayers)) {
        const oldRecordingConditions = {
          ...session.currentStage.recordingConditions
        };
        clearRecordingConditionsService(session, false);

        // if (
        //   domainLayers[0] === session.currentRootLayer ||
        //   domainLayers[0].type === "root"
        // ) {
        //   CreateStageForDomainMutator(
        //     session,
        //     BX_PREVIEW_FILE_PATH,
        //     domainLayers[0].parent.path
        //   );
        // } else {
        let response: any;
        response = CreateSymbolFile(
          session,
          domainLayersPath,
          // @ts-ignore
          domainParentLayer.getFullPath(),
          filePath,
          false,
          true
        );

        const { symbolInstance, template, wrapperLayer, noWrapper } = response;
        symbolFile = response.symbolFile;
        // wrapperLayer = response.wrapperLayer;
        if (!symbolInstance || !template || !wrapperLayer || !symbolFile) {
          throw new Error("Failed to export layer");
        }

        // session.globalStateService.setDimensions = false;
        const wrapperLayerChildren = [...wrapperLayer.getChildren()];
        forEach(wrapperLayerChildren, (child: Layer, index: string) => {
          const layerJSON = cloneDeep(child.toJS());
          // TODO: check this

          //TODO: image-fixes
          // if (layerJSON.type === "image") {
          //   layerJSON.blobURL = child.blobURL;
          // }
          AddLayerService(session, symbolFile.layer.getPath(), layerJSON);
          // AddLayerMutator(
          //   session,
          //   symbolFile.layer.getPath(),
          //   layerJSON.type,
          //   symbolFile.layer.getPath()
          // );
        });

        if (!noWrapper) {
          const wrapperChildren = [...wrapperLayer.getChildren()];

          ungroupService(session, wrapperLayer.getFullPath());

          domainLayers.forEach((layer: Layer, index: number) => {
            const layerOldTemplate = domainLayersTemplates[index];
            // if (layerOldTemplate.centerHorizontal) {
            //   setCenterHorizontal(session, layer, true, true);
            // }
            // if (layerOldTemplate.centerVertical) {
            //   setCenterVertical(session, layer, true, true);
            // }
          });

          forEach(wrapperChildren, (layer: Layer) => {
            //
          });
          session.globalStateService.previewGeneration = false;
        }
        // }

        selectFileService(session, selectedFile.getFullPath());
        // console.timeEnd("@@@ SelectFile");
        forEach(oldRecordingConditions, (value: any, key: string) => {
          const recordingConditions = session.currentStage.recordingConditions;
          updateRecordingConditionsService(
            session,
            recordingConditions,
            key,
            value,
            false
          );
        });

        // // @ts-ignore
        // session.stages
        //   .get(BX_PREVIEW_FILE_PATH)
        //   .canvas.setLayout({ width: 600, height: 400 });
        // // @ts-ignore
        // session.stages
        //   .get(BX_PREVIEW_FILE_PATH)
        //   .canvas.setViewport({ width: 600, height: 400 });

        // TODO: jugaad
        if (
          domainLayers[0] &&
          (domainLayers[0] === session.currentRootLayer ||
            domainLayers[0].type === "root")
        ) {
          updateStatusBar(
            domainLayers[0].getFile(),
            // getOwnCanvasRef(
            //   symbolInstance as any,
            ((session.stages.get(BX_PREVIEW_FILE_PATH) as any).canvas as any)
              .children[0]
            // ) as any
          );
        }
      }
      session.shouldDisableAutoSave(false);
      SelectLayersService(session, domainLayersPath);
      SetFileCode(session);
      UpdatePreviewStage(session);
    } catch (err) {
      if (err) {
        console.error(err, "Preview couldn't be generated");
      }
    }
  }
);

function shouldGeneratePreview(session: Session, domainLayers: Array<Layer>) {
  if (domainLayers.length === 0) {
    return false;
  }
  // if (
  //   domainLayers[0] &&
  //   (domainLayers[0] === session.currentRootLayer ||
  //     domainLayers[0].type === "root")
  // ) {
  //   return false;
  // }
  return true;
}

export default GenerateLayerPreview;
