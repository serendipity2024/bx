import { ICommand, CommandManager } from "command-manager";
import { Session } from "../../models/Session";
import AddSymbolFromJS from "../Symbols/AddSymbolFromJS";
import {
  MaterialComponentLibrary,
  CupertinoComponentLibrary
} from "shared-components";
import { find, get, camelCase, cloneDeep } from "lodash";
import { ComponentDefinition, LayerJSON } from "common-interfaces";
import AddLayer from "../Layer/AddLayer";
import DeselectAllLayers from "../Session/DeselectAllLayers";
import SelectFile from "../Session/SelectFile";
import { Utils } from "utils";

import { action } from "model";
import * as path from "path";
import { GetImageAbsPath } from "../CommandServices/GetImagePath";
import {
  stopChildrenLayoutUpdates,
  stopRerender,
  startChildrenLayoutUpdates,
  startRerender
} from "@builderx-core/designer";
import SetAllStyleAttributesMutator from "../../Mutators/SetAllStyleAttributesMutator";
export default class InsertSharedComponent implements ICommand {
  displayName = "InsertSharedComponent";
  private session: Session;
  private name: string;
  private category: string;
  private componentLibrary:
    | MaterialComponentLibrary
    | CupertinoComponentLibrary;
  // private symbolFileJSON: any;
  private symbolFile: any;
  private selectedArtboard: any;
  private commandManager: CommandManager;
  private dims: any;
  addInstance: boolean;
  constructor(
    session: Session,
    componentLibrary: MaterialComponentLibrary | CupertinoComponentLibrary,
    category: string,
    name: string,
    dims: any,
    addInstance: boolean = true
  ) {
    this.session = session;
    this.componentLibrary = componentLibrary;
    this.name = name;
    this.category = category;
    this.commandManager = new CommandManager();
    this.dims = dims;
    this.addInstance = addInstance;
  }
  async execute() {
    const symbolsPathMapper = new Map<string, string>();
    this.selectedArtboard = this.session.selectedFile;
    const componentDefinition: ComponentDefinition | undefined = cloneDeep(
      find(this.componentLibrary.templates[this.category], ["name", this.name])
    );

    if (!componentDefinition) {
      return;
    }
    // let forEachPromises: Promise<any>[] = [];
    await Utils.asyncForEach(
      componentDefinition.symbols,
      async (symbolName: string) => {
        let promises: Promise<any>[] = [];

        let symbolFileJSON = this.componentLibrary.symbols.get(symbolName);
        // delete symbolFileJSON.layer.props.style.flex;

        if (!symbolFileJSON) {
          return;
        }
        symbolFileJSON = cloneDeep(symbolFileJSON);
        // symbolFileJSON.layer.props.style.flex = 1;

        Utils.traverseJSON(
          symbolFileJSON.layer,
          async (layerJSON: LayerJSON) => {
            const promise = new Promise(async (resolve, reject) => {
              const layerImport = get(layerJSON, "import.packageName");
              const mappedPath = symbolsPathMapper.get(layerImport);
              if (layerImport && mappedPath) {
                layerJSON.import.packageName = mappedPath;
              }

              // Import assets
              const layerType = get(layerJSON, "type");
              if (layerType === "image") {
                const uri = get(layerJSON, "props.source.uri");
                // TODO: Handle conditional case, Rishab
                if (uri) {
                  let imageFileName = uri.split(/\/|\./);
                  const imageFileNameLength = imageFileName.length;
                  imageFileName =
                    imageFileName[imageFileNameLength - 2] +
                    "." +
                    imageFileName[imageFileNameLength - 1];
                  if (this.session.envConfig.runningContext === "session") {
                    return;
                  }
                  // imageFileName = "bx_logo.png";
                  // tslint:disable-next-line: max-line-length
                  const cloudImagePath = `${this.session.envConstants.APP_STATIC_URL}/src/shared-components/SharedComponentsJSON/Material/ComponentDefinitions/Card/assets/${imageFileName}`;
                  if (this.session.envConfig.isSharedComponentInstance) {
                    layerJSON.props["source"]["uri"] = cloudImagePath;
                    resolve(true);
                  } else {
                    const { relativePath } = GetImageAbsPath(
                      this.session,
                      imageFileName
                    );
                    layerJSON.props["source"]["uri"] = imageFileName;
                    // const result: any = await this.session.apiSdk.assets.getCloudImage(
                    //   cloudImagePath,
                    //   {
                    //     responseType: "blob"
                    //   }
                    // );
                    // var file = new File([result.data], imageFileName, {
                    //   type: result.data.type
                    // });
                    // layerJSON["blobURL"] = [file];
                    // try {
                    //   this.session.before();
                    //   await this.session.apiSdk.assets.uploadAsset(
                    //     this.session.project.projectId,
                    //     relativePath,
                    //     file as any,
                    //     this.session.connectionId,
                    //     "image"
                    //   );
                    //   resolve(true);
                    // } catch (err) {
                    //   console.error(
                    //     "Couldn't upload image in shared component",
                    //     err
                    //   );
                    //   resolve(false);
                    // } finally {
                    //   this.session.after();
                    // }
                  }
                } else {
                  resolve(true);
                }
              } else {
                resolve(true);
              }
            });
            promises.push(promise);
          }
        );

        await Promise.all(promises);

        const originalPath = symbolFileJSON.path;

        const newPathForSymbol = Utils.getNewSymbolFileName(
          this.session.project.defaultSymbolDirectory,
          this.session.domain.files,
          symbolFileJSON.path
        );

        const newSymbolFileJSON = { ...symbolFileJSON, path: newPathForSymbol };
        // Check if the symbol file we are adding is the one for the shared comp symbol instance,
        // then replace the import path in symbol instance template once we obtain new path
        if (originalPath === componentDefinition.template.import.packageName) {
          componentDefinition.template.import.packageName = newPathForSymbol;
          componentDefinition.template.import.layerName = path.basename(
            newPathForSymbol,
            ".js"
          );
          componentDefinition.template.styleName = camelCase(
            componentDefinition.template.import.layerName
          );
        }

        symbolsPathMapper.set(originalPath, newPathForSymbol);
        action(() => {
          stopChildrenLayoutUpdates();
          stopRerender();
          this.commandManager.executeAndSkip(
            new AddSymbolFromJS(this.session, newSymbolFileJSON)
          );
          startChildrenLayoutUpdates();
          startRerender();
          const symbolFile = this.session.domain.files.get(
            newSymbolFileJSON.path
          );
          if (symbolFile) {
            //
            SetAllStyleAttributesMutator(
              this.session,
              symbolFile.getFullPath(),
              newSymbolFileJSON.props.style
            );
          }
        });
      }
    );
    action(() => {
      // await Promise.all(forEachPromises);

      // this.commandManager.execute(
      //   new InsertSymbolInstance(this.session, this.symbolFile)
      // );
      if (this.addInstance) {
        // DOC: removing selected shared component
        this.addSymbolInstance(componentDefinition);
        this.session.selectedSharedComponent = undefined;
      }
    });
  }

  undo() {
    this.commandManager.undoAll();
    this.session.drivers.analyticsService.addActivity(
      {
        name: `undo.insert.shared.component`,
        path: "",
        category: "app/command"
      },
      true
    );
  }
  redo() {
    this.commandManager.redoAll();
    this.session.drivers.analyticsService.addActivity(
      {
        name: `redo.insert.shared.component`,
        path: "",
        category: "app/command"
      },
      true
    );
  }

  private addSymbolInstance(componentDefinition: ComponentDefinition) {
    this.session.commandManager.executeAndSkip(
      new DeselectAllLayers(this.session)
    );
    this.session.commandManager.executeAndSkip(
      new SelectFile(this.session, this.selectedArtboard)
    );
    const symbolFile = this.session.domain.getFileFromFileId(
      componentDefinition.template.import.packageName
    );
    // In symbol file props.style, we have default style for this symbol instance,
    // merge it with the style we get from the template
    componentDefinition.template.props.style = {
      ...componentDefinition.template.props.style,
      ...symbolFile.props.style.toJS()
    };
    componentDefinition.template.props.style.left = this.dims.left;
    componentDefinition.template.props.style.top = this.dims.top;

    const symbolJSON = componentDefinition.template;

    const symbolInstanceFile = this.session.domain.getSymbolFileFromSymbolInstance(
      symbolJSON as any
    );
    if (
      symbolJSON.type === "symbol" &&
      symbolInstanceFile &&
      Utils.checkIfCircularSymbol(
        this.session,
        symbolInstanceFile,
        this.session.currentRootLayer
      )
    ) {
      return;
    }

    this.commandManager.execute(
      new AddLayer(this.session, this.session.currentRootLayer, symbolJSON)
    );

    this.session.drivers.analyticsService.addActivity(
      {
        name: `insert.shared.component`,
        path: "",
        category: "app/command"
      },
      true
    );
  }
  readImage(file: any): Promise<string> {
    return new Promise((resolve, reject) => {
      var reader = new FileReader();
      reader.onload = function(evt: any) {
        resolve(evt.target.result);
      };
      reader.readAsDataURL(file);
    });
  }
}
