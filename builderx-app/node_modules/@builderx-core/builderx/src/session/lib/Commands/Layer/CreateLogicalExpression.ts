import { ICommand, CommandManager } from "command-manager";
import { Session } from "../../models/Session";
import { LogicalExpression } from "domain-x";
import { set } from "lodash";
import CreateExpressionNode from "./CreateExpressionNode";
import CreateLiteralNode from "./CreateLiteralNode";
import CreateBinaryExpression from "./CreateBinaryExpression";

export default class CreateLogicalExpression implements ICommand {
  displayName = "CreateLogicalExpression";
  private session: Session;
  private JSON: any;
  private parent: any;
  private key: string;
  private property?: any;
  private commandManager: CommandManager;
  constructor(
    session: Session,
    parent: any,
    key: string,
    JSON: any,
    property?: any
  ) {
    this.session = session;
    this.JSON = JSON;
    this.parent = parent;
    this.key = key;
    this.property = property;
    this.commandManager = new CommandManager();
  }
  execute() {
    const node = new LogicalExpression(this.JSON, this.session);
    node.parent = this.parent;

    if (this.JSON.left.type === "binaryExpression") {
      this.commandManager.execute(
        new CreateBinaryExpression(
          this.session,
          node,
          "left",
          this.JSON.left,
          this.property
        )
      );
    } else if (this.JSON.left.type === "expression") {
      this.commandManager.execute(
        new CreateExpressionNode(
          this.session,
          node,
          "left",
          this.JSON.left,
          this.property
        )
      );
    } else if (this.JSON.left.type === "logicalExpression") {
      this.commandManager.execute(
        new CreateLogicalExpression(
          this.session,
          node,
          "left",
          this.JSON.left,
          this.property
        )
      );
    } else if (this.JSON.left.type === "expression") {
      this.commandManager.execute(
        new CreateExpressionNode(
          this.session,
          node,
          "left",
          this.JSON.left,
          this.property
        )
      );
    } else if (this.JSON.left.type === "literal") {
      this.commandManager.execute(
        new CreateLiteralNode(
          this.session,
          node,
          "left",
          this.JSON.left,
          this.property
        )
      );
    } else if (this.JSON.left.type) {
      throw new Error("unsupported type => " + this.JSON.left.type);
    } else {
      node.left = this.JSON.left;
    }
    if (this.JSON.right.type === "binaryExpression") {
      this.commandManager.execute(
        new CreateBinaryExpression(
          this.session,
          node,
          "right",
          this.JSON.right,
          this.property
        )
      );
    } else if (this.JSON.right.type === "expression") {
      this.commandManager.execute(
        new CreateExpressionNode(
          this.session,
          node,
          "right",
          this.JSON.right,
          this.property
        )
      );
    } else if (this.JSON.right.type === "logicalExpression") {
      this.commandManager.execute(
        new CreateLogicalExpression(
          this.session,
          node,
          "right",
          this.JSON.right,
          this.property
        )
      );
    } else if (this.JSON.right.type === "literal") {
      this.commandManager.execute(
        new CreateLiteralNode(
          this.session,
          node,
          "right",
          this.JSON.right,
          this.property
        )
      );
    } else if (this.JSON.right.type) {
      throw new Error("unsupported type => " + this.JSON.right.type);
    } else {
      node.right = this.JSON.right;
    }
    set(this.parent, this.key, node);
  }
  undo() {
    //
  }
  redo() {
    //
  }
}
