import { ICommand, CommandManager } from "command-manager";
import { Session } from "../../models/Session";
import { ConditionalExpression, LiteralNode } from "domain-x";
import { set } from "lodash";
import CreateExpressionNode from "./CreateExpressionNode";
import CreateBinaryExpression from "./CreateLogicalExpression";
import CreateLiteralNode from "./CreateLiteralNode";
import CreateLogicalExpression from "./CreateLogicalExpression";
import { ResolveNodeValue } from "utils";
import { Layer as DomainLayer } from "domain-x";

export default class CreateConditionalExpression implements ICommand {
  displayName = "CreateConditionalExpression";
  private session: Session;
  private JSON: any;
  private parent: any;
  private key: string;
  private property?: string;
  private commandManager: CommandManager;
  private resolveDomainCompile: boolean;
  private replace: boolean;
  constructor(
    session: Session,
    parent: any,
    key: string,
    JSON: any,
    property?: string,
    resolveDomainCompile: boolean = true,
    replace: boolean = false
  ) {
    this.session = session;
    this.JSON = JSON;
    this.parent = parent;
    this.key = key;
    this.property = property;
    this.resolveDomainCompile = resolveDomainCompile;
    this.replace = replace;
    this.commandManager = new CommandManager();
  }
  execute() {
    const node = new ConditionalExpression(this.session);
    // debugger;
    node.parent = this.parent;
    if (node.parent instanceof DomainLayer && !this.replace) {
      const index = parseInt(this.key.replace("children.", ""), 10);
      node.parent.appendChild(node, index);
    } else {
      set(this.parent, this.key, node);
    } // create test

    if (this.JSON.test.type === "expression") {
      this.commandManager.execute(
        new CreateExpressionNode(this.session, node, "test", this.JSON.test)
      );
    } else if (this.JSON.test.type === "binaryExpression") {
      this.commandManager.execute(
        new CreateBinaryExpression(this.session, node, "test", this.JSON.test)
      );
    } else if (this.JSON.test.type === "logicalExpression") {
      this.commandManager.execute(
        new CreateLogicalExpression(this.session, node, "test", this.JSON.test)
      );
    }

    if (this.JSON.alternate.type === "expression") {
      this.commandManager.execute(
        new CreateExpressionNode(
          this.session,
          node,
          "alternate",
          this.JSON.alternate,
          this.property
        )
      );
    } else if (this.JSON.alternate.type === "binaryExpression") {
      this.commandManager.execute(
        new CreateBinaryExpression(
          this.session,
          node,
          "alternate",
          this.JSON.alternate
        )
      );
    } else if (this.JSON.alternate.type === "logicalExpression") {
      this.commandManager.execute(
        new CreateLogicalExpression(
          this.session,
          node,
          "alternate",
          this.JSON.alternate
        )
      );
    } else if (this.JSON.alternate.type === "literal") {
      this.commandManager.execute(
        new CreateLiteralNode(
          this.session,
          node,
          "alternate",
          this.JSON.alternate,
          this.property
        )
      );
    } else if (this.JSON.alternate.type === "conditionalExpression") {
      this.commandManager.execute(
        new CreateConditionalExpression(
          this.session,
          node,
          "alternate",
          this.JSON.alternate,
          this.property
        )
      );
    }
    if (this.JSON.consequent.type === "expression") {
      this.commandManager.execute(
        new CreateExpressionNode(
          this.session,
          node,
          "consequent",
          this.JSON.consequent
        )
      );
    } else if (this.JSON.consequent.type === "binaryExpression") {
      this.commandManager.execute(
        new CreateBinaryExpression(
          this.session,
          node,
          "consequent",
          this.JSON.consequent
        )
      );
    } else if (this.JSON.consequent.type === "logicalExpression") {
      this.commandManager.execute(
        new CreateLogicalExpression(
          this.session,
          node,
          "consequent",
          this.JSON.consequent
        )
      );
    } else if (this.JSON.consequent.type === "literal") {
      this.commandManager.execute(
        new CreateLiteralNode(
          this.session,
          node,
          "consequent",
          this.JSON.consequent
        )
      );
    } else if (this.JSON.consequent.type === "conditionalExpression") {
      this.commandManager.execute(
        new CreateConditionalExpression(
          this.session,
          node,
          "consequent",
          this.JSON.consequent
        )
      );
    }

    if (this.resolveDomainCompile) {
      const resolvedNodeValue = ResolveNodeValue(
        node,
        this.session.selectedFile
          ? this.session.selectedFile.scopeVariables
          : {}
      );
    }
  }
  undo() {
    //
  }
  redo() {
    //
  }
}
