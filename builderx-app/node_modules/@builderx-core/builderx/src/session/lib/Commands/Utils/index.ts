import { LAYOUT_PROPERTIES } from "bx-constants";
import {
  File as DomainFile,
  Layer as DomainLayer,
  OverrideModel,
  Layer
} from "domain-x";
import { forEach } from "lodash";
import { Session } from "../../models/Session";
import SetStyleAttribute from "../Style/SetStyleAttribute";
import { Gradient } from "@builderx-core/designer";
import { SetStyleAttributeMutator } from "../../Mutators";

export default class CommandUtils {
  static getFixedParent(
    session: Session,
    layer: DomainLayer | DomainFile
  ): DomainLayer | DomainFile {
    if (layer instanceof DomainFile) {
      // return;
      return layer;
    }
    // return layer;
    if (layer.type === "root" || session.currentRootLayer === layer) {
      return layer;
    }

    const layerParent = layer as DomainLayer;

    // TODO: refactor check heavy-jugaad
    if (!layerParent.parent) {
      return layer;
    }
    // if (flexDirection === "row") {
    if (
      layerParent.isWidthAuto ||
      layerParent.isHeightAuto ||
      layerParent.isFlexChild
    ) {
      return CommandUtils.getFixedParent(session, layerParent.parent);
    } else {
      return layerParent;
    }

    return layerParent;
  }

  static getFixedAncestor(layer: DomainLayer, handle: string): DomainLayer {
    if (layer.type === "root") {
      return layer;
    }
    const layerParent = layer.parent as DomainLayer;
    const flexDirection = layerParent.props.getResolvedStyleAttribute(
      "flexDirection"
    );
    if (
      flexDirection === "row" &&
      handle &&
      (handle.indexOf("L") !== -1 || handle.indexOf("R") !== -1)
    ) {
      if (layerParent.isWidthAuto) {
        return CommandUtils.getFixedAncestor(layerParent, handle);
      } else {
        return layerParent;
      }
    } else if (
      handle &&
      (handle.indexOf("B") !== -1 || handle.indexOf("T") !== -1)
    ) {
      if (layerParent.isHeightAuto) {
        return CommandUtils.getFixedAncestor(layerParent, handle);
      } else {
        return layerParent;
      }
    }
    return layerParent;
  }

  static getOverrideJsonForLayer(
    layer: DomainLayer
  ): Array<OverrideModel> | undefined {
    let overrideJsonArray: Array<OverrideModel> = [];
    let overrideJson: OverrideModel;

    // if (layer.type === "text") {
    //   overrideJson = new OverrideModel(
    //     layer.styleName + "Text",
    //     "string",
    //     (layer as TextLayer).innerText,
    //     "innerText",
    //     "innerText"
    //   );
    //   overrideJsonArray.push(overrideJson);
    // }
    // if (layer.type === "view" || layer.type === "touchableOpacity") {
    //   overrideJson = new OverrideModel(
    //     layer.styleName + "Color",
    //     "color",
    //     (layer as ViewLayer).props.style.backgroundColor,
    //     "style",
    //     "backgroundColor"
    //   );
    //   overrideJsonArray.push(overrideJson);
    // }
    // if (layer.type === "touchableOpacity") {
    //   overrideJson = new OverrideModel(
    //     layer.styleName + "Navigation",
    //     "navigation",
    //     (layer as TouchableOpacityLayer).navigateTo,
    //     "navigation",
    //     "navigateTo"
    //   );
    //   overrideJsonArray.push(overrideJson);
    // }

    return overrideJsonArray;
  }

  static setOverridesInCompiled(
    session: Session,
    symbolLayer: DomainLayer,
    override: any
  ): { layer: DomainLayer; overrideObj: OverrideModel } | any {
    // let symbolFile = session.domain.getSymbolFileFromSymbolInstance(
    //   symbolLayer
    // );
    // let layer: DomainLayer = symbolFile.layer;
    // let compiledLayer: CompiledLayer<any> = symbolLayer.domainCompiledRefs[0];
    // let overrideObj: OverrideModel | undefined;
    // compiledLayer.traverseLayers((child: CompiledLayer<any>) => {
    //   if (find(child.domain.overrideKeys, ["overrideKey", override.key])) {
    //     overrideObj = find(child.domain.overrideKeys, [
    //       "overrideKey",
    //       override.key
    //     ]);
    //     compiledLayer = child;
    //     layer = child.ref;
    //   }
    // });
    // if (!overrideObj) {
    //   return undefined;
    // }
    // let newLayerJSON = layer.resolveLayerFromOverrides(
    //   symbolLayer,
    //   overrideObj
    // );
    // CommandUtils.updateCompiledAndRenderCompiledLayer(
    //   session,
    //   compiledLayer,
    //   newLayerJSON
    // );
    // return { layer, overrideObj };
  }

  static removeOverridesInCompiled(
    session: Session,
    symbolLayer: DomainLayer,
    overrideKey: string
  ): { layer: DomainLayer; overrideObj: OverrideModel } | any {
    // let symbolFile = session.domain.getSymbolFileFromSymbolInstance(
    //   symbolLayer
    // );
    // let layer: DomainLayer = symbolFile.layer;
    // let compiledLayer: CompiledLayer<any> = symbolLayer.domainCompiledRefs[0];
    // let overrideObj: OverrideModel | undefined;
    // compiledLayer.traverseLayers((child: CompiledLayer<any>) => {
    //   if (find(child.domain.overrideKeys, ["overrideKey", overrideKey])) {
    //     overrideObj = find(child.domain.overrideKeys, [
    //       "overrideKey",
    //       overrideKey
    //     ]);
    //     compiledLayer = child;
    //     layer = child.ref;
    //   }
    // });
    // if (!overrideObj) {
    //   return undefined;
    // }
    // let newLayerJSON = layer.resolveLayerForSymbolInstance(symbolLayer);
    // CommandUtils.updateCompiledAndRenderCompiledLayer(
    //   session,
    //   compiledLayer,
    //   newLayerJSON
    // );
    // return { layer, overrideObj };
  }

  static setScrollViewContentContainerStyle(
    session: Session,
    layer: DomainLayer
  ) {
    const totalWidth = CommandUtils.getTotalWidthForScrollView(session, layer);
    const totalHeight = CommandUtils.getTotalHeightForScrollView(
      session,
      layer
    );
    SetStyleAttributeMutator(
      session,
      layer.getFullPath(),
      "width",
      totalWidth,
      "contentContainerStyle"
    );

    SetStyleAttributeMutator(
      session,
      layer.getFullPath(),
      "height",
      totalHeight,
      "contentContainerStyle"
    );
  }

  static getTotalHeightForScrollView(
    session: Session,
    layer: DomainLayer
  ): number {
    let totalMaxHeight = 0;

    const compiledLayer = session.executeFunction(
      "getOwnCanvasRef",
      layer,
      session.currentStage.canvas
    );

    forEach(compiledLayer.children, compiledChild => {
      const childBoundingClientRect = compiledChild.getBoundingClientRect();
      if (
        childBoundingClientRect.height + childBoundingClientRect.y >
        totalMaxHeight
      ) {
        totalMaxHeight =
          childBoundingClientRect.height + childBoundingClientRect.y;
      }
    });

    const layerBoundingClientRect = compiledLayer.getBoundingClientRect();
    if (layerBoundingClientRect.height > totalMaxHeight) {
      totalMaxHeight = layerBoundingClientRect.height;
    } else {
      totalMaxHeight = totalMaxHeight;
    }

    return totalMaxHeight;
  }

  static getTotalWidthForScrollView(
    session: Session,
    layer: DomainLayer
  ): number {
    let totalMaxWidth = 0;

    const compiledLayer = session.executeFunction(
      "getOwnCanvasRef",
      layer,
      session.currentStage.canvas
    );

    forEach(compiledLayer.children, compiledChild => {
      const childBoundingClientRect = compiledChild.getBoundingClientRect();
      if (
        childBoundingClientRect.width + childBoundingClientRect.x >
        totalMaxWidth
      ) {
        totalMaxWidth =
          childBoundingClientRect.width + childBoundingClientRect.x;
      }
    });

    const layerBoundingClientRect = compiledLayer.getBoundingClientRect();
    if (layerBoundingClientRect.width > totalMaxWidth) {
      totalMaxWidth = layerBoundingClientRect.width;
    } else {
      totalMaxWidth = totalMaxWidth;
    }

    return totalMaxWidth;
  }

  static getNewImagePath(
    session: Session,
    path: string,
    imageName: string = "image",
    extName: string = ".png"
  ) {
    let newImageId = `${path}/${imageName}`;
    let testFileId;
    let foundName = false;
    let untitledIndex = 1;
    // testNewImageId = newImageId;
    // //console.log(files);
    while (!foundName) {
      testFileId = newImageId;
      newImageId += untitledIndex ? untitledIndex : "";
      if (session.drivers.fileService.isFileExists(newImageId + extName)) {
        untitledIndex++;
        newImageId = testFileId;
      } else {
        foundName = true;
        newImageId = newImageId + extName;
      }
    }

    return newImageId;
  }
  static getOwnStageRefs(layer: Layer, preview?: boolean) {
    // return layer.domainCompiledRefs[0];
    // const first = layer.domainCompiledRefs[0];
    // const last = layer.domainCompiledRefs[layer.domainCompiledRefs.length - 1];
    // if (!first.getFile()) {
    //   return first;
    // }
    // return last;
    // const domainCompiledRef = layer.domainCompiledRefs;
    // const found = domainCompiledRef.filter(revRef => {
    //   const file = revRef.getFile();
    //   // if (selectedFile && file === selectedFile.domainCompiledRefs[0]) {
    //   //   return true;
    //   // }
    //   if (file && file.path === "src/preview/Index.js") {
    //     return true;
    //   }
    //   if (!file) {
    //     return true;
    //   }
    //   // const rootLayer = revRef.getRootLayer();
    //   // if (rootLayer && rootLayer.domainRef.type === "scrollView") {
    //   //   return true;
    //   // }
    //   // const rootLayerFile = session.currentRootLayer.parent;
    //   // if (revRefRootFile) return revRefRootFile.domainRef === rootLayerFile;
    //   return false;
    // });
    // // if (found.length > 0) {
    // //   return found;
    // // }
    // return found;
  }

  static traverseLayers(
    compiledLayer: any,
    domainLayer: DomainLayer,
    callback: (compiledLayer: any, domainLayer: DomainLayer) => void
  ) {
    callback(compiledLayer, domainLayer);
    compiledLayer.children.forEach((childLayer: any, index: number) => {
      // TODO: fix-this
      const symbolChildLayer = childLayer.domainRef;

      if (symbolChildLayer) {
        // if (symbolChildLayer.type === "symbol") {
        //   removeCurrentStageRef(session, symbolChildLayer);
        // } else {
        CommandUtils.traverseLayers(
          childLayer,
          symbolChildLayer as any,
          callback
        );
        // }
      } else {
        CommandUtils.traverseLayers(
          childLayer,
          symbolChildLayer as any,
          callback
        );
      }

      // const symbolChildLayer = domainLayer.children[index];
      // if (symbolChildLayer instanceof DomainLayer) {
      //   this.traverseLayers(childLayer, symbolChildLayer, callback);
      // }
    });
  }
}
