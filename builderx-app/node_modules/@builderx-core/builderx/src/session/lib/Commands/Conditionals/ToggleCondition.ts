import { ICommand } from "command-manager";
import { Session } from "../../models/Session";
import { File, Layer, DomainLayer } from "domain-x";
import { LiteralNode, ConditionalExpression } from "domain-x";
import { forEach, get } from "lodash";
export default class ToggleCondition implements ICommand {
  displayName = "ToggleCondition";
  private session: Session;
  private file: File;
  private payload: { active: boolean; references: Layer[] };
  constructor(
    session: Session,
    file: File,
    payload: { active: boolean; references: Layer[] }
  ) {
    this.session = session;
    this.file = file;
    this.payload = payload;
  }
  execute() {
    this.payload.active = !this.payload.active;
    const references = this.payload.references;
    forEach(references, (reference: Layer) => {
      let newLayer, oldLayer;
      if (this.payload.active) {
        newLayer = get(reference, "consequent");
        oldLayer = get(reference, "alternate");
      } else {
        newLayer = get(reference, "alternate");
        oldLayer = get(reference, "consequent");
      }
      this.switchLayer(newLayer, oldLayer, reference);
    });
    // this.file.emit("conditionalExpList");
    this.session.drivers.analyticsService.addActivity(
      {
        name: `conditionals.recording.toggleCondition`,
        path: "",
        category: "app/command"
      },
      true
    );
  }

  undo() {
    this.payload.active = !this.payload.active;
    const references = this.payload.references;
    forEach(references, (reference: Layer) => {
      let newLayer, oldLayer;
      if (this.payload.active) {
        newLayer = get(reference, "consequent");
        oldLayer = get(reference, "alternate");
      } else {
        newLayer = get(reference, "alternate");
        oldLayer = get(reference, "consequent");
      }
      this.switchLayer(newLayer, oldLayer, reference);
    });
    // this.file.emit("conditionalExpList");
  }
  redo() {
    this.payload.active = !this.payload.active;
    const references = this.payload.references;
    forEach(references, (reference: Layer) => {
      let newLayer, oldLayer;
      if (this.payload.active) {
        newLayer = get(reference, "consequent");
        oldLayer = get(reference, "alternate");
      } else {
        newLayer = get(reference, "alternate");
        oldLayer = get(reference, "consequent");
      }
      this.switchLayer(newLayer, oldLayer, reference);
    });
    // this.file.emit("conditionalExpList");
  }
  private createNestedLayers(
    session: Session,
    layer: Layer,
    parent: any,
    symbolInstance: DomainLayer,
    index: number
  ) {
    // const compiledLayer = CreateCompiledLayer(
    //   session,
    //   layer,
    //   parent,
    //   false,
    //   index,
    //   symbolInstance
    // );
    // if (compiledLayer instanceof LiteralNode) {
    //   return;
    // }
    // SetAllPropsInDCAndRC(
    //   session,
    //   compiledLayer,
    //   layer.props.toJS(),
    //   symbolInstance
    // );
    // if (compiledLayer) {
    //   // used native forEach intentionally
    //   layer.children.forEach((childLayer: Layer, childIndex: number) => {
    //     if (childLayer instanceof ConditionalExpression) {
    //       this.createNestedLayers(
    //         session,
    //         childLayer.alternate,
    //         compiledLayer,
    //         symbolInstance,
    //         childIndex
    //       );
    //     } else {
    //       this.createNestedLayers(
    //         session,
    //         childLayer,
    //         compiledLayer,
    //         symbolInstance,
    //         childIndex
    //       );
    //     }
    //   });
    // }
    // return compiledLayer;
  }
  private switchLayer(newLayer: any, oldLayer: any, reference: Layer) {
    // this.removeOldLayerConditonalChildrensRef(oldLayer);
    // if (newLayer.type) {
    //   oldLayer.domainCompiledRefs[0].renderCompiledRef.remove();
    //   // index can have style/prop attribute name or position of child
    //   const index: number | string = oldLayer.domainCompiledRefs[0].remove();
    //   oldLayer.domainCompiledRefs.splice(0, 1);
    //   if (newLayer.type === "literal" || newLayer.type === "expression") {
    //     const layerProps = reference.domainCompiledRefs[0].domain.props;
    //     if (layerProps.style.hasOwnProperty(index)) {
    //       SetStyleAttributeInDCAndRC(
    //         this.session,
    //         reference.domainCompiledRefs[0],
    //         index as string,
    //         newLayer.toJS(),
    //         "style"
    //       );
    //       newLayer.domainCompiledRefs.push(layerProps.style[index]);
    //     } else {
    //       SetPropInDCAndRC(
    //         this.session,
    //         reference.domainCompiledRefs[0],
    //         index as string,
    //         newLayer.toJS()
    //       );
    //       newLayer.domainCompiledRefs.push(layerProps[index]);
    //     }
    //   } else {
    //     this.createNestedLayers(
    //       this.session,
    //       newLayer,
    //       reference.domainCompiledRefs[0],
    //       undefined as any,
    //       0
    //     );
    //   }
    // }
    // reference.emit("children");
  }
  private removeOldLayerConditonalChildrensRef(layer: ConditionalExpression) {
    layer.traverseLayers((childLayer: any) => {
      console.log(
        childLayer,
        "childLayer removeOldLayerConditonalChildrensRef"
      );
    });
  }
}
