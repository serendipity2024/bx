import { Layer as DomainLayer, Layer } from "domain-x";
import { forEach, reverse, sortBy, cloneDeep } from "lodash";
import { Session } from "../../models/Session";
import { AddLayerService } from "./AddLayerService";
import NormalizeChildrenFlex from "./NormalizeChildrenFlex";
import ChangeToFlexService from "./ChangeToFlex";
import { SetAllStyleService } from "./SetAllStyleService";
import MoveLayerService from "./MoveLayerService";
import createService from ".";
import SetLayerIsGroupMutator from "../../Mutators/SetLayerIsGroupMutator";

const WrapFlexLayers = createService(
  "WrapFlexLayers",
  (session: Session, domainLayers: Array<DomainLayer>, layerJSON?: any) => {
    const domainParentLayer = domainLayers[0].parent as DomainLayer;
    if (!(domainParentLayer instanceof DomainLayer)) {
      return;
    }
    let wrapperLayerFlex = 0,
      wrapperLayerLength = 0,
      useFlex = false;
    const flexDirection = domainParentLayer.props.getResolvedStyleAttribute(
      "flexDirection"
    );
    let propertyName: string;

    if (flexDirection === "row") {
      propertyName = "width";
    } else {
      propertyName = "height";
    }
    forEach(domainLayers, (layer: Layer) => {
      if (layer.getFlexValue()) {
        useFlex = true;
      }

      wrapperLayerLength += layer.getBoundingClientRect()[propertyName];
      wrapperLayerFlex += getLayerFlexWRTParent(layer);
    });
    // create wrapper Layer
    let style = {};

    if (!useFlex) {
      if (flexDirection === "row") {
        style = {
          width: wrapperLayerLength
        };
      } else {
        style = {
          height: wrapperLayerLength
        };
      }
    } else {
      style = {
        flex: wrapperLayerFlex,
        flexDirection: flexDirection ? flexDirection : "column"
      };
    }
    // for flex items
    const flexItems = !domainParentLayer.showLayoutOptions();
    var boundingBox = session.getBoundingBox(domainLayers);

    if (!layerJSON) {
      const ViewDefinition = session.currentStage.canvas.getComponentDefinition(
        "view"
      );
      layerJSON = cloneDeep(ViewDefinition.template);
      if (flexItems) {
        if (flexDirection === "row") {
          style = {
            flexDirection: "row",
            width: boundingBox.width,
            height: boundingBox.height
          };
        } else {
          style = {
            flexDirection: "column",
            width: boundingBox.width,
            height: boundingBox.height
          };
        }
      }
      layerJSON.props.style = { ...style };
    }
    AddLayerService(
      session,
      domainParentLayer.getFullPath(),
      layerJSON,
      undefined,
      true
    );
    const parentLayerChildren = domainParentLayer.getChildren();
    const domainWrapperLayer = parentLayerChildren[
      parentLayerChildren.length - 1
    ] as DomainLayer;
    // domainWrapperLayer.setIsGroup();
    SetLayerIsGroupMutator(session, domainWrapperLayer.getFullPath());
    var firstLayerIndex: number | undefined = undefined;
    // sort layer ids in reverse order

    const sortedLayers = reverse(
      sortBy(domainLayers, (layer: any) => {
        const index = layer.findIndexInParent();
        if (firstLayerIndex === undefined || firstLayerIndex > index) {
          firstLayerIndex = index;
        }
        return index;
      })
    );

    let fromParentPath;

    forEach(sortedLayers, (layer: DomainLayer, index: number) => {
      let indexInParent = layer.findIndexInParent();
      fromParentPath = domainParentLayer.getFullPath();
      const toParentPath = domainWrapperLayer.getFullPath();

      MoveLayerService(session, fromParentPath, toParentPath, indexInParent, 0);
    });
    fromParentPath = domainParentLayer.getPath(undefined, true);

    MoveLayerService(
      session,
      fromParentPath,
      fromParentPath,
      parentLayerChildren.length - 1,
      firstLayerIndex ? firstLayerIndex : 0
    );

    const newDomainWrapperLayer =
      domainParentLayer.children[firstLayerIndex ? firstLayerIndex : 0];
    let newDomainWrapperLayerPath = newDomainWrapperLayer.getFullPath();

    SetAllStyleService(session, newDomainWrapperLayerPath, style, "style");

    ChangeToFlexService(session, newDomainWrapperLayerPath);
    NormalizeChildrenFlex(
      session,
      session.getLayerFromLayerPath(newDomainWrapperLayerPath)
    );
    return newDomainWrapperLayer;
  }
);
export default WrapFlexLayers;
function getLayerFlexWRTParent(layer: Layer): number {
  const parentLayer = layer.parent;
  const parentRenderCompiledLayer = layer.getOwnCanvasRef().layout as any;
  const layerFlex = layer.getFlexValue();

  if (layerFlex) {
    return layerFlex;
  }

  const parentFlexDirection = layer.getParentLayerFlexDirection();

  const totalChildrenFlex = (parentLayer as DomainLayer).getTotalFlexOfFlexChildren();
  const totalChildrenLength = getTotalLengthOfFixedChildrenInFlexContainer(
    parentLayer as DomainLayer
  );
  const renderCompiledLayer = layer.getBoundingClientRect() as any;
  if (!totalChildrenFlex) {
    return 0;
  }

  if (parentFlexDirection === "column") {
    return (
      renderCompiledLayer.height /
      (parentRenderCompiledLayer.height - totalChildrenLength) /
      totalChildrenFlex
    );
  }

  if (parentFlexDirection === "row") {
    return (
      renderCompiledLayer.width /
      (parentRenderCompiledLayer.width - totalChildrenLength) /
      totalChildrenFlex
    );
  }

  return 0;
}
function getTotalLengthOfFixedChildrenInFlexContainer(layer: Layer) {
  let totalLength: number = 0;
  const flexDirection = layer.props.getResolvedStyleAttribute("flexDirection");
  layer.forEachChild((child: Layer, index: number) => {
    const renderCompiledChild = child.getBoundingClientRect() as any;
    if (!child.getFlexValue()) {
      if (flexDirection === "column") {
        totalLength += renderCompiledChild.height;
      } else if (flexDirection === "row") {
        totalLength += renderCompiledChild.width;
      }
    }
  });
  return totalLength;
}
