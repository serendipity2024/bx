import { Session } from "../../models/Session";
import * as JSZip from "jszip";
import * as pathUtil from "path";
import { SystemFont } from "common-interfaces";
import { find } from "lodash";
import { Layer } from "domain-x";
import { BX_PREVIEW_FILE_PATH } from "bx-constants";
import { GenerateGradient } from "./GenerateGradient";
import urljoin from "url-join";
import createService from ".";

export const AddFontAndImageFiles = createService(
  "AddFontAndImageFiles",
  async (session: Session, references: any[], zip: JSZip, filePath: string) => {
    const promises: Promise<any>[] = [];
    references.forEach(
      async (reference: { type: string; path: string; layer?: Layer }) => {
        const promise = new Promise(async (resolve, reject) => {
          let response: any;
          try {
            if (reference.type === "font") {
              response = await getFontFile(session, reference.path, filePath);
            } else if (reference.type === "image") {
              response = await getImageFile(
                session,
                reference.path,
                filePath,
                session.project.projectId
              );
            } else if (reference.type === "gradient") {
              if (reference.layer) {
                response = await getGradientImage(session, reference.layer);
              }
            }
          } catch (err) {
            resolve(false);
          }
          if (response && response.path && response.file) {
            zip.file(response.path, response.file);
            resolve(true);
          } else {
            resolve(true);
          }
        });
        promises.push(promise);
      }
    );
    await Promise.all(promises);
  }
);

export async function getFontFile(
  session: Session,
  fontPostScriptName: string,
  previewFilePath: string
) {
  const font = find(session.systemFonts, (systemFont: SystemFont) => {
    return systemFont.postscriptName === fontPostScriptName;
  });

  try {
    if (font) {
      let { postscriptName, path } = font;
      const fileName = `${postscriptName}.ttf`;
      let filePath = pathUtil.join("/src/assets/fonts/", fileName);
      if (previewFilePath === BX_PREVIEW_FILE_PATH) {
        filePath = filePath.replace("/src/", "/");
      }
      let file;

      if (
        path.indexOf(session.envConstants.APP_STATIC_URL) === -1 &&
        path.indexOf("fonts.gstatic.com") === -1
      ) {
        // Local system fonts
        // const result = await session.apiSdk.assets.getFont(
        //   session.fontUrl,
        //   path,
        //   {
        //     responseType: "blob"
        //   }
        // );
        // file = new File([result.data], fileName, {
        //   type: result.data.type
        // });
      } else {
        // Google fonts and statically served custom fonts (AdditionalFonts)
        path = path.replace("http:", "https:");

        file = await getBlobFile(session, path, fileName);
      }

      const fileObj = { path: filePath, file };
      session.addAssetToMap(fileObj);
      return fileObj;
    } else {
      throw new Error("font not found");
    }
  } catch (error) {
    console.log(error, "Error fetching font file");
    const fallbackFont = {
      path: urljoin(
        session.envConstants.BUILDERX_ASSETS_URL,
        "fonts",
        "Roboto",
        "Roboto-Regular.ttf"
      ),
      postscriptName: "roboto-regular",
      family: "Roboto",
      style: "Regular",
      type: "system"
    };

    if (fallbackFont) {
      let { postscriptName, path } = fallbackFont;
      const fileName = `${postscriptName}.ttf`;
      let filePath = pathUtil.join("/src/assets/fonts/", fileName);
      if (previewFilePath === BX_PREVIEW_FILE_PATH) {
        filePath = filePath.replace("/src/", "/");
      }

      const originalFileName = `${fontPostScriptName}.ttf`;
      let originalFilePath = pathUtil.join(
        "/src/assets/fonts/",
        originalFileName
      );
      path = path.replace("http:", "https:");
      try {
        const file = await getBlobFile(session, path, originalFileName);
        const fileObj = { path: originalFilePath, file };
        session.addAssetToMap(fileObj, true, filePath);
        return { path: filePath, file };
      } catch (err) {
        throw err;
      }
    }

    return {};
  }
}
async function getGradientImage(session: Session, layer: Layer) {
  const response = await GenerateGradient(session, layer);
  return { path: response.path, file: response.gradientBlob };
}
async function getImageFile(
  session: Session,
  imageUrl: string,
  path: string,
  projectId: string
) {
  const fileName = pathUtil.basename(imageUrl);
  if (!imageUrl.includes("api/get-files-content/")) {
    imageUrl =
      `${session.envConstants.BACKEND_API_URL}/get-files-content/${projectId}?fileName=` +
      imageUrl;
  }
  let filePath = imageUrl.split("=")[1];
  if (path === BX_PREVIEW_FILE_PATH && filePath) {
    filePath = filePath.replace("/src/", "/");
  }
  try {
    var file = await getBlobFile(session, imageUrl, fileName);
    return { path: filePath, file };
  } catch (error) {
    console.log(error, "Error fetching image file");
    return {};
  }
}

async function getBlobFile(session: Session, path: string, fileName: string) {
  // const result: any = await session.apiSdk.raw.getBlob(path, {
  //   responseType: "blob"
  // });
  // var file = new File([result.data], fileName, {
  //   type: result.data.type
  // });
  // return file;
}
