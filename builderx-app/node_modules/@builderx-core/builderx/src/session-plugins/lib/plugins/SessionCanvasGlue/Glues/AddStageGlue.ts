import { DomainLayer, DomainFile } from "domain-x";
import {
  Canvas,
  HoverPlugin,
  ViewRendererPlugin,
  ScrollViewRendererPlugin,
  TouchableOpacityRendererPlugin,
  TextRendererPlugin,
  DragPlugin,
  StageDesignerPlugin,
  DataStorePlugin,
  LayerDragPlugin,
  GridRendererPlugin,
  SnapPointsCalculatorPlugin,
  ConstructionLinesPlugin,
  SnapLinesPlugin,
  LineDrawerPlugin,
  DrawComponent,
  StageDesignerDrawComponent,
  TooltipPlugin,
  GradientEditorPlugin,
  HtmlDragToWorldPlugin,
  ResizerRendererPlugin,
  LayerResizerPlugin,
  MouseRectPlugin,
  TextEditorPlugin,
  IconRendererPlugin,
  RulerScalePlugin,
  StageDesignerRulerPlugin,
  Layer,
  Event,
  MeasurementLinesPlugin,
  LayerLabel,
  PathEvent,
  PlusButtonPlugin,
  RulerLinesPlugin,
  PopoverMenuPlugin,
  PathEditorPlugin,
  PathRendererPlugin,
  ImageRendererPlugin,
  TextInputRendererPlugin,
  SwitchRendererPlugin,
  EllipseRendererPlugin,
  SliderRendererPlugin,
  MapViewRendererPlugin,
  ActivityIndicatorRendererPlugin,
  LayerResizerEvent,
  stopChildrenLayoutUpdates,
  stopRerender,
  startChildrenLayoutUpdates,
  startRerender,
  MouseEvent,
  FontResizerPlugin,
  NativeHtmlDragPlugin,
  FloatingButtonPlugin,
  FlexDragPlugin,
  StageDesignerPreviewModePlugin,
  GradientEditorEvent,
  stopAndBatchLayoutUpdates,
  resumeLayoutUpdates,
  DeviceFrame,
  StatusBar,
  StageDesignerDeviceDataPlugin,
  OpacityShortcutPlugin,
  IPosition
} from "@builderx-core/designer";
import { cloneDeep, get } from "lodash";
import { SessionEvent } from "event-manager";
import { Session, Stage, Commands } from "session";
import { action } from "model";
import { Utils } from "utils";
import { MinFileSize, Prompt, IconModalDialog } from "dialog-x";
import { BX_PREVIEW_FILE_PATH } from "bx-constants";
import * as path from "path";
import urljoin from "url-join";
import { func } from "prop-types";

const {
  AddNewArtboard,
  SetProp,
  SelectLayers,
  SelectRootLayer,
  SetHoveredLayers,
  SelectTool,
  InsertSymbolInstance,
  InsertSharedComponent,
  SetCenterWrapper,
  SetLayerDimensions,
  AddLayer,
  SetResizerVisibility,
  SelectFile,
  GenerateLayerPreview,
  SetAllStyle,
  SetStyleAttribute,
  RenameFileName,
  MoveLayer,
  RemoveLayer,
  SetCurrentStage,
  DeselectAllLayers,
  DuplicateLayers,
  SetZoom,
  RemoveHoveredForAllLayers
} = Commands;

let dragHasEndedJustNow = false;
let handlingDragEnd = false;

async function getDimension() {
  let dimension: { width?: number; height?: number } = {
    width: undefined,
    height: undefined
  };
  await MinFileSize(100).then(async (result: any) => {
    if (!result || !result.height || !result.width) {
      dimension = await getDimension();
    } else {
      dimension = result;
    }
  });
  return dimension;
}

function selectTargetLayer(e: any, session: Session, stage: Stage) {
  action(() => {
    const layer = e.target;

    if (!layer) {
      return;
    }

    const domainRef = layer.executeFunction("getData", "domainRef");
    if (domainRef) {
      if (session.keyboardService.getCurrentKey().includes("shift")) {
        stage.performShiftClick(session, domainRef);
      } else {
        session.commandManager.executeAndSkip(
          new SelectLayers(session, [domainRef])
        );
      }
    } else {
      session.commandManager.executeAndSkip(new SelectRootLayer(session));
    }
  });
}

function selectHitArtboard(session: Session, event: any) {
  const artboard = session.currentStage.canvas.executeFunction(
    "getHitArtboard",
    event.worldX,
    event.worldY
  );
  if (artboard) {
    const targetFile = artboard.executeFunction("getData", "domainRef");
    if (targetFile) {
      session.commandManager.executeAndSkip(
        new SelectFile(session, targetFile)
      );
    }
  }
}

function onMouseMove(session: Session, worldPoint: IPosition) {
  session.currentStage.tools.setCursorPosition(worldPoint);

  session.eventManager.dispatchEvent(
    "onCanvasMouseMove",
    new SessionEvent("onCanvasMouseMove", {
      position: worldPoint
    })
  );
}

function onLayerDrag(session: Session, domainLayer: DomainLayer) {
  session.eventManager.dispatchEvent(
    "onLayerDrag",
    new SessionEvent("onLayerDrag", {
      domainLayer: domainLayer
    })
  );
}

function onLayerDragStart(session: Session, domainLayers: Array<DomainLayer>) {
  session.eventManager.dispatchEvent(
    "onLayerDragStart",
    new SessionEvent("onLayerDragStart", {
      domainLayers: domainLayers
    })
  );
}

function onLayerDragEnd(session: Session, domainLayers: Array<DomainLayer>) {
  session.eventManager.dispatchEvent(
    "onLayerDragEnd",
    new SessionEvent("onLayerDragEnd", {
      domainLayers: domainLayers
    })
  );
}

function setupStageDesigner(
  session: Session,
  stage: Stage,
  thumbnailStage: boolean = false
) {
  stage.canvas = new Canvas(stage.canvasContainerDom);

  stage.canvas.setAssetUrl(
    urljoin(session.envConstants.WEBSITE_URL, "assets", "plugins", "designer")
  );

  const scrollContainer = get(
    // @ts-ignore
    stage.canvas.dom.getElementsByClassName("scrollcontainer"),
    "0"
  );
  if (scrollContainer) {
    scrollContainer.style.overflow = "hidden";
  }

  stage.canvas.setLayout({
    width: 500,
    height: 700
  });

  let viewport = {
    width: 500,
    height: 700
  };
  if (session.currentStage && session.currentStage.canvas) {
    viewport = session.currentStage.canvas.getViewport();
  }
  stage.canvas.setViewport({
    width: viewport.width,
    height: viewport.height
  });

  // window["debug"] = true;
  // DOC: set debug = true from console
  window["debugLog"] = (value: string) => {
    console.log("DEBUG::", value);
  };

  if (
    stage.id !== BX_PREVIEW_FILE_PATH &&
    !thumbnailStage &&
    !session.envConfig.isSharedComponentInstance
  ) {
    if (process.env.NODE_ENV !== "production") {
      const constructionLines = new ConstructionLinesPlugin();
      stage.canvas.installPlugin(constructionLines);
    }

    const hoverPlugin = new HoverPlugin();
    stage.canvas.installPlugin(hoverPlugin);

    const nativeHtmlDrag = new NativeHtmlDragPlugin();
    stage.canvas.installPlugin(nativeHtmlDrag);

    // if (stage.id !== BX_PREVIEW_FILE_PATH) {
    const floatingButton = new FloatingButtonPlugin();
    stage.canvas.installPlugin(floatingButton);
    // }
  }

  const deviceDataPlugin = new StageDesignerDeviceDataPlugin();
  stage.canvas.installPlugin(deviceDataPlugin);

  const viewRendererPlugin = new ViewRendererPlugin();
  stage.canvas.installPlugin(viewRendererPlugin);

  const scrollViewRendererPlugin = new ScrollViewRendererPlugin();
  stage.canvas.installPlugin(scrollViewRendererPlugin);

  const touchableOpacityRendererPlugin = new TouchableOpacityRendererPlugin();
  stage.canvas.installPlugin(touchableOpacityRendererPlugin);

  const textRendererPlugin = new TextRendererPlugin();
  stage.canvas.installPlugin(textRendererPlugin);

  const imageRendererPlugin = new ImageRendererPlugin();
  stage.canvas.installPlugin(imageRendererPlugin);

  const pathRendererPlugin = new PathRendererPlugin();
  stage.canvas.installPlugin(pathRendererPlugin);

  const iconRendererPlugin = new IconRendererPlugin();
  stage.canvas.installPlugin(iconRendererPlugin);

  const switchRendererPlugin = new SwitchRendererPlugin();
  stage.canvas.installPlugin(switchRendererPlugin);

  const ellipseRendererPlugin = new EllipseRendererPlugin();
  stage.canvas.installPlugin(ellipseRendererPlugin);

  const textInputRendererPlugin = new TextInputRendererPlugin();
  stage.canvas.installPlugin(textInputRendererPlugin);

  const sliderRendererPlugin = new SliderRendererPlugin();
  stage.canvas.installPlugin(sliderRendererPlugin);

  const mapViewRendererPlugin = new MapViewRendererPlugin();
  stage.canvas.installPlugin(mapViewRendererPlugin);

  const activityIndicatorRendererPlugin = new ActivityIndicatorRendererPlugin();
  stage.canvas.installPlugin(activityIndicatorRendererPlugin);

  if (
    stage.id !== BX_PREVIEW_FILE_PATH &&
    !thumbnailStage &&
    !session.envConfig.isSharedComponentInstance
  ) {
    const dragPlugin = new DragPlugin();
    stage.canvas.installPlugin(dragPlugin);

    const snapCalculatorPlugin = new SnapPointsCalculatorPlugin();
    stage.canvas.installPlugin(snapCalculatorPlugin);

    const layerDragPlugin = new LayerDragPlugin();
    stage.canvas.installPlugin(layerDragPlugin);

    const lineDrawerPlugin = new LineDrawerPlugin();
    stage.canvas.installPlugin(lineDrawerPlugin);
  }

  const stagaDesignerPlugin = new StageDesignerPlugin();
  stage.canvas.installPlugin(stagaDesignerPlugin);

  const dataStorePlugin = new DataStorePlugin();
  stage.canvas.installPlugin(dataStorePlugin);

  if (
    stage.id !== BX_PREVIEW_FILE_PATH &&
    !thumbnailStage &&
    !session.envConfig.isSharedComponentInstance
  ) {
    const gridPlugin = new GridRendererPlugin();
    stage.canvas.installPlugin(gridPlugin);

    const tooltipPlugin = new TooltipPlugin();
    stage.canvas.installPlugin(tooltipPlugin);

    const drawComponentPlugin = new DrawComponent();
    stage.canvas.installPlugin(drawComponentPlugin);

    const stageDesignerDrawComponentPlugin = new StageDesignerDrawComponent();
    stage.canvas.installPlugin(stageDesignerDrawComponentPlugin);

    const nativeHtmlDragPlugin = new NativeHtmlDragPlugin();
    stage.canvas.installPlugin(nativeHtmlDragPlugin);

    const htmlDragToWorldPlugin = new HtmlDragToWorldPlugin();
    stage.canvas.installPlugin(htmlDragToWorldPlugin);

    const deviceFramePlugin = new DeviceFrame();
    stage.canvas.installPlugin(deviceFramePlugin);

    const resizerRendererPlugin = new ResizerRendererPlugin();
    stage.canvas.installPlugin(resizerRendererPlugin);

    const plusButtonPlugin = new PlusButtonPlugin();
    stage.canvas.installPlugin(plusButtonPlugin);

    const layerResizerPlugin = new LayerResizerPlugin();
    stage.canvas.installPlugin(layerResizerPlugin);

    const stageDesignerPreviewModePlugin = new StageDesignerPreviewModePlugin();
    stage.canvas.installPlugin(stageDesignerPreviewModePlugin);

    const rulerLinesPlugin = new RulerLinesPlugin();
    stage.canvas.installPlugin(rulerLinesPlugin);

    const rulerScalePlugin = new RulerScalePlugin();
    stage.canvas.installPlugin(rulerScalePlugin);

    const mouseRectPlugin = new MouseRectPlugin();
    stage.canvas.installPlugin(mouseRectPlugin);

    const gradientEditorPlugin = new GradientEditorPlugin();
    stage.canvas.installPlugin(gradientEditorPlugin);

    const stageDesignerRulerPlugin = new StageDesignerRulerPlugin();
    stage.canvas.installPlugin(stageDesignerRulerPlugin);

    const measurementLinesPlugin = new MeasurementLinesPlugin();
    stage.canvas.installPlugin(measurementLinesPlugin);

    const layerLabelPlugin = new LayerLabel();
    stage.canvas.installPlugin(layerLabelPlugin);

    // }

    const popoverMenuPlugin = new PopoverMenuPlugin();
    stage.canvas.installPlugin(popoverMenuPlugin);

    // if (stage.id !== BX_PREVIEW_FILE_PATH && !thumbnailStage) {
    const pathEditorPlugin = new PathEditorPlugin();
    stage.canvas.installPlugin(pathEditorPlugin);

    const textEditorPlugin = new TextEditorPlugin();
    stage.canvas.installPlugin(textEditorPlugin);
    const flexDragPlugin = new FlexDragPlugin();
    stage.canvas.installPlugin(flexDragPlugin);

    const opacityShortcutPlugin = new OpacityShortcutPlugin();
    stage.canvas.installPlugin(opacityShortcutPlugin);

    if (
      session.isPluginLoaded("ExternalDesignerPluginsProvider") &&
      session.executeFunction("ExternalDesignerPluginsProvider.get")
    ) {
      const externalPlugins = session.executeFunction(
        "ExternalDesignerPluginsProvider.get"
      );
      externalPlugins.forEach((pluginData: any) => {
        // TODO: add readonly check
        const plugin = new pluginData.plugin();
        stage.canvas.installPlugin(plugin);
      });
    }
    setTimeout(() => {
      if (session.readonly) {
        stage.canvas.executeFunction("FlexDrag.disable");
        stage.canvas.executeFunction("FontResizer.disable");
      }
    }, 3000);
  }

  if (!thumbnailStage && !session.envConfig.isSharedComponentInstance) {
    const statusBarPlugin = new StatusBar();
    stage.canvas.installPlugin(statusBarPlugin);
  }

  const fontResizerPlugin = new FontResizerPlugin();
  stage.canvas.installPlugin(fontResizerPlugin);

  // TODO: Use this to set snap config

  if (
    stage.id !== BX_PREVIEW_FILE_PATH &&
    !thumbnailStage &&
    !session.envConfig.isSharedComponentInstance
  ) {
    stage.canvas.executeFunction("setSnapConfig", {
      snap: session.drivers.configuration.get("editor.snap"),
      parentSnap: session.drivers.configuration.get("editor.snap.parent"),
      siblingSnap: session.drivers.configuration.get("editor.snap.sibling"),
      gutterSnap: session.drivers.configuration.get("editor.snap.gutter"),
      gridSnap: session.drivers.configuration.get("editor.snap.grid"),
      rulerSnap: session.drivers.configuration.get("editor.snap.ruler")
    });

    stage.canvas.executeFunction(
      "setSnapBound",
      session.drivers.configuration.get("editor.snap.snapMagnet")
    );
  }

  // stage.canvas.setStyle({
  //   backgroundColor: "teal"
  // });

  // try {
  //   await stage.canvas.executeFunction(
  //     "addArtboard",
  //     "/src/screens/Untitled.js"
  //   );
  //   // await stage.canvas.executeFunction(
  //   //   "addArtboard",
  //   //   "/src/screens/Untitled2.js"
  //   // );

  //   // const myArtboard = await stage.canvas.executeFunction(
  //   //   "getArtboard",
  //   //   "/src/screens/Untitled.js"
  //   // );
  // } catch (err) {
  //   console.error(err);
  // }

  // stage.canvas.addEventListener("click", (e: any) => {
  //   const layer = e.target;
  //   const domainRef = layer.executeFunction("getData", "domainRef");
  //   if (domainRef) {
  //     console.log("Domain Ref ^^^", [domainRef]);
  //     session.commandManager.executeAndSkip(
  //       new SelectLayers(session, [domainRef])
  //     );
  //   }
  // });

  if (!window["debug"]) {
    if (stage.id !== BX_PREVIEW_FILE_PATH && !thumbnailStage) {
      if (process.env.NODE_ENV !== "production") {
        try {
          stage.canvas.executeFunction("hideConstructionLines");
        } catch (err) {
          console.log(err);
        }
      }
    }
  }

  stage.canvas.setScroll({
    x: 0.5,
    y: 0.5
  });

  stage.canvas.addEventListener(
    "selectArtboard",
    (selectArtboardEvent: Event) => {
      const artboardDomainRef = selectArtboardEvent.target.executeFunction(
        "getData",
        "domainRef"
      );

      if (artboardDomainRef instanceof DomainFile) {
        session.commandManager.executeAndSkip(
          new SelectFile(session, artboardDomainRef)
        );
      }
    }
  );

  stage.canvas.addEventListener(
    "StageDesignerPreviewMode.selectArtboard",
    (selectArtboardEvent: Event) => {
      const artboardDomainRef = selectArtboardEvent.target.executeFunction(
        "getData",
        "domainRef"
      );

      if (artboardDomainRef instanceof DomainFile) {
        session.commandManager.executeAndSkip(
          new SelectFile(session, artboardDomainRef)
        );

        session.commandManager.executeAndSkip(
          new SetZoom(session, session.calculateZoom())
        );
      }
    }
  );
  stage.canvas.addEventListener("mouseenter", (e: any) => {
    if (!session.currentStage.canvas.executeFunction("GradientEditor.isOpen")) {
      //TODO: heavy-jugaad
      if (session.currentStage.canvas.selectedLayers.length) {
        session.currentStage.canvas.executeFunction("ResizerRenderer.show");
      }
    }
  });

  stage.canvas.addEventListener("mousemove", (e: any) => {
    onMouseMove(session, {
      x: e.worldX,
      y: e.worldY
    });
  });

  if (stage.id === "artboard") {
    stage.canvas.executeFunction("addPlusButton", "Add Artboard", () => {
      if (session.readonly) {
        return;
      }
      if (
        session.currentStage.canvas.executeFunction("GradientEditor.isOpen")
      ) {
        session.currentStage.canvas.dispatchEvent(
          `GradientEditor.close`,
          new GradientEditorEvent(
            `GradientEditor.close`,
            session.currentStage.canvas
          )
        );
      }
      session.commandManager.execute(
        new AddNewArtboard(session, undefined, "artboard", true, true)
      );
    });
    stage.canvas.executeFunction("showPlusButton");
  }

  stage.canvas.addEventListener("MouseRect.drawEnd", (data: any) => {
    let layers = data.payload.filter((layer: any) => layer.type !== "canvas");
    let domainRefArray = [];
    for (let layer of layers) {
      let domainRef = layer.executeFunction("getData", "domainRef");
      if (domainRef && domainRef.type !== "file") {
        domainRefArray.push(domainRef);
      }
    }
    if (domainRefArray.length > 0) {
      session.commandManager.executeAndSkip(
        new SelectLayers(session, domainRefArray)
      );
    } else {
      session.commandManager.executeAndSkip(new SelectRootLayer(session));
    }
  });

  stage.canvas.addEventListener("selectLayers", (selectLayersEvent: any) => {
    let toSelectLayers: Array<any> = [];
    selectLayersEvent.layers.forEach((layer: Layer) => {
      const domainRef = layer.executeFunction("getData", "domainRef");
      if (domainRef) {
        toSelectLayers.push(domainRef);
      }
    });
    session.commandManager.executeAndSkip(
      new SelectLayers(session, toSelectLayers)
    );
  });

  // TODO: export HoverEvent from designer index
  stage.canvas.addEventListener("Canvas.hoverLayers", (data: any) => {
    if (data.payload.length === 1 && data.payload[0].type === "canvas") {
      session.commandManager.executeAndSkip(
        new RemoveHoveredForAllLayers(session)
      );
    } else {
      let layers = data.payload.filter((layer: any) => layer.type !== "canvas");
      let domainRefArray = [];
      for (let layer of layers) {
        let domainRef = layer.executeFunction("getData", "domainRef");
        if (domainRef && domainRef.type !== "file") {
          domainRefArray.push(domainRef);
        }
      }
      if (domainRefArray.length > 0) {
        session.commandManager.executeAndSkip(
          new SetHoveredLayers(session, domainRefArray, false)
        );
      }
    }
  });
  stage.canvas.addEventListener("MouseRect.draw", (data: any) => {
    let layers = data.payload.filter((layer: any) => layer.type !== "canvas");
    let domainRefArray = [];
    for (let layer of layers) {
      let domainRef = layer.executeFunction("getData", "domainRef");
      if (domainRef && domainRef.type !== "file") {
        domainRefArray.push(domainRef);
      }
    }
    if (domainRefArray.length > 0) {
      session.commandManager.executeAndSkip(
        new SetHoveredLayers(session, domainRefArray, true)
      );
    }
  });

  stage.canvas.addEventListener("drop", (event: any) => {
    if (session.selectedSharedComponent) {
      //   let position = this.getPosition(mouseEvent);
      if (session.selectedSharedComponent.external) {
        //     onEvent({
        //       originalEvent: mouseEvent,
        //       type: "insertSharedComponent",
        //       payload: {
        //         x: position.x / session.currentStage.tools.zoom,
        //         y: position.y / session.currentStage.tools.zoom
        //       }
        //     });
        selectHitArtboard(session, event);
        let parentLayer = session.currentRootLayer;
        if (!parentLayer || !session.selectedSharedComponent) {
          return;
        }
        let parentRenderCompiledLayer = parentLayer.getBoundingClientRect();
        let x = event.worldX - parentRenderCompiledLayer.rootX;
        let y = event.worldY - parentRenderCompiledLayer.rootY;

        stopChildrenLayoutUpdates();
        stopRerender();
        session.commandManager.execute(
          new InsertSharedComponent(
            session,
            session.selectedSharedComponent.library,
            session.selectedSharedComponent.class,
            session.selectedSharedComponent.name,
            { left: x, top: y }
          )
        );
        startChildrenLayoutUpdates();
        startRerender();
      } else {
        const symbolPath = session.selectedSharedComponent.symbolPath;

        if (!symbolPath) {
          return;
        }

        const file = session.domain.files.get(symbolPath);
        if (!file) {
          return;
        }
        selectHitArtboard(session, event);
        let rootLayer = session.currentRootLayer;
        if (!rootLayer || !session.selectedSharedComponent) {
          return;
        }

        const rootRenderLayer = rootLayer.getBoundingClientRect();
        const x = event.worldX - rootRenderLayer.rootX;
        const y = event.worldY - rootRenderLayer.rootY;
        session.commandManager.execute(
          new InsertSymbolInstance(session, file, {
            x: x,
            y: y
          })
        );
      }
    }
  });

  //TODO: heavy-jugaad

  stage.canvas.addEventListener(
    "StageDesignerDrawComponent.mousemove",
    (e: any) => {
      onMouseMove(session, {
        x: e.worldX,
        y: e.worldY
      });
    }
  );
  stage.canvas.addEventListener("StageDesignerDrawComponent.draw", (e: any) => {
    //
    //TODO: heavy-jugaad
    onMouseMove(session, {
      x: e.worldX,
      y: e.worldY
    });
    // console.log(e.worldX, e.worldY, "world point");
  });
  stage.canvas.addEventListener(
    "StageDesignerDrawComponent.drawEnd",
    async (data: any) => {
      if (session.readonly) {
        return;
      }
      const drawType = session.currentStage.tools.draw.getType();
      if (drawType !== "default") {
        const LayerDefinition = session.currentStage.canvas.getComponentDefinition(
          drawType
        );
        const layerJSON = Utils.domainLayerTemplateFromCanvasTemplate(
          LayerDefinition.template
        );
        let { x, y, width, height } = data.dimensions;
        let isDimensionLessType = [
          "icon",
          "switch",
          "activityIndicator"
        ].includes(drawType);
        if ((height < 3 && width < 3) || isDimensionLessType) {
          session.commandManager.executeAndSkip(
            new SelectTool(session, "default")
          );
          let newDim =
            drawType === "text" || isDimensionLessType
              ? { height: undefined, width: undefined }
              : await getDimension();
          height = newDim.height;
          width = newDim.width;
        }
        if (height < 1) {
          height = 1;
        }
        if (width < 1) {
          width = 1;
        }
        let styles = {
          position: "absolute",
          left: x,
          top: y,
          height,
          width
        };
        layerJSON.props.style = {
          ...layerJSON.props.style,
          ...styles
        };
        if (drawType === "icon") {
          await updateIcon(session, layerJSON);
        }
        if (session.currentRootLayer) {
          session.commandManager.execute(
            new AddLayer(
              session,
              session.currentRootLayer,
              cloneDeep(layerJSON)
            )
          );
        }
      }
      action(() => {
        session.commandManager.executeAndSkip(
          new SelectTool(session, "default")
        );
        let createdLayer = get(session, "selectedLayers[0]");
        if (
          createdLayer &&
          (createdLayer.type === "text" || createdLayer.type === "textInput")
        ) {
          stage.canvas.executeFunction("ResizerRenderer.hide");
          stage.canvas.executeFunction(
            "TextEditorPlugin.mountEditor",
            createdLayer.getOwnCanvasRef()
          );
        }
      });
    }
  );
  // stage.canvas.addEventListener("PathEditor.addNew", (data: PathEvent) => {
  //   if (session.readonly) {
  //     return;
  //   }
  //   const { style, viewBox, points, isClosed } = data.payload;
  //   const pathLayerDefinition = session.currentStage.canvas.getComponentDefinition(
  //     "path"
  //   );
  //   const pathLayer = cloneDeep(pathLayerDefinition.template);
  //   const selectedFile = session.getSelectedFile();
  //   let artboard;
  //   if (selectedFile) {
  //     artboard = selectedFile.layer.getBoundingClientRect();
  //   }
  //   pathLayer.props.type = "path";
  //   pathLayer.props.strokeWidth = "0";
  //   pathLayer.props.fill = "rgba(230, 230, 230,1)";
  //   pathLayer.props.stroke = "grey";
  //   pathLayer.props.viewBox = viewBox;
  //   pathLayer.props.points = points;
  //   pathLayer.props.isClosed = isClosed;
  //   pathLayer.props.style = {
  //     width: style.width,
  //     height: style.height,
  //     position: style.position,
  //     top: artboard ? style.top - artboard.rootY : style.top,
  //     left: artboard ? style.left - artboard.rootX : style.left
  //   };
  //   session.commandManager.execute(
  //     new AddLayer(session, session.currentRootLayer, pathLayer)
  //   );
  //   session.commandManager.executeAndSkip(new SelectTool(session, "default"));
  // });

  // stage.canvas.addEventListener(
  //   "PathEditor.selectParent",
  //   (data: MouseEvent) => {
  //     const artboard = session.currentStage.canvas.executeFunction(
  //       "getHitArtboard",
  //       data.worldX,
  //       data.worldY
  //     );
  //     if (artboard) {
  //       const targetFile = artboard.executeFunction("getData", "domainRef");
  //       if (targetFile) {
  //         session.commandManager.executeAndSkip(
  //           new SelectFile(session, targetFile)
  //         );
  //       }
  //     }
  //   }
  // );

  // stage.canvas.addEventListener("PathEditor.isClosed", (data: PathEvent) => {
  //   action(() => {
  //     stage.canvas.executeFunction("ResizerRenderer.show");
  //     session.currentStage.canvas.executeFunction("Hover.showAllHoverBoxes");
  //     if (session.currentStage.tools.selectedTool === "path") {
  //       session.commandManager.executeAndSkip(
  //         new SelectTool(session, "default")
  //       );
  //     }
  //   });
  // });
  // stage.canvas.addEventListener(
  //   "PathEditor.finishEditing",
  //   (data: PathEvent) => {
  //     action(() => {
  //       stage.canvas.executeFunction("ResizerRenderer.show");
  //       session.currentStage.canvas.executeFunction("Hover.showAllHoverBoxes");
  //       if (session.currentStage.tools.selectedTool === "path") {
  //         session.commandManager.executeAndSkip(
  //           new SelectTool(session, "default")
  //         );
  //       }
  //     });
  //   }
  // );

  if (!session.drivers.configuration.get("editor.show.ruler")) {
    if (
      stage.id !== BX_PREVIEW_FILE_PATH &&
      !thumbnailStage &&
      !session.envConfig.isSharedComponentInstance
    ) {
      stage.canvas.executeFunction("StageDesignerRuler.hide");
    }
  }

  stage.canvas.addEventListener("click", (e: any) => {
    if (dragHasEndedJustNow) {
      return;
    }
    selectTargetLayer(e, session, stage);
  });

  stage.canvas.addEventListener("LayerLabel.click", (event: any) => {
    // select root layer if artboard label is clicked
    const rootLayer = get(event, "target.children.0", event.target);

    const targetLayer = rootLayer.executeFunction("getData", "domainRef");

    if (targetLayer) {
      session.commandManager.executeAndSkip(
        new SelectLayers(session, [targetLayer])
      );
      session.commandManager.executeAndSkip(
        new SetResizerVisibility(
          session,
          rootLayer.parent.executeFunction("getData", "domainRef"),
          "show"
        )
      );
    }
  });

  stage.canvas.addEventListener(
    "LayerLabel.doubleClick",
    async (event: any) => {
      if (session.readonly) {
        return;
      }
      // select root layer if artboard label is clicked
      const artboardCanvasLayer = event.target;
      const file = artboardCanvasLayer.executeFunction("getData", "domainRef");
      let fileName = path.basename(file.path);
      const newFileName = await Utils.getFileNameUserInput(
        session,
        Prompt,
        fileName,
        "Rename File"
      );
      if (
        newFileName &&
        typeof newFileName === "string" &&
        session.selectedFile
      ) {
        // artboardCanvasLayer.executeFunction("setLabel", newFileName + ".js");
        action(() => {
          session.commandManager.execute(
            new RenameFileName(session, file as DomainFile, newFileName)
          );
        });
      }
    }
  );
  stage.canvas.addEventListener("contextmenu", (e: any) => {
    const layer = e.target;
    if (!layer) {
      return;
    }
    const domainLayer = layer.executeFunction("getData", "domainRef");
    session.commandManager.executeAndSkip(
      new RemoveHoveredForAllLayers(session)
    );
    if (domainLayer) {
      if (
        !session.getLayersFromSelectedLayerCollection().includes(domainLayer)
      ) {
        session.commandManager.executeAndSkip(
          new SelectLayers(session, [domainLayer])
        );
      }
    } else {
      session.commandManager.executeAndSkip(new DeselectAllLayers(session));
    }
    if (!session.readonly) {
      session.eventManager.dispatchEvent(
        "contextmenu",
        new SessionEvent("contextmenu", {
          originalEvent: e.originalEvent,
          hotspotData: { area: "canvas" }
        })
      );
    }
  });
  stage.canvas.addEventListener(
    "LayerResizer.dragStart",
    (e: LayerResizerEvent) => {
      if (session.readonly) {
        return;
      }
      session.currentStage.canvas.executeFunction("Hover.hideAllHoverBoxes");
      session.currentStage.dragging = true;
      let domainLayer = e.target.executeFunction("getData", "domainRef");
      // DOC: case for duplicate + drag
      const isFile = domainLayer.type === "file";
      if (session.keyboardService.getCurrentKey().includes("alt") && !isFile) {
        // lock children index on layer drag start

        session.commandManager.execute(
          new DuplicateLayers(session, [domainLayer])
        );
        domainLayer = session.getLayersFromSelectedLayerCollection()[0];
        const canvasLayer = domainLayer.getOwnCanvasRef();
        const initialDims = canvasLayer.getBoundingClientRect();
        canvasLayer.executeFunction("setData", "initialDims", initialDims);
        session.currentStage.canvas.dispatchEvent(
          "resetResizer",
          new MouseEvent(
            "resetResizer",
            session.currentStage.canvas,
            e.originalEvent
          )
        );
      }

      stopChildrenLayoutUpdates();
      stopAndBatchLayoutUpdates();
      if (domainLayer.type !== "file") {
        session.commandManager.executeAndSkip(
          new SetCenterWrapper(session, domainLayer, {
            horizontal: false,
            vertical: false
          })
        );
      }
      session.commandManager.executeAndForget(
        new SetLayerDimensions(session, domainLayer, e.payload)
      );

      onLayerDragStart(session, session.getLayersFromSelectedLayerCollection());

      resumeLayoutUpdates();
      startChildrenLayoutUpdates();
    }
  );
  stage.canvas.addEventListener("LayerResizer.drag", (e: LayerResizerEvent) => {
    if (session.readonly) {
      return;
    }

    //TODO: heavy-jugaad
    onMouseMove(session, {
      x: e.originalEvent.worldX,
      y: e.originalEvent.worldY
    });

    stopChildrenLayoutUpdates();
    stopAndBatchLayoutUpdates();
    const targetLayer = e.target.executeFunction("getData", "domainRef");
    if (targetLayer) {
      session.commandManager.executeAndSkip(
        new SetLayerDimensions(session, targetLayer, e.payload)
      );
    }
    resumeLayoutUpdates();
    startChildrenLayoutUpdates();
  });
  stage.canvas.addEventListener("FlexDrag.dragStart", (data: any) => {
    session.currentStage.dragging = true;
    session.currentStage.canvas.executeFunction("Hover.hideAllHoverBoxes");
    session.currentStage.canvas.executeFunction("ResizerRenderer.hide");
    onLayerDragStart(session, session.getLayersFromSelectedLayerCollection());
  });
  stage.canvas.addEventListener("FlexDrag.dragEnd", (data: any) => {
    session.currentStage.dragging = false;
    session.currentStage.canvas.executeFunction("Hover.showAllHoverBoxes");
    session.currentStage.canvas.executeFunction("ResizerRenderer.show");
    onLayerDragEnd(session, session.getLayersFromSelectedLayerCollection());
  });

  stage.canvas.addEventListener(
    "LayerResizer.dragEnd",
    (e: LayerResizerEvent) => {
      if (session.readonly) {
        return;
      }
      session.commandManager.executeAndSkip(
        new RemoveHoveredForAllLayers(session)
      );
      session.currentStage.canvas.executeFunction("Hover.showAllHoverBoxes");
      session.currentStage.dragging = false;
      const targetLayer = e.target.executeFunction("getData", "domainRef");

      stopAndBatchLayoutUpdates();

      if (targetLayer) {
        session.commandManager.execute(
          new SetLayerDimensions(session, targetLayer, e.payload)
        );
      }

      resumeLayoutUpdates();

      if (targetLayer && targetLayer.type !== "file") {
        if (session.getLayersFromSelectedLayerCollection().length === 1) {
          // logic for setting center wrapper
          if (
            e.meta &&
            e.meta.snappedSide.x &&
            e.meta.snappedSide.x.snappedSide &&
            e.meta.snappedSide.x.snappedSide.center &&
            e.meta.snappedSide.x.snapType === "documentBounds"
          ) {
            session.commandManager.executeAndSkip(
              new SetCenterWrapper(session, targetLayer, {
                horizontal: true
              })
            );
          }
          if (
            e.meta &&
            e.meta.snappedSide.y &&
            e.meta.snappedSide.y.snappedSide &&
            e.meta.snappedSide.y.snappedSide.center &&
            e.meta.snappedSide.y.snapType === "documentBounds"
          ) {
            session.commandManager.executeAndSkip(
              new SetCenterWrapper(session, targetLayer, {
                vertical: true
              })
            );
          }
        }
      }

      dragHasEndedJustNow = true;
      setTimeout(() => {
        dragHasEndedJustNow = false;
      }, 10);

      onLayerDragEnd(session, session.getLayersFromSelectedLayerCollection());
    }
  );
  stage.canvas.addEventListener(
    "LayerResizer.handleDragStart",
    (e: LayerResizerEvent) => {
      if (session.readonly) {
        return;
      }
      session.currentStage.dragging = true;
      session.currentStage.canvas.executeFunction("Hover.hideAllHoverBoxes");

      const targetLayer = e.target.executeFunction("getData", "domainRef");
      stopChildrenLayoutUpdates();
      stopAndBatchLayoutUpdates();

      if (targetLayer && targetLayer.type !== "file") {
        session.commandManager.executeAndSkip(
          new SetCenterWrapper(session, targetLayer, {
            horizontal: false,
            vertical: false
          })
        );
      }
      if (e.payload.height >= 1 && e.payload.width >= 1) {
        session.commandManager.executeAndForget(
          new SetLayerDimensions(session, targetLayer, e.payload)
        );
      }
      onLayerDragStart(session, session.getLayersFromSelectedLayerCollection());

      resumeLayoutUpdates();
      startChildrenLayoutUpdates();
    }
  );
  stage.canvas.addEventListener(
    "LayerResizer.handleDrag",
    (e: LayerResizerEvent) => {
      if (session.readonly) {
        return;
      }

      onMouseMove(session, {
        x: e.originalEvent.worldX,
        y: e.originalEvent.worldY
      });

      stopChildrenLayoutUpdates();
      stopAndBatchLayoutUpdates();
      const targetLayer = e.target.executeFunction("getData", "domainRef");
      if (targetLayer) {
        if (e.payload.height < 0) {
          e.payload.y = e.payload.y + e.payload.height;
          e.payload.height = Math.abs(e.payload.height);
        }
        if (e.payload.width < 0) {
          e.payload.x = e.payload.x + e.payload.width;
          e.payload.width = Math.abs(e.payload.width);
        }
        session.commandManager.executeAndSkip(
          new SetLayerDimensions(session, targetLayer, e.payload)
        );
      }

      resumeLayoutUpdates();
      startChildrenLayoutUpdates();
    }
  );

  stage.canvas.addEventListener(
    "LayerResizer.handleDragEnd",
    (e: LayerResizerEvent) => {
      if (session.readonly) {
        return;
      }
      session.currentStage.dragging = false;
      session.commandManager.executeAndSkip(
        new RemoveHoveredForAllLayers(session)
      );
      session.currentStage.canvas.executeFunction("Hover.showAllHoverBoxes");

      const targetLayer = e.target.executeFunction("getData", "domainRef");
      if (e.payload.height >= 1 && e.payload.width >= 1) {
        stopAndBatchLayoutUpdates();

        if (targetLayer) {
          session.commandManager.execute(
            new SetLayerDimensions(session, targetLayer, e.payload)
          );
        }

        resumeLayoutUpdates();

        // TODO: heavy jugaad
        handlingDragEnd = true;

        setTimeout(() => {
          if (handlingDragEnd && session.showCodeEditor) {
            session.commandManager.executeAndSkip(
              new GenerateLayerPreview(session, [
                ...session.getLayersFromSelectedLayerCollection()
              ])
            );
          }
          // designerAction(() => {
          //   action(() => {
          //     if (handlingDragEnd && session.showCodeEditor) {
          //       GenerateLayerPreview(session, [
          //         ...session.selectedLayers.map(l => l.getFullPath())
          //       ]);
          //     }
          //   });
          // });

          handlingDragEnd = false;
        }, 300);
      }
      onLayerDragEnd(session, session.getLayersFromSelectedLayerCollection());
    }
  );

  stage.canvas.addEventListener("LayerResizer.handleDragLayout", (e: any) => {
    if (session.readonly) {
      return;
    }

    stopChildrenLayoutUpdates();
    stopAndBatchLayoutUpdates();
    const targetLayer = e.target.executeFunction("getData", "domainRef");
    if (e.payload.flex > 0 && targetLayer) {
      session.commandManager.executeAndSkip(
        new SetAllStyle(session, targetLayer, e.payload)
      );
    }

    resumeLayoutUpdates();
    startChildrenLayoutUpdates();
  });
  stage.canvas.addEventListener(
    "LayerResizer.handleDragEndLayout",
    (e: any) => {
      if (session.readonly) {
        return;
      }
      session.currentStage.dragging = false;
      session.commandManager.executeAndSkip(
        new RemoveHoveredForAllLayers(session)
      );

      session.currentStage.canvas.executeFunction("Hover.showAllHoverBoxes");
      const targetLayer = e.target.executeFunction("getData", "domainRef");
      stopAndBatchLayoutUpdates();
      if (e.payload.flex > 0 && targetLayer) {
        session.commandManager.execute(
          new SetAllStyle(session, targetLayer, e.payload)
        );
      }
      resumeLayoutUpdates();

      // TODO: heavy jugaad
      handlingDragEnd = true;

      setTimeout(() => {
        if (handlingDragEnd && session.showCodeEditor) {
          session.commandManager.executeAndSkip(
            new GenerateLayerPreview(session, [
              ...session.getLayersFromSelectedLayerCollection()
            ])
          );
        }
        handlingDragEnd = false;
      }, 300);
    }
  );

  let duplicationStarted = false;
  stage.canvas.addEventListener("layerDragStart", (data: any) => {
    if (session.readonly) {
      return;
    }

    session.currentStage.dragging = true;
    let dragLayer = data.target;
    session.currentStage.canvas.executeFunction("Hover.hideAllHoverBoxes");
    let domainLayer = dragLayer.executeFunction("getData", "domainRef");

    if (!domainLayer) {
      return;
    }

    // lock children index on layer drag start

    const file = domainLayer.getFile();
    if (file) {
      session.commandManager.executeAndSkip(new SelectFile(session, file));
    }
    const isFile = domainLayer.type === "file";
    // DOC: case for duplicate + drag
    if (
      session.keyboardService.getCurrentKey().includes("alt") &&
      !duplicationStarted &&
      !isFile
    ) {
      session.commandManager.executeAndSkip(
        new DuplicateLayers(session, [domainLayer])
      );
      domainLayer = session.getLayersFromSelectedLayerCollection()[0];
      const mouseDownEvent = new MouseEvent(
        "mousedown",
        domainLayer.getOwnCanvasRef(),
        data.originalEvent,
        domainLayer.getOwnCanvasRef()
      );
      session.currentStage.canvas.dispatchEventOnHitLayer(
        "mousedown",
        mouseDownEvent
      );
      duplicationStarted = true;
    } else {
      duplicationStarted = false;
    }
    if (domainLayer) {
      if (
        !session.getLayersFromSelectedLayerCollection().includes(domainLayer)
      ) {
        session.commandManager.executeAndSkip(new DeselectAllLayers(session));
      }

      stopChildrenLayoutUpdates();
      stopAndBatchLayoutUpdates();

      if (domainLayer.template && domainLayer.type !== "file") {
        session.commandManager.executeAndSkip(
          new SetCenterWrapper(session, domainLayer, {
            horizontal: false,
            vertical: false
          })
        );
      }

      session.commandManager.executeAndForget(
        new SetAllStyle(session, domainLayer, data.layout)
      );
      resumeLayoutUpdates();
      startChildrenLayoutUpdates();
    }

    onLayerDragStart(session, [domainLayer]);
  });
  stage.canvas.addEventListener("layerDrag", (data: any) => {
    if (session.readonly) {
      return;
    }
    stopChildrenLayoutUpdates();
    let selectedLayer = data.target;
    const targetLayer = selectedLayer.executeFunction("getData", "domainRef");
    if (selectedLayer && targetLayer) {
      // onLayerDrag(session, targetLayer);

      stopAndBatchLayoutUpdates();
      session.commandManager.executeAndSkip(
        new SetAllStyle(session, targetLayer, data.layout)
      );
      resumeLayoutUpdates();
    }
    startChildrenLayoutUpdates();
  });

  stage.canvas.addEventListener("layerDragEnd", (data: any) => {
    if (session.readonly) {
      return;
    }
    session.currentStage.dragging = false;
    session.commandManager.executeAndSkip(
      new RemoveHoveredForAllLayers(session)
    );
    session.currentStage.canvas.executeFunction("Hover.showAllHoverBoxes");
    let selectedLayer = data.target;
    const targetLayer = selectedLayer.executeFunction("getData", "domainRef");
    if (selectedLayer && targetLayer) {
      stopAndBatchLayoutUpdates();

      session.commandManager.execute(
        new SetAllStyle(session, targetLayer, data.layout)
      );
      resumeLayoutUpdates();
    }

    if (targetLayer && targetLayer.type !== "file") {
      if (session.getLayersFromSelectedLayerCollection().length === 1) {
        if (
          data.meta &&
          data.meta.snappedSide.x &&
          data.meta.snappedSide.x.snappedSide &&
          data.meta.snappedSide.x.snappedSide.center &&
          data.meta.snappedSide.x.snapType === "documentBounds"
        ) {
          session.commandManager.executeAndSkip(
            new SetCenterWrapper(session, targetLayer, {
              horizontal: true
            })
          );
        }
        if (
          data.meta &&
          data.meta.snappedSide.y &&
          data.meta.snappedSide.y.snappedSide &&
          data.meta.snappedSide.y.snappedSide.center &&
          data.meta.snappedSide.y.snapType === "documentBounds"
        ) {
          session.commandManager.executeAndSkip(
            new SetCenterWrapper(session, targetLayer, {
              vertical: true
            })
          );
        }
      }

      if (targetLayer.type === "file") {
        session.commandManager.executeAndSkip(
          new SelectFile(session, targetLayer)
        );
      } else {
        session.commandManager.executeAndSkip(
          new SelectLayers(session, [targetLayer])
        );
      }
    }

    onLayerDragEnd(session, [targetLayer]);
  });

  stage.canvas.addEventListener("setStyleAttribute", (event: any) => {
    if (session.readonly) {
      return;
    }
    let domainLayer: DomainLayer = event.commandParams.layer.executeFunction(
      "getData",
      "domainRef"
    );
    let applyOp = true;
    if (
      domainLayer instanceof DomainFile &&
      event.commandParams.key === "opacity"
    ) {
      if (
        !(
          domainLayer.isResizerVisible ||
          (!domainLayer.isResizerVisible &&
            domainLayer.layer &&
            !get(domainLayer, "layer.children.length"))
        )
      ) {
        applyOp = false;
      }
      domainLayer = domainLayer.layer;
    }
    if (applyOp) {
      const command = new SetStyleAttribute(
        session,
        domainLayer,
        event.commandParams.key,
        event.commandParams.value,
        event.commandParams.stylePropName
      );
      switch (event.type) {
        case "Forget":
          session.commandManager.executeAndForget(command);
          break;
        case "Skip":
          session.commandManager.executeAndSkip(command);
          break;
        default:
          session.commandManager.execute(command);
          break;
      }
    }
  });

  stage.canvas.addEventListener("moveLayer", (event: any) => {
    if (session.readonly) {
      return;
    }
    const fromParent: DomainLayer = event.commandParams.fromParent.executeFunction(
      "getData",
      "domainRef"
    );
    const toParent: DomainLayer = event.commandParams.toParent.executeFunction(
      "getData",
      "domainRef"
    );
    session.commandManager.execute(
      new MoveLayer(
        session,
        fromParent,
        toParent,
        event.commandParams.fromIndex,
        event.commandParams.toIndex,
        undefined,
        undefined,
        undefined,
        undefined,
        fromParent === toParent
      )
    );
  });

  stage.canvas.addEventListener("FontResizer.setFontSize", (data: any) => {
    if (session.readonly) {
      return;
    }

    // Don't use the code below
    // No original event here, if important to update cursor position, find another way
    // onMouseMove(session, {
    //   x: data.originalEvent.worldX,
    //   y: data.originalEvent.worldY
    // });
    session.commandManager.executeAndSkip(
      new SetStyleAttribute(
        session,
        session.getLayersFromSelectedLayerCollection()[0],
        "fontSize",
        data.fontSize,
        "style"
      )
    );
  });
  stage.canvas.addEventListener("FontResizer.setPosition", (data: any) => {
    if (session.readonly) {
      return;
    }

    session.commandManager.executeAndForget(
      new SetLayerDimensions(
        session,
        session.getLayersFromSelectedLayerCollection()[0],
        {
          x: data.x,
          y: data.y,
          height: undefined,
          width: undefined,
          rotation: data.target.rotation
        }
      )
    );
  });
  stage.canvas.addEventListener("FontResizer.dragStart", (data: any) => {
    if (session.readonly) {
      return;
    }

    // lock children index on layer drag start
    onLayerDragStart(session, session.getLayersFromSelectedLayerCollection());

    session.commandManager.executeAndForget(
      new SetStyleAttribute(
        session,
        session.getLayersFromSelectedLayerCollection()[0],
        "fontSize",
        get(
          session.getLayersFromSelectedLayerCollection()[0],
          "props.style.fontSize",
          14
        ),
        "style"
      )
    );
    session.currentStage.canvas.executeFunction("Hover.hideAllHoverBoxes");
  });
  stage.canvas.addEventListener("FontResizer.dragEnd", (data: any) => {
    if (session.readonly) {
      return;
    }

    onLayerDragEnd(session, session.getLayersFromSelectedLayerCollection());

    session.commandManager.execute(
      new SetStyleAttribute(
        session,
        session.getLayersFromSelectedLayerCollection()[0],
        "fontSize",
        get(
          session.getLayersFromSelectedLayerCollection()[0],
          "props.style.fontSize",
          14
        ),
        "style"
      )
    );
    session.currentStage.canvas.executeFunction("Hover.showAllHoverBoxes");
  });
  if (
    stage.id !== "artboard" &&
    stage.id !== BX_PREVIEW_FILE_PATH &&
    !thumbnailStage &&
    !session.envConfig.isSharedComponentInstance
  ) {
    stage.canvas.executeFunction(
      "addFloatingButton",
      "Back to Main Screen",
      () => {
        session.commandManager.execute(
          new SetCurrentStage(session, "artboard")
        );
      }
    );
  }

  stage.canvas.addEventListener("removeLayer", (event: any) => {
    if (session.readonly) {
      return;
    }
    const domainLayer: DomainLayer = event.commandParams.layer.executeFunction(
      "getData",
      "domainRef"
    );
    session.commandManager.execute(new RemoveLayer(session, domainLayer));
  });

  if (
    stage.id !== BX_PREVIEW_FILE_PATH &&
    !thumbnailStage &&
    !session.envConfig.isSharedComponentInstance
  ) {
    const snapLinePlugin = new SnapLinesPlugin();
    stage.canvas.installPlugin(snapLinePlugin);
  }
}

function applySideEffects(
  session: Session,
  stageId: string,
  thumbnailStage: boolean = false
) {
  const stage = !thumbnailStage
    ? session.stages.get(stageId)
    : session.thumbnailStages.get(stageId);

  // const stage = session.stages.get(stageId);

  if (stage) {
    setupStageDesigner(session, stage, thumbnailStage);
  }
}

async function updateIcon(session: Session, layerJSON: any) {
  const iconFamily = "All";

  const iconName = undefined;

  let response: any = await IconModalDialog(true, iconFamily, iconName);
  if (layerJSON && response && response.iconName && response.iconFamily) {
    layerJSON.props.name = response.iconName;
    layerJSON.props.type = response.iconFamily;
  }
}
export default function AddStageGlue(session: Session, e: SessionEvent) {
  applySideEffects(session, e.payload.stageId, e.payload.thumbnailStage);
}
