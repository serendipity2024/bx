import { DomainLayer, LogicalExpression } from "domain-x";
import { Layer, PathEvent } from "@builderx-core/designer";
import { forEach, find, cloneDeep } from "lodash";
import { SessionEvent } from "event-manager";
import { Session, StageArtboard, Mutators } from "session";
import { globalRefMap } from "global-ref-map";
import { Utils } from "utils";

type Center = {
  vertical?: boolean;
  horizontal?: boolean;
};

const removeCenterWrapper = (
  session: Session,
  domainLayer: DomainLayer
  // centerHorizontal: boolean,
  // centerVertical: boolean
) => {
  // if (!centerHorizontal && !centerVertical) {
  //   return;
  // }

  const domainCompiledLayers = globalRefMap.get(domainLayer);

  if (domainCompiledLayers) {
    forEach(domainCompiledLayers, (compiledLayer: Layer, index: any) => {
      const centerWrapper = compiledLayer.parent;

      if (
        centerWrapper &&
        centerWrapper.style.get("pointerEvents") === "none"
      ) {
        const parentLayer = centerWrapper ? centerWrapper.parent : null;
        if (centerWrapper && centerWrapper.parent && parentLayer) {
          const index = parentLayer.children.indexOf(centerWrapper);

          centerWrapper.removeChild(compiledLayer);
          parentLayer.removeChild(centerWrapper);

          parentLayer.addChild(compiledLayer, index);

          // if (centerVertical) {
          //   wrapperLayerJSON.props.style["justifyContent"] = "center";
          // }
          // if (centerHorizontal) {
          //   wrapperLayerJSON.props.style["alignItems"] = "center";
          // }

          // compiledLayer.removeLayout("justifyContent");
          // compiledLayer.removeLayout("alignItems");
          // compiledLayer.removeLayout();

          forEach(domainLayer.props.style, (value: any, key: any) => {
            if (Utils.isInvalidKey(key)) {
              return;
            }

            if (session.currentStage.canvas.isValidLayoutKey(key)) {
              compiledLayer.setLayout(key, value);
            } else {
              compiledLayer.setStyle(key, value);
            }
          });
        }
      }
    });
  }
};

export const setCenterWrapperForCompiledLayer = (
  session: Session,
  domainLayer: DomainLayer,
  compiledLayer: Layer
) => {
  //

  const centerHorizontal = domainLayer.template.centerHorizontal;
  const centerVertical = domainLayer.template.centerVertical;
  if (!centerHorizontal && !centerVertical) {
    return;
  }

  const layerIndexInParent = domainLayer.findIndexInParent();

  const ViewDefinition = session.currentStage.canvas.getComponentDefinition(
    "view"
  );
  const wrapperLayerJSON = cloneDeep(ViewDefinition.template);
  wrapperLayerJSON.props.style = {
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    pointerEvents: "none",
    // backgroundColor: "red",
    position: "absolute"
  };

  if (centerVertical) {
    wrapperLayerJSON.props.style["justifyContent"] = "center";
  }
  if (centerHorizontal) {
    wrapperLayerJSON.props.style["alignItems"] = "center";
  }

  if (!compiledLayer.parent) {
    return;
  }

  const compiledParent: Layer = compiledLayer.parent;

  const CWCompiledLayer = compiledParent.getCanvas().createLayer();

  // remove the domain compiled of the layer that is being wrapped
  // from  domain compiled parent of that layer
  compiledLayer.parent.removeChild(compiledLayer); // removed compiled layer's ref from parent
  // compiledLayer.renderCompiledRef.remove(); // removed render compiled layer's ref from parent
  // add center wrapper compiled layer in parent Layer

  compiledParent.addChild(CWCompiledLayer, layerIndexInParent);

  forEach(wrapperLayerJSON.props.style, (value: any, key: any) => {
    if (session.currentStage.canvas.isValidLayoutKey(key)) {
      CWCompiledLayer.setLayout(key, value);
    } else {
      CWCompiledLayer.setStyle(key, value);
    }
  });

  // add current layer inside the center wrapper compiled layer
  CWCompiledLayer.addChild(compiledLayer, 0);
  compiledLayer.setLayout({});
  CWCompiledLayer.setLayout({});
};

const setCenterWrapper = (session: Session, domainLayer: DomainLayer) => {
  const domainCompiledLayers = globalRefMap.get(domainLayer);

  forEach(domainCompiledLayers, (compiledLayer: any, index: number) => {
    setCenterWrapperForCompiledLayer(session, domainLayer, compiledLayer);
  });
};

function applySideEffects(session: Session, domainLayer: DomainLayer) {
  //

  if (domainLayer) {
    removeCenterWrapper(session, domainLayer);

    if (domainLayer.template) {
      setCenterWrapper(session, domainLayer);
    }
  }
}

export default function SetCenterWrapperGlue(
  session: Session,
  e: SessionEvent
) {
  applySideEffects(session, e.payload.layer);
}
