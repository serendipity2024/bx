import { DomainLayer, DomainFile } from "domain-x";
import { Layer } from "@builderx-core/designer";
import { forEach } from "lodash";
import { SessionEvent } from "event-manager";
import { Session, StageArtboard, Mutators, Stage } from "session";
import { globalRefMap } from "global-ref-map";
import {
  BX_PREVIEW_FILE_PATH,
  LAYOUT_PROPERTIES_AFFECTING_CHILDREN
} from "bx-constants";
import { getOwnCanvasRef } from "../Utils";
import {
  addCompiledLayer,
  createNestedCompiledLayer,
  setOwnCanvasPropsAndStyle
} from "./AddLayerGlue";
import { setCenterWrapperForCompiledLayer } from "./SetCenterWrapperGlue";
import { setCompiledLayersProps } from "./SetPropGlue";
import { updateCompiledLayerStyle } from "./SetStyleAttributeGlue";

function createStageForDomain(
  session: Session,
  domainLayer: DomainLayer,
  stageArtboard: StageArtboard,
  stageId?: string
) {
  stageId = stageId ? stageId : `layer:${domainLayer.getFullPath()}`;

  const currentStage = session.stages.get(stageId);

  if (!currentStage) {
    return;
  }

  const domainLayerStyle = domainLayer.props.style.toJS();

  const currentCompiledLayer = getOwnCanvasRef(
    domainLayer,
    currentStage.canvas
  );

  currentStage.canvas.setScroll({ x: 0.5, y: 0.5 });

  const originalCompiledLayerLayout = domainLayer.getBoundingClientRect();
  let width = originalCompiledLayerLayout.width;
  let height = originalCompiledLayerLayout.height;

  if (domainLayer.props.getResolvedProp("horizontal")) {
    width = width * 3;
  } else {
    height = height * 3;
  }

  setCompiledLayersProps(session, stageArtboard, "style", {
    width: width,
    height: height
  });

  if (currentCompiledLayer instanceof Layer) {
    forEach(currentCompiledLayer.layout.getAll(), (value, key) => {
      if (!LAYOUT_PROPERTIES_AFFECTING_CHILDREN.includes(key)) {
        currentCompiledLayer.removeLayout(key);
      }
    });

    updateCompiledLayerStyle(session, currentCompiledLayer, "top", 0);
    updateCompiledLayerStyle(session, currentCompiledLayer, "left", 0);

    updateCompiledLayerStyle(
      session,
      currentCompiledLayer,
      "backgroundColor",
      domainLayerStyle.backgroundColor
        ? domainLayerStyle.backgroundColor
        : "white"
    );
    updateCompiledLayerStyle(session, currentCompiledLayer, "width", width);

    updateCompiledLayerStyle(session, currentCompiledLayer, "height", height);
    updateCompiledLayerStyle(
      session,
      currentCompiledLayer,
      "position",
      "absolute"
    );
  }
}

function setReferences(
  session: Session,
  stageArtboard: StageArtboard,
  canvasLayer: Layer
) {
  const domainFile = session.domain.files.get(stageArtboard.path);
  canvasLayer.executeFunction("setData", "stageArtboardRef", stageArtboard);
  canvasLayer.executeFunction("setData", "domainRef", domainFile);

  const stageArtboardRef = globalRefMap.get(stageArtboard);
  if (stageArtboardRef) {
    stageArtboardRef.splice(0, 0, canvasLayer);
  } else {
    globalRefMap.set(stageArtboard, [canvasLayer]);
  }
}

function addLayer(
  session: Session,
  currentStage: Stage,
  domainLayer: DomainLayer,
  parentDomainLayer: any
) {
  const parentCompiledLayer = getOwnCanvasRef(
    parentDomainLayer,
    currentStage.canvas
  );
  if (!parentCompiledLayer) {
    return;
  }
  const compiledLayer = addCompiledLayer(
    session,
    domainLayer,
    parentCompiledLayer,
    undefined
  );

  if (compiledLayer) {
    setCenterWrapperForCompiledLayer(session, domainLayer, compiledLayer);
  }

  if (domainLayer.props) {
    const props = domainLayer.props.toJS();

    setOwnCanvasPropsAndStyle(
      session,
      domainLayer,
      compiledLayer,
      (domainLayer.getFile() as DomainFile).scopeVariables
    );
  }
  domainLayer.children.forEach((child: any) => {
    addLayer(session, currentStage, child, domainLayer);
  });

  return compiledLayer;
}
function applySideEffects(
  session: Session,
  stageId: string,
  stageArtboard: StageArtboard,
  layerId: string,
  thumbnailStage: boolean = false
) {
  //

  const domainLayer = session.getLayerFromLayerPath(layerId);
  let currentStage: any = !thumbnailStage
    ? session.stages.get(stageId)
    : session.thumbnailStages.get(stageId);

  if (currentStage && currentStage.canvas) {
    if (!stageArtboard) {
      return;
    }

    let addedCompiledArtboard = currentStage.canvas.executeFunction(
      "addArtboard",
      stageArtboard.path
    );

    if (stageId === "artboard") {
      addedCompiledArtboard.setStyle("overflow", "hidden");
    }

    let addedArtboardName = stageArtboard.path.substring(
      stageArtboard.path.lastIndexOf("/") + 1,
      stageArtboard.path.length
    );

    if (
      stageId !== BX_PREVIEW_FILE_PATH &&
      stageId.includes("layer:") === false &&
      !thumbnailStage
    ) {
      addedCompiledArtboard.executeFunction(
        "LayerLabel.add",
        addedArtboardName
      );

      //TODO: heavy-jugaad (fix Plus button plugin)
      currentStage.canvas.executeFunction("showPlusButton");
    }

    if (process.env.NODE_ENV !== "production") {
      addedCompiledArtboard.setName(stageArtboard.path);
    }
    if (addedCompiledArtboard) {
      setReferences(session, stageArtboard, addedCompiledArtboard);
    }

    if (stageId.includes("layer:")) {
      const addedCompiledLayer = addLayer(
        session,
        currentStage,
        domainLayer,
        stageArtboard
      );
      if (addedCompiledLayer) {
        addedCompiledLayer.setStyle("overflow", "visible");
      }

      currentStage.canvas.executeFunction(
        "selectArtboard",
        addedCompiledArtboard
      );

      createStageForDomain(session, domainLayer, stageArtboard, stageId);
    }
  }
}

export default function AddStageArtboardGlue(
  session: Session,
  e: SessionEvent
) {
  applySideEffects(
    session,
    e.payload.stageId,
    e.payload.stageArtboard,
    e.payload.rootLayerId,
    e.payload.thumbnailStage
  );
}
