import { DomainLayer, LogicalExpression } from "domain-x";
import {
  Layer,
  TextEditorEvent,
  MouseEvent as DesignerMouseEvent,
  stopAndForgetLayoutUpdates,
  resumeLayoutUpdates
} from "@builderx-core/designer";
import { forEach, isNil } from "lodash";
import { SessionEvent } from "event-manager";
import {
  Session,
  StageArtboard,
  AddSymbolFromJsService,
  Commands,
  GenerateLayerPreview
} from "session";
import { globalRefMap } from "global-ref-map";
import { updateCompiledLayerStyle } from "./SetStyleAttributeGlue";
import { ResolveNodeValue, Utils, ResolveNode } from "utils";
import { getStageForCompiled, getOwnCanvasRef } from "../Utils";
import { IconModalDialog } from "dialog-x";
import { setCenterWrapperForCompiledLayer } from "./SetCenterWrapperGlue";
import { updateCompiledLayerProp } from "./SetPropGlue";
const {
  SetCurrentStage,
  CreateStageForDomain,
  SelectTool,
  SetProp,
  SetText
} = Commands;

function addSymbolInstRefInSymbolFile(
  session: Session,
  domainLayer: DomainLayer
) {
  try {
    const symbolFile = session.domain.getSymbolFileFromSymbolInstance(
      domainLayer
    );
    if (!symbolFile) {
      return;
    }
    const index = symbolFile.symbolInstances.indexOf(domainLayer);
    if (isNil(index) || index === -1) {
      symbolFile.symbolInstances.push(domainLayer);
    }
  } catch (err) {
    console.log(err, "Could't add symbol layer ref in symbol file");
  }
}
function resolveSymbolInstance(
  session: Session,
  domainLayer: DomainLayer,
  compiledParentLayer: Layer,
  inputIndex: number
): any {
  //

  let compiledLayer;
  try {
    let symbolFile = session.domain.getSymbolFileFromSymbolInstance(
      domainLayer
    );

    if (!symbolFile) {
      // unresolved symbol

      const importPath = domainLayer.import.packageName;
      // Adding dependent symbol file before resolving symbol layer
      // nahi toh ** fategi baad me
      let symbol = session.existingFilesJSON.symbols.find(
        (symbolIn: any) => symbolIn.path === importPath
      );
      if (!symbol) {
        throw new Error(
          `symbol file doesnot exists for file id ${domainLayer.import.layerName}`
        );
      }

      AddSymbolFromJsService(session, symbol);
      // Mutators

      symbolFile = session.domain.files.get(importPath);
    }

    if (!symbolFile) {
      throw new Error(
        `symbol file doesnot exists for file id ${domainLayer.import.layerName}`
      );
    } else {
      addSymbolInstRefInSymbolFile(session, domainLayer);
      const symbolInstFile: any = domainLayer.getFile();
      if (symbolInstFile) {
        stopAndForgetLayoutUpdates();

        compiledLayer = createNestedCompiledLayer(
          session,
          symbolFile.layer,
          compiledParentLayer,
          inputIndex,
          true,
          domainLayer.scopeVariables
        );
        resumeLayoutUpdates();

        // compiledLayers.push(compiledLayer);
      }
    }
  } catch (Error) {
    console.error(Error);
    console.log("will resolve this symbol layer later");
    const canvas = compiledParentLayer.getCanvas();
    compiledLayer = canvas.createLayer();
    compiledLayer.setName(domainLayer.type + "-layer");
    compiledParentLayer.addChild(compiledLayer, inputIndex);
    setReferences(domainLayer, compiledLayer);
  }

  return compiledLayer;
}
function setReferences(domainLayer: any, compiledLayer: any) {
  compiledLayer.executeFunction("setData", "domainRef", domainLayer);

  // if (domainLayer["domainCompiledRefs"]) {
  //   domainLayer["domainCompiledRefs"].splice(0, 0, compiledLayer);
  // } else {
  //   domainLayer.domainCompiledRefs = [compiledLayer];
  // }

  const domainCompiledLayers = globalRefMap.get(domainLayer);
  if (domainCompiledLayers) {
    domainCompiledLayers.splice(0, 0, compiledLayer);
  } else {
    globalRefMap.set(domainLayer, [compiledLayer]);
  }
}

export function createCompiledLayer(
  session: Session,
  domainLayer: any,
  compiledParent: any,
  index?: any,
  selectable: boolean = true
) {
  if (compiledParent) {
    if (domainLayer.type === "symbol") {
      const compiledLayer = resolveSymbolInstance(
        session,
        domainLayer,
        compiledParent,
        index
      );
      setReferences(domainLayer, compiledLayer);
      return compiledLayer;
    } else {
      if (compiledParent.type === "text") {
        const scopeVariables = compiledParent.executeFunction(
          "getData",
          "scopeVariables"
        );
        window["ResolveNodeValue"] = ResolveNodeValue;
        const value = ResolveNodeValue(
          domainLayer,
          scopeVariables ? scopeVariables : {}
        );
        compiledParent.setInnerText(value);
        return;
      }

      const canvas = compiledParent.getCanvas();
      const layer: Layer = canvas.createLayer();

      layer.setName(domainLayer.type + "-layer");

      if (process.env.NODE_ENV !== "production") {
        layer.setName(domainLayer.getFullPath());
      }
      compiledParent.addChild(layer, index);

      if (domainLayer.type === "root") {
        layer.setType("view");
      } else {
        layer.setType(domainLayer.type);
      }

      if (domainLayer.type === "text" || domainLayer.type === "textInput") {
        layer.addEventListener("setText", (data: TextEditorEvent) => {
          const domainLayer1 = data.target.executeFunction(
            "getData",
            "domainRef"
          );

          if (domainLayer1 && data.isFinal) {
            session.commandManager.execute(
              new SetText(session, domainLayer1, data.payload, data.isFinal)
            );
          }
        });
      } else if (domainLayer.type === "path") {
        // layer = this.canvas.createLayer();
        // this.iconLayer.setStyle('backgroundColor', 'lightgreen');
        // layer.addEventListener("PathEditor.onEdit", (data: PathEvent) => {
        //   const { style, isClosed, points } = data.payload;
        //   const oldBounds = layer.getBoundingClientRect();
        //   layer.setProp("isClosed", isClosed);
        //   layer.setProp("points", points);
        //   layer.setLayout({
        //     width: style.width,
        //     height: style.height,
        //     position: style.position,
        //     top: style.top - (layer.rootY - oldBounds.y),
        //     left: style.left - (layer.rootX - oldBounds.x)
        //   });
        // });
      }

      if (!selectable) {
        layer.lock();
      }
      setReferences(domainLayer, layer);
      return layer;
    }
  }
}

export function createNestedCompiledLayer(
  session: Session,
  domainLayer: DomainLayer,
  parentCompiledLayer: any,
  index?: number,
  selectable: boolean = true,
  scopeVariables?: any
) {
  // const scopeVariables = { ...domainLayer.scopeVariables };
  // scopeVariables.color = true;

  if (Utils.isExpression(domainLayer.type)) {
    // window["ResolveNode"] = ResolveNode;
    // window["ResolveNodeValue"] = ResolveNodeValue;
    domainLayer = ResolveNodeValue(domainLayer, scopeVariables);
  }

  const compiledLayer = createCompiledLayer(
    session,
    domainLayer,
    parentCompiledLayer,
    index,
    selectable
  );

  if (!compiledLayer) {
    return;
  }
  compiledLayer.executeFunction("setData", "scopeVariables", scopeVariables);

  setOwnCanvasPropsAndStyle(
    session,
    domainLayer,
    compiledLayer,
    scopeVariables
  );

  setCenterWrapperForCompiledLayer(session, domainLayer, compiledLayer);

  // update style for nested symbol layer

  if (compiledLayer) {
    // used native forEach intentionally
    forEach(
      domainLayer.children,
      (childLayer: DomainLayer, childIndex: number) => {
        createNestedCompiledLayer(
          session,
          childLayer,
          compiledLayer,
          childIndex,
          false,
          scopeVariables
        );
      }
    );
  }
  return compiledLayer;
}

export function setOwnCanvasPropsAndStyle(
  session: Session,
  domainLayer: DomainLayer,
  compiledLayer: any,
  scopeVariables?: any
) {
  forEach(domainLayer.props.style.toJS(), (styleValue, styleKey) => {
    if (Utils.isExpression(styleValue && styleValue.type)) {
      const resovledNode = ResolveNodeValue(styleValue, scopeVariables);
      updateCompiledLayerStyle(
        session,
        compiledLayer as Layer,
        styleKey,
        resovledNode
      );
    } else {
      updateCompiledLayerStyle(session, compiledLayer, styleKey, styleValue);
    }
  });
  forEach(domainLayer.props.toJS(), (value, key) => {
    if (key !== "style" && key !== "contentContainerStyle") {
      if (Utils.isExpression(value && value.type)) {
        const resovledNode = ResolveNodeValue(value, scopeVariables);
        updateCompiledLayerProp(
          session,
          compiledLayer,
          key,
          resovledNode,
          domainLayer
        );
      } else {
        updateCompiledLayerProp(
          session,
          compiledLayer,
          key,
          value,
          domainLayer
        );
      }
    }
  });
}

export function addCompiledLayer(
  session: Session,
  domainLayer: DomainLayer,
  parentCompiledLayer: Layer,
  index?: any
  // thumbnailStage: boolean = false
) {
  const domainParentLayer = domainLayer.parent;

  if (domainParentLayer && !(domainParentLayer instanceof LogicalExpression)) {
    createCompiledLayer(
      session,
      domainLayer as DomainLayer,
      parentCompiledLayer,
      index
    );
  }

  if (domainLayer.type === "literal") {
    return;
  }

  const compiledLayer = getOwnCanvasRef(
    domainLayer,
    parentCompiledLayer.getCanvas()
  );

  if (!compiledLayer) {
    return;
  }

  if (domainLayer.type === "root" && compiledLayer) {
    try {
      compiledLayer.executeFunction("LayerResizer.hideLayer");
      compiledLayer.executeFunction("Hover.hideLayer");
      // compiledLayer.setStyle("overflow", "hidden");
    } catch (err) {
      console.log(err, "heavy jugaad");
    }
  }

  if (domainLayer.type === "root" && domainLayer.parent.isSymbol()) {
    // const stage = !thumbnailStage
    //   ? session.stages.get(domainLayer.parent.path)
    //   : session.thumbnailStages.get(domainLayer.parent.path);
    const stage = getStageForCompiled(
      session,
      parentCompiledLayer
      // domainLayer.parent.path
    );

    if (stage) {
      const compiledRootLayer = session.executeFunction(
        "getOwnCanvasRef",
        domainLayer,
        stage.canvas
      );
      compiledRootLayer.setLayout("flex", 1);
    }
  }

  // if (domainLayer.type === "symbol") {
  //   // const compiledSymbolLayer: Layer = domainLayer.getOwnCanvasRef();

  //   if (compiledLayer) {
  //     compiledLayer.addEventListener("dblclick", (e: DesignerMouseEvent) => {
  //       if (session.selectedLayers[0] === domainLayer) {
  //         session.commandManager.execute(
  //           new SetCurrentStage(session, domainLayer.import.packageName)
  //         );
  //         // e.stopPropagation();
  //       }
  //     });

  //     compiledLayer.children.forEach(child => {
  //       child.lock();
  //     });
  //   }
  // }
  if (compiledLayer) {
    compiledLayer.addEventListener(
      "dblclick",
      async (e: DesignerMouseEvent) => {
        if (session.getLayersFromSelectedLayerCollection()[0] !== domainLayer) {
          return;
        }
        if (domainLayer.type === "scrollView") {
          const compiledParentDomainRef = parentCompiledLayer.executeFunction(
            "getData",
            "domainRef"
          );

          if (
            compiledParentDomainRef &&
            compiledParentDomainRef.type === "file"
          ) {
            return;
          }

          session.commandManager.execute(
            new CreateStageForDomain(
              session,
              domainLayer,
              `layer:${domainLayer.getFullPath()}`
            )
          );
          e.stopPropagation();
        } else if (domainLayer.type === "symbol") {
          session.commandManager.execute(
            new SetCurrentStage(session, domainLayer.import.packageName)
          );
          e.stopPropagation();
        } else if (!session.readonly) {
          const canvas = e.target.getCanvas();
          if (domainLayer.type === "text") {
            canvas.executeFunction("ResizerRenderer.hide");
            canvas.executeFunction(
              "TextEditorPlugin.mountEditor",
              compiledLayer
            );
          } else if (domainLayer.type === "icon") {
            const iconFamily = domainLayer.props.getResolvedProp("type");
            const iconName = domainLayer.props.getResolvedProp("name");
            let response: any = await IconModalDialog(
              true,
              iconFamily,
              iconName
            );
            let layer = domainLayer;
            if (layer && response && response.iconName && response.iconFamily) {
              session.commandManager.executeAndSkip(
                new SetProp(session, layer, "name", response.iconName)
              );
              session.commandManager.executeAndSkip(
                new SetProp(session, layer, "type", response.iconFamily)
              );
            }
            if (session.showCodeEditor) {
              GenerateLayerPreview(session, [domainLayer.getFullPath()]);
            }
          }
          // else if (domainLayer.type === "path") {
          //   canvas.executeFunction("ResizerRenderer.hide");
          //   session.currentStage.canvas.executeFunction(
          //     "Hover.hideAllHoverBoxes"
          //   );
          //   session.commandManager.executeAndSkip(
          //     new SelectTool(session, "path")
          //   );
          //   canvas.executeFunction(
          //     "PathEditor.mount",
          //     domainLayer.getOwnCanvasRef()
          //   );
          // }
        }
      }
    );
  }

  return compiledLayer;
  // if (domainLayer.parent && domainLayer.parent.type === "scrollView") {
  //   const compiledScrollViewChild: Layer = domainLayer.getOwnCanvasRef();
  //   compiledScrollViewChild.lock();
  // }
}

export default function AddLayerGlue(session: Session, e: SessionEvent) {
  const domainLayer = e.payload.domainLayer;
  const parentDomainLayer = e.payload.parentDomainLayer;
  const index = e.payload.index;
  const parentCompiledLayers = globalRefMap.get(parentDomainLayer);

  if (domainLayer && parentCompiledLayers) {
    forEach(parentCompiledLayers, (compiledParent: any) => {
      if (compiledParent instanceof StageArtboard) {
        const event = new SessionEvent("addLayer", {
          domainLayer: domainLayer,
          parentDomainLayer: compiledParent
        });
        session.eventManager.dispatchEvent("addLayer", event);
      } else {
        addCompiledLayer(session, domainLayer as any, compiledParent, index);
      }
    });
  }
}
