import { BinaryExpressionX, DomainNode } from "common-interfaces";
import Expression from "./Expression";
import LayerNodeModel from "./LayerNodeModel";
import DomainFile from "../Base/Domain/File";
import DomainLayer from "../Base/Domain/Layer";
import { ConditionalExpression } from "domain-x";
import { Session } from "session";

export default class BinaryExpression extends LayerNodeModel
  implements BinaryExpressionX {
  type: string = "binaryExpression";
  operator: string;
  left: Expression | any;
  right: Expression | any;
  _parent: any;
  constructor(binaryExpressionJSON: BinaryExpressionX, session: Session) {
    super(session);
    this.type = binaryExpressionJSON.type;
    this.operator = binaryExpressionJSON.operator;
    this.left = undefined;
    this.right = undefined;
  }
  toJS() {
    return {
      type: this.type,
      operator: this.operator,
      left: this.left.toJS ? this.left.toJS() : this.left,
      right: this.right.toJS ? this.right.toJS() : this.right
    };
  }

  get parent() {
    return this._parent;
  }
  set parent(node: any) {
    this._parent = node;
  }
  appendTo(
    parentNode: DomainFile | DomainLayer | DomainNode,
    index?: number | string | undefined
  ) {
    throw new Error("Method not implemented.");
  }
  appendChild(
    childNode: DomainLayer | ConditionalExpression,
    index?: number | string | undefined
  ) {
    throw new Error("Method not implemented.");
  }
  remove() {
    throw new Error("Method not implemented. ConditionalExpression");
  }
  removeChild(index: number) {
    throw new Error("Method not implemented. ConditionalExpression");
  }
  traverseLayers(callback: any) {
    callback(this);
    this.left.traverseLayers(callback);
    this.right.traverseLayers(callback);
  }
}
