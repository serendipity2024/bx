import { ExpressionX, DomainNode } from "common-interfaces";
import DomainLayer from "../Base/Domain/Layer";
import DomainFile from "../Base/Domain/File";
import ConditionalExpression from "./ConditionalExpression";
import LayerNodeModel from "./LayerNodeModel";
import { types } from "serializable";
import { Session } from "session";

export default class Expression extends LayerNodeModel implements ExpressionX {
  type: string = "expression";
  expression: string;
  parent: DomainLayer | DomainFile | ConditionalExpression | undefined;
  evaluatedValue: any;

  constructor(expressionJSON: ExpressionX, session: Session) {
    super(session);
    this.type = expressionJSON.type;
    this.expression = expressionJSON.expression;
  }

  getFields(): { [key: string]: any } {
    return {
      type: types.literal,
      expression: types.literal
    };
  }

  getLayer(node?: any): any {
    if (!node) {
      node = this;
    }
    if (node && node.type === "root") {
      return node;
    }
    if (node instanceof DomainLayer) {
      return node;
    }
    if (!node || !node.parent) {
      return undefined;
    }
    return this.getLayer(node.parent as any);
  }
  appendTo(
    parentNode: DomainFile | DomainLayer | DomainNode,
    index?: number | string | undefined
  ) {
    throw new Error("Method not implemented.");
  }
  appendChild(
    childNode: DomainLayer | ConditionalExpression,
    index?: number | string | undefined
  ) {
    //
    throw new Error("Method not implemented.  ConditionalExpression");
  }
  remove() {
    throw new Error("Method not implemented. ConditionalExpression");
  }
  removeChild(index: number) {
    throw new Error("Method not implemented. ConditionalExpression");
  }

  findConditionalParent(node?: any): any {
    if (!node) {
      node = this;
    }

    if (
      node._parent &&
      node._parent.type !== "conditionalExpression" &&
      node._parent.type !== "expressionStatement" &&
      (node.type === "conditionalExpression" ||
        node.type === "expressionStatement")
    ) {
      return node;
    } else if (node._parent) {
      return this.findConditionalParent(node._parent);
    } else {
      return undefined;
    }
  }
  getValue(scopeVariables: any) {
    return scopeVariables[this.expression];
  }
  traverseLayers(callback: (childLayer: Expression) => void) {
    callback(this);
  }
}
