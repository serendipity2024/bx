import { types } from "serializable";
import {
  IDisposable,
  IClone,
  DomainNode,
  IFormControl,
  IStatusBar
} from "common-interfaces";
import { camelCase, remove, findIndex, isNil, snakeCase } from "lodash";
import LayerNode from "../../../Common/Interfaces";
import Layer from "../Layer";
import { Layer as CanvasLayer } from "@builderx-core/designer";
import {
  TAG_NAME_STYLE_NAME_MAPPING,
  BX_PREVIEW_FILE_PATH
} from "bx-constants";
import { Dimension } from "../../../types";
import LayerNodeModel from "../../../Common/LayerNodeModel";
import Expression from "../../../Common/Expression";
import FormControl from "./FormControl";
import { DomainLayer, Props } from "domain-x";
import { Session, StageArtboard } from "session";
import { Utils } from "utils";

export default class DomainFile extends LayerNodeModel
  implements
    IDisposable,
    IClone<File>,
    LayerNode<DomainLayer | DomainNode | DomainFile, DomainLayer | DomainNode> {
  path: string;
  content: string;
  isDirty: boolean;
  layer: DomainLayer;
  version: string;
  isResizerVisible: boolean;
  props: Props;
  type: string;
  _parent: DomainLayer | DomainNode | DomainFile | undefined;
  children: Array<DomainLayer | DomainNode>;
  selected: boolean;
  hovered: boolean;
  collapsed: boolean;
  locked: boolean;
  dragHoverInside: boolean;
  dragHoverBefore: boolean;
  dragHoverParent: boolean;
  dragHoverAfter: boolean;
  expressionList: Map<string, Array<string>>;
  symbolInstances: Array<DomainLayer>;
  isProcessing: boolean;
  scopeVariables: { [key: string]: any };
  dbFileId: string;
  conditionalExpList: Map<
    string,
    { active: boolean; references: DomainLayer[] }
  >;
  overrides: { [key: string]: any };
  formControls: Array<FormControl>;
  calculatedDims: boolean = false;

  statusBar: IStatusBar = {
    display: true,
    barStyle: "default",
    animated: false,
    backgroundColor: undefined
  };

  beforeDisposeCallback?: (ref: any) => void;
  constructor(fileJSON: any, session: Session) {
    super(session);
    this.type = fileJSON.type ? fileJSON.type : "file";
    this.path = fileJSON.path;
    this.version = fileJSON.version;
    this.content = fileJSON.content;
    this.isDirty = !isNil(fileJSON.isDirty) ? fileJSON.isDirty : false;
    this.isResizerVisible = false;
    this.props = new Props();
    this.props.parent = this;
    this.expressionList = new Map();
    this.conditionalExpList = new Map();
    this.scopeVariables = fileJSON.scopeVariables
      ? fileJSON.scopeVariables
      : {};
    this.overrides = {};
    this.formControls = [];
    this.symbolInstances = [];
    this.dbFileId = fileJSON.dbFileId;
  }
  getFields() {
    return {
      type: types.literal,
      path: types.literal,
      dbFileId: types.literal,
      content: types.literal,
      isDirty: types.literal,
      version: types.literal,
      layer: Layer,
      props: Props,
      scopeVariables: types.literal,
      statusBar: types.literal
    };
  }
  get parent() {
    return this._parent;
  }
  set parent(node: any) {
    this._parent = node;
  }
  get id(): string {
    return this.path;
  }
  setFileId(id: string) {
    this.dbFileId = id;
  }
  getFile() {
    if (this.type === "fileHeader") {
      return this["file"];
    }
    return this;
  }
  beforeDispose(beforeDisposeCallback?: (ref: any) => void) {
    this.beforeDisposeCallback = beforeDisposeCallback;
  }
  clone() {
    return DomainFile.fromJS(this.toJS());
  }
  dispose() {
    if (this.beforeDisposeCallback) {
      this.beforeDisposeCallback(this);
    }
    // this.searchMap.delete(this.id);
    // traverse for child and dispose
  }
  appendTo() {
    //
  }
  appendChild() {
    //
  }
  remove() {
    //
  }
  removeChild() {
    //
  }

  getBoundingClientRect() {
    let dims = {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      rotation: 0,
      rootX: 0,
      rootY: 0
    };
    const ownStageRef = this.getOwnCanvasRef();
    if (ownStageRef) {
      return ownStageRef.getBoundingClientRect();
    }

    return dims;
  }
  getOwnCanvasRef(): CanvasLayer {
    return this.session.executeFunction(
      "getOwnCanvasRef",
      this,
      this.session.currentStage.canvas
    );
  }

  getOwnStageArtboardRef(): StageArtboard {
    return this.session.executeFunction(
      "getOwnStageArtboardRef",
      this,
      this.session.currentStage
    );
  }

  getPath(node?: any, appendString?: boolean | undefined): string {
    if (this.type === "fileHeader") {
      return `${this.path}:header`;
    }
    return this.path;
  }
  getFullPath() {
    return this.getPath(undefined, true);
  }
  setIsDirty(isDirty: boolean) {
    this.isDirty = isDirty;
  }
  findLastIndexOfStyleNameInStylesheet(name: string) {
    let returnValue: any = 1;
    if (this.layer) {
      this.layer.traverseLayersForStyleName((childLayer: any) => {
        const styleName = childLayer.styleName;
        if (styleName && styleName.indexOf(name) !== -1) {
          const tempName = styleName.replace(name, "");
          let index = parseInt(tempName.replace(/^\D+/g, ""), 10);
          if (isNaN(index)) {
            index = 1;
          }
          index++;
          if (index > returnValue) {
            returnValue = index;
          }
        }
      });
    }
    if (returnValue === 1) {
      returnValue = "";
    }
    return returnValue;
  }

  isValidNewNameForLayer(name: string) {
    let returnValue = true;
    this.layer.traverseLayersForStyleName((childLayer: any) => {
      const styleName = childLayer.styleName;
      if (styleName === Utils.getValidLayerName(name)) {
        returnValue = false;
        return;
      }
    });
    return returnValue;
  }
  newFindLastIndexOfStyleNameInStylesheet(name: string) {
    // DOC: integrate this with existing one
    // Handle condition to find the missing indices too, if it is the only layer, then no 1 in the end
    let returnValue: any = 1;
    this.layer.traverseLayersForStyleName((childLayer: any) => {
      let styleName = childLayer.styleName;
      if (styleName && styleName.indexOf(name) !== -1) {
        let index = parseInt(styleName.replace(/^\D+/g, ""), 10);
        if (isNaN(index)) {
          index = 0;
        }
        index++;
        if (index > returnValue) {
          returnValue = index;
        }
      }
    });
    return returnValue;
  }
  findLastIndexOfNameInFormControl(name: string) {
    // DOC: integrate this with existing one
    // Handle condition to find the missing indices too, if it is the only layer, then no 1 in the end
    let returnValue: any = 1;

    this.formControls.forEach((formControl: any) => {
      let title = formControl.title;
      if (title && title.indexOf(name) !== -1) {
        let index = parseInt(title.replace(/^\D+/g, ""), 10);
        if (isNaN(index)) {
          index = 0;
        }
        index++;
        if (index > returnValue) {
          returnValue = index;
        }
      }
    });
    return returnValue;
  }
  newGetStyleNameForStyleSheet(name: string): number | string {
    let layerName = TAG_NAME_STYLE_NAME_MAPPING[name];
    if (!layerName) {
      layerName = name;
    }
    layerName = camelCase(layerName);

    let oldNameTrimmed = layerName.replace(layerName.replace(/^\D+/g, ""), "");
    const styleName =
      oldNameTrimmed +
      this.newFindLastIndexOfStyleNameInStylesheet(oldNameTrimmed);
    return styleName;
  }
  getStyleNameForStyleSheet(tagName: string): any {
    let layerName = TAG_NAME_STYLE_NAME_MAPPING[tagName];
    if (!layerName) {
      layerName = tagName;
    }
    layerName = camelCase(layerName);
    const styleName =
      layerName + this.findLastIndexOfStyleNameInStylesheet(layerName);
    return styleName;
  }

  getNameForFormControl(layer: any): any {
    const tagName = layer.import.layerName;

    let layerName = TAG_NAME_STYLE_NAME_MAPPING[tagName];
    if (!layerName) {
      layerName = tagName;
    }
    layerName = camelCase(layerName);
    const styleName =
      layerName + this.findLastIndexOfNameInFormControl(layerName);
    return styleName;
  }

  setDimensions(dimensions: Dimension) {
    let style = {
      left: dimensions.x,
      top: dimensions.y,
      width: dimensions.width,
      height: dimensions.height
    };
    this.props.setAllStyle(style);
  }
  getDimensions(): Dimension {
    return {
      x: this.props.style.get("left") as number,
      y: this.props.style.get("top") as number,
      width: this.props.style.get("width") as number,
      height: this.props.style.get("height") as number
    };
  }
  isSymbol() {
    return (
      this.path.includes("/src/symbols") ||
      this.path.includes("/src/components")
    );
  }
  isArtboard() {
    return !this.isSymbol() && this.path !== BX_PREVIEW_FILE_PATH; // this.path.indexOf("/src/screens") !== -1;
  }
  setIsProcessing(flag: boolean) {
    this.isProcessing = flag;
  }
  setCalculatedDims(flag: boolean) {
    this.calculatedDims = flag;
  }
  // addFormControl(newFormControl: IFormControl) {
  //   const { type, title, layer } = newFormControl;

  //   const index = findIndex(this.formControls, (formControl: FormControl) => {
  //     return formControl.layer === layer;
  //   });
  //   if (isNil(index) || index === -1) {
  //     // const titleExists = find(this.formControls, (formControl:FormControl) => {
  //     //   return formControl.title === title;
  //     // });

  //     // if (titleExists) {
  //     //   console.log(titleExists, "hello form controls ttitle exists");
  //     // }

  //     // const name = this.getNameForFormControl(layer);
  //     // const name = `this.props.${this.getNameForFormControl(layer)}`;
  //     this.formControls.push(new FormControl(type, title, layer));
  //   }
  // }
  // removeFormControl(layer: Layer) {
  //   const formControls = remove(
  //     this.formControls,
  //     (formControl: FormControl) => {
  //       return formControl.layer === layer;
  //     }
  //   );
  //   const symbolInstances = this.symbolInstances;
  //   symbolInstances.forEach((symbolInstance: any) => {
  //     formControls.forEach((formControl: any) => {
  //       if (symbolInstance.scopeVariables[formControl.title]) {
  //         delete symbolInstance.scopeVariables[formControl.title];
  //       }
  //     });
  //   });
  // }
}
