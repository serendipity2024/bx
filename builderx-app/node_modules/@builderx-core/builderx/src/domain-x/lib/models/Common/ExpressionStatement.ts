import {
  ExpressionX,
  DomainNode,
  ExpressionStatementX
} from "common-interfaces";
import DomainLayer from "../Base/Domain/Layer";
import DomainFile from "../Base/Domain/File";
import ConditionalExpression from "./ConditionalExpression";
import LayerNodeModel from "./LayerNodeModel";
import { types } from "serializable";
import { LogicalExpression, BinaryExpression } from "domain-x";
import { findIndex, isNil } from "lodash";
import { Session } from "session";

export default class ExpressionStatement extends LayerNodeModel
  implements ExpressionStatementX {
  type: string = "expressionStatement";
  expression: LogicalExpression | BinaryExpression;
  parent: DomainLayer | DomainFile | ConditionalExpression | undefined;

  constructor(expressionJSON: ExpressionStatementX, session: Session) {
    super(session);
    this.type = expressionJSON.type;
  }

  // getFields(): { [key: string]: any } {
  //   return {
  //     type: types.literal,
  //     expression: types.literal
  //   };
  // }
  getFile(
    node?: DomainLayer | ExpressionStatement | ConditionalExpression
  ): DomainFile | null {
    if (!node) {
      node = this;
    }
    if (node.type === "root" && node.parent instanceof DomainFile) {
      return node.parent;
    } else if (node.parent) {
      return this.getFile(node.parent as DomainLayer);
    } else {
      return null;
    }
  }
  toJS() {
    return {
      type: this.type,
      expression:
        this.expression && this.expression.toJS
          ? this.expression.toJS()
          : this.expression
    };
  }

  getAbstractedLayer() {
    return this;
  }
  getLayer(node?: any): any {
    if (!node) {
      node = this;
    }
    if (node && node.type === "root") {
      return node;
    }
    if (node instanceof DomainLayer) {
      return node;
    }
    if (!node || !node.parent) {
      return undefined;
    }
    return this.getLayer(node.parent as any);
  }
  appendTo(
    parentNode: DomainFile | DomainLayer | DomainNode,
    index?: number | string | undefined
  ) {
    throw new Error("Method not implemented.");
  }
  appendChild(
    childNode: DomainLayer | ConditionalExpression,
    index?: number | string | undefined
  ) {
    //
    throw new Error("Method not implemented.  ConditionalExpression");
  }
  remove() {
    const parentNode = this.parent;
    if (parentNode) {
      this.parent = undefined;
      const index = findIndex(parentNode["children"], (child: any) => {
        return child === this;
      });
      if (!isNil(index)) {
        parentNode["children"].splice(index, 1);
      }
      return index;
    } else {
      throw Error("Parent Node not found on Detach");
    }
  }
  removeChild(index: number) {
    throw new Error("Method not implemented. ConditionalExpression");
  }

  findConditionalParent(node?: any): any {
    if (!node) {
      node = this;
    }

    if (node.type === "conditionalExpression") {
      return node;
    } else if (node.parent) {
      return this.findConditionalParent(node.parent);
    } else {
      return undefined;
    }
  }
  traverseLayers(callback: (childLayer: ExpressionStatement) => void) {
    callback(this);
    this.expression.traverseLayers(callback);
  }
}
