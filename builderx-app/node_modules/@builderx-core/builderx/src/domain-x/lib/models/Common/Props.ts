import Style from "./Style";
import {
  isNil,
  forEach,
  findIndex,
  keys,
  size,
  isArray,
  indexOf
} from "lodash";
import { ResolveNodeValue } from "utils";
import DomainLayer from "../Base/Domain/Layer";
import { StylePropNameType } from "common-interfaces";
import DomainFile from "../Base/Domain/File";
import { FLATLIST_PROPS, STYLE_PROP_NAMES } from "bx-constants";
import { Utils } from "utils";
import { Model } from "model";
import LayerNodeModel from "./LayerNodeModel";

export default class Props extends Model {
  _parent: DomainLayer | DomainFile | LayerNodeModel;
  style: Style;
  constructor() {
    super();
    this.style = new Style();
    this.style.parent = this;
  }
  get parent() {
    return this._parent;
  }
  set parent(node: any) {
    this._parent = node;
  }

  set(key: string, value: any) {
    this[key] = value;
  }

  get(key: string) {
    return this[key];
  }

  getFields(): { [key: string]: any } {
    return {};
  }

  findIndexInParent() {
    let index;
    const parent = this.parent;
    forEach(parent, (value: any, key: string) => {
      if (isArray(value)) {
        const childIndex = indexOf(value, this);
        if (childIndex > -1) {
          index = `${key}.${childIndex}`;
        }
      } else {
        if (value === this) {
          index = key;
        }
      }
    });
    return index;
  }

  getAllPropsResolvedValue() {
    const file = this.getFile();
    if (!file) {
      return undefined;
    }
    let scopeVarialbes = file.scopeVariables;
    const props = this;
    forEach(props, (value: any, key: string) => {
      props[key] = ResolveNodeValue(value, scopeVarialbes);
    });
    return props;
  }
  getProp(key: string) {
    if (key === "style") {
      return this.getStyle();
    } else if (!isNil(this.get(key))) {
      return this.get(key);
    } else {
      return undefined;
    }
  }

  getPath(): string {
    const node = this;
    if (node.parent && node.parent.getFullPath) {
      return `${node.parent.getFullPath()}.props`;
    } else {
      return "";
    }
  }

  getFullPath() {
    return this.getPath();
  }

  getResolvedProp(key: string): any {
    const file = this.getFile();
    if (!file) {
      return undefined;
    }
    let scopeVariables = file.scopeVariables;
    if (key === "style") {
      return this.getStyle();
    } else if (!isNil(this[key])) {
      return ResolveNodeValue(this[key], scopeVariables);
    } else {
      return undefined;
    }
  }

  removeProp(key: string) {
    delete this[key];
  }
  setProp(key: string, value: any) {
    if (key === "style") {
      this.setAllStyle(value);
    } else {
      this.set(key, value);
    }
  }
  setAllProps(props: { [key: string]: any }) {
    forEach(props, (value: any, key: string) => {
      this.setProp(key, value);
    });
  }
  getAllProps(): { [key: string]: any } {
    return this;
  }
  setStyleAttribute(
    key: string,
    value: any,
    stylePropName: StylePropNameType = "style"
  ) {
    if (!this.get(stylePropName)) {
      this.set(stylePropName, new Style());
    }
    const style = this.get(stylePropName);
    if (key === "gradient") {
      style.set(key, value);
    } else {
      style.set(key, value);
    }
    // if (style.hasOwnProperty(key)) {
    // if (key === "transform") {
    //   if (isArray(value)) {
    //     if (style.transform) {
    //       forEach(value, element => {
    //         const elementKeys: string[] = Object.keys(element);
    //         forEach(elementKeys, (elementKey: string) => {
    //           const object: any = find(
    //             style.transform,
    //             (transformObj: any) => !isNil(transformObj[elementKey])
    //           );
    //           if (object) {
    //             object[elementKey] = element[elementKey];
    //           } else {
    //             style.transform.push(new Transform(element));
    //           }
    //         });
    //       });
    //     } else {
    //       var transform: Transform[] = [];
    //       forEach(value, transformVal => {
    //         transform.push(new Transform(transformVal));
    //       });
    //       style["transform"] = transform;
    //     }
    //   } else {
    //     style["transform"] = value;
    //   }
    // } else if (key === "shadowOffset") {
    //   style["shadowOffset"] = new ShadowOffset(value);
    // } else {
    //   style[key] = value;
    // }
  }
  removeStyleAttribute(
    key: string,
    stylePropName: StylePropNameType = "style"
  ) {
    let style = this.get(stylePropName);
    if (!style) {
      return;
    }
    if (key) {
      delete style[key];
      // style.remove(key);
    }
  }

  getFile(node?: Props | DomainLayer): DomainFile | null {
    if (!node) {
      node = this;
    }

    if (node.parent && node.parent instanceof DomainFile) {
      return node.parent;
    } else if (
      node &&
      node["type"] === "root" &&
      node.parent instanceof DomainFile
    ) {
      return node.parent;
    } else if (node.parent) {
      return this.getFile(node.parent as DomainLayer);
    } else {
      return null;
    }
  }

  getStyleAttribute(
    key: string,
    stylePropName: StylePropNameType = "style"
  ): any {
    const style = this.get(stylePropName);
    if (!style) {
      return null;
    }
    return style.get(key);
  }

  getRotateKey() {
    const transformValue = this.getStyleAttribute("transform");
    let rotateKey = "";
    if (transformValue) {
      var index = findIndex(transformValue, (item: any) => {
        var rotate = keys(item).indexOf("rotate");
        return rotate !== -1 && !isNil(item["rotate"]);
      });

      if (index > -1) {
        rotateKey = `transform.${index}.rotate`;
      } else {
        rotateKey = `transform.${transformValue.length}.rotate`;
      }
    } else {
      rotateKey = `transform.0.rotate`;
    }
    return rotateKey;
  }
  getResolvedStyleAttribute(
    key: string,
    stylePropName: StylePropNameType = "style"
  ): any {
    const file = this.getFile();

    if (!file) {
      return undefined;
    }
    let scopeVarialbes = file.scopeVariables;

    const style = this.get(stylePropName);
    if (!style) {
      return null;
    }

    let obj = style.get(key);
    return ResolveNodeValue(obj, scopeVarialbes);
  }
  setAllStyle(style: { [key: string]: any }, stylePropName: string = "style") {
    if (!this.get(stylePropName)) {
      this.set(stylePropName, new Style());
    }

    forEach(style, (value: any, key: string) => {
      this[stylePropName].set(key, value);
    });
  }
  getStyle(): { [key: string]: any } {
    return this.get("style");
  }

  toJS() {
    const propsJSON: any = {};

    forEach(this, (value: any, key: any) => {
      if (!Utils.isInvalidKey(key)) {
        if (
          STYLE_PROP_NAMES.indexOf(key) !== -1 ||
          FLATLIST_PROPS.indexOf(key) !== -1
        ) {
          let keyVal = this.get(key);
          propsJSON[key] = keyVal && keyVal.toJS ? keyVal.toJS() : keyVal;
          if (size(propsJSON[key]) === 0 && key !== "style") {
            delete propsJSON[key];
          }
        } else {
          propsJSON[key] = value && value.toJS ? value.toJS() : value;
        }
      }
    });
    return propsJSON;
  }
}
