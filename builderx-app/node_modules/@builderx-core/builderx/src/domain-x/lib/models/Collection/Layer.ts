import { DomainNode, IClone, IDisposable } from "common-interfaces";
import { ExpressionStatement, LiteralNode } from "domain-x";
import { Utils, findSchemaIntersection } from "utils";
import { types } from "serializable";
import VirtualProps from "./VirtualProps";
import LayerNode from "./../Common/Interfaces";
import DomainFile from "./../Base/Domain/File";
import { Model } from "model";
import ResizingType from "../Common/ResizingType";
import DomainLayer from "./../Base/Domain/Layer";
import ConditionalExpression from "../Common/ConditionalExpression";
import { Session } from "session";
import { Layer as CanvasLayer } from "@builderx-core/designer";
import { BX_PREVIEW_FILE_PATH } from "bx-constants";
import { Position, Size } from "../types";
import { forEach } from "lodash";

type DimsMode = "fixed" | "auto" | "fill" | "percent";

interface ILayer {
  // children: Array<DomainLayer>;
  layers: Array<DomainLayer>;
}
export class RCDims extends Model {
  x: number;
  y: number;
  width: number;
  height: number;
  constructor(rcDims: any) {
    super();
    this.x = rcDims.x;
    this.y = rcDims.y;
    this.height = rcDims.height;
    this.width = rcDims.width;
  }
  getFields(): { [key: string]: any } {
    return {
      x: types.literal,
      y: types.literal,
      width: types.literal,
      height: types.literal
    };
  }
}
class DomainLayerCollection
  implements
    ILayer,
    IDisposable,
    IClone<DomainLayer | DomainNode>,
    LayerNode<DomainLayer | DomainFile | DomainNode, DomainLayer | DomainNode> {
  _parent:
    | DomainLayer
    | DomainFile
    // | ConditionalExpression
    | ExpressionStatement
    | undefined;
  id: string;
  _layers: Array<DomainLayer>;
  beforeDisposeCallback?: ((instance: any) => void) | undefined;
  private session: Session;
  props: VirtualProps;
  constructor(
    layers: DomainLayer | Array<DomainLayer> | undefined,
    session: Session
  ) {
    if (layers) {
      this._layers = Array.isArray(layers) ? layers : [layers];
    }
    this.session = session;
    this.props = new VirtualProps(this._layers);
  }
  push(layer: DomainLayer) {
    this._layers.push(layer);
    this.props.addLayer(layer);
  }
  pop(layer: DomainLayer) {
    let index = this._layers.indexOf(layer);
    if (index > -1) {
      this._layers.splice(index, 1);
    }
    this.props.removeLayer(layer);
  }
  get layers(): Array<DomainLayer> {
    return this._layers;
  }
  on(properties: Array<string> | string, listener: any) {
    if (this._layers.length) {
      this._layers[0].on(properties, listener);
    }
  }
  off(properties: Array<string> | string, listener: any) {
    if (this._layers.length) {
      this._layers[0].off(properties, listener);
    }
  }
  get parent() {
    return this._layers[0].parent;
  }
  get children() {
    let tempChildren: Array<any> = [];
    this._layers.forEach((layer: DomainLayer) => {
      tempChildren.concat(layer.children);
    });
    return tempChildren;
  }
  get type() {
    let type: string = "";
    this._layers.forEach((layer: DomainLayer) => {
      type = type && layer.type !== type ? "mix" : layer.type;
    });
    return type;
  }
  getUniqueLayerTypes() {
    return this._layers.map((layer: DomainLayer) => layer.type);
  }
  get styleName() {
    return this._layers[0].styleName;
  }
  get import() {
    return this._layers[0].import;
  }
  get selected() {
    return this._layers[0].selected;
  }
  set selected(val: any) {
    this._layers.forEach((layer: DomainLayer) => {
      layer.selected = val;
    });
  }
  get hovered() {
    return this._layers[0].hovered;
  }
  set hovered(val: any) {
    this._layers.forEach((layer: DomainLayer) => {
      layer.hovered = val;
    });
  }
  get collapsed() {
    return this._layers[0].collapsed;
  }
  set collapsed(val: any) {
    this._layers.forEach((layer: DomainLayer) => {
      layer.collapsed = val;
    });
  }
  get locked() {
    return this._layers[0].locked;
  }
  set locked(val: any) {
    this._layers.forEach((layer: DomainLayer) => {
      layer.locked = val;
    });
  }
  get hidden() {
    return this._layers[0].hidden;
  }
  set hidden(val: any) {
    this._layers.forEach((layer: DomainLayer) => {
      layer.hidden = val;
    });
  }
  get dragHoverInside() {
    return this._layers[0].dragHoverInside;
  }
  set dragHoverInside(val: any) {
    this._layers.forEach((layer: DomainLayer) => {
      layer.dragHoverInside = val;
    });
  }
  get dragHoverParent() {
    return this._layers[0].dragHoverParent;
  }
  set dragHoverParent(val: any) {
    this._layers.forEach((layer: DomainLayer) => {
      layer.dragHoverParent = val;
    });
  }
  get dragHoverBefore() {
    return this._layers[0].dragHoverBefore;
  }
  set dragHoverBefore(val: any) {
    this._layers.forEach((layer: DomainLayer) => {
      layer.dragHoverBefore = val;
    });
  }
  get dragHoverAfter() {
    return this._layers[0].dragHoverAfter;
  }
  set dragHoverAfter(val: any) {
    this._layers.forEach((layer: DomainLayer) => {
      layer.dragHoverAfter = val;
    });
  }
  get isResizerVisible() {
    return this._layers[0].isResizerVisible;
  }
  set isResizerVisible(val: any) {
    this._layers.forEach((layer: DomainLayer) => {
      layer.isResizerVisible = val;
    });
  }
  get navigateTo() {
    return this._layers[0].navigateTo;
  }
  get ui() {
    return this._layers[0].ui;
  }
  get template() {
    return this._layers[0].template;
  }
  get overrideKeys() {
    return this._layers[0].overrideKeys;
  }
  get stageData() {
    return this._layers[0].stageData;
  }
  get layout() {
    return this._layers[0].layout;
  }
  get _isGroup() {
    return this._layers[0]._isGroup;
  }
  get scopeVariables() {
    return this._layers[0].scopeVariables;
  }
  get autoRenaming() {
    return this._layers[0].autoRenaming;
  }
  get aspectRatio() {
    return this._layers[0].aspectRatio;
  }
  private getLayerControlsProperty(layerType: string) {
    return this.session.currentStage.canvas.getComponentDefinition(layerType)
      .controlsProperty;
  }
  getFormBuilderSchema() {
    let schema: any = this._layers.length
      ? this.getLayerControlsProperty(this._layers[0].type)
      : {};
    for (let i = 1; i < this._layers.length; i++) {
      schema = findSchemaIntersection(
        schema,
        this.getLayerControlsProperty(this._layers[i].type)
      );
    }
    return schema;
  }
  getFullPath() {
    let cumulativePath = "";
    // TODO: uncomment this
    // this._layers.forEach((layer: DomainLayer, index: number) => {
    //   cumulativePath +=
    //     layer.getFullPath() + (index !== this._layers.length - 1 ? "," : "");
    // });
    cumulativePath = this._layers[0].getFullPath();
    return cumulativePath;
  }
  clone(): DomainLayer {
    return DomainLayer.fromJS(this._layers[0].toJS());
  }
  toJS() {
    return this._layers[0].toJS();
  }
  forEachChild(
    callback: (childLayer: DomainLayer, index: number) => void,
    traverseConditionalsLayers: boolean = false
  ) {
    this._layers[0].forEachChild(callback, traverseConditionalsLayers);
  }
  traverseLayers(
    callback: (
      // childLayer: DomainLayer | ConditionalExpression | ExpressionStatement
      childLayer: DomainLayer | ConditionalExpression | ExpressionStatement
    ) => void
  ) {
    this._layers.forEach((layer: DomainLayer) => {
      callback(layer);
    });
    this.forEachChild(
      (
        childLayer: DomainLayer | ConditionalExpression | ExpressionStatement,
        childIndex: number
      ) => {
        if (childLayer instanceof LiteralNode) {
          childLayer.traverseLayers(callback);
        } else if (childLayer instanceof DomainLayer) {
          if (childLayer.import.layerName === "FlatList") {
            forEach(childLayer.props, (prop: any, key: string) => {
              if (!Utils.isInvalidKey(key)) {
                if (
                  prop instanceof ExpressionStatement ||
                  prop instanceof DomainLayer
                ) {
                  (prop as any).traverseLayers(callback);
                }
              }
            });
          } else if (typeof childLayer !== "string") {
            childLayer.traverseLayers(callback);
          }
        } else if (childLayer instanceof ConditionalExpression) {
          childLayer.consequent.traverseLayers(callback);
          childLayer.alternate.traverseLayers(callback);
        } else if (childLayer instanceof ExpressionStatement) {
          childLayer.traverseLayers(callback);
        }
      }
    );
  }
  dispose() {
    if (this.beforeDisposeCallback) {
      this.beforeDisposeCallback(this);
    }
    this.traverseLayers((childLayer: DomainLayer) => {
      if (childLayer instanceof DomainLayer) {
        childLayer.dispose();
      }
    });

    // this.disposed = true;
    // traverse children and dispose
  }
  beforeDispose(beforeDisposeCallback: (instance: any) => void) {
    this.beforeDisposeCallback = beforeDisposeCallback;
  }
  getFile(
    node?: DomainLayer | ExpressionStatement | ConditionalExpression
  ): DomainFile | null {
    return this._layers[0].getFile(node);
  }
  getOwnCanvasRef(): CanvasLayer {
    const canvasRef = this.session.executeFunction(
      "getOwnCanvasRef",
      this._layers[0],
      this.session.currentStage.canvas
    );

    return canvasRef;
  }
  get rcDims() {
    if (this._layers.length) {
      return this._layers[0].rcDims;
    }
    return undefined;
  }
  getBoundingClientRect() {
    if (this._layers.length === 1) {
      return this._layers[0].getBoundingClientRect();
    }
    return this.session.getBoundingBox(this._layers, false);
  }
  restore() {
    this._layers.forEach((layer: DomainLayer) => {
      layer.restore();
    });
  }
  appendTo(parentNode: DomainLayer, index?: number | undefined) {
    this._layers.forEach((layer: DomainLayer) => {
      layer.appendTo(parentNode, index);
    });
  }
  appendChild(
    childNode: DomainLayer | ExpressionStatement | ConditionalExpression,
    index?: number | undefined,
    replaceChild?: boolean
  ): any {
    return this._layers[0].appendChild(childNode, index, replaceChild);
  }
  remove() {
    this._layers.forEach((layer: DomainLayer) => {
      layer.remove();
    });
  }
  removeChild(index: number) {
    this._layers[0].removeChild(index);
  }

  getRootLayer(currentRootLayer: any, node?: any): any {
    return this._layers[0].getRootLayer(currentRootLayer, node);
  }
  getParentLayer(parent?: any): any {
    return this._layers[0].getParentLayer(parent);
  }
  getPath(node?: any, appendString?: boolean) {
    return this._layers[0].getPath(node, appendString);
  }
  isDescendantOfThirdParty(): boolean {
    let val = false;
    this._layers.forEach((layer: DomainLayer) => {
      if (layer.isDescendantOfThirdParty()) {
        val = true;
      }
    });
    return val;
  }
  getChildren() {
    return this.children;
  }
  getLayerPosition(): Position {
    const x = this.props.getResolvedStyleAttribute("left");
    const y = this.props.getResolvedStyleAttribute("top");
    return { x, y };
  }
  getLayerSize(): Size {
    const height = this.props.getResolvedStyleAttribute("height");
    const width = this.props.getResolvedStyleAttribute("width");
    return { width, height };
  }

  findIndexInParent(): any {
    return this._layers[0].findIndexInParent();
  }
  traverseLayersForStyleName(
    callback: (
      childLayer: DomainLayer | ConditionalExpression | ExpressionStatement
    ) => void
  ) {
    this._layers[0].traverseLayersForStyleName(callback);
  }

  traverseParentLayer(callback: (parentLayer: DomainLayer) => void) {
    this._layers[0].traverseParentLayer(callback);
  }

  get widthMode(): DimsMode {
    return this._layers[0].widthMode;
  }

  get heightMode(): DimsMode {
    return this._layers[0].heightMode;
  }

  get isWidthPercent(): boolean {
    let val = false;
    this._layers.forEach((layer: DomainLayer) => {
      if (layer.isWidthPercent) {
        val = true;
      }
    });
    return val;
  }

  get isHeightPercent(): boolean {
    let val = false;
    this._layers.forEach((layer: DomainLayer) => {
      if (layer.isHeightPercent) {
        val = true;
      }
    });
    return val;
  }

  get isWidthFill(): boolean {
    let val = false;
    this._layers.forEach((layer: DomainLayer) => {
      if (layer.isWidthFill) {
        val = true;
      }
    });
    return val;
  }
  get isHeightFill(): boolean {
    let val = false;
    this._layers.forEach((layer: DomainLayer) => {
      if (layer.isHeightFill) {
        val = true;
      }
    });
    return val;
  }
  get isWidthAuto(): boolean {
    let val = false;
    this._layers.forEach((layer: DomainLayer) => {
      if (layer.isWidthAuto) {
        val = true;
      }
    });
    return val;
  }
  get isHeightAuto(): boolean {
    let val = false;
    this._layers.forEach((layer: DomainLayer) => {
      if (layer.isHeightAuto) {
        val = true;
      }
    });
    return val;
  }

  getSiblingsWithFlex(): Array<DomainLayer> {
    return this._layers[0].getSiblingsWithFlex();
  }
  getFlexValue() {
    return this._layers[0].getFlexValue();
  }

  getParentLayerFlexDirection(): any {
    return this._layers[0].getParentLayerFlexDirection();
  }

  get isAutoDoable() {
    let val = false;
    this._layers.forEach((layer: DomainLayer) => {
      if (layer.isAutoDoable) {
        val = true;
      }
    });
    return val;
  }
  containsFlexChild() {
    let val = false;
    this._layers.forEach((layer: DomainLayer) => {
      if (layer.containsFlexChild()) {
        val = true;
      }
    });
  }

  getLayerElementType(): "position" | "flex" | "" {
    return this._layers[0].getLayerElementType();
  }

  updateEditorState(propertyName: string, values: any) {
    const property = this.ui[propertyName];
    forEach(values, (value: boolean | number, key: string) => {
      property[key] = value;
    });
  }

  toggleResizingTypeIsDoable(): boolean {
    const elementTypePosition = this.props.getResolvedStyleAttribute(
      "position"
    );
    if (elementTypePosition && elementTypePosition === "absolute") {
      return true;
    }
    return false;
  }

  getResizingType(): ResizingType {
    return this.ui.resizingType;
  }

  get setFlexPropertyIsDoable(): boolean {
    let val = false;
    this._layers.forEach((layer: DomainLayer) => {
      if (layer.setFlexPropertyIsDoable) {
        val = true;
      }
    });
    return val;
  }
  get setAlignSelfIsDoable(): boolean {
    let val = false;
    this._layers.forEach((layer: DomainLayer) => {
      if (layer.setAlignSelfIsDoable) {
        val = true;
      }
    });
    return val;
  }
  get isFlexChild() {
    let val = false;
    this._layers.forEach((layer: DomainLayer) => {
      if (layer.isFlexChild) {
        val = true;
      }
    });
    return val;
  }

  get isLayoutChild() {
    let val = false;
    this._layers.forEach((layer: DomainLayer) => {
      if (layer.isLayoutChild) {
        val = true;
      }
    });
    return val;
  }
  get splitViewIsDoable(): any {
    let val = false;
    this._layers.forEach((layer: DomainLayer) => {
      if (layer.splitViewIsDoable) {
        val = true;
      }
    });
    return val;
  }
  getLayoutChildrenLayerIds(): Array<DomainLayer> {
    return this._layers[0].getLayoutChildrenLayerIds();
  }
  getFlexChildrenLayerIds(): Array<DomainLayer> {
    return this._layers[0].getFlexChildrenLayerIds();
  }
  showLayoutOptions(): boolean {
    return this._layers[0].showLayoutOptions();
  }
  childrenFillTheParent() {
    return this._layers[0].childrenFillTheParent();
  }
  getTotalFlexOfFlexChildren() {
    return this._layers[0].getTotalFlexOfFlexChildren();
  }
}

export default DomainLayerCollection;
