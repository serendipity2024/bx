import {
  ExpressionX,
  BinaryExpressionX,
  DomainNode,
  LiteralX
} from "common-interfaces";
import Expression from "./Expression";
import BinaryExpression from "./BinaryExpression";
import DomainLayer from "../Base/Domain/Layer";
import DomainFile from "../Base/Domain/File";
import LayerNodeModel from "./LayerNodeModel";
import ConditionalExpression from "./ConditionalExpression";
import { types } from "serializable";
import { forEach, isNil, isObject, isPlainObject } from "lodash";
import { ExpressionStatement } from "domain-x";
import { Session } from "session";

export default class LiteralNode extends LayerNodeModel implements LiteralX {
  type: string = "literal";
  value: any;
  _parent: DomainLayer | DomainFile | ConditionalExpression | undefined;
  getFields(): { [key: string]: any } {
    return { type: types.literal, value: types.literal };
  }

  constructor(literalJSON: any, session: Session) {
    super(session);
    this.type = literalJSON.type;
    this.value = literalJSON.value;
    //
  }

  get parent() {
    return this._parent;
  }
  set parent(node: any) {
    this._parent = node;
  }
  get children() {
    return [];
  }

  toJS() {
    let valueJSON;
    if (this.value && this.value.toJS) {
      valueJSON = this.value.toJS();
    } else {
      if (isPlainObject(this.value)) {
        valueJSON = { ...this.value };
        // Fix for remaining _parent in plain object causing issue later in getFileCode
        delete valueJSON._parent;
      } else {
        valueJSON = this.value;
      }
    }
    return {
      type: this.type,
      value: valueJSON
    };
  }
  getValue(scopeVariables: any) {
    return isNil(this.value) ? this : this.value;
  }
  appendTo(
    parentNode: DomainFile | DomainLayer | DomainNode,
    index?: number | string | undefined
  ) {
    // throw new Error("Method not implemented.");
  }
  appendChild(
    childNode: DomainNode | ConditionalExpression,
    index?: number | string | undefined
  ) {
    this.value = childNode;
    // throw new Error("Method not implemented in domain-x LiteralNode");
  }
  remove() {
    const parentNode = this.parent;
    let attributeName;
    if (parentNode) {
      this.parent = undefined;
      forEach(parentNode, (value: any, key: string) => {
        if (value === this) {
          parentNode[key] = undefined;
          attributeName = key;
        }
      });
    }
    if (attributeName) {
      return attributeName;
    } else {
      throw new Error(
        "property dosenot exists on " + parentNode + " in Domain Compiled"
      );
    }
  }
  removeChild(index: number) {
    throw new Error("Method not implemented in domain-x LiteralNode");
  }
  traverseLayers(
    callback: (
      childLayer:
        | LiteralNode
        | DomainLayer
        | ExpressionStatement
        | ConditionalExpression
    ) => void
  ) {
    callback(this);
    if (this.value instanceof DomainLayer) {
      this.value.traverseLayers(callback);
    }
  }
}
