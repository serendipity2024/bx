import File from "./File";
import DomainLayer from "./Layer";
import { forEach, get } from "lodash";
import { Model } from "model";
import { types } from "serializable";
import { BX_PREVIEW_FILE_PATH } from "bx-constants";
import { Session } from "session";

export default class Domain extends Model {
  files: Map<string, File>;
  constructor() {
    super();
    this.files = new Map();
    // Talk to Himanshu
    this.files.forEach = (callback: any) => {
      const keys = this.files.keys();
      var key = keys.next();
      while (!key.done) {
        if (key.value !== BX_PREVIEW_FILE_PATH) {
          callback(this.files.get(key.value), key.value);
        } else {
          // console.log(BX_PREVIEW_FILE_PATH, callback, "callback");
        }
        key = keys.next();
      }
    };
  }

  forEachChild(
    layerJson: any,
    callback: (childLayer: any, index: number) => void
  ) {
    if (typeof layerJson.children === "string") {
      return;
    }
    forEach(layerJson.children, (childLayer: any, index: number) => {
      if (
        childLayer &&
        childLayer.type !== "unknown" &&
        childLayer.type !== "condtionalExpression" &&
        childLayer.type !== "" &&
        childLayer.type !== "statusBar"
      ) {
        callback(childLayer, index);
      }
    });
  }
  traverseLayers(layer: any, callback: (childLayer: any) => void) {
    callback(layer);
    this.forEachChild(layer, (childLayer: any, childIndex: number) => {
      if (typeof childLayer !== "string") {
        this.traverseLayers(childLayer, callback);
      }
    });
  }

  getFields() {
    return {
      files: types.map(types.literal, File)
    };
  }
  addFile(fileJSON: any, session: Session) {
    const file = new File(fileJSON, session);
    this.files.set(file.path, file);
    return file;
  }
  removeFile(fileId: string) {
    if (this.files.has(fileId)) {
      this.files.delete(fileId);
    }
  }
  setAllFilesIsDirty(isDirty: boolean) {
    this.files.forEach((file: File) => {
      file.setIsDirty(isDirty);
    });
  }
  renameFile(selectedFile: File, newFileName: string) {
    const newFileId = `${selectedFile.path.substring(
      0,
      selectedFile.path.lastIndexOf("/")
    )}/${newFileName}.js`;

    if (this.files.has(selectedFile.path)) {
      // const currentFileObj = this.getFileFromFileId(currentFileName);
      this.files.delete(selectedFile.path);
      selectedFile.path = newFileId;
      this.files.set(newFileId, selectedFile);
    }
  }
  getFileFromFileId(fileId: string) {
    const file = this.files.get(fileId);
    if (file) {
      return file;
    } else {
      throw new Error(`Domain File doesn't exists for ${fileId}`);
    }
  }
  getSymbols() {
    let symbols: any = [];
    this.files.forEach((file: File) => {
      if (file.isSymbol()) {
        symbols.push(file);
      }
    });
    return symbols;
  }

  getOverridableLayers(fileId: string): Array<DomainLayer> {
    let overridableLayers = new Array<DomainLayer>();
    const symbolFile = this.files.get(fileId);
    if (!symbolFile) {
      return [];
    }

    let symbolRootLayer = symbolFile.layer;

    if (symbolRootLayer instanceof DomainLayer) {
      symbolRootLayer.traverseLayers((childLayer: DomainLayer) => {
        if (
          childLayer.import.layerName === "Text" &&
          get(childLayer, "children.0.type") === "literal"
        ) {
          overridableLayers.push(childLayer);
        } else if (childLayer.import.layerName === "TextInput") {
          const placeholder = get(childLayer, "props.placeholder");
          if (!placeholder || typeof placeholder === "string") {
            overridableLayers.push(childLayer);
          }
        } else if (childLayer.type === "view") {
          const style = get(childLayer, "props.style");
          const backgroundColor = style.get("backgroundColor");
          if (!backgroundColor || typeof backgroundColor === "string") {
            overridableLayers.push(childLayer);
          }
        }
      });
    }
    return overridableLayers;
  }

  getSymbolFileFromSymbolInstance(layer: DomainLayer): File | undefined {
    const importPath = layer.import.packageName;
    if (!importPath) {
      throw new Error(`import Path doesnot exists on ${layer}`);
    }

    const symbolFile = this.files.get(importPath);
    if (!symbolFile) {
      console.error(
        `symbol file doesnot exists for ${layer} with import path ${importPath}`
      );
      return undefined;
    }
    return symbolFile;
  }
}
