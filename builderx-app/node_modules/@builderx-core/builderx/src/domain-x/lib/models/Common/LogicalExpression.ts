import { LogicalExpressionX, DomainNode } from "common-interfaces";
import Expression from "./Expression";
import BinaryExpression from "./BinaryExpression";
import LayerNodeModel from "./LayerNodeModel";
import DomainFile from "../Base/Domain/File";
import DomainLayer from "../Base/Domain/Layer";
import { ConditionalExpression, ExpressionStatement } from "domain-x";
import { set } from "lodash";
import { Session } from "session";

export default class LogicalExpression extends LayerNodeModel
  implements LogicalExpressionX {
  type: string = "logicalExpression";
  operator: string;
  left: BinaryExpression | Expression | any;
  right: BinaryExpression | Expression | any;
  _parent: any;
  toJS() {
    return {
      type: this.type,
      operator: this.operator,
      left: this.left.toJS ? this.left.toJS() : this.left,
      right: this.right.toJS ? this.right.toJS() : this.right
    };
  }
  get parent() {
    return this._parent;
  }
  set parent(node: any) {
    this._parent = node;
  }
  constructor(logicalExpressionJSON: LogicalExpressionX, session: Session) {
    super(session);
    this.type = logicalExpressionJSON.type;
    this.operator = logicalExpressionJSON.operator;
  }
  appendTo(
    parentNode: DomainFile | DomainLayer | DomainNode,
    index?: number | string | undefined
  ) {
    throw new Error("Method not implemented.");
  }
  appendChild(
    childNode: DomainLayer | ConditionalExpression | ExpressionStatement,
    index?: number | undefined
  ): any {
    if (index) {
      set(this, index, childNode);
      return index;
    }
    throw new Error("index undefined in LogicalExpression");
  }
  remove() {
    throw new Error("Method not implemented. ConditionalExpression");
  }
  removeChild(index: number) {
    throw new Error("Method not implemented. ConditionalExpression");
  }
  traverse(callback: any, node?: any) {
    if (!node) {
      node = this;
    }
    if (node instanceof LogicalExpression) {
      this.traverse(callback, node.left);
      this.traverse(callback, node.right);
    } else {
      callback(node);
    }
  }
  traverseLayers(callback: any) {
    callback(this);
    this.left.traverseLayers(callback);
    this.right.traverseLayers(callback);
  }
}
