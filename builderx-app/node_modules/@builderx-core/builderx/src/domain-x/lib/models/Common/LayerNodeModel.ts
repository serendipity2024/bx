import { Model } from "model";
import { INode, DomainNode } from "common-interfaces";
import { findIndex, get, forEach, isArray, indexOf, findKey } from "lodash";
import DomainLayer from "../Base/Domain/Layer";
import DomainFile from "../Base/Domain/File";
import { Style, ExpressionStatement, Props } from "domain-x";
import ConditionalExpression from "./ConditionalExpression";
import { types } from "serializable";
import { Session } from "session";

abstract class LayerNodeModel extends Model
  implements
    INode<DomainLayer | DomainFile | DomainNode, DomainLayer | DomainNode> {
  children: Array<DomainLayer | DomainNode>;
  _parent: DomainFile | DomainLayer | DomainNode | undefined;
  session: Session;
  constructor(session: Session) {
    //
    super();
    this.session = session;
  }
  get parent() {
    return this._parent;
  }
  set parent(node: any) {
    this._parent = node;
  }
  getFields(): { [key: string]: any } {
    return {
      _parent: types.ignore
    };
  }
  appendTo(
    parentNode: DomainFile | DomainLayer | DomainNode,
    index?: number | string | undefined
  ) {
    // throw new Error("Method not implemented.");
  }
  abstract appendChild(
    childNode: DomainLayer | DomainNode,
    index?: number | string | undefined
  ): any;
  remove() {
    throw new Error("Method not implemented.");
  }
  removeChild(index: number) {
    throw new Error("Method not implemented.");
  }
  //   getPath(node: any): string {
  //     throw new Error("Method not implemented.");
  //   }
  getPath(node?: any, appendString?: boolean): string {
    if (!node) {
      node = this;
    }
    if (node.type === "file") {
      return node.path;
    } else if (node.type === "fileHeader" && node.file) {
      return `${this.getPath(node.file, appendString)}:header`;
    } else if (node.type === "root" && node.parent) {
      return `${this.getPath(node.parent, appendString)}:0`;
    } else if (node.type === "loop" && node.parent) {
      return `${this.getPath(node.parent, appendString)}`;
    } else if (node.type && node.parent) {
      if (node._parent.type === "expressionStatement") {
        return `${this.getPath(node._parent, appendString)}.expression`;
      } else if (node._parent.type === "literal") {
        return `${this.getPath(node._parent, appendString)}`;
      } else if (node._parent.type === "expression") {
        return `${this.getPath(node._parent, appendString)}.expression`;
      } else if (
        node._parent.type === "binaryExpression" ||
        node._parent.type === "logicalExpression"
      ) {
        if (node._parent.left === node) {
          return `${this.getPath(node._parent, appendString)}.left`;
        } else {
          return `${this.getPath(node._parent, appendString)}.right`;
        }
      } else if (node._parent.type === "conditionalExpression") {
        if (node._parent.alternate === node) {
          return `${this.getPath(node._parent, appendString)}.alternate`;
        } else {
          return `${this.getPath(node._parent, appendString)}.consequent`;
        }
      } else if (get(node, "parent.import.layerName", "") === "FlatList") {
        const parentProps: Array<DomainLayer> = node.parent.props;
        const childIndex = findKey(parentProps, (child: DomainLayer) => {
          if (child) {
            return node === child;
          }
          return false;
        });

        return `${this.getPath(node.parent, appendString)}.props.${childIndex}`;
        // return `${this.getPath(node.parent, appendString)}.props`;
      } else if (
        (!node.parent.type || node.parent instanceof Props) &&
        node.parent.getFullPath
      ) {
        const parentStyle: Array<any> = node.parent;
        const childIndex = findKey(parentStyle, (child: any) => {
          if (child) {
            return node === child;
          }
          return false;
        });

        return `${node.parent.getFullPath()}.${childIndex}`;
      } else {
        if (node.parent.type === "loop") {
          node = node.parent;
        }
        const parentChildren: Array<DomainLayer> = node.parent.children;

        const childIndex = findIndex(parentChildren, (child: DomainLayer) => {
          if (child) {
            return node === child;
          }
          return false;
        });

        if (appendString) {
          return `${this.getPath(
            node.parent,
            appendString
          )}.children.${childIndex}`;
        } else {
          return `${this.getPath(node.parent, appendString)}.${childIndex}`;
        }
      }
    } else {
      return "";
    }
  }

  getFullPath() {
    return this.getPath(undefined, true);
  }

  getAbstractedLayer(
    layer?: any
  ): DomainLayer | ExpressionStatement | ConditionalExpression {
    if (!layer) {
      layer = this;
    }
    // console.log(layer, layer._parent, "layer here layer");
    if (layer._parent) {
      if (
        layer._parent instanceof DomainLayer ||
        layer._parent instanceof DomainFile
      ) {
        return layer;
      } else if (
        layer._parent.type === "expressionStatement" ||
        layer._parent.type === "conditionalExpression"
      ) {
        return layer._parent;
      } else {
        // console.log(
        //   layer._parent,
        //   layer._parent instanceof DomainLayer,
        //   layer._parent instanceof ExpressionStatement,
        //   layer._parent instanceof ConditionalExpression,
        //   layer._parent.type === "expressionStatement",
        //   layer._parent.type === "conditionalExpression",
        //   "layer._parentlayer._parentlayer._parentlayer._parent"
        // );
        // debugger;
        return this.getAbstractedLayer(layer._parent);
      }
    } else {
      // return undefined;
      throw new Error("_parent undefined");
    }
  }

  // getPartialPath2(node?: any): string {
  //   if (!node) {
  //     node = this;
  //   }
  //   if (node.type === "root") {
  //     return `0`;
  //   } else if (node.type && node.parent && node.parent.children) {
  //     if (node.parent.type === "conditionalExpression") {
  //       if (node.parent.alternate === node) {
  //         return `${this.getPartialPath2(node.parent)}.alternate`;
  //       } else {
  //         return `${this.getPartialPath2(node.parent)}.consequent`;
  //       }
  //     } else if (
  //       get(node, "type", "") === "thirdParty" &&
  //       get(node, "parent.import.layerName", "") === "FlatList"
  //     ) {
  //       return `${this.getPath(node.parent)}.props`;
  //     } else {
  //       const parentChildren: Array<DomainLayer> = node.parent.children;
  //       const childIndex = findIndex(parentChildren, (child: DomainLayer) => {
  //         if (child) {
  //           return node === child;
  //         }
  //         return false;
  //       });

  //       return `${this.getPartialPath2(node.parent)}.children.${childIndex}`;
  //     }
  //   } else {
  //     return "";
  //   }
  // }
  getPartialPath(node?: any): string {
    const path = this.getPath(node, true);

    const partialPath = path.split(":")[1];
    return partialPath;
    // if (!node) {
    //   node = this;
    // }
    // if (node.type === "root") {
    //   return `0`;
    // } else if (node.type && node.parent && node.parent.children) {
    //   if (node.parent.type === "conditionalExpression") {
    //     if (node.parent.alternate === node) {
    //       return `${this.getPartialPath(node.parent)}.alternate`;
    //     } else {
    //       return `${this.getPartialPath(node.parent)}.consequent`;
    //     }
    //   } else if (
    //     get(node, "type", "") === "thirdParty" &&
    //     get(node, "parent.import.layerName", "") === "FlatList"
    //   ) {
    //     return `${this.getPath(node.parent)}.props`;
    //   } else {
    //     const parentChildren: Array<DomainLayer> = node.parent.children;
    //     const childIndex = findIndex(parentChildren, (child: DomainLayer) => {
    //       if (child) {
    //         return node === child;
    //       }
    //       return false;
    //     });

    //     return `${this.getPartialPath(node.parent)}.children.${childIndex}`;
    //   }
    // } else {
    //   return "";
    // }
  }

  //   getPath(node?: any): string {
  //     if (!node) {
  //       node = this;
  //     }
  //     if (node.type === "root") {
  //       return `${node.parent.path}:0`;
  //     } else if (node.type && node.parent && node.parent.children) {
  //       const parentChildren: Array<any> = node.parent.children;
  //       const childIndex = findIndex(parentChildren, (child: any) => {
  //         if (child) {
  //           return node === child;
  //         }
  //         return false;
  //       });
  //       return `${this.getPath(node.parent)}.${childIndex}`;
  //     } else {
  //       return "";
  //     }
  //   }
  //   getPartialPath(node?: any): string {
  //     if (!node) {
  //       node = this;
  //     }
  //     if (node.type === "root") {
  //       return `0`;
  //     } else if (node.type && node.parent && node.parent.children) {
  //       const parentChildren: Array<DomainLayer> = node.parent.children;
  //       const childIndex = findIndex(parentChildren, (child: DomainLayer) => {
  //         if (child) {
  //           return node === child;
  //         }
  //         return false;
  //       });
  //       return `${this.getPartialPath(node.parent)}.${childIndex}`;
  //     } else {
  //       return "";
  //     }
  //   }

  findIndexInParent() {
    let index;
    const parent = this.parent;
    forEach(parent, (value: any, key: string) => {
      if (isArray(value)) {
        const childIndex = indexOf(value, this);
        if (childIndex > -1) {
          index = `${key}.${childIndex}`;
        }
      } else {
        if (value === this) {
          index = key;
        }
      }
    });
    return index;
  }

  getLayerFromPath(path: string) {
    let partialPath = path.split(":")[1];
    if (!partialPath) {
      return this;
    }
    partialPath = partialPath.replace("0", "layer");
    let layer = get(this, partialPath);
    return layer;
  }

  getFile(node?: any): DomainFile | null {
    if (!node) {
      node = this;
    }
    if (node.type === "root" && node.parent instanceof DomainFile) {
      return node.parent;
    } else if (node.parent) {
      return this.getFile(node.parent);
    } else {
      return null;
    }
  }

  findParentWithReverseRef(node?: any): any {
    if (!node) {
      node = this;
    }
    if (
      !(node instanceof ConditionalExpression) &&
      !(node instanceof ExpressionStatement)
    ) {
      return node;
    } else if (node.parent) {
      return this.findParentWithReverseRef(node.parent);
    } else {
      return undefined;
    }
  }

  getSymbolRootLayer(node?: any): any {
    if (!node) {
      node = this;
    }

    console.log(node, "node here there");
    if (node && node.domain && node.domain.type === "root") {
      return node;
    }
    if (node && node.domain && node.domain.type === "file") {
      return node.layer;
    }
    if (!node || !node.parent) {
      return undefined;
    }
    return this.getSymbolRootLayer(node.parent);
  }
}

export default LayerNodeModel;
