import { forEach, isArray, isNil, indexOf, set, get } from "lodash";
import { Model } from "model";
import { types } from "serializable";
import Props from "./Props";
import { Utils } from "utils";
import LayerNodeModel from "./LayerNodeModel";
import { STYLE_PROP_NAMES } from "bx-constants";

export class Transform extends Model {
  rotate?: string;
  scaleX?: number;
  scaleY?: number;
  constructor(transform: any) {
    super();
    if (transform) {
      this.rotate = transform.rotate;
      this.scaleX = transform.scaleX;
      this.scaleY = transform.scaleY;
    }
  }
  getFields(): { [key: string]: any } {
    return {
      rotate: types.literal,
      scaleX: types.literal,
      scaleY: types.literal
    };
  }

  isEqual(otherTransform: any) {
    if (this.rotate === otherTransform.rotate) {
      return true;
    } else {
      return false;
    }
  }
}

export default class Style extends Model {
  _parent: Props | LayerNodeModel;

  static fromJS(styles: any) {
    const classInstance = new Style();
    forEach(styles, (value: any, key: any) => {
      classInstance[key] = value;
    });
    return classInstance as any;
  }
  set(key: string, value: any) {
    set(this, key, value);
  }

  get(key: string) {
    return get(this, key);
  }

  get parent() {
    return this._parent;
  }
  set parent(node: any) {
    this._parent = node;
  }
  getPath(): string {
    const node = this;
    if (node.parent && node.parent.getFullPath) {
      const styleObjectsInProp = STYLE_PROP_NAMES.map(styleName => ({
        key: styleName,
        value: node.parent[styleName]
      }));

      let stylePropName;
      styleObjectsInProp.forEach(({ key, value }) => {
        if (value === this) {
          stylePropName = key;
        }
      });
      if (stylePropName) {
        return `${node.parent.getFullPath()}.${stylePropName}`;
      } else {
        return "";
      }
    } else {
      return "";
    }
  }

  getFullPath() {
    return this.getPath();
  }

  toJS() {
    const styleJSON: any = {};

    forEach(this, (value: any, key: any) => {
      if (!Utils.isInvalidKey(key)) {
        // if (
        //   STYLE_PROP_NAMES.indexOf(key) !== -1 ||
        //   FLATLIST_PROPS.indexOf(key) !== -1
        // ) {
        //   let keyVal = this.get(key);
        //   styleJSON[key] = keyVal && keyVal.toJS ? keyVal.toJS() : keyVal;
        //   if (size(styleJSON[key]) === 0 && key !== "style") {
        //     delete styleJSON[key];
        //   }
        // } else {
        styleJSON[key] = value && value.toJS ? value.toJS() : value;
        // }
      }
    });
    return styleJSON;
  }

  // toJS() {
  //   const styleJSON: any = this.getAll();
  //   delete styleJSON["parent"];
  //   return styleJSON;
  // }

  findIndexInParent() {
    let index;
    const parent = this.parent;
    forEach(parent, (value: any, key: string) => {
      if (isArray(value)) {
        const childIndex = indexOf(value, this);
        if (childIndex > -1) {
          index = `${key}.${childIndex}`;
        }
      } else {
        if (value === this) {
          index = key;
        }
      }
    });
    return index;
  }

  customToJS(propsJSON: any) {
    let propObj = {};
    if (isArray(propsJSON)) {
      propObj = [];
    }

    forEach(propsJSON, (value: any, key: string) => {
      if (!isNil(value) && typeof value === "object") {
        if (isArray(propObj)) {
          propObj.push(
            value && value.toJS ? value.toJS() : this.customToJS(value)
          );
        } else {
          propObj[key] =
            value && value.toJS ? value.toJS() : this.customToJS(value);
        }
      } else {
        if (isArray(propObj)) {
          propObj.push(value && value.toJS ? value.toJS() : value);
        } else {
          propObj[key] = value && value.toJS ? value.toJS() : value;
        }
      }
    });

    return propObj;
  }
}
