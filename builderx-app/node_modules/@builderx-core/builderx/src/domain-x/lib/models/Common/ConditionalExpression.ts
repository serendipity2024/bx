import { ConditionalExpressionX, DomainNode } from "common-interfaces";
import Expression from "./Expression";
import BinaryExpression from "./BinaryExpression";
import DomainLayer from "../Base/Domain/Layer";
import DomainFile from "../Base/Domain/File";
import LayerNodeModel from "./LayerNodeModel";
import { forEach, isNil, findIndex } from "lodash";
import { ExpressionStatement } from "domain-x";
import { Session } from "session";

export default class ConditionalExpression extends LayerNodeModel
  implements ConditionalExpressionX {
  type: string = "conditionalExpression";
  test: Expression | BinaryExpression;
  consequent: DomainNode | any;
  alternate: DomainNode | any;
  parent: DomainLayer | DomainFile | ConditionalExpression | undefined;
  conditionalParent: DomainNode | any;

  constructor(session: Session) {
    super(session);
    this.type = "conditionalExpression";
    this.conditionalParent = null;
  }

  getAbstractedLayer() {
    return this;
  }
  toJS() {
    return {
      type: this.type,
      test: this.test.toJS ? this.test.toJS() : this.test,
      consequent:
        this.consequent && this.consequent.toJS
          ? this.consequent.toJS()
          : this.consequent,
      alternate:
        this.alternate && this.alternate.toJS
          ? this.alternate.toJS()
          : this.alternate
    };
  }

  getPathRelativeToLayer(
    node?: DomainLayer | ExpressionStatement | ConditionalExpression
  ): string {
    //
    if (!node) {
      node = this;
    }
    if (node && node.parent) {
      if (
        node.parent instanceof DomainLayer ||
        node.parent instanceof DomainFile
      ) {
        return `${node.findIndexInParent()}`;
      } else {
        return `${this.getPathRelativeToLayer(
          node.parent as any
        )}.${node.findIndexInParent()}`;
      }
    } else if (!node || !node.parent) {
      return "";
    } else {
      return "";
    }
  }
  getFile(
    node?: DomainLayer | ExpressionStatement | ConditionalExpression
  ): DomainFile | null {
    if (!node) {
      node = this;
    }
    if (node.type === "root" && node.parent instanceof DomainFile) {
      return node.parent;
    } else if (node.parent) {
      return this.getFile(node.parent as DomainLayer);
    } else {
      return null;
    }
  }
  // get children() {
  //   let children = [];
  //   if (this.consequent) {
  //     children.push(this.consequent);
  //   }
  //   if (this.alternate) {
  //     children.push(this.alternate);
  //   }
  //   return children;
  // }
  appendTo(
    parentNode: DomainFile | DomainLayer | DomainNode,
    index?: number | string | undefined
  ) {
    // throw new Error("Method not implemented.");
  }
  appendChild(
    childNode: DomainLayer | ConditionalExpression,
    index?: number | string | undefined
  ) {
    this[index as string] = childNode;
    childNode.parent = this;
    return index;
  }
  remove() {
    const parentNode = this.parent;
    if (parentNode) {
      this.parent = undefined;
      const index = findIndex(parentNode["children"], (child: any) => {
        return child === this;
      });
      if (!isNil(index)) {
        parentNode["children"].splice(index, 1);
      }
      return index;
    } else {
      throw Error("Parent Node not found on Detach");
    }
  }
  removeChild(index: number) {
    throw new Error("Method not implemented. ConditionalExpression");
  }
  traverseLayers(
    callback: (childLayer: DomainLayer | ConditionalExpression) => void
  ) {
    console.log(this, "hello this");
    callback(this);
    if (this instanceof ConditionalExpression) {
      this.consequent.traverseLayers(callback);
      this.alternate.traverseLayers(callback);
    }
    this.forEachChild(
      (childLayer: DomainLayer | ConditionalExpression, childIndex: number) => {
        if (childLayer instanceof DomainLayer) {
          if (typeof childLayer !== "string") {
            childLayer.traverseLayers(callback);
          }
        } else if (childLayer instanceof ConditionalExpression) {
          childLayer.consequent.traverseLayers(callback);
          childLayer.alternate.traverseLayers(callback);
        } else {
          // console.log(childLayer, "childLayerchildLayerchildLayer");
        }
      }
    );
  }
  forEachChild(callback: (childLayer: DomainLayer, index: number) => void) {
    if (typeof this.children === "string") {
      return;
    }
    forEach(this.children, (childLayer: DomainLayer, index: number) => {
      if (
        childLayer &&
        childLayer.type !== "unknown" &&
        childLayer.type !== "literal" &&
        childLayer.type !== "" &&
        childLayer.type !== "expression" &&
        childLayer.type !== "statusBar"
      ) {
        callback(childLayer, index);
      }
    });
  }
}
