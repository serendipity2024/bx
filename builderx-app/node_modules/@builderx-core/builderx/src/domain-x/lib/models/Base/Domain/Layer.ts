import { DomainNode, IClone, IDisposable } from "common-interfaces";
import { ExpressionStatement, LogicalExpression, LiteralNode } from "domain-x";
import {
  cloneDeep,
  findIndex,
  forEach,
  isNil,
  omitBy,
  get,
  isEmpty
} from "lodash";
import { types } from "serializable";
import { Utils, ResolveNodeValue } from "utils";
import { v4 as uuid } from "uuid";
import ConditionalExpression from "../../Common/ConditionalExpression";
import Import from "../../Common/Import";
import LayerNodeModel from "../../Common/LayerNodeModel";
import OverrideModel from "../../Common/OverrideModel";
import Props from "../../Common/Props";
import ResizingType from "../../Common/ResizingType";
import Template from "../../Common/Template";
import Ui from "../../Common/Ui";
import { Position, Size } from "../../types";
import LayerNode from "./../../Common/Interfaces";
import DomainFile from "./File";
import { Model } from "model";
import { Layout } from "@builderx-core/designer/dist/models/Layout";
import { Canvas, Layer } from "@builderx-core/designer";
import { Session } from "session";
import { BX_PREVIEW_FILE_PATH } from "bx-constants";
type DimsMode = "fixed" | "auto" | "fill" | "percent";

export class RCDims extends Model {
  x: number;
  y: number;
  width: number;
  height: number;
  constructor(rcDims: any) {
    super();
    this.x = rcDims.x;
    this.y = rcDims.y;
    this.height = rcDims.height;
    this.width = rcDims.width;
  }
  getFields(): { [key: string]: any } {
    return {
      x: types.literal,
      y: types.literal,
      width: types.literal,
      height: types.literal
    };
  }
}

type StageData = {
  scroll: {
    x: number;
    y: number;
  };
  zoom: number;
};
class DomainLayer extends LayerNodeModel
  implements
    IDisposable,
    IClone<DomainLayer | DomainNode>,
    LayerNode<DomainLayer | DomainFile | DomainNode, DomainLayer | DomainNode> {
  _parent:
    | DomainLayer
    | DomainFile
    | ConditionalExpression
    | LogicalExpression
    | ExpressionStatement
    | undefined;
  id: string;
  children: Array<DomainLayer | ConditionalExpression | ExpressionStatement>;
  beforeDisposeCallback?: ((instance: any) => void) | undefined;
  type: string;
  styleName: string;
  import: Import;
  selected: boolean;
  hovered: boolean;
  collapsed: boolean;
  locked: boolean;
  hidden: boolean = false;
  dragHoverInside: boolean;
  dragHoverParent: boolean;
  dragHoverBefore: boolean;
  dragHoverAfter: boolean;
  isResizerVisible: boolean;
  navigateTo?: string;
  props: Props;
  ui: Ui;
  template: Template;
  overrideKeys: Array<OverrideModel>;
  stageData?: StageData;
  layout: Layout;
  _isGroup: boolean;
  scopeVariables: { [key: string]: any } = {};
  autoRenaming: boolean;
  aspectRatio: number | undefined;
  childrenLocked: boolean;
  constructor(layerJSON: any, session: Session) {
    super(session);
    this.type = layerJSON.type;
    this.id = layerJSON.id ? layerJSON.id : uuid();
    this.styleName = layerJSON.styleName;
    this.import = new Import(layerJSON.import);
    this.props = new Props();
    // this.props.set("parent", this);
    this.props.parent = this;
    this.children = [];
    this.overrideKeys = [];
    if (layerJSON.overrideKeys) {
      layerJSON.overrideKeys.forEach((overrideObject: any) => {
        this.overrideKeys.push(OverrideModel.fromJS(overrideObject));
      });
    }
    this.template = new Template(layerJSON.template);
    this.locked = layerJSON.locked;
    this.hidden = layerJSON.hidden;
    this.collapsed = layerJSON.collapsed;
    this._isGroup = false;
    this.ui = new Ui(layerJSON.props.style);
    this.scopeVariables = layerJSON.scopeVariables
      ? layerJSON.scopeVariables
      : {};
    this.autoRenaming = layerJSON.autoRenaming || false;
    this.aspectRatio = layerJSON.aspectRatio;
  }
  get isGroup() {
    return this.type !== "text" && (this._isGroup || !isEmpty(this.children));
  }
  setIsGroup(val: boolean = true) {
    this._isGroup = val;
  }
  setNavigationRoute(routeName: string) {
    this.navigateTo = routeName;
  }
  setAspectRatio(value: number | undefined) {
    this.aspectRatio = value;
  }
  get parent() {
    // TODO: heavy jugaad
    try {
      return this.getAbstractedLayer()._parent;
    } catch (err) {
      console.log(err);
      return undefined;
    }
  }
  set parent(node: any) {
    this._parent = node;
  }
  get rcDims() {
    const file = this.getFile();
    let renderRef = this.getOwnCanvasRef();

    if (file && file.isSymbol()) {
      const stage = this.session.stages.get(file.path);
      if (stage) {
        renderRef = this.session.executeFunction(
          "getOwnCanvasRef",
          this,
          stage.canvas
        );
      }
    }
    if (file && file.path === BX_PREVIEW_FILE_PATH) {
      const previewStage = this.session.stages.get(BX_PREVIEW_FILE_PATH);
      if (previewStage) {
        renderRef = this.session.executeFunction(
          "getOwnCanvasRef",
          this,
          previewStage.canvas
        );
      }
    }
    if (renderRef) {
      const dims = renderRef.getBoundingClientRect();
      return new RCDims({
        x: Math.round(dims.x * 100) / 100,
        y: Math.round(dims.y * 100) / 100,
        height: Math.round(dims.height * 100) / 100,
        width: Math.round(dims.width * 100) / 100
      });
    }
    return undefined;
  }
  getBoundingClientRect() {
    let dims = {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      rotation: 0,
      rootX: 0,
      rootY: 0
    };
    const ownStageRef = this.getOwnCanvasRef();
    if (ownStageRef) {
      return ownStageRef.getBoundingClientRect();
    }

    return dims;
  }
  getOwnCanvasRef(): Layer {
    const canvasRef = this.session.executeFunction(
      "getOwnCanvasRef",
      this,
      this.session.currentStage.canvas
    );

    return canvasRef;
  }
  setStageData(data: StageData) {
    this.stageData = data;
  }
  platform() {
    let fileLayer: any = this;
    while (fileLayer.type !== "file") {
      fileLayer = fileLayer.parent;
    }
    return fileLayer.scopeVariables.platform || "iOS";
  }
  getSelectedAbstractLayer(
    layer?: any
  ): DomainLayer | ExpressionStatement | ConditionalExpression | DomainFile {
    if (!layer) {
      layer = this;
    }
    if (layer._parent) {
      if (
        layer._parent instanceof DomainLayer ||
        layer._parent instanceof DomainFile
      ) {
        return layer._parent;
      } else if (
        !(layer._parent instanceof DomainLayer) &&
        (layer._parent instanceof ExpressionStatement ||
          layer._parent instanceof ConditionalExpression)
      ) {
        return layer._parent;
      } else {
        return this.getSelectedAbstractLayer(layer._parent);
      }
    } else {
      // return undefined;
      throw new Error("_parent undefined");
    }
  }

  getFields(): { [key: string]: any } {
    return {
      _parent: types.ignore,
      type: types.literal,
      // id: types.literal,
      children: types.array(DomainLayer),
      import: Import,
      innerText: types.literal,
      styleName: types.literal,
      locked: types.literal,
      hidden: types.literal,
      collapsed: types.literal,
      overrideKeys: types.array(types.literal),
      template: Template,
      navigateTo: types.literal,
      _top: types.literal,
      _left: types.literal,
      _right: types.literal,
      _bottom: types.literal,
      _height: types.literal,
      _width: types.literal,
      rcDims: RCDims,
      props: Props,
      scopeVariables: types.literal,
      blobURL: types.literal,
      aspectRatio: types.literal
      // gradient: Gradient
    };
  }

  dispose() {
    if (this.beforeDisposeCallback) {
      this.beforeDisposeCallback(this);
    }
    this.traverseLayers(childLayer => {
      if (childLayer instanceof DomainLayer && this !== childLayer) {
        childLayer.dispose();
      }
    });

    this.disposed = true;
    // traverse children and dispose
  }

  restore() {
    this.traverseLayers(childLayer => {
      if (childLayer instanceof DomainLayer && this !== childLayer) {
        childLayer.restore();
      }
    });

    this.disposed = false;
    // traverse children and restore
  }

  beforeDispose(beforeDisposeCallback: (instance: any) => void) {
    this.beforeDisposeCallback = beforeDisposeCallback;
  }
  clone(): DomainLayer {
    return DomainLayer.fromJS(this.toJS());
  }
  appendTo(parentNode: DomainLayer, index?: number | undefined) {
    this.parent = parentNode;
    if (!parentNode.children) {
      throw new Error("layer's children property not defined");
    }

    this.restore();

    if (index) {
      parentNode.children.splice(index, 0, this);
    } else {
      parentNode.children.push(this);
      index = parentNode.children.length - 1;
    }
    this.ui.setResizingType(this.props.style);

    return index;
  }
  appendChild(
    childNode: DomainLayer | ExpressionStatement | ConditionalExpression,
    index?: number | undefined,
    replaceChild?: boolean
  ): any {
    // if (childNode.type === "literal") debugger;

    if (childNode instanceof DomainLayer) {
      childNode.restore();
    }

    if (!isNil(index)) {
      if (replaceChild) {
        this.children.splice(index, 1, childNode);
      } else {
        this.children.splice(index, 0, childNode);
      }
    } else {
      this.children.push(childNode);
      index = this.children.length - 1;
    }

    childNode.parent = this;

    return index;
  }
  remove() {
    const parentNode = this.parent;
    let index;
    if (parentNode) {
      this.parent = undefined;
      if (parentNode.type === "thirdParty") {
        parentNode.removeChildByRef(this);
      } else if (this.type === "root" && parentNode instanceof DomainFile) {
        index = "layer";
        delete parentNode["layer"];
      } else {
        index = findIndex(parentNode["children"], (child: DomainLayer) => {
          return child === this;
        });
        if (!isNil(index)) {
          parentNode["children"].splice(index, 1);
        }
      }

      this.dispose();
      return index;
    } else {
      throw Error("Parent Node not found on Detach");
    }
  }
  removeChild(index: number) {
    const child = this.children[index];
    if (
      child instanceof DomainLayer ||
      child instanceof ExpressionStatement ||
      child instanceof ConditionalExpression
    ) {
      child.parent = undefined;
      let childNode: DomainLayer | ExpressionStatement | ConditionalExpression;
      childNode = child;
      this.children.splice(index, 1);
      if (childNode instanceof DomainLayer) {
        childNode.dispose();
      }
      return childNode;
    } else {
      throw new Error(" removeChild in domain layer ");
    }
  }

  getRootLayer(currentRootLayer: any, node?: any): any {
    node = node ? node : this;

    if (!node) {
      return undefined;
    } else if (node.type === "root") {
      return node;
    } else if (node === currentRootLayer) {
      return node;
    } else if (node._parent && node._parent.type === "thirdParty") {
      return node._parent;
    } else if (node._parent) {
      return this.getRootLayer(currentRootLayer, node._parent);
    } else {
      return undefined;
    }
  }
  getParentLayer(parent?: any): any {
    parent = parent ? parent : this.parent;
    if (!parent) {
      return undefined;
    } else if (!Utils.shouldIgnoreLayer(parent.type)) {
      return parent;
    } else {
      return this.getParentLayer(parent.parent);
    }
  }
  isDescendantOfThirdParty(): boolean {
    let parent = this.parent;
    while (parent && parent.type !== "root") {
      if (parent.type === "thirdParty") {
        return true;
      }
      parent = parent.parent;
    }
    return false;
  }
  getChildren() {
    return this.type !== "conditionalExpression" ? this.children : [];
  }

  getFile(
    node?: DomainLayer | ExpressionStatement | ConditionalExpression
  ): DomainFile | null {
    if (!node) {
      node = this;
    }
    if (node.type === "root" && node.parent instanceof DomainFile) {
      return node.parent;
    } else if (node.parent) {
      return this.getFile(node.parent as DomainLayer);
    } else {
      return null;
    }
  }

  setStyleName(name: string) {
    this.styleName = name;
  }

  getLayerPosition(): Position {
    const x = this.props.getResolvedStyleAttribute("left");
    const y = this.props.getResolvedStyleAttribute("top");
    return { x, y };
  }
  getLayerSize(): Size {
    const height = this.props.getResolvedStyleAttribute("height");
    const width = this.props.getResolvedStyleAttribute("width");
    return { width, height };
  }

  findIndexInParent(): any {
    const parentLayer = this.parent;
    if (parentLayer && parentLayer instanceof DomainLayer) {
      const index = findIndex(
        parentLayer.children,
        (child: ExpressionStatement | ConditionalExpression | DomainLayer) => {
          if (
            child instanceof ExpressionStatement ||
            child instanceof ConditionalExpression
          ) {
            const file = parentLayer.getFile();
            if (file) {
              const resolvedChild = ResolveNodeValue(
                child,
                file.scopeVariables
              );
              return resolvedChild === this;
            } else {
              return false;
            }
          }
          return child === this;
        }
      );
      return index;
    } else {
      return -1;
    }
  }

  forEachChild(
    callback: (childLayer: DomainLayer, index: number) => void,
    traverseConditionalsLayers: boolean = false
  ) {
    if (typeof this.children === "string") {
      return;
    }
    forEach(this.children, (childLayer: DomainLayer, index: number) => {
      if (childLayer.type === "loop") {
        childLayer.forEachChild(callback);
      } else if (!Utils.shouldIgnoreLayer(childLayer.type)) {
        callback(childLayer, index);
      } else if (traverseConditionalsLayers) {
        if (
          childLayer.type === "expressionStatement" ||
          childLayer.type === "conditionalExpression"
        ) {
          callback(childLayer, index);
        }
      }
    });
  }

  traverseLayers(
    callback: (
      childLayer: DomainLayer | ConditionalExpression | ExpressionStatement
    ) => void
  ) {
    callback(this);
    this.forEachChild(
      (
        childLayer: DomainLayer | ConditionalExpression | ExpressionStatement,
        childIndex: number
      ) => {
        if (childLayer instanceof LiteralNode) {
          childLayer.traverseLayers(callback);
        } else if (childLayer instanceof DomainLayer) {
          if (childLayer.import.layerName === "FlatList") {
            forEach(childLayer.props, (prop: any, key: string) => {
              if (!Utils.isInvalidKey(key)) {
                if (
                  prop instanceof ExpressionStatement ||
                  prop instanceof DomainLayer
                ) {
                  (prop as any).traverseLayers(callback);
                }
              }
            });
          } else if (typeof childLayer !== "string") {
            childLayer.traverseLayers(callback);
          }
        } else if (childLayer instanceof ConditionalExpression) {
          childLayer.consequent.traverseLayers(callback);
          childLayer.alternate.traverseLayers(callback);
        } else if (childLayer instanceof ExpressionStatement) {
          childLayer.traverseLayers(callback);
        }
      }
    );
  }
  // Same function as traverse layer
  // Don't remove this
  traverseLayersForStyleName(
    callback: (
      childLayer: DomainLayer | ConditionalExpression | ExpressionStatement
    ) => void
  ) {
    callback(this);
    this.forEachChild(
      (
        childLayer: DomainLayer | ConditionalExpression | ExpressionStatement,
        childIndex: number
      ) => {
        if (childLayer instanceof DomainLayer) {
          if (childLayer.import.layerName === "FlatList") {
            forEach(childLayer.props, (prop: any, key: string) => {
              if (!Utils.isInvalidKey(key)) {
                if (
                  prop instanceof ExpressionStatement ||
                  prop instanceof DomainLayer
                ) {
                  (prop as any).traverseLayers(callback);
                }
              }
            });
          } else if (typeof childLayer !== "string") {
            childLayer.traverseLayers(callback);
          }
        } else if (childLayer instanceof ConditionalExpression) {
          childLayer.consequent.traverseLayers(callback);
          childLayer.alternate.traverseLayers(callback);
        } else if (childLayer instanceof ExpressionStatement) {
          childLayer.traverseLayers(callback);
        }
      },
      true
    );
  }

  traverseParentLayer(callback: (parentLayer: DomainLayer) => void) {
    let parent: DomainLayer;
    if (this.type === "root") {
      parent = this;
      callback(parent);
    } else if (this.parent && this.parent instanceof DomainLayer) {
      parent = this.parent;
      if (parent) {
        callback(parent);
        parent.traverseParentLayer(callback);
      }
    }
  }

  get widthMode(): DimsMode {
    if (this.isWidthFill) {
      return "fill";
    } else if (this.isWidthAuto) {
      return "auto";
    } else if (this.isWidthPercent) {
      return "percent";
    } else {
      return "fixed";
    }
  }

  get heightMode(): DimsMode {
    if (this.isHeightFill) {
      return "fill";
    } else if (this.isHeightAuto) {
      return "auto";
    } else if (this.isHeightPercent) {
      return "percent";
    } else {
      return "fixed";
    }
  }

  get isWidthPercent(): boolean {
    const width = this.props.getResolvedStyleAttribute("width");
    if (typeof width === "string" && width.endsWith("%")) {
      return true;
    } else {
      return false;
    }
  }

  get isHeightPercent(): boolean {
    const height = this.props.getResolvedStyleAttribute("height");
    if (typeof height === "string" && height.endsWith("%")) {
      return true;
    } else {
      return false;
    }
  }

  get isWidthFill(): boolean {
    const position = this.props.getResolvedStyleAttribute("position");
    const property = this.props.getResolvedStyleAttribute("width");

    if (!isNil(property)) {
      return false;
    }

    if (position === "absolute") {
      let left, right;
      left = this.props.getResolvedStyleAttribute("left");
      right = this.props.getResolvedStyleAttribute("right");

      if (!isNil(left) && !isNil(right)) {
        return true;
      } else {
        return false;
      }
    } else {
      const flexDirection = this.getParentLayerFlexDirection();

      if (!flexDirection) {
        return false;
      }

      if (flexDirection.indexOf("row") !== -1) {
        // Main axis
        const flex = this.props.getResolvedStyleAttribute("flex");
        if (flex > 0) {
          return true;
        } else {
          return false;
        }
      } else {
        // Cross axis
        const alignSelf = this.props.getResolvedStyleAttribute("alignSelf");
        // if (!alignSelf || alignSelf === "stretch") {
        if (alignSelf === "stretch") {
          return true;
        } else {
          return false;
        }
      }
    }
  }
  get isHeightFill(): boolean {
    const position = this.props.getResolvedStyleAttribute("position");
    const property = this.props.getResolvedStyleAttribute("height");

    if (!isNil(property)) {
      return false;
    }

    if (position === "absolute") {
      let top, bottom;
      top = this.props.getResolvedStyleAttribute("top");
      bottom = this.props.getResolvedStyleAttribute("bottom");
      if (!isNil(top) && !isNil(bottom)) {
        return true;
      } else {
        return false;
      }
    } else {
      const flexDirection = this.getParentLayerFlexDirection();
      if (!flexDirection) {
        return false;
      }
      if (flexDirection.indexOf("column") !== -1) {
        const flex = this.props.getResolvedStyleAttribute("flex");
        if (flex > 0) {
          return true;
        } else {
          return false;
        }
      } else {
        const alignSelf = this.props.getResolvedStyleAttribute("alignSelf");
        // if (!alignSelf || alignSelf === "stretch") {
        if (alignSelf === "stretch") {
          return true;
        } else {
          return false;
        }
      }
    }
  }
  get isWidthAuto(): boolean {
    const position = this.props.getResolvedStyleAttribute("position");
    const property = this.props.getResolvedStyleAttribute("width");
    if (!isNil(property)) {
      return false;
    }
    if (position === "absolute") {
      let left, right;

      left = this.props.getResolvedStyleAttribute("left");
      right = this.props.getResolvedStyleAttribute("right");

      if (!isNil(left) && !isNil(right)) {
        return false;
      } else {
        return true;
      }
    } else {
      const flexDirection = this.getParentLayerFlexDirection();
      if (!flexDirection) {
        return false;
      }
      if (flexDirection === "row") {
        // Main axis
        const flex = this.props.getResolvedStyleAttribute("flex");
        if (isNil(flex) || isNaN(flex)) {
          return true;
        } else {
          return false;
        }
      } else {
        // Cross axis
        const flex = this.props.getResolvedStyleAttribute("flex");
        const alignSelf = this.props.getResolvedStyleAttribute("alignSelf");
        if ((isNil(flex) || isNaN(flex)) && alignSelf !== "stretch") {
          return true;
        } else {
          return false;
        }
      }
    }
  }
  get isHeightAuto(): boolean {
    const position = this.props.getResolvedStyleAttribute("position");
    const property = this.props.getResolvedStyleAttribute("height");
    if (!isNil(property)) {
      return false;
    }
    if (position === "absolute") {
      let top, bottom;
      top = this.props.getResolvedStyleAttribute("top");
      bottom = this.props.getResolvedStyleAttribute("bottom");

      if (!isNil(top) && !isNil(bottom)) {
        return false;
      } else {
        return true;
      }
    } else {
      const flexDirection = this.getParentLayerFlexDirection();

      if (!flexDirection) {
        return false;
      }
      if (flexDirection !== "row") {
        // Main axis
        const flex = this.props.getResolvedStyleAttribute("flex");

        if (isNil(flex) || isNaN(flex)) {
          return true;
        } else {
          return false;
        }
      } else {
        // Cross axis
        const alignSelf = this.props.getResolvedStyleAttribute("alignSelf");
        const flex = this.props.getResolvedStyleAttribute("flex");
        if ((isNil(flex) || isNaN(flex)) && alignSelf !== "stretch") {
          return true;
        } else {
          return false;
        }
      }
    }
  }

  getSiblingsWithFlex(): Array<DomainLayer> {
    let siblingsWithFlex = new Array<DomainLayer>();
    let isFillWidth = this.isWidthFill;
    let isFillHeight = this.isHeightFill;
    if (this.parent instanceof DomainLayer) {
      this.parent.forEachChild((childLayer: DomainLayer, index: number) => {
        const flex = this.getFlexValue();
        if (flex && this !== childLayer) {
          if (
            childLayer.isWidthFill === isFillWidth &&
            childLayer.isHeightFill === isFillHeight
          ) {
            siblingsWithFlex.push(childLayer);
          }
        }
      });
    }
    return siblingsWithFlex;
  }
  getFlexValue() {
    const flexGrow = this.props.getResolvedStyleAttribute("flexGrow");
    const flex = this.props.getResolvedStyleAttribute("flex");

    return flexGrow ? flexGrow : flex;
  }

  getParentLayerFlexDirection(): any {
    let parentLayer;
    // TODO: heavy jugaad
    try {
      parentLayer = this.getAbstractedLayer().parent as DomainLayer;
    } catch (err) {
      console.log(err);
    }
    if (!parentLayer) {
      return "column";
    }
    const flexDirection = parentLayer.props.getResolvedStyleAttribute(
      "flexDirection"
    );
    return flexDirection ? flexDirection : "column";
  }

  get isAutoDoable() {
    if (this && this.type === "symbol") {
      return false;
    }
    if (
      this &&
      (this.type === "flatList" ||
        this.type === "tabView" ||
        this.type === "swiper")
    ) {
      return false;
    }
    let hasFlexChild = this.containsFlexChild();
    if (hasFlexChild) {
      return true;
    } else {
      return false;
    }
  }
  containsFlexChild() {
    let hasFlexChild = false;
    this.forEachChild((childLayer, index) => {
      const position = childLayer.props.getResolvedStyleAttribute("position");
      if (isNil(position)) {
        hasFlexChild = true;
      }
    });
    return hasFlexChild;
  }

  getLayerElementType(): "position" | "flex" | "" {
    let type: "position" | "flex" | "" = "";

    if (this.children.length === 0) {
      return type;
    }

    let children = this.getChildren();

    if (children.length === 0) {
      return type;
    }
    this.forEachChild((child, index) => {
      if (this.type === "text" || Utils.shouldIgnoreLayer(child.type)) {
        return;
      } // const childId = layerId + `.${index}`;
      const elementTypePosition = child.props.getResolvedStyleAttribute(
        "position"
      );
      // // console.log("elementType", elementTypePosition);

      if (elementTypePosition && elementTypePosition === "absolute") {
        type = "position";
      }
    });
    // @ts-ignore
    if (type === "position") {
      return type;
    } else {
      type = "flex";
      return type;
    }
  }

  updateEditorState(propertyName: string, values: any) {
    const property = this.ui[propertyName];
    forEach(values, (value: boolean | number, key: string) => {
      property[key] = value;
    });
  }

  toggleResizingTypeIsDoable(): boolean {
    const elementTypePosition = this.props.getResolvedStyleAttribute(
      "position"
    );

    if (elementTypePosition && elementTypePosition === "absolute") {
      return true;
    }

    return false;
  }

  getResizingType(): ResizingType {
    return this.ui.resizingType;
  }

  get setFlexPropertyIsDoable(): boolean {
    var isDoable: boolean = true;

    this.forEachChild((childLayer: DomainLayer, index: number): any => {
      const childIsFluidWidthOrAutoHeight = childLayer.props.getResolvedStyleAttribute(
        "minHeight"
      );
      const childIsFluidWidthOrAutoWidth = childLayer.props.getResolvedStyleAttribute(
        "minWidth"
      );
      const elementTypePosition = childLayer.props.getResolvedStyleAttribute(
        "position"
      );
      const flexDirection = childLayer.props.getResolvedStyleAttribute(
        "flexDirection"
      );

      if (elementTypePosition && elementTypePosition === "absolute") {
        isDoable = false;
        return false;
      }
      if (
        (!flexDirection || flexDirection === "column") &&
        childIsFluidWidthOrAutoHeight
      ) {
        isDoable = true;
        return false;
      }
      if (flexDirection === "row" && childIsFluidWidthOrAutoWidth) {
        isDoable = true;
        return false;
      }
    });
    return isDoable;
  }
  get setAlignSelfIsDoable(): boolean {
    let elementTypePosition, minWidth, minHeight, parentElementFlexDirection;
    elementTypePosition = this.props.getResolvedStyleAttribute("position");
    minWidth = this.props.getResolvedStyleAttribute("minWidth");
    minHeight = this.props.getResolvedStyleAttribute("minHeight");
    parentElementFlexDirection = this.getParentLayerFlexDirection();

    if (elementTypePosition && elementTypePosition === "absolute") {
      return false;
    }

    if (
      (!parentElementFlexDirection ||
        parentElementFlexDirection === "column") &&
      minWidth
    ) {
      return false;
    }

    if (parentElementFlexDirection === "row" && minHeight) {
      return false;
    }
    return true;
  }
  get isFlexChild() {
    if (this.type === "root") {
      return false;
    }
    const elementType = this.props.getResolvedStyleAttribute("position");
    if (elementType && elementType === "absolute") {
      return false;
    } else {
      return true;
    }
  }

  get isLayoutChild() {
    const flexDirection = this.parent.props.getResolvedStyleAttribute(
      "flexDirection"
    );
    if (flexDirection === "row") {
      return this.isWidthFill;
    } else if (flexDirection === "column") {
      return this.isHeightFill;
    }
    return false;
  }
  get splitViewIsDoable(): any {
    let isDoable: boolean = true;
    const children = this.getLayoutChildrenLayerIds();
    if (children.length === 0) {
      return isDoable;
    }

    let sum = 0;
    this.forEachChild((child: DomainLayer, index: number) => {
      if (child.type === "statusBar") {
        return;
      }

      const childFlexGrowVal = this.props.getResolvedStyleAttribute("flexGrow");
      const childFlexVal = this.props.getResolvedStyleAttribute("flex");
      const childHasPosition = this.props.getResolvedStyleAttribute("position");

      if (childHasPosition && childHasPosition === "absolute") {
        isDoable = false;
        return;
      }

      if (!childFlexGrowVal && !childFlexVal) {
        isDoable = false;
        return;
      }

      if (childFlexGrowVal) {
        sum = sum + childFlexGrowVal;
      }

      if (childFlexVal) {
        sum = sum + childFlexVal;
      }
    });

    if (sum >= 1) {
      return isDoable;
    } else if (sum < 1) {
      isDoable = false;
      return isDoable;
    }

    return isDoable;
  }
  getLayoutChildrenLayerIds(): Array<DomainLayer> {
    const flexDirection = this.props.getResolvedStyleAttribute("flexDirection");
    let layoutChildren = new Array<DomainLayer>();
    this.forEachChild((child: DomainLayer, index: number) => {
      const position = child.props.getResolvedStyleAttribute("position");
      // console.log(position, "hello position")

      if (position !== "absolute") {
        if (flexDirection === "row") {
          if (child.isWidthFill) {
            layoutChildren.push(child);
          }
        } else {
          if (child.isHeightFill) {
            layoutChildren.push(child);
          }
        }
      }
    });
    return layoutChildren;
  }
  getFlexChildrenLayerIds(): Array<DomainLayer> {
    const flexDirection = this.props.getResolvedStyleAttribute("flexDirection");
    let layoutChildren = new Array<DomainLayer>();
    this.forEachChild((child: DomainLayer, index: number) => {
      // if (child instanceof StatusBarLayer) {
      //   return;
      // }
      const position = child.props.getResolvedStyleAttribute("position");
      // console.log(position, "hello position")

      if (position !== "absolute") {
        if (flexDirection === "row") {
          // if (child.isWidthFill) {
          layoutChildren.push(child);
          // }
        } else {
          // if (child.isHeightFill) {
          layoutChildren.push(child);
          // }
        }
      }
    });
    return layoutChildren;
  }
  showLayoutOptions(): boolean {
    if (this.type === "symbol" || this.type === "ellipse") {
      return false;
    }
    const layerHasFlex: boolean = this.props.getResolvedStyleAttribute("flex");
    const layerHasHeight = this.props.getResolvedStyleAttribute("height");
    const layerHasWidth = this.props.getResolvedStyleAttribute("width");
    const layerHasFlexdirection = this.props.getResolvedStyleAttribute(
      "flexDirection"
    );

    // TODO: check if the current layer is symbol layer
    const isSymbolRootLayer = false;
    const childrenFillTheParent = this.childrenFillTheParent();

    if (
      (childrenFillTheParent &&
        (isSymbolRootLayer ||
          layerHasFlex ||
          (layerHasHeight && layerHasWidth))) ||
      ((layerHasHeight || layerHasWidth) &&
        (layerHasFlexdirection === "column" || !layerHasFlexdirection))
    ) {
      return true;
    }
    return false;
  }
  childrenFillTheParent() {
    var sum = 0;

    if (!this) {
      return false;
    }

    const layoutChildren = this.getLayoutChildrenLayerIds();

    if (this.children.length === 0) {
      return true;
    }

    if (typeof this.children === "string") {
      return false;
    }

    forEach(layoutChildren, (child: DomainLayer, index: number) => {
      const elementTypePosition = child.props.getResolvedStyleAttribute(
        "position"
      );
      const flexGrow = child.props.getResolvedStyleAttribute("flexGrow");
      const flex = child.props.getResolvedStyleAttribute("flex");

      if (!elementTypePosition || elementTypePosition !== "absolute") {
        if (flexGrow) {
          sum = sum + flexGrow;
        } else if (flex) {
          sum = sum + flex;
        }
      }
    });

    if (Math.round(sum * 10) / 10 >= 1) {
      return true;
    } else {
      return false;
    }
  }

  getTotalFlexOfFlexChildren() {
    let sumOfFlex: number = 0;
    this.forEachChild((child: DomainLayer, index: number) => {
      if (Utils.shouldIgnoreLayer(child.type)) {
        return;
      }
      const layerFlex = child.getFlexValue();
      if (layerFlex !== undefined) {
        sumOfFlex += layerFlex;
      }
    });
    return sumOfFlex;
  }
}

export default DomainLayer;
