export function roundOffDomPositionElement(cords) {
  cords.fromViewport.bottom = Math.round(cords.fromViewport.bottom);
  cords.fromViewport.left = Math.round(cords.fromViewport.left);
  cords.fromViewport.leftCenter = Math.round(cords.fromViewport.leftCenter);
  cords.fromViewport.right = Math.round(cords.fromViewport.right);
  cords.fromViewport.top = Math.round(cords.fromViewport.top);
  cords.fromViewport.topCenter = Math.round(cords.fromViewport.topCenter);
  cords.fromViewport.x = Math.round(cords.fromViewport.x);
  cords.fromViewport.y = Math.round(cords.fromViewport.y);
  cords.fromWindow.left = Math.round(cords.fromWindow.left);
  cords.fromWindow.leftCenter = Math.round(cords.fromWindow.leftCenter);
  cords.fromWindow.top = Math.round(cords.fromWindow.top);
  cords.fromWindow.topCenter = Math.round(cords.fromWindow.topCenter);
  cords.fromWindow.x = Math.round(cords.fromWindow.x);
  cords.fromWindow.y = Math.round(cords.fromWindow.y);
  cords.height = Math.round(cords.height);
  cords.width = Math.round(cords.width);
}

export function makeRandomName(length) {
  var result = "";
  var characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  var charactersLength = characters.length;
  for (var i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }
  return result;
}

export function getOffsetsOf(offsetOf, offsetFrom, callback) {
  // return new Promise((resolve, reject) => {
  var offset = {};
  cy.get(offsetFrom)
    .first()
    .then(parent => {
      var parentPos = Cypress.dom.getElementCoordinatesByPosition(parent)
        .fromViewport;
      cy.get(offsetOf)
        .first()
        .then(child => {
          var childAttr = Cypress.dom.getElementCoordinatesByPosition(child);
          var childPos = childAttr.fromViewport;
          console.log("childpos", childPos, "parentPos", parentPos);

          offset.left = parseInt(
            (childPos.left - parentPos.left).toFixed(0),
            10
          );
          offset.top = parseInt((childPos.top - parentPos.top).toFixed(0), 10);
          offset.right = parseInt(
            (parentPos.right - childPos.right).toFixed(0),
            10
          );
          offset.bottom = parseInt(
            (parentPos.bottom - childPos.bottom).toFixed(0),
            10
          );
          offset.selfWidth = childAttr.width;
          offset.selfHeight = childAttr.height;
          offset.leftCenter = childPos.leftCenter;
          offset.topCenter = childPos.topCenter;

          callback(offset);
        });
    });
  // });
}

export function getFileBlob(dataURL, fileName) {
  const BASE64_MARKER = ";base64,";
  const parts = dataURL.split(BASE64_MARKER);
  const contentType = parts[0].split(":")[1];
  const raw = window.atob(parts[1]);
  const rawLength = raw.length;
  const uInt8Array = new Uint8Array(rawLength);

  for (let i = 0; i < rawLength; ++i) {
    uInt8Array[i] = raw.charCodeAt(i);
  }

  const blob = new Blob([uInt8Array], { type: "" });

  return new File([blob], fileName, { type: "" });
}
