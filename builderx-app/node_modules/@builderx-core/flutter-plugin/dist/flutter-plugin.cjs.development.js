'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var BuilderX = require('@builderx-core/builderx');

function expandChildrens(childrens) {
  var rowColumnData = [];
  var stackData = [];
  var i;

  for (i = 0; i < childrens.length; i++) {
    if (childrens[i].props.style.position === "absolute") {
      stackData.push(childrens[i]);
    } else {
      rowColumnData.push(typeDetect(childrens[i]));
    }
  }

  var stackPosData = positionChildrens(stackData);
  var finalData = {
    "rowColumnData": rowColumnData.join("\n"),
    "stackData": stackPosData
  };
  return finalData;
}

function positionChildrens(childrens) {
  var temp = [];
  var i;

  for (i = 0; i < childrens.length; i++) {
    temp.push("Positioned(\n          " + checkDef(childrens[i].props.style.top, "top") + "\n          " + checkDef(childrens[i].props.style.left, "left") + "\n          " + checkDef(childrens[i].props.style.right, "right") + "\n          " + checkDef(childrens[i].props.style.bottom, "bottom") + "\n          child: " + typeDetect(childrens[i]) + " \n      ),\n      ");
  }

  return temp.join("");
}

function checkDef(prop, key) {
  var temp;

  if (prop === undefined) {
    temp = "";
  } else {
    temp = key + ": " + prop + ",";
  }

  return temp;
}

function stackFlutter(childrens, alignProperties) {
  var result;
  var i;
  var tempArray = [];
  var childrenOfRowColumnStack = expandChildrens(childrens);

  for (i = 0; i < childrens.length; i++) {
    if (childrens[i].props.style.position === 'absolute') {
      tempArray.push(childrens[i]);
      result = "Stack(\n               children: <Widget>[\n               " + positionChildrens$1(tempArray) + "\n               ], \n             ),";
    } else {
      var tempData;
      tempData = "Column(\n          " + alignmentProperties(alignProperties) + "\n              children: <Widget>[\n              " + childrenOfRowColumnStack["rowColumnData"] + "\n          ],\n        ),";

      if (typeof childrenOfRowColumnStack["stackData"] !== 'undefined' && childrenOfRowColumnStack["stackData"].length > 0) {
        result = "Stack(\n            children: <Widget>[\n              " + tempData + "\n              " + childrenOfRowColumnStack["stackData"] + "\n            ],\n          ),";
      } else {
        result = tempData;
      }
    }
  }

  return result;
}

function positionChildrens$1(childrens) {
  var temp = [];
  var i;

  for (i = 0; i < childrens.length; i++) {
    temp.push("Positioned(\n          " + checkDef$1(childrens[i].props.style.top, "top") + "\n          " + checkDef$1(childrens[i].props.style.left, "left") + "\n          " + checkDef$1(childrens[i].props.style.right, "right") + "\n          " + checkDef$1(childrens[i].props.style.bottom, "bottom") + "\n          child: " + typeDetect(childrens[i]) + " \n      ),\n      ");
  }

  return temp.join("");
}

function checkDef$1(prop, key) {
  var temp;

  if (prop === undefined) {
    temp = "";
  } else {
    temp = key + ": " + prop + ",";
  }

  return temp;
}

function detectRowColumn(direction, childrens, alignProperties) {
  var temp; // var finalData ={
  //   "rowColumnData": rowColumnData.join("\n"),
  //   "stackData": stackPosData
  // };

  var childrenOfRowColumnStack = expandChildrens(childrens);

  if (direction === "row") {
    console.log('====================================');
    console.log(childrenOfRowColumnStack);
    console.log('====================================');
    var result;
    result = "Row(\n       " + alignmentProperties(alignProperties) + "\n          children: <Widget>[\n          " + childrenOfRowColumnStack["rowColumnData"] + "\n       ],\n     ),";

    if (typeof childrenOfRowColumnStack["stackData"] !== 'undefined' && childrenOfRowColumnStack["stackData"].length > 0) {
      temp = "Stack(\n        children: <Widget>[\n           " + result + "\n           " + childrenOfRowColumnStack["stackData"] + "\n        ],\n      ),";
    } else {
      temp = result;
    }
  } else if (direction === "column") {
    var result;
    result = "Column(\n       " + alignmentProperties(alignProperties) + "\n          children: <Widget>[\n          " + childrenOfRowColumnStack["rowColumnData"] + "\n       ],\n     ),";

    if (typeof childrenOfRowColumnStack["stackData"] !== 'undefined' && childrenOfRowColumnStack["stackData"].length > 0) {
      temp = "Stack(\n        children: <Widget>[\n           " + result + "\n           " + childrenOfRowColumnStack["stackData"] + "\n        ],\n      ),";
    } else {
      temp = result;
    }
  } else {
    temp = stackFlutter(childrens, alignProperties);
  }

  return temp.replace(/^\s*[\r\n]/gm, "");
}
function alignmentProperties(alignProperties) {
  var temp = ["crossAxisAlignment: CrossAxisAlignment.start,\n"];

  if (alignProperties[0] === "space-between") {
    temp.push("mainAxisAlignment: MainAxisAlignment.spaceBetween,\n");
  }

  if (alignProperties[0] === "space-around") {
    temp.push("mainAxisAlignment: MainAxisAlignment.spaceAround,\n");
  }

  if (alignProperties[0] === "flex-start") {
    temp.push("mainAxisAlignment: MainAxisAlignment.start,\n");
  }

  if (alignProperties[0] === "flex-end") {
    temp.push("mainAxisAlignment: MainAxisAlignment.end,\n");
  }

  if (alignProperties[0] === "center") {
    temp.push("mainAxisAlignment: MainAxisAlignment.center,\n");
  }

  if (alignProperties[0] === "space-evenly") {
    temp.push("mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n");
  }

  if (alignProperties[1] === "stretch") {
    temp.push("crossAxisAlignment: CrossAxisAlignment.stretch,\n");
  }

  if (alignProperties[1] === "flex-start") {
    temp.push("crossAxisAlignment: CrossAxisAlignment.start,\n");
  }

  if (alignProperties[1] === "center") {
    temp.push("crossAxisAlignment: CrossAxisAlignment.center,\n");
  }

  if (alignProperties[1] === "flex-end") {
    temp.push("crossAxisAlignment: CrossAxisAlignment.end,\n");
  }

  if (alignProperties[1] === "baseline") {
    temp.push("crossAxisAlignment: CrossAxisAlignment.baseline,\n");
  }

  return temp.join("");
}

function colorMaker(prop, key) {
  var color;
  var temp;

  if (prop === undefined) {
    temp = "";
  } else if (prop === "grey") {
    temp = key + " Colors.grey";
  } else {
    if (prop.startsWith('#')) {
      color = hexToRgbA(prop).match(/\d+/g).map(Number);
    } else if (prop.startsWith('rgba')) {
      color = prop.match(/\d+/g).map(Number);
    } else {
      color = prop;
    }

    temp = key + " Color.fromRGBO(" + color + ")";
  }

  return temp;
}

function hexToRgbA(hex) {
  var c;

  if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
    c = hex.substring(1).split('');

    if (c.length == 3) {
      c = [c[0], c[0], c[1], c[1], c[2], c[2]];
    }

    c = '0x' + c.join('');
    return 'rgba(' + [c >> 16 & 255, c >> 8 & 255, c & 255].join(',') + ',1)';
  }

  throw new Error('Bad Hex');
}

function propertiesDetect(prop, attributeName, dir, alignProperties) {
  var temp;

  if (prop === undefined) {
    temp = "";
  } else if (attributeName === "child") {
    if (prop.length === 0) {
      temp = "";
    } else if (prop.length === 1) {
      temp = attributeName + ": " + typeDetect(prop[0]);
    } else if (prop.length > 1) {
      temp = attributeName + ": " + detectRowColumn(dir, prop, alignProperties);
    }
  } else if (attributeName === "borderStyle") {
    temp = "style: BorderStyle.solid,";
  } else if (attributeName === "borderRadius") {
    temp = attributeName + ": BorderRadius.circular(" + prop + "),";
  } else if (attributeName === "margin") {
    temp = attributeName + ": EdgeInsets.all(" + prop.match(/\d+/g).map(Number) + "),";
  } else if (attributeName === "padding") {
    temp = attributeName + ": EdgeInsets.all(" + prop.match(/\d+/g).map(Number) + "),";
  } else if (attributeName === "color") {
    temp = colorMaker(prop, "color:") + ",";
  } else {
    temp = attributeName + ": " + prop + ",";
  }

  return temp;
}

function marginFlutter(value) {
  // {
  //           "margin": reactObject.props.style.margin,
  //           "marginLeft": reactObject.props.style.marginLeft,
  //           "marginRight": reactObject.props.style.marginTop,
  //           "marginTop": reactObject.props.style.marginRight,
  //           "marginBottom": reactObject.props.style.marginBottom,
  //           "marginHorizontal": reactObject.props.style.marginHorizontal,
  //           "marginVertical": reactObject.props.style.marginVertical
  //  }
  var flutterResultMargin;
  var top;
  var left;
  var bottom;
  var right;
  top = addMargin(value["margin"], value["marginTop"], value["marginVertical"]);
  bottom = addMargin(value["margin"], value["marginBottom"], value["marginVertical"]);
  left = addMargin(value["margin"], value["marginLeft"], value["marginHorizontal"]);
  right = addMargin(value["margin"], value["marginRight"], value["marginHorizontal"]);

  if (top === 0 && left === 0 && right === 0 && bottom === 0) {
    return flutterResultMargin = "";
  }

  return flutterResultMargin = "margin: EdgeInsets.fromLTRB(" + left + "," + top + "," + right + "," + bottom + "),";
}

function addMargin(a, b, c) {
  if (a === undefined) {
    a = "0";
  }

  if (b === undefined) {
    b = "0";
  }

  if (c === undefined) {
    c = "0";
  }

  var i = a.toString().match(/\d+/g).map(Number);
  var j = b.toString().match(/\d+/g).map(Number);
  var k = c.toString().match(/\d+/g).map(Number);
  return parseInt(i, 10) + parseInt(j, 10) + parseInt(k, 10);
}

function paddingFlutter(value) {
  // {
  //           "padding": reactObject.props.style.padding,
  //           "paddingLeft": reactObject.props.style.paddingLeft,
  //           "paddingRight": reactObject.props.style.paddingTop,
  //           "paddingTop": reactObject.props.style.paddingRight,
  //           "paddingBottom": reactObject.props.style.paddingBottom,
  //           "paddingHorizontal": reactObject.props.style.paddingHorizontal,
  //           "paddingVertical": reactObject.props.style.paddingVertical
  //         }
  var flutterResultPadding;
  var top;
  var left;
  var bottom;
  var right;
  top = addPadding(value["padding"], value["paddingTop"], value["paddingVertical"]);
  bottom = addPadding(value["padding"], value["paddingBottom"], value["paddingVertical"]);
  left = addPadding(value["padding"], value["paddingLeft"], value["paddingHorizontal"]);
  right = addPadding(value["padding"], value["paddingRight"], value["paddingHorizontal"]);

  if (top === 0 && left === 0 && right === 0 && bottom === 0) {
    return flutterResultPadding = "";
  }

  return flutterResultPadding = "padding: EdgeInsets.fromLTRB(" + left + "," + top + "," + right + "," + bottom + "),";
}

function addPadding(a, b, c) {
  if (a === undefined) {
    a = "0";
  }

  if (b === undefined) {
    b = "0";
  }

  if (c === undefined) {
    c = "0";
  }

  var i = a.toString().match(/\d+/g).map(Number);
  var j = b.toString().match(/\d+/g).map(Number);
  var k = c.toString().match(/\d+/g).map(Number);
  return parseInt(i, 10) + parseInt(j, 10) + parseInt(k, 10);
}

function borderFlutter(value) {
  // {
  //           "border": [reactObject.props.style.borderWidth, color],
  //           "borderLeft": [reactObject.props.style.borderLeftWidth, color],
  //           "borderRight": [reactObject.props.style.borderTopWidth, color],
  //           "borderTop": [reactObject.props.style.borderRightWidth, color],
  //           "borderBottom": [reactObject.props.style.borderBottomWidth, color],
  //  }
  var borderResult;
  var top;
  var left;
  var bottom;
  var right;
  top = addBorder(value["border"][0], value["borderTop"][0]);
  bottom = addBorder(value["border"][0], value["borderBottom"][0]);
  left = addBorder(value["border"][0], value["borderLeft"][0]);
  right = addBorder(value["border"][0], value["borderRight"][0]);
  var topColor = colorBorder(value["borderTop"][1], value["border"][1]);
  var bottomColor = colorBorder(value["borderBottom"][1], value["border"][1]);
  var leftColor = colorBorder(value["borderLeft"][1], value["border"][1]);
  var rightColor = colorBorder(value["borderRight"][1], value["border"][1]);

  if (top === 0 && left === 0 && right === 0 && bottom === 0) {
    return borderResult = "";
  }

  borderResult = "border: Border(\n                top: BorderSide(\n                    " + topColor + ", \n                    width: " + top + ",\n                    ),\n                bottom: BorderSide(\n                    " + bottomColor + ", \n                    width: " + bottom + ",\n                    ),\n                right: BorderSide(\n                    " + rightColor + ", \n                    width: " + right + ",\n                    ),\n                left: BorderSide(\n                    " + leftColor + ", \n                    width: " + left + ",\n                    ),\n             ),";
  return borderResult;
}

function addBorder(a, b) {
  if (a === undefined) {
    a = "0";
  }

  if (b === undefined) {
    b = "0";
  }

  var i = a.toString().match(/\d+/g).map(Number);
  var j = b.toString().match(/\d+/g).map(Number);
  return parseInt(i, 10) + parseInt(j, 10);
}

function colorBorder(color, primaryColor) {
  var temp;

  if (color === undefined) {
    temp = "";
  } else {
    temp = colorMaker(color, "color:");
  }

  if (primaryColor != undefined) {
    temp = colorMaker(primaryColor, "color:");
  }

  return temp;
}

function layoutProperties(reactObject) {
  return "\n            " + propertiesDetect(reactObject.props.style.width, "width") + "\n            " + propertiesDetect(reactObject.props.style.height, "height") + "\n            " + marginFlutter({
    "margin": reactObject.props.style.margin,
    "marginLeft": reactObject.props.style.marginLeft,
    "marginRight": reactObject.props.style.marginRight,
    "marginTop": reactObject.props.style.marginTop,
    "marginBottom": reactObject.props.style.marginBottom,
    "marginHorizontal": reactObject.props.style.marginHorizontal,
    "marginVertical": reactObject.props.style.marginVertical
  }) + "\n            " + paddingFlutter({
    "padding": reactObject.props.style.padding,
    "paddingLeft": reactObject.props.style.paddingLeft,
    "paddingRight": reactObject.props.style.paddingRight,
    "paddingTop": reactObject.props.style.paddingTop,
    "paddingBottom": reactObject.props.style.paddingBottom,
    "paddingHorizontal": reactObject.props.style.paddingHorizontal,
    "paddingVertical": reactObject.props.style.paddingVertical
  }) + "\n            decoration: BoxDecoration(\n            " + propertiesDetect(reactObject.props.style.backgroundColor, "color") + "\n            " + propertiesDetect(reactObject.props.style.borderRadius, "borderRadius") + "\n            " + borderFlutter({
    "border": [reactObject.props.style.borderWidth, reactObject.props.style.borderColor],
    "borderLeft": [reactObject.props.style.borderLeftWidth, reactObject.props.style.borderLeftColor],
    "borderRight": [reactObject.props.style.borderRightWidth, reactObject.props.style.borderRightColor],
    "borderTop": [reactObject.props.style.borderTopWidth, reactObject.props.style.borderTopColor],
    "borderBottom": [reactObject.props.style.borderBottomWidth, reactObject.props.style.borderBottomColor]
  }) + "\n            ),\n    ";
}

function containerFlutter(reactObject) {
  var flutterResultContainer = "Container(\n  " + layoutProperties(reactObject) + "\n  " + propertiesDetect(reactObject.children, "child", reactObject.props.style.flexDirection, [reactObject.props.style.justifyContent, reactObject.props.style.alignItems, reactObject.props.style.alignSelf]) + "\n\n),";
  var temp = alignSelfFlutter(reactObject.props.style.alignSelf, flutterResultContainer);
  return temp.replace(/^\s*[\r\n]/gm, "");
}

function alignSelfFlutter(prop, child) {
  var temp;

  if (prop === undefined) {
    temp = child;
  } else {
    if (prop === "center") {
      temp = "Align(\n        alignment: Alignment(0.0, -1.0),\n        child: " + child + "\n        ),";
    } else if (prop === "flex-end") {
      temp = "Align(\n        alignment: Alignment(1.0, 1.0),\n        child: " + child + "\n        ),";
    } else if (prop === "flex-start") {
      temp = "Align(\n        alignment: Alignment.topCenter,\n        child: " + child + "\n        ),";
    } else {
      temp = child;
    }
  }

  return temp;
}

function textFlutter(reactObject) {
  var temp;
  var flutterResultText = "Text(\n            \"" + reactObject.children[0].value + "\",\n            style: " + textStyle(reactObject) + "\n            " + textAlignProp(reactObject.props.style.textAlign) + " \n            ),";
  temp = "Container(\n          " + layoutProperties(reactObject) + "\n                child: " + flutterResultText + "\n                ),";
  return temp.replace(/^\s*[\r\n]/gm, "");
}
function textStyle(reactObject) {
  var temp = "TextStyle(\n                " + fontFamily(reactObject.props.style.fontFamily) + ",\n                " + propertiesDetect(reactObject.props.style.fontSize, "fontSize") + "\n                " + propertiesDetect(reactObject.props.style.color, "color") + "\n                " + propertiesDetect(reactObject.props.style.letterSpacing, "letterSpacing") + "\n                " + propertiesDetect(reactObject.props.style.lineHeight, "height") + "\n                " + fontWeightProp(reactObject.props.style.fontWeight) + "\n                " + fontStyleProp(reactObject.props.style.fontStyle) + "\n                " + textDecorationProp(reactObject.props.style.textDecorationLine) + "\n            ),";
  return temp;
}

function fontFamily(prop) {
  var temp;

  if (prop === undefined) {
    temp = "";
  } else {
    temp = "fontFamily: '" + prop.replace(/ /g, '') + "'";
  }

  return temp;
} //    "style": {
//                 "fontFamily": "Comic Sans MS",
//                 "fontPostscriptName": "comic-sans-ms-regular",
//                 "fontStyle": "normal",
//                 "fontWeight": "400",
//                 "color": "#121212",
//                 "height": 45,
//                 "width": 216,
//                 "marginTop": 208,
//                 "marginLeft": 83


function fontWeightProp(prop) {
  var temp;

  if (prop === undefined) {
    temp = "";
  } else {
    if (prop === "regular") {
      temp = "";
    } else {
      temp = "fontWeight: FontWeight." + (isNaN(prop) ? prop : 'w' + prop) + ",";
    }
  }

  return temp;
}

function fontStyleProp(prop) {
  var temp;

  if (prop === undefined) {
    temp = "";
  } else {
    temp = "fontStyle: FontStyle." + prop + ",";
  }

  return temp;
}

function textDecorationProp(prop) {
  var temp;
  var propTemp;

  if (prop === undefined) {
    temp = "";
  } else {
    if (prop === "line-through") {
      propTemp = 'lineThrough';
    } else {
      propTemp = prop;
    }

    temp = "decoration: TextDecoration." + propTemp + ",";
  }

  return temp;
}

function textAlignProp(prop) {
  var temp;
  var propTemp;

  if (prop === undefined) {
    temp = "";
  } else {
    if (prop === "auto") {
      propTemp = "start";
    } else {
      propTemp = prop;
    }

    temp = "textAlign: TextAlign." + propTemp + ",";
  }

  return temp;
}
 //String fontFamily, //fontFamily Left as Flutter doesnt support it internally its a package

function imageFlutter(reactObject) {
  var flutterResultImage;

  if (reactObject.props.source["uri"].includes('https://')) {
    flutterResultImage = "Image.network(\n              \"" + reactObject.props.source["uri"] + "\",\n              fit: BoxFit." + (reactObject.props.resizeMode === undefined ? "contain" : reactObject.props.resizeMode) + ",\n              " + propertiesDetect(reactObject.props.style.width, "width") + "\n              " + propertiesDetect(reactObject.props.style.height, "height") + "\n            ),";
  } else {
    flutterResultImage = "Image.asset(\n              \"" + reactObject.props.source["uri"] + "\",\n              " + propertiesDetect(reactObject.props.style.width, "width") + "\n              " + propertiesDetect(reactObject.props.style.height, "height") + "\n            ),";
  }

  return flutterResultImage.replace(/^\s*[\r\n]/gm, "");
}

function buttonFlutter(reactObject) {
  var flutterButton;
  flutterButton = "InkWell(\n              onTap: (){},\n              child: " + containerFlutter(reactObject) + "\n            ),";
  return flutterButton;
}

function listView(reactObject) {
  var flutterResult;
  var temp = "SingleChildScrollView(\n        " + scrollDirection(reactObject.props.horizontal, reactObject, [reactObject.props.style.justifyContent, reactObject.props.style.alignItems, reactObject.props.style.alignSelf]) + "\n        ),";
  flutterResult = "Container(\n        " + layoutProperties(reactObject) + "\n        child: " + temp + "\n    ),";
  return flutterResult.replace(/^\s*[\r\n]/gm, "");
}

function scrollDirection(prop, reactObject, alignProperties) {
  var temp;

  if (prop) {
    temp = "scrollDirection: Axis.horizontal,\n                    child: Row(\n                        " + alignmentProperties(alignProperties) + "\n                        children: <Widget>[ \n                           " + expandChildrens(reactObject.children) + " \n                        ],\n                    ),";
  } else {
    temp = "scrollDirection: Axis.horizontal,\n                    child: Column(\n                        " + alignmentProperties(alignProperties) + "\n                        children: <Widget>[ \n                           " + expandChildrens(reactObject.children) + " \n                        ],\n                    ),";
  }

  return temp;
}

function textInputFlutter(reactObject) {
  var flutterTextInputResult = "TextField(\n" + keyboardType(reactObject.props.keyboardType) + "\n" + keyboardAppearance(reactObject.props.keyboardAppearance) + "\n" + propcheck(reactObject.props.secureTextEntry, "obscureText") + "\n" + propcheck(reactObject.props.autoCorrect, "autocorrect") + "\n" + propcheck(reactObject.props.autoFocus, "autofocus") + "\n" + propcheck(reactObject.props.maxLength, "maxLength") + "\n" + propcheck(reactObject.props.numberOfLines, "maxLines") + "\n" + textCaptilize(reactObject.props.autoCapitalize) + "\nstyle: " + textStyle(reactObject) + "\n" + textAlignProp(reactObject.props.style.textAlign) + "\ndecoration: InputDecoration(\n  " + checkAvailablityOfPropString(reactObject.props.placeholder, "hintText") + "\n  " + hintTextStyle(reactObject.props.placeholderTextColor) + "\n\tfilled: true,\n    " + fillColorFunc(colorMaker(reactObject.props.style.backgroundColor, ""), "fillColor") + "\n  " + inputBorder({
    "borderWidth": reactObject.props.style.borderWidth,
    "borderColor": reactObject.props.style.borderColor,
    "borderRadius": reactObject.props.style.borderRadius
  }, "enabled") + "\n  " + inputBorder({
    "borderWidth": reactObject.props.style.borderWidth,
    "borderColor": reactObject.props.style.borderColor,
    "borderRadius": reactObject.props.style.borderRadius
  }, reactObject.props.autoFocus) + "\n),      \n)";
  var result = "Container(\n        " + propcheck(reactObject.props.style.width, "width") + "\n        " + propcheck(reactObject.props.style.height, "height") + "\n        " + marginFlutter({
    "margin": reactObject.props.style.margin,
    "marginLeft": reactObject.props.style.marginLeft,
    "marginRight": reactObject.props.style.marginRight,
    "marginTop": reactObject.props.style.marginTop,
    "marginBottom": reactObject.props.style.marginBottom,
    "marginHorizontal": reactObject.props.style.marginHorizontal,
    "marginVertical": reactObject.props.style.marginVertical
  }) + "\n        child: " + flutterTextInputResult + ",\n    ),";
  return result.replace(/^\s*[\r\n]/gm, "");
}

function propcheck(prop, key) {
  if (prop === undefined || prop === "") {
    return "";
  } else {
    return key + ": " + prop + ",";
  }
}

function fillColorFunc(prop, key) {
  if (prop === "") {
    return "";
  } else {
    return key + ": " + prop + ",";
  }
}

function textCaptilize(prop) {
  if (prop === undefined) {
    return "";
  } else {
    return "textCapitalization: TextCapitalization." + prop + ",";
  }
}

function hintTextStyle(prop) {
  if (prop === undefined) {
    return "";
  } else {
    return "hintStyle: TextStyle(\n                " + colorMaker(prop, "color:") + ",\n            ),";
  }
}

function inputBorder(prop, isEnable) {
  var borderRadiusLine;
  var borderWidthLine;
  var temp;

  if (prop["borderRadius"] === undefined) {
    borderRadiusLine = "";
  } else {
    borderRadiusLine = "borderRadius: BorderRadius.all(Radius.circular(" + prop["borderRadius"] + ")),";
  }

  if (prop["borderWidth"] === undefined) {
    borderWidthLine = "";
  } else {
    borderWidthLine = "borderSide: BorderSide(\n          " + colorMaker(prop["borderColor"], "color:") + ", \n          width: " + prop["borderWidth"] + ",\n          ),";
  }

  if (prop["borderRadius"] === undefined && prop["borderWidth"] === undefined) {
    temp = "";
  } else {
    if (isEnable === "enabled") {
      temp = "enabledBorder: OutlineInputBorder(\n\t\t" + borderRadiusLine + "\n\t\t" + borderWidthLine + "\n\t   ),";
    } else {
      if (isEnable) {
        temp = "focusedBorder: OutlineInputBorder(\n\t\t" + borderRadiusLine + "\n\t\t" + borderWidthLine + "\n\t    ),";
      } else {
        temp = "";
      }
    }
  }

  return temp;
}

function checkAvailablityOfPropString(prop, key) {
  if (prop === undefined) {
    return "";
  } else {
    return key + ": \"" + prop + "\",";
  }
}

function keyboardAppearance(prop) {
  if (prop === undefined) {
    return "";
  } else {
    if (prop === "dark") {
      return "keyboardAppearance: Brightness.dark,";
    } else {
      return "keyboardAppearance: Brightness.light,";
    }
  }
}

function keyboardType(prop) {
  if (prop === undefined) {
    return "";
  } else {
    switch (prop) {
      case "number-pad":
        return "keyboardType: TextInputType.number,";

      case "decimal-pad":
        return "keyboardType: TextInputType.numberWithOptions(decimal: true),";

      case "numeric":
        return "keyboardType: TextInputType.number,";

      case "email-address":
        return "keyboardType: TextInputType.emailAddress,";

      case "phone-pad":
        return "keyboardType: TextInputType.phone,";
    }
  }
}

function activityIndicatorFlutter(reactObject) {
  var flutterResultCircularProgressIndicator = "\nContainer(\n  " + layoutProperties(reactObject) + "\n  child: CircularProgressIndicator(\n    " + coloredIndicatior(reactObject.props.color) + "\n  ),\n),";
  return flutterResultCircularProgressIndicator.replace(/^\s*[\r\n]/gm, "");
}

function coloredIndicatior(prop) {
  var temp = "";

  if (prop === undefined) {
    temp = "";
  } else {
    temp = "valueColor: new AlwaysStoppedAnimation<Color>(" + colorMaker(prop, "") + ",),";
  }

  return temp;
}

function iconsFlutterComponent(reactObject) {
  var flutterResultIcon = "\n    Container(\n        " + layoutProperties(reactObject) + "\n        child: Icon(\n        " + reactObject.props.type + "." + replaceAll(reactObject.props.name.toString(), "-", "_") + ",\n        " + colorMaker(reactObject.props.style.color, "color:") + ",\n        " + propCheck(reactObject.props.style.fontSize, "size") + "\n        ),\n    ),";
  return flutterResultIcon.replace(/^\s*[\r\n]/gm, "");
}

function propCheck(prop, key) {
  var temp = "";

  if (prop === undefined) {
    temp = "";
  } else {
    temp = key + ": " + prop + ",";
  }

  return temp;
}

function replaceAll(string, search, replace) {
  return string.split(search).join(replace);
}

function mapStyle(params) {
  var temp;

  switch (params) {
    case "Dark":
      return temp = "controller.setMapStyle('''[\n          {\n            elementType: \"geometry\",\n            stylers: [\n              {\n                color: \"#212121\"\n              }\n            ]\n          },\n          {\n            elementType: \"labels.icon\",\n            stylers: [\n              {\n                visibility: \"off\"\n              }\n            ]\n          },\n          {\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#757575\"\n              }\n            ]\n          },\n          {\n            elementType: \"labels.text.stroke\",\n            stylers: [\n              {\n                color: \"#212121\"\n              }\n            ]\n          },\n          {\n            featureType: \"administrative\",\n            elementType: \"geometry\",\n            stylers: [\n              {\n                color: \"#757575\"\n              }\n            ]\n          },\n          {\n            featureType: \"administrative.country\",\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#9e9e9e\"\n              }\n            ]\n          },\n          {\n            featureType: \"administrative.land_parcel\",\n            stylers: [\n              {\n                visibility: \"off\"\n              }\n            ]\n          },\n          {\n            featureType: \"administrative.locality\",\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#bdbdbd\"\n              }\n            ]\n          },\n          {\n            featureType: \"poi\",\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#757575\"\n              }\n            ]\n          },\n          {\n            featureType: \"poi.park\",\n            elementType: \"geometry\",\n            stylers: [\n              {\n                color: \"#181818\"\n              }\n            ]\n          },\n          {\n            featureType: \"poi.park\",\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#616161\"\n              }\n            ]\n          },\n          {\n            featureType: \"poi.park\",\n            elementType: \"labels.text.stroke\",\n            stylers: [\n              {\n                color: \"#1b1b1b\"\n              }\n            ]\n          },\n          {\n            featureType: \"road\",\n            elementType: \"geometry.fill\",\n            stylers: [\n              {\n                color: \"#2c2c2c\"\n              }\n            ]\n          },\n          {\n            featureType: \"road\",\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#8a8a8a\"\n              }\n            ]\n          },\n          {\n            featureType: \"road.arterial\",\n            elementType: \"geometry\",\n            stylers: [\n              {\n                color: \"#373737\"\n              }\n            ]\n          },\n          {\n            featureType: \"road.highway\",\n            elementType: \"geometry\",\n            stylers: [\n              {\n                color: \"#3c3c3c\"\n              }\n            ]\n          },\n          {\n            featureType: \"road.highway.controlled_access\",\n            elementType: \"geometry\",\n            stylers: [\n              {\n                color: \"#4e4e4e\"\n              }\n            ]\n          },\n          {\n            featureType: \"road.local\",\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#616161\"\n              }\n            ]\n          },\n          {\n            featureType: \"transit\",\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#757575\"\n              }\n            ]\n          },\n          {\n            featureType: \"water\",\n            elementType: \"geometry\",\n            stylers: [\n              {\n                color: \"#000000\"\n              }\n            ]\n          },\n          {\n            featureType: \"water\",\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#3d3d3d\"\n              }\n            ]\n          }\n        ]''');";

    case "Standard":
      return temp = "";

    case "Silver":
      return temp = "controller.setMapStyle('''[\n          {\n            elementType: \"geometry\",\n            stylers: [\n              {\n                color: \"#f5f5f5\"\n              }\n            ]\n          },\n          {\n            elementType: \"labels.icon\",\n            stylers: [\n              {\n                visibility: \"off\"\n              }\n            ]\n          },\n          {\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#616161\"\n              }\n            ]\n          },\n          {\n            elementType: \"labels.text.stroke\",\n            stylers: [\n              {\n                color: \"#f5f5f5\"\n              }\n            ]\n          },\n          {\n            featureType: \"administrative.land_parcel\",\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#bdbdbd\"\n              }\n            ]\n          },\n          {\n            featureType: \"poi\",\n            elementType: \"geometry\",\n            stylers: [\n              {\n                color: \"#eeeeee\"\n              }\n            ]\n          },\n          {\n            featureType: \"poi\",\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#757575\"\n              }\n            ]\n          },\n          {\n            featureType: \"poi.park\",\n            elementType: \"geometry\",\n            stylers: [\n              {\n                color: \"#e5e5e5\"\n              }\n            ]\n          },\n          {\n            featureType: \"poi.park\",\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#9e9e9e\"\n              }\n            ]\n          },\n          {\n            featureType: \"road\",\n            elementType: \"geometry\",\n            stylers: [\n              {\n                color: \"#ffffff\"\n              }\n            ]\n          },\n          {\n            featureType: \"road.arterial\",\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#757575\"\n              }\n            ]\n          },\n          {\n            featureType: \"road.highway\",\n            elementType: \"geometry\",\n            stylers: [\n              {\n                color: \"#dadada\"\n              }\n            ]\n          },\n          {\n            featureType: \"road.highway\",\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#616161\"\n              }\n            ]\n          },\n          {\n            featureType: \"road.local\",\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#9e9e9e\"\n              }\n            ]\n          },\n          {\n            featureType: \"transit.line\",\n            elementType: \"geometry\",\n            stylers: [\n              {\n                color: \"#e5e5e5\"\n              }\n            ]\n          },\n          {\n            featureType: \"transit.station\",\n            elementType: \"geometry\",\n            stylers: [\n              {\n                color: \"#eeeeee\"\n              }\n            ]\n          },\n          {\n            featureType: \"water\",\n            elementType: \"geometry\",\n            stylers: [\n              {\n                color: \"#c9c9c9\"\n              }\n            ]\n          },\n          {\n            featureType: \"water\",\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#9e9e9e\"\n              }\n            ]\n          }\n        ]''');";

    case "Night":
      return temp = "controller.setMapStyle('''[\n          {\n            elementType: \"geometry\",\n            stylers: [\n              {\n                color: \"#242f3e\"\n              }\n            ]\n          },\n          {\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#746855\"\n              }\n            ]\n          },\n          {\n            elementType: \"labels.text.stroke\",\n            stylers: [\n              {\n                color: \"#242f3e\"\n              }\n            ]\n          },\n          {\n            featureType: \"administrative.locality\",\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#d59563\"\n              }\n            ]\n          },\n          {\n            featureType: \"poi\",\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#d59563\"\n              }\n            ]\n          },\n          {\n            featureType: \"poi.park\",\n            elementType: \"geometry\",\n            stylers: [\n              {\n                color: \"#263c3f\"\n              }\n            ]\n          },\n          {\n            featureType: \"poi.park\",\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#6b9a76\"\n              }\n            ]\n          },\n          {\n            featureType: \"road\",\n            elementType: \"geometry\",\n            stylers: [\n              {\n                color: \"#38414e\"\n              }\n            ]\n          },\n          {\n            featureType: \"road\",\n            elementType: \"geometry.stroke\",\n            stylers: [\n              {\n                color: \"#212a37\"\n              }\n            ]\n          },\n          {\n            featureType: \"road\",\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#9ca5b3\"\n              }\n            ]\n          },\n          {\n            featureType: \"road.highway\",\n            elementType: \"geometry\",\n            stylers: [\n              {\n                color: \"#746855\"\n              }\n            ]\n          },\n          {\n            featureType: \"road.highway\",\n            elementType: \"geometry.stroke\",\n            stylers: [\n              {\n                color: \"#1f2835\"\n              }\n            ]\n          },\n          {\n            featureType: \"road.highway\",\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#f3d19c\"\n              }\n            ]\n          },\n          {\n            featureType: \"transit\",\n            elementType: \"geometry\",\n            stylers: [\n              {\n                color: \"#2f3948\"\n              }\n            ]\n          },\n          {\n            featureType: \"transit.station\",\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#d59563\"\n              }\n            ]\n          },\n          {\n            featureType: \"water\",\n            elementType: \"geometry\",\n            stylers: [\n              {\n                color: \"#17263c\"\n              }\n            ]\n          },\n          {\n            featureType: \"water\",\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#515c6d\"\n              }\n            ]\n          },\n          {\n            featureType: \"water\",\n            elementType: \"labels.text.stroke\",\n            stylers: [\n              {\n                color: \"#17263c\"\n              }\n            ]\n          }\n        ]''');";

    case "Aubergine":
      return temp = "controller.setMapStyle('''[\n          {\n            elementType: \"geometry\",\n            stylers: [\n              {\n                color: \"#1d2c4d\"\n              }\n            ]\n          },\n          {\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#8ec3b9\"\n              }\n            ]\n          },\n          {\n            elementType: \"labels.text.stroke\",\n            stylers: [\n              {\n                color: \"#1a3646\"\n              }\n            ]\n          },\n          {\n            featureType: \"administrative.country\",\n            elementType: \"geometry.stroke\",\n            stylers: [\n              {\n                color: \"#4b6878\"\n              }\n            ]\n          },\n          {\n            featureType: \"administrative.land_parcel\",\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#64779e\"\n              }\n            ]\n          },\n          {\n            featureType: \"administrative.province\",\n            elementType: \"geometry.stroke\",\n            stylers: [\n              {\n                color: \"#4b6878\"\n              }\n            ]\n          },\n          {\n            featureType: \"landscape.man_made\",\n            elementType: \"geometry.stroke\",\n            stylers: [\n              {\n                color: \"#334e87\"\n              }\n            ]\n          },\n          {\n            featureType: \"landscape.natural\",\n            elementType: \"geometry\",\n            stylers: [\n              {\n                color: \"#023e58\"\n              }\n            ]\n          },\n          {\n            featureType: \"poi\",\n            elementType: \"geometry\",\n            stylers: [\n              {\n                color: \"#283d6a\"\n              }\n            ]\n          },\n          {\n            featureType: \"poi\",\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#6f9ba5\"\n              }\n            ]\n          },\n          {\n            featureType: \"poi\",\n            elementType: \"labels.text.stroke\",\n            stylers: [\n              {\n                color: \"#1d2c4d\"\n              }\n            ]\n          },\n          {\n            featureType: \"poi.park\",\n            elementType: \"geometry.fill\",\n            stylers: [\n              {\n                color: \"#023e58\"\n              }\n            ]\n          },\n          {\n            featureType: \"poi.park\",\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#3C7680\"\n              }\n            ]\n          },\n          {\n            featureType: \"road\",\n            elementType: \"geometry\",\n            stylers: [\n              {\n                color: \"#304a7d\"\n              }\n            ]\n          },\n          {\n            featureType: \"road\",\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#98a5be\"\n              }\n            ]\n          },\n          {\n            featureType: \"road\",\n            elementType: \"labels.text.stroke\",\n            stylers: [\n              {\n                color: \"#1d2c4d\"\n              }\n            ]\n          },\n          {\n            featureType: \"road.highway\",\n            elementType: \"geometry\",\n            stylers: [\n              {\n                color: \"#2c6675\"\n              }\n            ]\n          },\n          {\n            featureType: \"road.highway\",\n            elementType: \"geometry.stroke\",\n            stylers: [\n              {\n                color: \"#255763\"\n              }\n            ]\n          },\n          {\n            featureType: \"road.highway\",\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#b0d5ce\"\n              }\n            ]\n          },\n          {\n            featureType: \"road.highway\",\n            elementType: \"labels.text.stroke\",\n            stylers: [\n              {\n                color: \"#023e58\"\n              }\n            ]\n          },\n          {\n            featureType: \"transit\",\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#98a5be\"\n              }\n            ]\n          },\n          {\n            featureType: \"transit\",\n            elementType: \"labels.text.stroke\",\n            stylers: [\n              {\n                color: \"#1d2c4d\"\n              }\n            ]\n          },\n          {\n            featureType: \"transit.line\",\n            elementType: \"geometry.fill\",\n            stylers: [\n              {\n                color: \"#283d6a\"\n              }\n            ]\n          },\n          {\n            featureType: \"transit.station\",\n            elementType: \"geometry\",\n            stylers: [\n              {\n                color: \"#3a4762\"\n              }\n            ]\n          },\n          {\n            featureType: \"water\",\n            elementType: \"geometry\",\n            stylers: [\n              {\n                color: \"#0e1626\"\n              }\n            ]\n          },\n          {\n            featureType: \"water\",\n            elementType: \"labels.text.fill\",\n            stylers: [\n              {\n                color: \"#4e6d70\"\n              }\n            ]\n          }\n        ]''');";

    default:
      return temp = "";
  }
}

function mapViewFlutterComponent(reactObject) {
  var flutterResultMapView = "\nContainer(\n" + layoutProperties(reactObject) + "\nchild: GoogleMap(\n  mapType: MapType.normal,\n  initialCameraPosition: CameraPosition(\n    target: LatLng(" + reactObject.props.initialRegion.latitude + ", " + reactObject.props.initialRegion.longitude + "),\n    zoom: 14.4746,\n  ),\n  onMapCreated: (GoogleMapController controller) {\n    _controller.complete(controller);\n    " + mapStyle(reactObject.props.customMapStyle) + "\n   \n  },\n),\n    ),";
  return flutterResultMapView.replace(/^\s*[\r\n]/gm, "");
}

function sliderFlutterComponent(reactObject) {
  var flutterResultSlider = "\nContainer(\n        " + layoutProperties(reactObject) + "\n        child: SliderTheme(\ndata: SliderTheme.of(context).copyWith(\n  " + propCheck$1(colorMaker(reactObject.props.minimumTrackTintColor, ""), "activeTrackColor") + "  \n  " + propCheck$1(colorMaker(reactObject.props.maximumTrackTintColor, ""), "inactiveTrackColor") + "\n  " + propCheck$1(colorMaker(reactObject.props.thumbTintColor, ""), "thumbColor") + "\n  trackHeight: 2.0,\n  thumbShape: RoundSliderThumbShape(enabledThumbRadius: 8.0),\n  " + overlayThumbColor(reactObject.props.thumbTintColor) + "\n  overlayShape: RoundSliderOverlayShape(overlayRadius: 14.0),\n),\nchild: Slider(\n  " + propCheck$1(reactObject.props.step, "divisions") + "\n  min: " + defaultValues(reactObject.props.minimumValue, 0) + "\n  max: " + defaultValues(reactObject.props.maximumValue, 100) + "\n  value: value.toDouble(),\n  " + disableSlider(reactObject.props.disabled) + "\n),\n),\n),";
  return flutterResultSlider.replace(/^\s*[\r\n]/gm, "");
}

function defaultValues(prop, value) {
  var temp = "";

  if (prop === undefined) {
    temp = value + ",";
  } else {
    temp = prop + ",";
  }

  return temp;
}

function propCheck$1(prop, key) {
  var temp = "";

  if (prop === undefined || prop === "") {
    temp = "";
  } else {
    temp = key + ": " + prop + ",";
  }

  return temp;
}

function overlayThumbColor(prop) {
  var temp = "";

  if (prop === undefined) {
    temp = "overlayColor: Colors.grey.withAlpha(32),";
  } else {
    temp = "overlayColor: " + colorMaker(prop, "") + ".withAlpha(32),";
  }

  return temp;
}

function disableSlider(prop) {
  var temp = "";

  if (prop === undefined) {
    temp = "onChanged: (double newValue) {\n                 setState(() {\n                    value = newValue.round();\n                 });\n                  },";
  } else {
    if (prop) {
      temp = "onChanged: null,";
    } else {
      temp = "onChanged: (double newValue) {\n                 setState(() {\n                    value = newValue.round();\n                 });\n                  },";
    }
  }

  return temp;
}

function switchFlutterComponent(reactObject) {
  var flutterResultSwitch = "\nContainer(\n" + layoutProperties(reactObject) + "\nchild: Switch(\n" + propCheck$2(colorMaker(reactObject.props.thumbTintColor, ""), "inactiveThumbColor") + "  \n" + propCheck$2(colorMaker(reactObject.props.thumbTintColor, ""), "activeColor") + "\n" + propCheck$2(colorMaker(reactObject.props.tintColor, ""), "inactiveTrackColor") + "  \n" + propCheck$2(colorMaker(reactObject.props.onTintColor, ""), "activeTrackColor") + "\nvalue: isSwitched,\n" + disableSlider$1(reactObject.props.disabled) + "\n),\n),";
  return flutterResultSwitch.replace(/^\s*[\r\n]/gm, "");
}

function propCheck$2(prop, key) {
  var temp = "";

  if (prop === undefined || prop === "") {
    temp = "";
  } else {
    temp = key + ": " + prop + ",";
  }

  return temp;
}

function disableSlider$1(prop) {
  var temp = "";

  if (prop === undefined) {
    temp = "onChanged: (value) {\n                    setState(() {\n                        isSwitched = value;\n                    });\n                },";
  } else {
    if (prop) {
      temp = "onChanged: null,";
    } else {
      temp = "onChanged: (value) {\n                    setState(() {\n                        isSwitched = value;\n                    });\n                },";
    }
  }

  return temp;
}

function ellipseFlutter(reactObject) {
  var flutterResultEllipse = "\nContainer(\n" + propertiesDetect(reactObject.props.style.width, "width") + "\n" + propertiesDetect(reactObject.props.style.height, "height") + "\n" + marginFlutter({
    "margin": reactObject.props.style.margin,
    "marginLeft": reactObject.props.style.marginLeft,
    "marginRight": reactObject.props.style.marginRight,
    "marginTop": reactObject.props.style.marginTop,
    "marginBottom": reactObject.props.style.marginBottom,
    "marginHorizontal": reactObject.props.style.marginHorizontal,
    "marginVertical": reactObject.props.style.marginVertical
  }) + "\n  decoration: BoxDecoration(\n  " + colorMaker(reactObject.props.fill, "color:") + ",\n  borderRadius: BorderRadius.all(Radius.elliptical(" + reactObject.props.cx + ", " + reactObject.props.cy + ")),\n  border: Border.all(\n    " + colorMaker(reactObject.props.stroke, "color:") + ",\n    width: " + reactObject.props.strokeWidth + ",\n  ),\n  ),\n),";
  return flutterResultEllipse.replace(/^\s*[\r\n]/gm, "");
}

function pathFlutter(reactObject) {
  var viewBoxArray = reactObject.props.viewBox.split(/(\s+)/).filter(function (e) {
    return e.trim().length > 0;
  });
  var flutterResult = "\nFittedBox(\nchild: Transform(\ntransform: new Matrix4.identity()..scale(" + reactObject.props.style.width / viewBoxArray[2] + ", " + reactObject.props.style.height / viewBoxArray[3] + "),    \nchild: Container(\nwidth: " + viewBoxArray[2] + ",\nheight: " + viewBoxArray[3] + ",\n" + marginFlutter({
    "margin": reactObject.props.style.margin,
    "marginLeft": reactObject.props.style.marginLeft,
    "marginRight": reactObject.props.style.marginRight,
    "marginTop": reactObject.props.style.marginTop,
    "marginBottom": reactObject.props.style.marginBottom,
    "marginHorizontal": reactObject.props.style.marginHorizontal,
    "marginVertical": reactObject.props.style.marginVertical
  }) + "\nchild: Stack(\n  children: <Widget>[\n    ClipPath(\n      clipper: CustomClip" + (reactObject.styleName.toString().charAt(0).toUpperCase() + reactObject.styleName.slice(1)) + "(),\n      child: Container(\n        width: " + viewBoxArray[2] + ",\n        height: " + viewBoxArray[3] + ",\n        " + colorMaker(reactObject.props.fill, "color:") + ",\n      ),\n    ),\n    CustomPaint(\n      painter: BorderPainter" + (reactObject.styleName.toString().charAt(0).toUpperCase() + reactObject.styleName.slice(1)) + "(),\n      child: Container(\n        width: " + viewBoxArray[2] + ",\n        height: " + viewBoxArray[3] + ",\n      ),\n    ),\n  ],\n),\n),\n),\n),";
  return flutterResult.replace(/^\s*[\r\n]/gm, "");
} //                     "isClosed": true,
//                     "strokeWidth": "0",
//                     "stroke": "grey",
//                     "fill": "rgba(230, 230, 230,1)",
//                     "type": "path",
//                     "viewBox": "0 0 441.0273113408157 152.42056652604106"

function typeDetect(reactObject) {
  switch (reactObject.type) {
    case "view":
      return containerFlutter(reactObject);

    case "root":
      return containerFlutter(reactObject);

    case "text":
      return textFlutter(reactObject);

    case "image":
      return imageFlutter(reactObject);

    case "touchableOpacity":
      return buttonFlutter(reactObject);

    case "scrollView":
      return listView(reactObject);

    case "textInput":
      return textInputFlutter(reactObject);

    case "activityIndicator":
      return activityIndicatorFlutter(reactObject);

    case "icon":
      return iconsFlutterComponent(reactObject);

    case "mapView":
      return mapViewFlutterComponent(reactObject);

    case "slider":
      return sliderFlutterComponent(reactObject);

    case "switch":
      return switchFlutterComponent(reactObject);

    case "ellipse":
      return ellipseFlutter(reactObject);

    case "path":
      return pathFlutter(reactObject);

    default:
      return containerFlutter(reactObject);
  }
}

function convertAstData(tree) {
  var reactObject = tree;
  return typeDetect(reactObject);
}

function addImports(code) {
  var temp = [];

  if (code.search("Icon") !== -1) {
    temp.push("import 'package:flutter_icons/flutter_icons.dart';");
  }

  if (code.search("GoogleMap") !== -1) {
    temp.push("import 'dart:async';", "import 'package:google_maps_flutter/google_maps_flutter.dart';");
  }

  return temp.join("\n");
}

function addVariable(code, x) {
  var temp = [];

  if (code.search("GoogleMap") !== -1) {
    temp.push("Completer<GoogleMapController> _controller = Completer();");
  }

  if (code.search("Slider") !== -1) {
    temp.push("int value = " + x["sliderValue"] + ";");
  }

  if (code.search("Switch") !== -1) {
    temp.push("bool isSwitched = " + x["switchValue"] + ";");
  }

  return temp.join("\n");
}

function detectState(state, res, x) {
  console.log(x["pathProps"]);
  var code;

  if (state === "statefull") {
    code = "class ConvertedWidget extends StatefulWidget {\n  @override\n  _ConvertedWidgetState createState() => _ConvertedWidgetState();\n}\n\nclass _ConvertedWidgetState extends State<ConvertedWidget> {\n" + addVariable(res, x) + "\n  @override\n  Widget build(BuildContext context) {\n    return SingleChildScrollView(\n        child: " + res + ",\n        );\n  }\n}";
  } else {
    code = "class ConvertedWidget extends StatelessWidget {\n" + addVariable(res, x) + "\n@override\nWidget build(BuildContext context) {\n    return " + res + ";\n}\n}\n";
  }

  return code;
}

function stateWidgets(res, x) {
  var temp;

  if (res.search("Slider") !== -1) {
    temp = detectState("statefull", res, x);
  } else if (res.search("Switch") !== -1) {
    temp = detectState("statefull", res, x);
  } else {
    temp = detectState("stateless", res, x);
  }

  return temp;
}

function detectVariable(children) {
  var x = {
    "sliderValue": 0,
    "switchValue": false,
    "pathProps": []
  };

  for (var index = 0; index < children.length; index++) {
    if (children[index].type === "slider") {
      x["sliderValue"] = children[index].props.value;
    } else if (children[index].type === "switch") {
      x["switchValue"] = children[index].props.value;
    } else if (children[index].type === "path") {
      x["pathProps"].push(children[index]);
    }

    for (var j = 0; j < children[index]["children"].length; j++) {
      if (children[index]["children"][j].type === "slider") {
        x["sliderValue"] = children[index]["children"][j].props.value;
      } else if (children[index]["children"][j].type === "switch") {
        x["switchValue"] = children[index]["children"][j].props.value;
      } else if (children[index]["children"][j].type === "path") {
        x["pathProps"].push(children[index]["children"][j]);
      }
    }
  }

  console.log('====================================');
  console.log(x);
  console.log('====================================');
  return x;
} // {
//     "type": "file",
//     "path": "/src/screens/Untitled2.js",
//     "dbFileId": 18194,
//     "isDirty": false,
//     "version": "4.0",
//     "layer": {
//         "type": "root",
//         "children": [
//             {
//                 "type": "view",
//                 "children": [
//                     {
//                         "type": "switch",
//                         "children": [],
//                         "import": {
//                             "layerName": "Switch",
//                             "packageName": "react-native",
//                             "isDefaultImport": false,
//                             "asName": ""
//                         },
//                         "styleName": "switch",
//                         "locked": false,
//                         "overrideKeys": [],
//                         "template": {
//                             "centerVertical": false,
//                             "centerHorizontal": false
//                         },
//                         "rcDims": {
//                             "x": 0,
//                             "y": 0,
//                             "width": 45,
//                             "height": 23
//                         },
//                         "props": {
//                             "style": {},
//                             "value": true
//                         },
//                         "scopeVariables": {}
//                     },
//                     {
//                         "type": "slider",
//                         "children": [],
//                         "import": {
//                             "layerName": "Slider",
//                             "packageName": "react-native",
//                             "isDefaultImport": false,
//                             "asName": ""
//                         },
//                         "styleName": "slider",
//                         "locked": false,
//                         "overrideKeys": [],
//                         "template": {
//                             "centerVertical": false,
//                             "centerHorizontal": false
//                         },
//                         "rcDims": {
//                             "x": 0,
//                             "y": 93,
//                             "width": 107,
//                             "height": 21
//                         },
//                         "props": {
//                             "style": {
//                                 "height": 21,
//                                 "width": 107
//                             },
//                             "value": 50
//                         },
//                         "scopeVariables": {}
//                     },
//                     {
//                         "type": "view",
//                         "children": [],
//                         "import": {
//                             "layerName": "View",
//                             "packageName": "native",
//                             "isDefaultImport": false,
//                             "asName": ""
//                         },
//                         "styleName": "rect",
//                         "locked": false,
//                         "overrideKeys": [],
//                         "template": {
//                             "centerVertical": false,
//                             "centerHorizontal": false
//                         },
//                         "rcDims": {
//                             "x": 0,
//                             "y": 183,
//                             "width": 95,
//                             "height": 47
//                         },
//                         "props": {
//                             "style": {
//                                 "width": 95,
//                                 "height": 47,
//                                 "backgroundColor": "#E6E6E6"
//                             }
//                         },
//                         "scopeVariables": {}
//                     }
//                 ],
//                 "import": {
//                     "layerName": "View",
//                     "packageName": "native",
//                     "isDefaultImport": false,
//                     "asName": ""
//                 },
//                 "styleName": "group",
//                 "locked": false,
//                 "overrideKeys": [],
//                 "template": {
//                     "centerVertical": false,
//                     "centerHorizontal": false
//                 },
//                 "rcDims": {
//                     "x": 40,
//                     "y": 90,
//                     "width": 107,
//                     "height": 230
//                 },
//                 "props": {
//                     "style": {
//                         "width": 107,
//                         "height": 230,
//                         "flexDirection": "column",
//                         "justifyContent": "space-between",
//                         "marginTop": 90,
//                         "marginLeft": 40
//                     }
//                 },
//                 "scopeVariables": {},
//                 "_flexParent": true
//             }
//         ],
//         "import": {
//             "layerName": "View",
//             "packageName": "native",
//             "isDefaultImport": false,
//             "asName": ""
//         },
//         "styleName": "container",
//         "locked": false,
//         "overrideKeys": [],
//         "template": {
//             "centerVertical": false,
//             "centerHorizontal": false
//         },
//         "rcDims": {
//             "x": 0,
//             "y": 0,
//             "width": 215.16,
//             "height": 387.89
//         },
//         "props": {
//             "style": {
//                 "flex": 1,
//                 "flexDirection": "column",
//                 "display": "flex"
//             }
//         },
//         "scopeVariables": {}
//     },
//     "props": {
//         "style": {
//             "left": 2583.6083984375,
//             "top": 2000,
//             "width": 215.16269662039622,
//             "height": 387.8932189941406,
//             "position": "absolute"
//         }
//     },
//     "scopeVariables": {
//         "deviceName": "custom",
//         "deviceOrientation": "portrait",
//         "platform": "iOS"
//     },
//     "statusBar": {
//         "display": true,
//         "barStyle": "default",
//         "animated": false
//     },
//     "smartFlexTransformed": true
// }
// {
//     "type": "file",
//     "path": "/src/screens/Untitled.js",
//     "dbFileId": 18195,
//     "version": "4.0",
//     "layer": {
//         "type": "root",
//         "children": [
//             {
//                 "type": "switch",
//                 "children": [],
//                 "import": {
//                     "layerName": "Switch",
//                     "packageName": "react-native",
//                     "isDefaultImport": false,
//                     "asName": ""
//                 },
//                 "styleName": "switch",
//                 "locked": false,
//                 "overrideKeys": [],
//                 "template": {
//                     "centerVertical": false,
//                     "centerHorizontal": false
//                 },
//                 "rcDims": {
//                     "x": 34,
//                     "y": 100,
//                     "width": 45,
//                     "height": 23
//                 },
//                 "props": {
//                     "style": {
//                         "marginTop": 100,
//                         "marginLeft": 34
//                     },
//                     "value": true
//                 },
//                 "scopeVariables": {}
//             },
//             {
//                 "type": "view",
//                 "children": [],
//                 "import": {
//                     "layerName": "View",
//                     "packageName": "native",
//                     "isDefaultImport": false,
//                     "asName": ""
//                 },
//                 "styleName": "rect",
//                 "locked": false,
//                 "overrideKeys": [],
//                 "template": {
//                     "centerVertical": false,
//                     "centerHorizontal": false
//                 },
//                 "rcDims": {
//                     "x": 56,
//                     "y": 213,
//                     "width": 85,
//                     "height": 54
//                 },
//                 "props": {
//                     "style": {
//                         "width": 85,
//                         "height": 53,
//                         "backgroundColor": "#E6E6E6",
//                         "marginTop": 90,
//                         "marginLeft": 56
//                     }
//                 },
//                 "scopeVariables": {}
//             }
//         ],
//         "import": {
//             "layerName": "View",
//             "packageName": "native",
//             "isDefaultImport": false,
//             "asName": ""
//         },
//         "styleName": "container",
//         "locked": false,
//         "overrideKeys": [],
//         "template": {
//             "centerVertical": false,
//             "centerHorizontal": false
//         },
//         "rcDims": {
//             "x": 0,
//             "y": 0,
//             "width": 210.23,
//             "height": 387.89
//         },
//         "props": {
//             "style": {
//                 "flex": 1,
//                 "flexDirection": "column",
//                 "display": "flex"
//             }
//         },
//         "scopeVariables": {}
//     },
//     "props": {
//         "style": {
//             "left": 2534.064697265625,
//             "top": 2000,
//             "width": 210.2252960205078,
//             "height": 387.8932189941406,
//             "position": "absolute"
//         }
//     },
//     "scopeVariables": {
//         "deviceName": "custom",
//         "deviceOrientation": "portrait",
//         "platform": "iOS"
//     },
//     "statusBar": {
//         "display": true,
//         "barStyle": "default",
//         "animated": false
//     },
//     "smartFlexTransformed": true
// }

function customPainterFlutter(propArray) {
  var temp = [];

  for (var i = 0; i < propArray.length; i++) {
    temp.push(drawpath(propArray[i]));
  }

  return temp.join("\n");
}
function drawpath(prop) {
  var temp;

  if (isEmpty(prop)) {
    temp = "";
  } else {
    var points = BuilderX.generateSVGPath(prop.props.points, prop.props.strokeWidth, prop.props.isClosed);
    console.log(takeoutPointsForPainter(points.toString()));
    temp = "class BorderPainter" + (prop.styleName.toString().charAt(0).toUpperCase() + prop.styleName.slice(1)) + " extends CustomPainter {\n  @override\n  void paint(Canvas canvas, Size size) {\n    Paint paint = Paint()\n      ..style = PaintingStyle.stroke\n      ..strokeWidth = " + prop.props.strokeWidth + "\n      ..color = " + colorMaker(prop.props.stroke, "") + ";\n    Path path = Path();\n    " + takeoutPointsForPainter(points.toString()) + "\n    path.close();\n    canvas.drawPath(path, paint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) => false;\n}\n\nclass CustomClip" + (prop.styleName.toString().charAt(0).toUpperCase() + prop.styleName.slice(1)) + " extends CustomClipper<Path> {\n  @override\n  Path getClip(Size size) {\n    Path path = Path();\n    " + takeoutPointsForPainter(points.toString()) + "\n    path.close();\n    return path;\n  }\n\n  @override\n  bool shouldReclip(CustomClipper<Path> oldClipper) => false;\n}\n";
  }

  return temp;
}

function isEmpty(obj) {
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) return false;
  }

  return true;
}

function takeoutPointsForPainter(code) {
  // var code = "M58.72 56.35 C221.32 241.23 210.72 90.01 210.72 90.01 L122.78 200.75 C122.78 200.75 -103.88 -128.54 58.72 56.35 Z";
  var newCode = code.substring(0, code.length - 1).split(/(?=[LMC])/);
  var pathCodeArray = [];

  for (var i = 0; i < newCode.length; i++) {
    var temp = newCode[i].substring(1).split(/[ ,]+/).filter(function (v) {
      return v !== '';
    }).join(', ');

    if (newCode[i].charAt(0) === "M") {
      var str = "path.moveTo(" + temp + ")";
      pathCodeArray.push(str);
    }

    if (newCode[i].charAt(0) === "L") {
      var str = "path.lineTo(" + temp + ")";
      pathCodeArray.push(str);
    }

    if (newCode[i].charAt(0) === "C") {
      var str = "path.cubicTo(" + temp + ")";
      pathCodeArray.push(str);
    }
  }

  var str = pathCodeArray.join(";\n").replace(/^\s*[\r\n]/gm, "");
  console.log(str + ";");
  return str + ";";
}

function finalConversion(file) {
  var basic = {
    type: "view",
    styleName: "container",
    props: {
      style: file["layer"]["props"]["style"]
    },
    children: file["layer"]["children"]
  };
  var temp = convertAstData(basic).toString();
  var trimed = temp.trim();
  var res = trimed.slice(0, -1);
  console.log(JSON.stringify(file, null, 4));
  var x = detectVariable(file["layer"]["children"]);
  var code = "import 'package:flutter/material.dart';\n" + addImports(res) + "\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      debugShowCheckedModeBanner: false,\n      home: Scaffold(\n        body: ConvertedWidget(), \n      ),\n    );\n  }\n}\n" + stateWidgets(res, x) + "\n" + customPainterFlutter(x["pathProps"]) + "\n";
  console.log(indentCode(code));
  return indentCode(code);
}

var indentCode = function indentCode(codeStr, indentLevel) {
  if (indentLevel === void 0) {
    indentLevel = 2;
  }

  var OPENERS = ['{', '(', '['];
  var CLOSERS = ['}', ')', ']'];
  var curIndent = 0;
  var newLines = [];
  var lines = codeStr.split(/\r?\n/);
  lines.forEach(function (line) {
    var lineTrimmed = line.trim();
    var lastChar = lineTrimmed[lineTrimmed.length - 1];
    var secLastChar = lineTrimmed[lineTrimmed.length - 2];
    var endOpenerFound = OPENERS.includes(lastChar);
    var endCloserFound = CLOSERS.includes(lastChar) || CLOSERS.includes(secLastChar);

    if (endCloserFound && !endOpenerFound) {
      var someOpenerFound = [].concat(lineTrimmed).some(function (c) {
        return OPENERS.includes(c);
      });

      if (!someOpenerFound) {
        curIndent -= indentLevel;
      }
    }

    newLines.push(' '.repeat(curIndent) + lineTrimmed);
    if (endOpenerFound) curIndent += indentLevel;
  });
  return newLines.join('\n');
};

var FlutterCodeEngine = function FlutterCodeEngine() {
  this.meta = {
    name: 'flutter',
    icon: 'https://pre-cloud.builderx.io/assets/plugins/component/icons/Flutter.svg'
  };

  this.execute = function (fileJSON) {
    return finalConversion(fileJSON);
  };
};

var FlutterCodeGen = /*#__PURE__*/function () {
  function FlutterCodeGen() {
    this.name = 'FlutterCodeGen';
  }

  var _proto = FlutterCodeGen.prototype;

  _proto.init = function init(session) {
    this.session = session;
  };

  _proto.activate = function activate() {
    var codeEngine = new FlutterCodeEngine();
    this.session.addCodeEngine(codeEngine);
  };

  _proto.deactivate = function deactivate() {};

  _proto.logSession = function logSession() {
    this.session.executeFunction('logSession');
  };

  return FlutterCodeGen;
}();

exports.FlutterCodeGen = FlutterCodeGen;
//# sourceMappingURL=flutter-plugin.cjs.development.js.map
