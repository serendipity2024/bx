{"version":3,"file":"conversions.cjs.production.min.js","sources":["../src/fromPaperPath.ts","../src/toPaperPath.ts","../src/getRadiusAdjustedPoints.ts","../src/pathUtils.ts","../src/toSVGPath.ts","../src/pointsFromSVGPath.ts"],"sourcesContent":["//@ts-ignore\nimport paper from \"paper\";\nif (typeof document !== \"undefined\") {\n  let canvasDOMElement = document.createElement(\"canvas\");\n  canvasDOMElement.style.position = \"absolute\";\n  canvasDOMElement.setAttribute(\"height\", \"1000px\");\n  canvasDOMElement.setAttribute(\"width\", \"1000px\");\n  canvasDOMElement.style.top = \"0px\";\n  canvasDOMElement.style.left = \"0px\";\n  paper.setup(canvasDOMElement as HTMLCanvasElement);\n  paper.settings[\"insertItems\"] = false;\n} else {\n  // @ts-ignore\n  paper.setup([640, 480]);\n}\nexport function convertPaperPointToBxObj(finalPaperPath: any) {\n  return {\n    closed: finalPaperPath.closed,\n    points: convertPaperToBx(finalPaperPath.exportJSON()),\n  };\n}\nexport function convertPaperToBx(finalPathPaper: any) {\n  let finalPaperPoints: any = [];\n  let finalPathPaperJson = JSON.parse(finalPathPaper);\n  if (\n    finalPathPaperJson[0] !== \"CompoundPath\" &&\n    finalPathPaperJson[1] &&\n    finalPathPaperJson[1].segments\n  ) {\n    finalPaperPoints = finalPaperPoints.concat(\n      getPaperPoints(finalPathPaperJson[1].segments)\n    );\n  } else if (\n    finalPathPaperJson[1] &&\n    finalPathPaperJson[1].children &&\n    finalPathPaperJson[1].children.length > 0\n  ) {\n    for (let k = 0; k < finalPathPaperJson[1].children.length; k++) {\n      finalPaperPoints = finalPaperPoints.concat(\n        getPaperPoints(finalPathPaperJson[1].children[k][1].segments)\n      );\n      // Jugaad: using 776 and 777 for closed and no-closed paths\n      let filler = finalPathPaperJson[1].children[k][1].closed ? 776 : 777;\n      // Adding Filler Point\n      finalPaperPoints.push(\n        createPointObject(filler, filler, false, false, 0, 0, 0, 0, 0, 0)\n      );\n    }\n  }\n  return finalPaperPoints;\n}\n\nfunction getPaperPoints(segments: any) {\n  let finalPaperPoints = [];\n  for (let j = 0; j < segments.length; j++) {\n    let point: any = {};\n    let curveFrom: any = {};\n    let curveTo: any = {};\n    let pointObject = {};\n    if (segments[j][0] && segments[j][0].constructor === Array) {\n      point.x = segments[j][0][0];\n      point.y = segments[j][0][1];\n      curveTo.x = segments[j][1][0] + segments[j][0][0];\n      curveTo.y = segments[j][1][1] + segments[j][0][1];\n      curveFrom.x = segments[j][2][0] + segments[j][0][0];\n      curveFrom.y = segments[j][2][1] + segments[j][0][1];\n      pointObject = createPointObject(\n        0,\n        0,\n        true,\n        true,\n        curveFrom.x,\n        curveFrom.y,\n        curveTo.x,\n        curveTo.y,\n        point.x,\n        point.y\n      );\n    } else {\n      point.x = segments[j][0];\n      point.y = segments[j][1];\n      pointObject = createPointObject(\n        0,\n        0,\n        false,\n        false,\n        point.x,\n        point.y,\n        point.x,\n        point.y,\n        point.x,\n        point.y\n      );\n    }\n    finalPaperPoints.push(pointObject);\n  }\n  return finalPaperPoints;\n}\n\nfunction createPointObject(\n  cornerRadius: number,\n  curveMode: number,\n  hasCurveFrom: boolean,\n  hasCurveTo: boolean,\n  curveFromX: number,\n  curveFromY: number,\n  curveToX: number,\n  curveToY: number,\n  px: number,\n  py: number\n) {\n  return {\n    cornerRadius: cornerRadius,\n    curveMode: curveMode,\n    hasCurveTo: hasCurveTo,\n    hasCurveFrom: hasCurveFrom,\n    curveFrom: {\n      x: curveFromX,\n      y: curveFromY,\n    },\n    curveTo: {\n      x: curveToX,\n      y: curveToY,\n    },\n    point: {\n      x: px,\n      y: py,\n    },\n  };\n}\n","//@ts-ignore\nimport paper from \"paper\";\nif (typeof document !== \"undefined\") {\n  let canvasDOMElement = document.createElement(\"canvas\");\n  canvasDOMElement.style.position = \"absolute\";\n  canvasDOMElement.setAttribute(\"height\", \"1000px\");\n  canvasDOMElement.setAttribute(\"width\", \"1000px\");\n  canvasDOMElement.style.top = \"0px\";\n  canvasDOMElement.style.left = \"0px\";\n  paper.setup(canvasDOMElement as HTMLCanvasElement);\n  paper.settings[\"insertItems\"] = false;\n} else {\n  // @ts-ignore\n  paper.setup([640, 480]);\n}\nexport function getPaperPathFromPoints(pointsInPath: any, isClosed: boolean) {\n  let segments = getSegmentFromPoints(pointsInPath);\n  let paperPath = new paper.Path(segments);\n  paperPath.closed = isClosed;\n  return paperPath;\n}\n\nexport function getSegmentFromPoints(pointsInPath: any) {\n  let segments = [];\n  for (let pointIndex = 0; pointIndex < pointsInPath.length; pointIndex++) {\n    let handleInPoint = new paper.Point(\n      pointsInPath[pointIndex].curveTo.x - pointsInPath[pointIndex].point.x,\n      pointsInPath[pointIndex].curveTo.y - pointsInPath[pointIndex].point.y\n    );\n    let handleOutPoint = new paper.Point(\n      pointsInPath[pointIndex].curveFrom.x - pointsInPath[pointIndex].point.x,\n      pointsInPath[pointIndex].curveFrom.y - pointsInPath[pointIndex].point.y\n    );\n    let handleIn = pointsInPath[pointIndex].hasCurveFrom\n      ? handleInPoint\n      : undefined;\n    let handleOut = pointsInPath[pointIndex].hasCurveTo\n      ? handleOutPoint\n      : undefined;\n    let point = new paper.Point(\n      pointsInPath[pointIndex].point.x,\n      pointsInPath[pointIndex].point.y\n    );\n    let segment = new paper.Segment({\n      point,\n      handleIn,\n      handleOut,\n      radius: pointsInPath[pointIndex].Radius,\n    });\n    segments.push(segment);\n  }\n  return segments;\n}\n","import { Point, Coordinate } from \"./types\";\nimport { getRadiusAdjustment } from \"./pathUtils\";\n\nexport default function getRadiusAdjustedPoints(\n  pointsArray: Array<Point>,\n  viewBox: string\n) {\n  const dims: Array<any> =\n    viewBox && viewBox.split ? viewBox.split(\" \") : [0, 0, 100, 100];\n  const maxRadius = Math.min(dims[2] - dims[0], dims[3] - dims[1]) / 2;\n  let newPoints: Array<Point> = [];\n  pointsArray.forEach((oldPoint: Point, i: number) => {\n    if (oldPoint.cornerRadius) {\n      let d: Coordinate = { x: 0, y: 0 };\n      let point: Coordinate;\n      let additionalPoint: Point;\n      if (i === 0) {\n        d = getRadiusAdjustment(pointsArray, i, i + 1, maxRadius);\n        point = {\n          x: Number(oldPoint.point.x + d.x),\n          y: Number(oldPoint.point.y + d.y),\n        };\n        newPoints.push({\n          ...oldPoint,\n          cornerRadius: 0,\n          point,\n        });\n      }\n      const nextIndex = i === pointsArray.length - 1 ? 0 : i + 1;\n      const nextToNextIndex =\n        i === pointsArray.length - 1 ? 1 : pointsArray[i + 2] ? i + 2 : 0;\n      d = getRadiusAdjustment(pointsArray, i, nextIndex, maxRadius);\n      point = {\n        x: Number(pointsArray[nextIndex].point.x - d.x),\n        y: Number(pointsArray[nextIndex].point.y - d.y),\n      };\n      newPoints.push({\n        ...oldPoint,\n        cornerRadius: 0,\n        hasCurveFrom: true,\n        curveFrom: point,\n        curveTo: point,\n        point,\n      });\n      const d2 = getRadiusAdjustment(\n        pointsArray,\n        nextIndex,\n        nextToNextIndex,\n        maxRadius\n      );\n      additionalPoint = {\n        curveMode: 1,\n        hasCurveFrom: true,\n        hasCurveTo: true,\n        cornerRadius: 0,\n        curveFrom: {\n          x: pointsArray[nextIndex].point.x + d2.x,\n          y: pointsArray[nextIndex].point.y + d2.y,\n        },\n        curveTo: {\n          x: pointsArray[nextIndex].point.x,\n          y: pointsArray[nextIndex].point.y,\n        },\n        point: {\n          x: pointsArray[nextIndex].point.x + d2.x,\n          y: pointsArray[nextIndex].point.y + d2.y,\n        },\n      };\n      newPoints.push(additionalPoint);\n    } else {\n      newPoints.push(oldPoint);\n    }\n  });\n  return newPoints;\n}\n","//@ts-ignore\nimport paper from \"paper\";\nimport { getSegmentFromPoints } from \"./toPaperPath\";\nimport { Point, Coordinate } from \"./types\";\nimport getRadiusAdjustedPoints from \"./getRadiusAdjustedPoints\";\n\nif (typeof document !== \"undefined\") {\n  let canvasDOMElement = document.createElement(\"canvas\");\n  canvasDOMElement.style.position = \"absolute\";\n  canvasDOMElement.setAttribute(\"height\", \"1000px\");\n  canvasDOMElement.setAttribute(\"width\", \"1000px\");\n  canvasDOMElement.style.top = \"0px\";\n  canvasDOMElement.style.left = \"0px\";\n  paper.setup(canvasDOMElement as HTMLCanvasElement);\n  paper.settings[\"insertItems\"] = false;\n} else {\n  // @ts-ignore\n  paper.setup([640, 480]);\n}\n\nfunction getManipulatedPath(layer: any, paperPath: any) {\n  // TODO: keep this order, otherwise malfunctions\n  // adds roatation\n  if (layer.rotation) {\n    paperPath.rotate(-layer.rotation);\n  }\n  // checks for flip\n  if (layer.isFlippedHorizontal || layer.isFlippedVertical) {\n    paperPath.scale(\n      layer.isFlippedHorizontal ? -1 : 1,\n      layer.isFlippedVertical ? -1 : 1\n    );\n  }\n  paperPath.closed = layer.isClosed;\n  return paperPath;\n}\n\nexport function applyBooleanOpsOnPaths(\n  layers: any,\n  frame: any,\n  scalingFactor: number,\n  viewBox: string\n) {\n  if (!layers) {\n    return [];\n  }\n  try {\n    // to keep track of hidden layers and exclude them\n    let firstValidIndex = 0;\n    // check for first valid index, shapes might be hidden which are not to be counted\n    while (firstValidIndex < layers.length - 1) {\n      if (layers[firstValidIndex] && layers[firstValidIndex].isVisible) {\n        break;\n      } else if (\n        firstValidIndex === layers.length - 1 &&\n        layers[firstValidIndex] &&\n        !layers[firstValidIndex].isVisible\n      ) {\n        firstValidIndex = -1;\n        return [];\n      } else {\n        firstValidIndex++;\n      }\n    }\n    let zeroPointInPath: any = getRadiusAdjustedPoints(\n      convertPointsArrayBool(\n        layers[firstValidIndex].points,\n        layers[firstValidIndex].frame,\n        frame,\n        scalingFactor\n      ),\n      viewBox\n    );\n    const segments = getSegmentFromPoints(zeroPointInPath);\n    let finalPaperPath: any = new paper.Path(segments);\n    finalPaperPath = getManipulatedPath(\n      layers[firstValidIndex],\n      finalPaperPath\n    );\n    if (firstValidIndex < layers.length - 1) {\n      for (let index = firstValidIndex + 1; index < layers.length; index++) {\n        if (layers[index].isVisible) {\n          let pointsInPath = getRadiusAdjustedPoints(\n            convertPointsArrayBool(\n              layers[index].points,\n              layers[index].frame,\n              frame,\n              scalingFactor\n            ),\n            viewBox\n          );\n          let paperPath = new paper.Path(getSegmentFromPoints(pointsInPath));\n          paperPath = getManipulatedPath(layers[index], paperPath);\n          switch (layers[index].booleanOperation) {\n            case 0:\n              finalPaperPath = finalPaperPath.unite(paperPath);\n              break;\n            case 1:\n              finalPaperPath = finalPaperPath.subtract(paperPath);\n              break;\n            case 2:\n              finalPaperPath = finalPaperPath.intersect(paperPath);\n              break;\n            default:\n              finalPaperPath = finalPaperPath.exclude(paperPath);\n              break;\n          }\n        }\n      }\n    }\n\n    return finalPaperPath.exportJSON();\n  } catch (error) {\n    console.log(\"JSON read error in Boolean Operations\", error);\n    return [];\n    // throw new Error(\"JSON read error in Boolean Operations\");\n  }\n}\n\nfunction convertPointsArrayBool(\n  points: any,\n  frame: any,\n  referenceFrame: any,\n  scalingFactor: number\n) {\n  let newPoints = [];\n  if (points && points.length > 0) {\n    let pointsApplied =\n      points[0].point !== points[points.length - 1].point\n        ? points\n        : getValidPoints(points);\n    for (let i = 0; i < pointsApplied.length; i++) {\n      let tempPoint: any = {};\n      tempPoint.cornerRadius = pointsApplied[i].cornerRadius;\n      tempPoint.curveMode = pointsApplied[i].curveMode;\n      tempPoint.hasCurveTo = pointsApplied[i].hasCurveTo;\n      tempPoint.hasCurveFrom = pointsApplied[i].hasCurveFrom;\n      tempPoint.curveFrom = convertPointBool(\n        pointsApplied[i].curveFrom,\n        frame,\n        referenceFrame,\n        scalingFactor\n      );\n      tempPoint.curveTo = convertPointBool(\n        pointsApplied[i].curveTo,\n        frame,\n        referenceFrame,\n        scalingFactor\n      );\n      tempPoint.point = convertPointBool(\n        pointsApplied[i].point,\n        frame,\n        referenceFrame,\n        scalingFactor\n      );\n      newPoints.push(tempPoint);\n    }\n  }\n  return newPoints;\n}\n\nfunction convertPointBool(\n  point: any,\n  frame: any,\n  // @ts-ignore\n  referenceFrame: any,\n  scalingFactor: any\n) {\n  let tempP1 = point.split(\",\");\n  let px = tempP1[0].slice(1);\n  let py = tempP1[1].slice(0, -1);\n  px = (px * frame.width + frame.x) * scalingFactor;\n  py = (py * frame.height + frame.y) * scalingFactor;\n\n  return {\n    x: parseFloat(px.toFixed(4)),\n    y: parseFloat(py.toFixed(4)),\n  };\n}\n\n// function to convert Sketch points json to Bx json\nexport function convertPointsArray(\n  points: any,\n  frame: any,\n  referenceFrame: any,\n  maskingDisplacement: any,\n  scalingFactor: number\n) {\n  let newPoints = [];\n  if (points && points.length > 0) {\n    for (let i = 0; i < points.length; i++) {\n      let tempPoint: any = {};\n      tempPoint.cornerRadius = points[i].cornerRadius;\n      tempPoint.curveMode = points[i].curveMode;\n      tempPoint.hasCurveTo = points[i].hasCurveTo;\n      tempPoint.hasCurveFrom = points[i].hasCurveFrom;\n      tempPoint.curveFrom = convertPoint(\n        points[i].curveFrom,\n        frame,\n        referenceFrame,\n        maskingDisplacement,\n        scalingFactor\n      );\n      tempPoint.curveTo = convertPoint(\n        points[i].curveTo,\n        frame,\n        referenceFrame,\n        maskingDisplacement,\n        scalingFactor\n      );\n      tempPoint.point = convertPoint(\n        points[i].point,\n        frame,\n        referenceFrame,\n        maskingDisplacement,\n        scalingFactor\n      );\n      newPoints.push(tempPoint);\n    }\n  }\n  return newPoints;\n}\n\nfunction convertPoint(\n  point: any,\n  frame: any,\n  referenceFrame: any,\n  maskingDisplacement: any,\n  scalingFactor: number\n) {\n  let tempP1 = point.split(\",\");\n  let px = tempP1[0].slice(1);\n  let py = tempP1[1].slice(0, -1);\n  px =\n    ((px * frame.width + maskingDisplacement.x) * frame.width * scalingFactor) /\n    referenceFrame.width;\n  py =\n    ((py * frame.height + maskingDisplacement.y) *\n      frame.height *\n      scalingFactor) /\n    referenceFrame.height;\n\n  return {\n    x: parseFloat(px.toFixed(4)),\n    y: parseFloat(py.toFixed(4)),\n  };\n}\n\nfunction getValidPoints(points: any) {\n  let newPoints = points.slice(1, points.length - 1);\n  let obj = {\n    _class: \"curvePoint\",\n    cornerRadius: points[0].cornerRadius,\n    curveMode: points[0].curveMode,\n    curveTo: points[0].hasCurveTo\n      ? points[0].curveTo\n      : points[points.length - 1].curveTo,\n    curveFrom: points[0].hasCurveFrom\n      ? points[0].curveFrom\n      : points[points.length - 1].curveFrom,\n    hasCurveFrom: points[0].hasCurveFrom\n      ? true\n      : points[points.length - 1].hasCurveFrom,\n    hasCurveTo: points[0].hasCurveTo\n      ? true\n      : points[points.length - 1].hasCurveTo,\n    point: points[0].point,\n  };\n  newPoints.unshift(obj);\n  return newPoints;\n}\n\nexport function getRadiusAdjustment(\n  pointsArray: Array<Point>,\n  currentIndex: number,\n  nextIndex: number,\n  maxRadius: number\n): Coordinate {\n  if (!pointsArray[currentIndex] || !pointsArray[nextIndex]) {\n    return { x: 0, y: 0 };\n  }\n  const radius =\n    maxRadius > pointsArray[currentIndex].cornerRadius\n      ? pointsArray[currentIndex].cornerRadius\n      : maxRadius;\n  const x0 = pointsArray[currentIndex].point.x;\n  const y0 = pointsArray[currentIndex].point.y;\n  const x1 = pointsArray[nextIndex].point.x;\n  const y1 = pointsArray[nextIndex].point.y;\n  if (x1 === x0 && y1 === y0) {\n    return { x: 0, y: 0 };\n  } else if (x1 === x0) {\n    return {\n      x: 0,\n      y: y1 > y0 ? radius : -radius,\n    };\n  } else {\n    let angle: any = Math.atan2(y1 - y0, x1 - x0);\n    return {\n      x: Math.cos(angle) * radius,\n      y: Math.sin(angle) * radius,\n    };\n  }\n}\n","import { Point, Coordinate } from \"./types\";\nimport { getRadiusAdjustment } from \"./pathUtils\";\nexport default function generateSVGPath(\n  pointsArray: Array<Point>,\n  strokeWidthOffset: number,\n  isClosed: boolean,\n  viewBox: string\n) {\n  let generatedPath = \"\";\n  if (!pointsArray) {\n    return \"\";\n  }\n  // console.log(\"*** pointsArray\", JSON.stringify(pointsArray));\n  const dims: Array<any> =\n    viewBox && viewBox.split ? viewBox.split(\" \") : [0, 0, 100, 100];\n  const maxRadius = Math.min(dims[2] - dims[0], dims[3] - dims[1]) / 2;\n  strokeWidthOffset = strokeWidthOffset <= 1 ? 0 : strokeWidthOffset / 2;\n  let initialIndex = 0; // Maintains track of each shape start after combining\n  let d1: Coordinate = { x: 0, y: 0 }; // Distance with radius\n  for (let i = 0; i < pointsArray.length; i++) {\n    if (i === initialIndex) {\n      // Moving to initial points with \"M\"\n      let xy0 = pointsArray[i].point;\n      if (pointsArray[i].cornerRadius) {\n        d1 = getRadiusAdjustment(pointsArray, i, i + 1, maxRadius);\n      }\n      let x0 = (strokeWidthOffset + xy0.x + d1.x).toFixed(2);\n      let y0 = (strokeWidthOffset + xy0.y + d1.y).toFixed(2);\n      generatedPath += \"M\" + x0 + \" \" + y0 + \" \";\n      generatedPath += getNextPathPoint(\n        pointsArray,\n        i,\n        strokeWidthOffset,\n        initialIndex,\n        maxRadius\n      );\n    } else if (isFillerCondition(pointsArray[i])) {\n      initialIndex = i + 1;\n      if (i !== pointsArray.length - 1 && isFillerClosed(pointsArray[i])) {\n        generatedPath += \"Z \";\n      }\n    } else if (\n      i === pointsArray.length - 1 ||\n      (i !== pointsArray.length - 1 && isFillerCondition(pointsArray[i + 1]))\n    ) {\n      // adding additional point in the end of string\n      if (\n        isClosed &&\n        pointsArray[i].point.x !== pointsArray[initialIndex].point.x &&\n        pointsArray[i].point.y !== pointsArray[initialIndex].point.y\n      ) {\n        let pointTo = pointsArray[initialIndex].point;\n        let radiusPoint;\n        if (pointsArray[i].cornerRadius) {\n          d1 = getRadiusAdjustment(pointsArray, i, initialIndex, maxRadius);\n          const passedPointIndex = pointsArray[initialIndex + 1]\n            ? initialIndex + 1\n            : initialIndex;\n          let d2 = getRadiusAdjustment(\n            pointsArray,\n            initialIndex,\n            passedPointIndex,\n            maxRadius\n          );\n          let px0 = (strokeWidthOffset + pointTo.x + d2.x).toFixed(2);\n          let py0 = (strokeWidthOffset + pointTo.y + d2.y).toFixed(2);\n          let curveFromX0 = (strokeWidthOffset + pointTo.x - d1.x / 2).toFixed(\n            2\n          );\n          let curveFromY0 = (strokeWidthOffset + pointTo.y - d1.y / 2).toFixed(\n            2\n          );\n          let curveToX0 = (strokeWidthOffset + pointTo.x + d2.x / 2).toFixed(2);\n          let curveToY0 = (strokeWidthOffset + pointTo.y + d2.y / 2).toFixed(2);\n          radiusPoint =\n            \"C\" +\n            curveFromX0 +\n            \" \" +\n            curveFromY0 +\n            \" \" +\n            curveToX0 +\n            \" \" +\n            curveToY0 +\n            \" \" +\n            px0 +\n            \" \" +\n            py0 +\n            \" \";\n        }\n        let px = (strokeWidthOffset + pointTo.x - d1.x).toFixed(2);\n        let py = (strokeWidthOffset + pointTo.y - d1.y).toFixed(2);\n        let curveFromPoint = pointsArray[i].curveFrom;\n        let curveFromX = (strokeWidthOffset + curveFromPoint.x).toFixed(2);\n        let curveFromY = (strokeWidthOffset + curveFromPoint.y).toFixed(2);\n        let curveTo = pointsArray[initialIndex].curveTo;\n        let curveToX = (strokeWidthOffset + curveTo.x).toFixed(2);\n        let curveToY = (strokeWidthOffset + curveTo.y).toFixed(2);\n        if (\n          (pointsArray[initialIndex] && pointsArray[initialIndex].hasCurveTo) ||\n          pointsArray[i].hasCurveFrom\n        ) {\n          generatedPath +=\n            \"C\" +\n            curveFromX +\n            \" \" +\n            curveFromY +\n            \" \" +\n            curveToX +\n            \" \" +\n            curveToY +\n            \" \" +\n            px +\n            \" \" +\n            py +\n            \" \" +\n            (radiusPoint || \"\");\n        } else {\n          generatedPath += \"L\" + px + \" \" + py + \" \" + (radiusPoint || \"\");\n        }\n      }\n    } else {\n      generatedPath += getNextPathPoint(\n        pointsArray,\n        i,\n        strokeWidthOffset,\n        initialIndex,\n        maxRadius\n      );\n    }\n  }\n  if (isClosed) {\n    generatedPath += \"Z\";\n  }\n  // console.log(\"*** generatedPath\", generatedPath);\n  return generatedPath;\n}\n\nfunction getNextPathPoint(\n  pointsArray: Array<Point>,\n  i: number,\n  strokeWidthOffset: number,\n  initialIndex: number,\n  maxRadius: number\n) {\n  if (i + 1 >= pointsArray.length) {\n    return \"\";\n  }\n  let nextPoint = \"\";\n  let pointTo = pointsArray[i + 1].point;\n  let d1: Coordinate = { x: 0, y: 0 };\n  let radiusPoint;\n  if (pointsArray[i].cornerRadius) {\n    d1 = getRadiusAdjustment(pointsArray, i, i + 1, maxRadius);\n    const passedPointIndex = pointsArray[i + 2] ? i + 2 : initialIndex;\n    const d2 = getRadiusAdjustment(\n      pointsArray,\n      i + 1,\n      passedPointIndex,\n      maxRadius\n    );\n    let px0 = (strokeWidthOffset + pointTo.x + d2.x).toFixed(2);\n    let py0 = (strokeWidthOffset + pointTo.y + d2.y).toFixed(2);\n    let curveFromX0 = (strokeWidthOffset + pointTo.x - d1.x / 2).toFixed(2);\n    let curveFromY0 = (strokeWidthOffset + pointTo.y - d1.y / 2).toFixed(2);\n    let curveToX0 = (strokeWidthOffset + pointTo.x + d2.x / 2).toFixed(2);\n    let curveToY0 = (strokeWidthOffset + pointTo.y + d2.y / 2).toFixed(2);\n    radiusPoint =\n      \"C\" +\n      curveFromX0 +\n      \" \" +\n      curveFromY0 +\n      \" \" +\n      curveToX0 +\n      \" \" +\n      curveToY0 +\n      \" \" +\n      px0 +\n      \" \" +\n      py0 +\n      \" \";\n  }\n  let px = (strokeWidthOffset + pointTo.x - d1.x).toFixed(2);\n  let py = (strokeWidthOffset + pointTo.y - d1.y).toFixed(2);\n\n  let curveFromPoint = pointsArray[i].curveFrom;\n  let curveFromX = (strokeWidthOffset + curveFromPoint.x).toFixed(2);\n  let curveFromY = (strokeWidthOffset + curveFromPoint.y).toFixed(2);\n\n  let curveTo = pointsArray[i + 1].curveTo;\n  let curveToX = (strokeWidthOffset + curveTo.x).toFixed(2);\n  let curveToY = (strokeWidthOffset + curveTo.y).toFixed(2);\n  if (\n    (pointsArray[i + 1] && pointsArray[i + 1].hasCurveTo) ||\n    pointsArray[i].hasCurveFrom\n  ) {\n    nextPoint +=\n      \"C\" +\n      curveFromX +\n      \" \" +\n      curveFromY +\n      \" \" +\n      curveToX +\n      \" \" +\n      curveToY +\n      \" \" +\n      px +\n      \" \" +\n      py +\n      \" \" +\n      (radiusPoint || \"\");\n  } else {\n    nextPoint += \"L\" + px + \" \" + py + \" \" + (radiusPoint || \"\");\n  }\n  return nextPoint;\n}\n\nfunction isFillerCondition(point: any): boolean {\n  return (\n    (point.cornerRadius === 777 && point.curveMode === 777) ||\n    (point.cornerRadius === 776 && point.curveMode === 776)\n  );\n}\nfunction isFillerClosed(point: any): boolean {\n  return point.cornerRadius === 776 && point.curveMode === 776;\n}\n","import { isEmpty } from \"lodash\";\n// CAUTION: First read about SVG paths before making any changes in this file.\nexport default function getPointsArrayFromPath(\n  path: string,\n  strokeWidthOffset: number,\n  isClosed: boolean\n) {\n  strokeWidthOffset = strokeWidthOffset <= 1 ? 0 : strokeWidthOffset / 2;\n  let pointsArray: any = [];\n  let pathArray: any = path.split(\"M\"); // stores initial split path string\n  let pathArray2: any = []; // storing each point in this array\n  for (let i = 0; i < pathArray.length; i++) {\n    pathArray2[i] = [];\n    let tempPath = \"\";\n    if (!isEmpty(pathArray)) {\n      for (let j = 0; j < pathArray[i].length; j++) {\n        if (pathArray[i].charAt(j) === \"C\" || pathArray[i].charAt(j) === \"L\") {\n          pathArray2[i].push(tempPath.split(\" \"));\n          tempPath = pathArray[i].charAt(j);\n        } else {\n          tempPath += pathArray[i].charAt(j);\n        }\n      }\n    }\n    if (tempPath !== \"Z\" && tempPath !== \"z\") {\n      pathArray2[i].push(tempPath.split(\" \"));\n    }\n  }\n  for (let i = 1; i < pathArray2.length; i++) {\n    let tempPointsArray = [];\n    for (let j = 0; j < pathArray2[i].length; j++) {\n      if (\n        !isEmpty(pathArray2[i]) &&\n        pathArray2[i][j] &&\n        !isEmpty(pathArray2[i][j]) &&\n        pathArray2[i][j][0]\n      ) {\n        if (\n          pathArray2[i][j].length > 6 ||\n          (pathArray2[i][j].length > 2 && pathArray2[i][j][0].charAt(0) === \"L\")\n        ) {\n          let tempPoint = getPropsOnCondition(\n            pathArray2[i],\n            j,\n            strokeWidthOffset\n          );\n          let obj = createPointObject(\n            0,\n            0,\n            tempPoint.hasCurveFrom,\n            pathArray2[i][j].length > 6,\n            tempPoint.curveFromX,\n            tempPoint.curveFromY,\n            tempPoint.curveToX,\n            tempPoint.curveToY,\n            tempPoint.pointToX,\n            tempPoint.pointToY\n          );\n          if (isClosed && j === pathArray2[i].length - 1) {\n            tempPointsArray.unshift(obj);\n          } else {\n            tempPointsArray.push(obj);\n          }\n        } else {\n          if (i !== 1) {\n            // DOC: checking the previous shape for closed path and adding corresponding filler,\n            // DOC: 776 for closed and 777 for non-closed\n            let filler =\n              pathArray2[i - 1] &&\n              pathArray2[i - 1][pathArray2[i - 1].length - 1].length > 3 &&\n              (pathArray2[i - 1][pathArray2[i - 1].length - 1][\n                pathArray2[i - 1][pathArray2[i - 1].length - 1].length - 2\n              ] === \"Z\" ||\n                pathArray2[i - 1][pathArray2[i - 1].length - 1][\n                  pathArray2[i - 1][pathArray2[i - 1].length - 1].length - 2\n                ] === \"z\")\n                ? 776\n                : 777;\n            pointsArray.push(\n              createPointObject(filler, filler, true, true, 0, 0, 0, 0, 0, 0)\n            );\n          }\n          if (\n            !isClosed &&\n            pathArray2[i][j][0].charAt(0) !== \"C\" &&\n            pathArray2[i][j][0].charAt(0) !== \"L\"\n          ) {\n            let tempPoint = getPropsOnCondition(\n              pathArray2[i],\n              j,\n              strokeWidthOffset\n            );\n            let obj = createPointObject(\n              0,\n              0,\n              tempPoint.hasCurveFrom,\n              pathArray2[i][j].length > 6,\n              tempPoint.curveFromX,\n              tempPoint.curveFromY,\n              tempPoint.curveToX,\n              tempPoint.curveToY,\n              tempPoint.pointToX,\n              tempPoint.pointToY\n            );\n            // console.log(\"*** obj\", obj, isClosed);\n            tempPointsArray.unshift(obj);\n          }\n        }\n      }\n    }\n    pointsArray = pointsArray.concat(tempPointsArray);\n  }\n  return pointsArray;\n}\n\nfunction getPropsOnCondition(\n  pathSubArray: any,\n  j: number,\n  strokeWidthOffset: number\n) {\n  let tempPoint: any = {};\n  let nextIndex = j === pathSubArray.length - 1 ? 1 : j + 1;\n  let hasCurveFrom =\n    !isEmpty(pathSubArray) &&\n    pathSubArray[nextIndex] &&\n    !isEmpty(pathSubArray[nextIndex]) &&\n    pathSubArray[nextIndex][0] &&\n    pathSubArray[nextIndex][0].charAt(0) === \"C\";\n  // DOC: checking whether next point has curve and setting curveFrom point acc. to that only\n  if (\n    !isEmpty(pathSubArray) &&\n    pathSubArray[j] &&\n    !isEmpty(pathSubArray[j]) &&\n    pathSubArray[j][0] &&\n    !isEmpty(pathSubArray[j][0])\n  ) {\n    if (pathSubArray[j][0].charAt(0) === \"C\") {\n      tempPoint.hasCurveFrom = hasCurveFrom;\n      tempPoint.curveFromX =\n        hasCurveFrom &&\n        pathSubArray[nextIndex] &&\n        !isEmpty(pathSubArray[nextIndex])\n          ? pathSubArray[nextIndex][0].substring(1) - strokeWidthOffset\n          : pathSubArray[j][0].substring(1) - strokeWidthOffset;\n      tempPoint.curveFromY =\n        hasCurveFrom &&\n        pathSubArray[nextIndex] &&\n        !isEmpty(pathSubArray[nextIndex])\n          ? pathSubArray[nextIndex][1] - strokeWidthOffset\n          : pathSubArray[j][1] - strokeWidthOffset;\n      tempPoint.curveToX = pathSubArray[j][2] - strokeWidthOffset;\n      tempPoint.curveToY = pathSubArray[j][3] - strokeWidthOffset;\n      tempPoint.pointToX = pathSubArray[j][4] - strokeWidthOffset;\n      tempPoint.pointToY = pathSubArray[j][5] - strokeWidthOffset;\n    } else if (pathSubArray[j][0].charAt(0) === \"L\") {\n      tempPoint.hasCurveFrom = hasCurveFrom;\n      tempPoint.curveFromX =\n        hasCurveFrom &&\n        pathSubArray[nextIndex] &&\n        !isEmpty(pathSubArray[nextIndex])\n          ? pathSubArray[nextIndex][0].substring(1) - strokeWidthOffset\n          : pathSubArray[j][0].substring(1) - strokeWidthOffset;\n      tempPoint.curveFromY =\n        hasCurveFrom &&\n        pathSubArray[nextIndex] &&\n        !isEmpty(pathSubArray[nextIndex])\n          ? pathSubArray[nextIndex][1] - strokeWidthOffset\n          : pathSubArray[j][1] - strokeWidthOffset;\n\n      tempPoint.curveToX = pathSubArray[j][0].substring(1) - strokeWidthOffset;\n      tempPoint.curveToY = pathSubArray[j][1] - strokeWidthOffset;\n\n      tempPoint.pointToX = pathSubArray[j][0].substring(1) - strokeWidthOffset;\n      tempPoint.pointToY = pathSubArray[j][1] - strokeWidthOffset;\n    } else {\n      tempPoint.hasCurveFrom = true;\n      tempPoint.curveFromX =\n        pathSubArray[nextIndex] && !isEmpty(pathSubArray[nextIndex])\n          ? pathSubArray[nextIndex][0].substring(1) - strokeWidthOffset\n          : 0;\n      tempPoint.curveFromY =\n        pathSubArray[nextIndex] && !isEmpty(pathSubArray[nextIndex])\n          ? pathSubArray[nextIndex][1] - strokeWidthOffset\n          : 0;\n      tempPoint.curveToX = pathSubArray[j][0] - strokeWidthOffset;\n      tempPoint.curveToY = pathSubArray[j][1] - strokeWidthOffset;\n      tempPoint.pointToX = pathSubArray[j][0] - strokeWidthOffset;\n      tempPoint.pointToY = pathSubArray[j][1] - strokeWidthOffset;\n    }\n  }\n  return tempPoint;\n}\n\nfunction createPointObject(\n  cornerRadius: number,\n  curveMode: number,\n  hasCurveFrom: boolean,\n  hasCurveTo: boolean,\n  curveFromX: number,\n  curveFromY: number,\n  curveToX: number,\n  curveToY: number,\n  px: number,\n  py: number\n) {\n  return {\n    cornerRadius: cornerRadius,\n    curveMode: curveMode,\n    hasCurveTo: hasCurveTo,\n    hasCurveFrom: hasCurveFrom,\n    curveFrom: {\n      x: curveFromX,\n      y: curveFromY,\n    },\n    curveTo: {\n      x: curveToX,\n      y: curveToY,\n    },\n    point: {\n      x: px,\n      y: py,\n    },\n  };\n}\n"],"names":["document","canvasDOMElement","createElement","style","position","setAttribute","top","left","paper","setup","settings","convertPaperToBx","finalPathPaper","finalPaperPoints","finalPathPaperJson","JSON","parse","segments","concat","getPaperPoints","children","length","k","filler","closed","push","createPointObject","j","point","curveFrom","curveTo","pointObject","constructor","Array","x","y","cornerRadius","curveMode","hasCurveFrom","hasCurveTo","curveFromX","curveFromY","curveToX","curveToY","px","py","getSegmentFromPoints","pointsInPath","pointIndex","handleInPoint","Point","handleOutPoint","handleIn","undefined","handleOut","segment","Segment","radius","Radius","getRadiusAdjustedPoints","pointsArray","viewBox","dims","split","maxRadius","Math","min","newPoints","forEach","oldPoint","i","d","getRadiusAdjustment","Number","nextIndex","nextToNextIndex","d2","getManipulatedPath","layer","paperPath","rotation","rotate","isFlippedHorizontal","isFlippedVertical","scale","isClosed","convertPointsArrayBool","points","frame","referenceFrame","scalingFactor","pointsApplied","slice","unshift","_class","getValidPoints","tempPoint","convertPointBool","tempP1","width","height","parseFloat","toFixed","convertPoint","maskingDisplacement","currentIndex","x0","y0","x1","y1","angle","atan2","cos","sin","getNextPathPoint","strokeWidthOffset","initialIndex","radiusPoint","pointTo","d1","px0","py0","curveFromPoint","isFillerCondition","getPropsOnCondition","pathSubArray","isEmpty","charAt","substring","pointToX","pointToY","layers","firstValidIndex","isVisible","finalPaperPath","Path","index","booleanOperation","unite","subtract","intersect","exclude","exportJSON","error","console","log","generatedPath","xy0","path","pathArray","pathArray2","tempPath","tempPointsArray","obj"],"mappings":"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"}