'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var paper = _interopDefault(require('paper'));
var lodash = require('lodash');

//@ts-ignore

if (typeof document !== "undefined") {
  var canvasDOMElement =
  /*#__PURE__*/
  document.createElement("canvas");
  canvasDOMElement.style.position = "absolute";
  canvasDOMElement.setAttribute("height", "1000px");
  canvasDOMElement.setAttribute("width", "1000px");
  canvasDOMElement.style.top = "0px";
  canvasDOMElement.style.left = "0px";
  paper.setup(canvasDOMElement);
  paper.settings["insertItems"] = false;
} else {
  // @ts-ignore
  paper.setup([640, 480]);
}

function convertPaperPointToBxObj(finalPaperPath) {
  return {
    closed: finalPaperPath.closed,
    points: convertPaperToBx(finalPaperPath.exportJSON())
  };
}
function convertPaperToBx(finalPathPaper) {
  var finalPaperPoints = [];
  var finalPathPaperJson = JSON.parse(finalPathPaper);

  if (finalPathPaperJson[0] !== "CompoundPath" && finalPathPaperJson[1] && finalPathPaperJson[1].segments) {
    finalPaperPoints = finalPaperPoints.concat(getPaperPoints(finalPathPaperJson[1].segments));
  } else if (finalPathPaperJson[1] && finalPathPaperJson[1].children && finalPathPaperJson[1].children.length > 0) {
    for (var k = 0; k < finalPathPaperJson[1].children.length; k++) {
      finalPaperPoints = finalPaperPoints.concat(getPaperPoints(finalPathPaperJson[1].children[k][1].segments)); // Jugaad: using 776 and 777 for closed and no-closed paths

      var filler = finalPathPaperJson[1].children[k][1].closed ? 776 : 777; // Adding Filler Point

      finalPaperPoints.push(createPointObject(filler, filler, false, false, 0, 0, 0, 0, 0, 0));
    }
  }

  return finalPaperPoints;
}

function getPaperPoints(segments) {
  var finalPaperPoints = [];

  for (var j = 0; j < segments.length; j++) {
    var point = {};
    var curveFrom = {};
    var curveTo = {};
    var pointObject = {};

    if (segments[j][0] && segments[j][0].constructor === Array) {
      point.x = segments[j][0][0];
      point.y = segments[j][0][1];
      curveTo.x = segments[j][1][0] + segments[j][0][0];
      curveTo.y = segments[j][1][1] + segments[j][0][1];
      curveFrom.x = segments[j][2][0] + segments[j][0][0];
      curveFrom.y = segments[j][2][1] + segments[j][0][1];
      pointObject = createPointObject(0, 0, true, true, curveFrom.x, curveFrom.y, curveTo.x, curveTo.y, point.x, point.y);
    } else {
      point.x = segments[j][0];
      point.y = segments[j][1];
      pointObject = createPointObject(0, 0, false, false, point.x, point.y, point.x, point.y, point.x, point.y);
    }

    finalPaperPoints.push(pointObject);
  }

  return finalPaperPoints;
}

function createPointObject(cornerRadius, curveMode, hasCurveFrom, hasCurveTo, curveFromX, curveFromY, curveToX, curveToY, px, py) {
  return {
    cornerRadius: cornerRadius,
    curveMode: curveMode,
    hasCurveTo: hasCurveTo,
    hasCurveFrom: hasCurveFrom,
    curveFrom: {
      x: curveFromX,
      y: curveFromY
    },
    curveTo: {
      x: curveToX,
      y: curveToY
    },
    point: {
      x: px,
      y: py
    }
  };
}

//@ts-ignore

if (typeof document !== "undefined") {
  var canvasDOMElement$1 =
  /*#__PURE__*/
  document.createElement("canvas");
  canvasDOMElement$1.style.position = "absolute";
  canvasDOMElement$1.setAttribute("height", "1000px");
  canvasDOMElement$1.setAttribute("width", "1000px");
  canvasDOMElement$1.style.top = "0px";
  canvasDOMElement$1.style.left = "0px";
  paper.setup(canvasDOMElement$1);
  paper.settings["insertItems"] = false;
} else {
  // @ts-ignore
  paper.setup([640, 480]);
}

function getPaperPathFromPoints(pointsInPath, isClosed) {
  var segments = getSegmentFromPoints(pointsInPath);
  var paperPath = new paper.Path(segments);
  paperPath.closed = isClosed;
  return paperPath;
}
function getSegmentFromPoints(pointsInPath) {
  var segments = [];

  for (var pointIndex = 0; pointIndex < pointsInPath.length; pointIndex++) {
    var handleInPoint = new paper.Point(pointsInPath[pointIndex].curveTo.x - pointsInPath[pointIndex].point.x, pointsInPath[pointIndex].curveTo.y - pointsInPath[pointIndex].point.y);
    var handleOutPoint = new paper.Point(pointsInPath[pointIndex].curveFrom.x - pointsInPath[pointIndex].point.x, pointsInPath[pointIndex].curveFrom.y - pointsInPath[pointIndex].point.y);
    var handleIn = pointsInPath[pointIndex].hasCurveFrom ? handleInPoint : undefined;
    var handleOut = pointsInPath[pointIndex].hasCurveTo ? handleOutPoint : undefined;
    var point = new paper.Point(pointsInPath[pointIndex].point.x, pointsInPath[pointIndex].point.y);
    var segment = new paper.Segment({
      point: point,
      handleIn: handleIn,
      handleOut: handleOut,
      radius: pointsInPath[pointIndex].Radius
    });
    segments.push(segment);
  }

  return segments;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function getRadiusAdjustedPoints(pointsArray, viewBox) {
  var dims = viewBox && viewBox.split ? viewBox.split(" ") : [0, 0, 100, 100];
  var maxRadius = Math.min(dims[2] - dims[0], dims[3] - dims[1]) / 2;
  var newPoints = [];
  pointsArray.forEach(function (oldPoint, i) {
    if (oldPoint.cornerRadius) {
      var d = {
        x: 0,
        y: 0
      };
      var point;
      var additionalPoint;

      if (i === 0) {
        d = getRadiusAdjustment(pointsArray, i, i + 1, maxRadius);
        point = {
          x: Number(oldPoint.point.x + d.x),
          y: Number(oldPoint.point.y + d.y)
        };
        newPoints.push(_extends({}, oldPoint, {
          cornerRadius: 0,
          point: point
        }));
      }

      var nextIndex = i === pointsArray.length - 1 ? 0 : i + 1;
      var nextToNextIndex = i === pointsArray.length - 1 ? 1 : pointsArray[i + 2] ? i + 2 : 0;
      d = getRadiusAdjustment(pointsArray, i, nextIndex, maxRadius);
      point = {
        x: Number(pointsArray[nextIndex].point.x - d.x),
        y: Number(pointsArray[nextIndex].point.y - d.y)
      };
      newPoints.push(_extends({}, oldPoint, {
        cornerRadius: 0,
        hasCurveFrom: true,
        curveFrom: point,
        curveTo: point,
        point: point
      }));
      var d2 = getRadiusAdjustment(pointsArray, nextIndex, nextToNextIndex, maxRadius);
      additionalPoint = {
        curveMode: 1,
        hasCurveFrom: true,
        hasCurveTo: true,
        cornerRadius: 0,
        curveFrom: {
          x: pointsArray[nextIndex].point.x + d2.x,
          y: pointsArray[nextIndex].point.y + d2.y
        },
        curveTo: {
          x: pointsArray[nextIndex].point.x,
          y: pointsArray[nextIndex].point.y
        },
        point: {
          x: pointsArray[nextIndex].point.x + d2.x,
          y: pointsArray[nextIndex].point.y + d2.y
        }
      };
      newPoints.push(additionalPoint);
    } else {
      newPoints.push(oldPoint);
    }
  });
  return newPoints;
}

//@ts-ignore

if (typeof document !== "undefined") {
  var canvasDOMElement$2 =
  /*#__PURE__*/
  document.createElement("canvas");
  canvasDOMElement$2.style.position = "absolute";
  canvasDOMElement$2.setAttribute("height", "1000px");
  canvasDOMElement$2.setAttribute("width", "1000px");
  canvasDOMElement$2.style.top = "0px";
  canvasDOMElement$2.style.left = "0px";
  paper.setup(canvasDOMElement$2);
  paper.settings["insertItems"] = false;
} else {
  // @ts-ignore
  paper.setup([640, 480]);
}

function getManipulatedPath(layer, paperPath) {
  // TODO: keep this order, otherwise malfunctions
  // adds roatation
  if (layer.rotation) {
    paperPath.rotate(-layer.rotation);
  } // checks for flip


  if (layer.isFlippedHorizontal || layer.isFlippedVertical) {
    paperPath.scale(layer.isFlippedHorizontal ? -1 : 1, layer.isFlippedVertical ? -1 : 1);
  }

  paperPath.closed = layer.isClosed;
  return paperPath;
}

function applyBooleanOpsOnPaths(layers, frame, scalingFactor, viewBox) {
  if (!layers) {
    return [];
  }

  try {
    // to keep track of hidden layers and exclude them
    var firstValidIndex = 0; // check for first valid index, shapes might be hidden which are not to be counted

    while (firstValidIndex < layers.length - 1) {
      if (layers[firstValidIndex] && layers[firstValidIndex].isVisible) {
        break;
      } else if (firstValidIndex === layers.length - 1 && layers[firstValidIndex] && !layers[firstValidIndex].isVisible) {
        firstValidIndex = -1;
        return [];
      } else {
        firstValidIndex++;
      }
    }

    var zeroPointInPath = getRadiusAdjustedPoints(convertPointsArrayBool(layers[firstValidIndex].points, layers[firstValidIndex].frame, frame, scalingFactor), viewBox);
    var segments = getSegmentFromPoints(zeroPointInPath);
    var finalPaperPath = new paper.Path(segments);
    finalPaperPath = getManipulatedPath(layers[firstValidIndex], finalPaperPath);

    if (firstValidIndex < layers.length - 1) {
      for (var index = firstValidIndex + 1; index < layers.length; index++) {
        if (layers[index].isVisible) {
          var pointsInPath = getRadiusAdjustedPoints(convertPointsArrayBool(layers[index].points, layers[index].frame, frame, scalingFactor), viewBox);
          var paperPath = new paper.Path(getSegmentFromPoints(pointsInPath));
          paperPath = getManipulatedPath(layers[index], paperPath);

          switch (layers[index].booleanOperation) {
            case 0:
              finalPaperPath = finalPaperPath.unite(paperPath);
              break;

            case 1:
              finalPaperPath = finalPaperPath.subtract(paperPath);
              break;

            case 2:
              finalPaperPath = finalPaperPath.intersect(paperPath);
              break;

            default:
              finalPaperPath = finalPaperPath.exclude(paperPath);
              break;
          }
        }
      }
    }

    return finalPaperPath.exportJSON();
  } catch (error) {
    console.log("JSON read error in Boolean Operations", error);
    return []; // throw new Error("JSON read error in Boolean Operations");
  }
}

function convertPointsArrayBool(points, frame, referenceFrame, scalingFactor) {
  var newPoints = [];

  if (points && points.length > 0) {
    var pointsApplied = points[0].point !== points[points.length - 1].point ? points : getValidPoints(points);

    for (var i = 0; i < pointsApplied.length; i++) {
      var tempPoint = {};
      tempPoint.cornerRadius = pointsApplied[i].cornerRadius;
      tempPoint.curveMode = pointsApplied[i].curveMode;
      tempPoint.hasCurveTo = pointsApplied[i].hasCurveTo;
      tempPoint.hasCurveFrom = pointsApplied[i].hasCurveFrom;
      tempPoint.curveFrom = convertPointBool(pointsApplied[i].curveFrom, frame, referenceFrame, scalingFactor);
      tempPoint.curveTo = convertPointBool(pointsApplied[i].curveTo, frame, referenceFrame, scalingFactor);
      tempPoint.point = convertPointBool(pointsApplied[i].point, frame, referenceFrame, scalingFactor);
      newPoints.push(tempPoint);
    }
  }

  return newPoints;
}

function convertPointBool(point, frame, // @ts-ignore
referenceFrame, scalingFactor) {
  var tempP1 = point.split(",");
  var px = tempP1[0].slice(1);
  var py = tempP1[1].slice(0, -1);
  px = (px * frame.width + frame.x) * scalingFactor;
  py = (py * frame.height + frame.y) * scalingFactor;
  return {
    x: parseFloat(px.toFixed(4)),
    y: parseFloat(py.toFixed(4))
  };
} // function to convert Sketch points json to Bx json


function convertPointsArray(points, frame, referenceFrame, maskingDisplacement, scalingFactor) {
  var newPoints = [];

  if (points && points.length > 0) {
    for (var i = 0; i < points.length; i++) {
      var tempPoint = {};
      tempPoint.cornerRadius = points[i].cornerRadius;
      tempPoint.curveMode = points[i].curveMode;
      tempPoint.hasCurveTo = points[i].hasCurveTo;
      tempPoint.hasCurveFrom = points[i].hasCurveFrom;
      tempPoint.curveFrom = convertPoint(points[i].curveFrom, frame, referenceFrame, maskingDisplacement, scalingFactor);
      tempPoint.curveTo = convertPoint(points[i].curveTo, frame, referenceFrame, maskingDisplacement, scalingFactor);
      tempPoint.point = convertPoint(points[i].point, frame, referenceFrame, maskingDisplacement, scalingFactor);
      newPoints.push(tempPoint);
    }
  }

  return newPoints;
}

function convertPoint(point, frame, referenceFrame, maskingDisplacement, scalingFactor) {
  var tempP1 = point.split(",");
  var px = tempP1[0].slice(1);
  var py = tempP1[1].slice(0, -1);
  px = (px * frame.width + maskingDisplacement.x) * frame.width * scalingFactor / referenceFrame.width;
  py = (py * frame.height + maskingDisplacement.y) * frame.height * scalingFactor / referenceFrame.height;
  return {
    x: parseFloat(px.toFixed(4)),
    y: parseFloat(py.toFixed(4))
  };
}

function getValidPoints(points) {
  var newPoints = points.slice(1, points.length - 1);
  var obj = {
    _class: "curvePoint",
    cornerRadius: points[0].cornerRadius,
    curveMode: points[0].curveMode,
    curveTo: points[0].hasCurveTo ? points[0].curveTo : points[points.length - 1].curveTo,
    curveFrom: points[0].hasCurveFrom ? points[0].curveFrom : points[points.length - 1].curveFrom,
    hasCurveFrom: points[0].hasCurveFrom ? true : points[points.length - 1].hasCurveFrom,
    hasCurveTo: points[0].hasCurveTo ? true : points[points.length - 1].hasCurveTo,
    point: points[0].point
  };
  newPoints.unshift(obj);
  return newPoints;
}

function getRadiusAdjustment(pointsArray, currentIndex, nextIndex, maxRadius) {
  if (!pointsArray[currentIndex] || !pointsArray[nextIndex]) {
    return {
      x: 0,
      y: 0
    };
  }

  var radius = maxRadius > pointsArray[currentIndex].cornerRadius ? pointsArray[currentIndex].cornerRadius : maxRadius;
  var x0 = pointsArray[currentIndex].point.x;
  var y0 = pointsArray[currentIndex].point.y;
  var x1 = pointsArray[nextIndex].point.x;
  var y1 = pointsArray[nextIndex].point.y;

  if (x1 === x0 && y1 === y0) {
    return {
      x: 0,
      y: 0
    };
  } else if (x1 === x0) {
    return {
      x: 0,
      y: y1 > y0 ? radius : -radius
    };
  } else {
    var angle = Math.atan2(y1 - y0, x1 - x0);
    return {
      x: Math.cos(angle) * radius,
      y: Math.sin(angle) * radius
    };
  }
}

function generateSVGPath(pointsArray, strokeWidthOffset, isClosed, viewBox) {
  var generatedPath = "";

  if (!pointsArray) {
    return "";
  } // console.log("*** pointsArray", JSON.stringify(pointsArray));


  var dims = viewBox && viewBox.split ? viewBox.split(" ") : [0, 0, 100, 100];
  var maxRadius = Math.min(dims[2] - dims[0], dims[3] - dims[1]) / 2;
  strokeWidthOffset = strokeWidthOffset <= 1 ? 0 : strokeWidthOffset / 2;
  var initialIndex = 0; // Maintains track of each shape start after combining

  var d1 = {
    x: 0,
    y: 0
  }; // Distance with radius

  for (var i = 0; i < pointsArray.length; i++) {
    if (i === initialIndex) {
      // Moving to initial points with "M"
      var xy0 = pointsArray[i].point;

      if (pointsArray[i].cornerRadius) {
        d1 = getRadiusAdjustment(pointsArray, i, i + 1, maxRadius);
      }

      var x0 = (strokeWidthOffset + xy0.x + d1.x).toFixed(2);
      var y0 = (strokeWidthOffset + xy0.y + d1.y).toFixed(2);
      generatedPath += "M" + x0 + " " + y0 + " ";
      generatedPath += getNextPathPoint(pointsArray, i, strokeWidthOffset, initialIndex, maxRadius);
    } else if (isFillerCondition(pointsArray[i])) {
      initialIndex = i + 1;

      if (i !== pointsArray.length - 1 && isFillerClosed(pointsArray[i])) {
        generatedPath += "Z ";
      }
    } else if (i === pointsArray.length - 1 || i !== pointsArray.length - 1 && isFillerCondition(pointsArray[i + 1])) {
      // adding additional point in the end of string
      if (isClosed && pointsArray[i].point.x !== pointsArray[initialIndex].point.x && pointsArray[i].point.y !== pointsArray[initialIndex].point.y) {
        var pointTo = pointsArray[initialIndex].point;
        var radiusPoint = void 0;

        if (pointsArray[i].cornerRadius) {
          d1 = getRadiusAdjustment(pointsArray, i, initialIndex, maxRadius);
          var passedPointIndex = pointsArray[initialIndex + 1] ? initialIndex + 1 : initialIndex;
          var d2 = getRadiusAdjustment(pointsArray, initialIndex, passedPointIndex, maxRadius);
          var px0 = (strokeWidthOffset + pointTo.x + d2.x).toFixed(2);
          var py0 = (strokeWidthOffset + pointTo.y + d2.y).toFixed(2);
          var curveFromX0 = (strokeWidthOffset + pointTo.x - d1.x / 2).toFixed(2);
          var curveFromY0 = (strokeWidthOffset + pointTo.y - d1.y / 2).toFixed(2);
          var curveToX0 = (strokeWidthOffset + pointTo.x + d2.x / 2).toFixed(2);
          var curveToY0 = (strokeWidthOffset + pointTo.y + d2.y / 2).toFixed(2);
          radiusPoint = "C" + curveFromX0 + " " + curveFromY0 + " " + curveToX0 + " " + curveToY0 + " " + px0 + " " + py0 + " ";
        }

        var px = (strokeWidthOffset + pointTo.x - d1.x).toFixed(2);
        var py = (strokeWidthOffset + pointTo.y - d1.y).toFixed(2);
        var curveFromPoint = pointsArray[i].curveFrom;
        var curveFromX = (strokeWidthOffset + curveFromPoint.x).toFixed(2);
        var curveFromY = (strokeWidthOffset + curveFromPoint.y).toFixed(2);
        var curveTo = pointsArray[initialIndex].curveTo;
        var curveToX = (strokeWidthOffset + curveTo.x).toFixed(2);
        var curveToY = (strokeWidthOffset + curveTo.y).toFixed(2);

        if (pointsArray[initialIndex] && pointsArray[initialIndex].hasCurveTo || pointsArray[i].hasCurveFrom) {
          generatedPath += "C" + curveFromX + " " + curveFromY + " " + curveToX + " " + curveToY + " " + px + " " + py + " " + (radiusPoint || "");
        } else {
          generatedPath += "L" + px + " " + py + " " + (radiusPoint || "");
        }
      }
    } else {
      generatedPath += getNextPathPoint(pointsArray, i, strokeWidthOffset, initialIndex, maxRadius);
    }
  }

  if (isClosed) {
    generatedPath += "Z";
  } // console.log("*** generatedPath", generatedPath);


  return generatedPath;
}

function getNextPathPoint(pointsArray, i, strokeWidthOffset, initialIndex, maxRadius) {
  if (i + 1 >= pointsArray.length) {
    return "";
  }

  var nextPoint = "";
  var pointTo = pointsArray[i + 1].point;
  var d1 = {
    x: 0,
    y: 0
  };
  var radiusPoint;

  if (pointsArray[i].cornerRadius) {
    d1 = getRadiusAdjustment(pointsArray, i, i + 1, maxRadius);
    var passedPointIndex = pointsArray[i + 2] ? i + 2 : initialIndex;
    var d2 = getRadiusAdjustment(pointsArray, i + 1, passedPointIndex, maxRadius);
    var px0 = (strokeWidthOffset + pointTo.x + d2.x).toFixed(2);
    var py0 = (strokeWidthOffset + pointTo.y + d2.y).toFixed(2);
    var curveFromX0 = (strokeWidthOffset + pointTo.x - d1.x / 2).toFixed(2);
    var curveFromY0 = (strokeWidthOffset + pointTo.y - d1.y / 2).toFixed(2);
    var curveToX0 = (strokeWidthOffset + pointTo.x + d2.x / 2).toFixed(2);
    var curveToY0 = (strokeWidthOffset + pointTo.y + d2.y / 2).toFixed(2);
    radiusPoint = "C" + curveFromX0 + " " + curveFromY0 + " " + curveToX0 + " " + curveToY0 + " " + px0 + " " + py0 + " ";
  }

  var px = (strokeWidthOffset + pointTo.x - d1.x).toFixed(2);
  var py = (strokeWidthOffset + pointTo.y - d1.y).toFixed(2);
  var curveFromPoint = pointsArray[i].curveFrom;
  var curveFromX = (strokeWidthOffset + curveFromPoint.x).toFixed(2);
  var curveFromY = (strokeWidthOffset + curveFromPoint.y).toFixed(2);
  var curveTo = pointsArray[i + 1].curveTo;
  var curveToX = (strokeWidthOffset + curveTo.x).toFixed(2);
  var curveToY = (strokeWidthOffset + curveTo.y).toFixed(2);

  if (pointsArray[i + 1] && pointsArray[i + 1].hasCurveTo || pointsArray[i].hasCurveFrom) {
    nextPoint += "C" + curveFromX + " " + curveFromY + " " + curveToX + " " + curveToY + " " + px + " " + py + " " + (radiusPoint || "");
  } else {
    nextPoint += "L" + px + " " + py + " " + (radiusPoint || "");
  }

  return nextPoint;
}

function isFillerCondition(point) {
  return point.cornerRadius === 777 && point.curveMode === 777 || point.cornerRadius === 776 && point.curveMode === 776;
}

function isFillerClosed(point) {
  return point.cornerRadius === 776 && point.curveMode === 776;
}

function getPointsArrayFromPath(path, strokeWidthOffset, isClosed) {
  strokeWidthOffset = strokeWidthOffset <= 1 ? 0 : strokeWidthOffset / 2;
  var pointsArray = [];
  var pathArray = path.split("M"); // stores initial split path string

  var pathArray2 = []; // storing each point in this array

  for (var i = 0; i < pathArray.length; i++) {
    pathArray2[i] = [];
    var tempPath = "";

    if (!lodash.isEmpty(pathArray)) {
      for (var j = 0; j < pathArray[i].length; j++) {
        if (pathArray[i].charAt(j) === "C" || pathArray[i].charAt(j) === "L") {
          pathArray2[i].push(tempPath.split(" "));
          tempPath = pathArray[i].charAt(j);
        } else {
          tempPath += pathArray[i].charAt(j);
        }
      }
    }

    if (tempPath !== "Z" && tempPath !== "z") {
      pathArray2[i].push(tempPath.split(" "));
    }
  }

  for (var _i = 1; _i < pathArray2.length; _i++) {
    var tempPointsArray = [];

    for (var _j = 0; _j < pathArray2[_i].length; _j++) {
      if (!lodash.isEmpty(pathArray2[_i]) && pathArray2[_i][_j] && !lodash.isEmpty(pathArray2[_i][_j]) && pathArray2[_i][_j][0]) {
        if (pathArray2[_i][_j].length > 6 || pathArray2[_i][_j].length > 2 && pathArray2[_i][_j][0].charAt(0) === "L") {
          var tempPoint = getPropsOnCondition(pathArray2[_i], _j, strokeWidthOffset);
          var obj = createPointObject$1(0, 0, tempPoint.hasCurveFrom, pathArray2[_i][_j].length > 6, tempPoint.curveFromX, tempPoint.curveFromY, tempPoint.curveToX, tempPoint.curveToY, tempPoint.pointToX, tempPoint.pointToY);

          if (isClosed && _j === pathArray2[_i].length - 1) {
            tempPointsArray.unshift(obj);
          } else {
            tempPointsArray.push(obj);
          }
        } else {
          if (_i !== 1) {
            // DOC: checking the previous shape for closed path and adding corresponding filler,
            // DOC: 776 for closed and 777 for non-closed
            var filler = pathArray2[_i - 1] && pathArray2[_i - 1][pathArray2[_i - 1].length - 1].length > 3 && (pathArray2[_i - 1][pathArray2[_i - 1].length - 1][pathArray2[_i - 1][pathArray2[_i - 1].length - 1].length - 2] === "Z" || pathArray2[_i - 1][pathArray2[_i - 1].length - 1][pathArray2[_i - 1][pathArray2[_i - 1].length - 1].length - 2] === "z") ? 776 : 777;
            pointsArray.push(createPointObject$1(filler, filler, true, true, 0, 0, 0, 0, 0, 0));
          }

          if (!isClosed && pathArray2[_i][_j][0].charAt(0) !== "C" && pathArray2[_i][_j][0].charAt(0) !== "L") {
            var _tempPoint = getPropsOnCondition(pathArray2[_i], _j, strokeWidthOffset);

            var _obj = createPointObject$1(0, 0, _tempPoint.hasCurveFrom, pathArray2[_i][_j].length > 6, _tempPoint.curveFromX, _tempPoint.curveFromY, _tempPoint.curveToX, _tempPoint.curveToY, _tempPoint.pointToX, _tempPoint.pointToY); // console.log("*** obj", obj, isClosed);


            tempPointsArray.unshift(_obj);
          }
        }
      }
    }

    pointsArray = pointsArray.concat(tempPointsArray);
  }

  return pointsArray;
}

function getPropsOnCondition(pathSubArray, j, strokeWidthOffset) {
  var tempPoint = {};
  var nextIndex = j === pathSubArray.length - 1 ? 1 : j + 1;
  var hasCurveFrom = !lodash.isEmpty(pathSubArray) && pathSubArray[nextIndex] && !lodash.isEmpty(pathSubArray[nextIndex]) && pathSubArray[nextIndex][0] && pathSubArray[nextIndex][0].charAt(0) === "C"; // DOC: checking whether next point has curve and setting curveFrom point acc. to that only

  if (!lodash.isEmpty(pathSubArray) && pathSubArray[j] && !lodash.isEmpty(pathSubArray[j]) && pathSubArray[j][0] && !lodash.isEmpty(pathSubArray[j][0])) {
    if (pathSubArray[j][0].charAt(0) === "C") {
      tempPoint.hasCurveFrom = hasCurveFrom;
      tempPoint.curveFromX = hasCurveFrom && pathSubArray[nextIndex] && !lodash.isEmpty(pathSubArray[nextIndex]) ? pathSubArray[nextIndex][0].substring(1) - strokeWidthOffset : pathSubArray[j][0].substring(1) - strokeWidthOffset;
      tempPoint.curveFromY = hasCurveFrom && pathSubArray[nextIndex] && !lodash.isEmpty(pathSubArray[nextIndex]) ? pathSubArray[nextIndex][1] - strokeWidthOffset : pathSubArray[j][1] - strokeWidthOffset;
      tempPoint.curveToX = pathSubArray[j][2] - strokeWidthOffset;
      tempPoint.curveToY = pathSubArray[j][3] - strokeWidthOffset;
      tempPoint.pointToX = pathSubArray[j][4] - strokeWidthOffset;
      tempPoint.pointToY = pathSubArray[j][5] - strokeWidthOffset;
    } else if (pathSubArray[j][0].charAt(0) === "L") {
      tempPoint.hasCurveFrom = hasCurveFrom;
      tempPoint.curveFromX = hasCurveFrom && pathSubArray[nextIndex] && !lodash.isEmpty(pathSubArray[nextIndex]) ? pathSubArray[nextIndex][0].substring(1) - strokeWidthOffset : pathSubArray[j][0].substring(1) - strokeWidthOffset;
      tempPoint.curveFromY = hasCurveFrom && pathSubArray[nextIndex] && !lodash.isEmpty(pathSubArray[nextIndex]) ? pathSubArray[nextIndex][1] - strokeWidthOffset : pathSubArray[j][1] - strokeWidthOffset;
      tempPoint.curveToX = pathSubArray[j][0].substring(1) - strokeWidthOffset;
      tempPoint.curveToY = pathSubArray[j][1] - strokeWidthOffset;
      tempPoint.pointToX = pathSubArray[j][0].substring(1) - strokeWidthOffset;
      tempPoint.pointToY = pathSubArray[j][1] - strokeWidthOffset;
    } else {
      tempPoint.hasCurveFrom = true;
      tempPoint.curveFromX = pathSubArray[nextIndex] && !lodash.isEmpty(pathSubArray[nextIndex]) ? pathSubArray[nextIndex][0].substring(1) - strokeWidthOffset : 0;
      tempPoint.curveFromY = pathSubArray[nextIndex] && !lodash.isEmpty(pathSubArray[nextIndex]) ? pathSubArray[nextIndex][1] - strokeWidthOffset : 0;
      tempPoint.curveToX = pathSubArray[j][0] - strokeWidthOffset;
      tempPoint.curveToY = pathSubArray[j][1] - strokeWidthOffset;
      tempPoint.pointToX = pathSubArray[j][0] - strokeWidthOffset;
      tempPoint.pointToY = pathSubArray[j][1] - strokeWidthOffset;
    }
  }

  return tempPoint;
}

function createPointObject$1(cornerRadius, curveMode, hasCurveFrom, hasCurveTo, curveFromX, curveFromY, curveToX, curveToY, px, py) {
  return {
    cornerRadius: cornerRadius,
    curveMode: curveMode,
    hasCurveTo: hasCurveTo,
    hasCurveFrom: hasCurveFrom,
    curveFrom: {
      x: curveFromX,
      y: curveFromY
    },
    curveTo: {
      x: curveToX,
      y: curveToY
    },
    point: {
      x: px,
      y: py
    }
  };
}

exports.applyBooleanOpsOnPaths = applyBooleanOpsOnPaths;
exports.convertPaperPointToBxObj = convertPaperPointToBxObj;
exports.convertPaperToBx = convertPaperToBx;
exports.convertPointsArray = convertPointsArray;
exports.generateSVGPath = generateSVGPath;
exports.getPaperPathFromPoints = getPaperPathFromPoints;
exports.getPointsArrayFromPath = getPointsArrayFromPath;
exports.getRadiusAdjustedPoints = getRadiusAdjustedPoints;
exports.getSegmentFromPoints = getSegmentFromPoints;
//# sourceMappingURL=conversions.cjs.development.js.map
