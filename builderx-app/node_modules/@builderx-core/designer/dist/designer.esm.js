import { createElement, PureComponent, Children, cloneElement, Component, forwardRef } from 'react';
import ReactDOM__default, { findDOMNode, render } from 'react-dom';
import { Collisions } from 'detect-collisions';
import Scrollbars from 'react-custom-scrollbars';
import { forEach, isArray, omitBy, isNil, uniq, reduce, union, remove, map as map$1, reverse, set, get, last, findIndex, orderBy, keys, isEmpty, minBy, maxBy, isFunction, pick, find, round, intersection, indexOf, filter, findLast, cloneDeep, sortBy, isEqual } from 'lodash-es';
import { yoga } from '@builderx-core/yogax';
import { v4 } from 'uuid';
import { findNodeHandle, View, Text, TextInput, Image as Image$1, Switch, ActivityIndicator } from 'react-native-web';
import includes from 'lodash-es/includes';
import replace from 'lodash-es/replace';
import Svg, { Defs, Mask, Path, Image, LinearGradient, Stop, Ellipse } from 'svgs';
import { generateSVGPath, convertPaperPointToBxObj, getPaperPathFromPoints } from '@builderx-core/conversions';
import EntypoIcon from 'react-native-vector-icons/dist/Entypo';
import AntDesignIcon from 'react-native-vector-icons/dist/AntDesign';
import EvilIconsIcon from 'react-native-vector-icons/dist/EvilIcons';
import FeatherIcon from 'react-native-vector-icons/dist/Feather';
import FontAwesomeIcon from 'react-native-vector-icons/dist/FontAwesome';
import FoundationIcon from 'react-native-vector-icons/dist/Foundation';
import IoniconsIcon from 'react-native-vector-icons/dist/Ionicons';
import MaterialCommunityIconsIcon from 'react-native-vector-icons/dist/MaterialCommunityIcons';
import MaterialIconsIcon from 'react-native-vector-icons/dist/MaterialIcons';
import OcticonsIcon from 'react-native-vector-icons/dist/Octicons';
import SimpleLineIconsIcon from 'react-native-vector-icons/dist/SimpleLineIcons';
import ZocialIcon from 'react-native-vector-icons/dist/Zocial';
import EntypoFont from 'react-native-vector-icons/Fonts/Entypo.ttf';
import AntDesignFont from 'react-native-vector-icons/Fonts/AntDesign.ttf';
import EvilIconsFont from 'react-native-vector-icons/Fonts/EvilIcons.ttf';
import FeatherFont from 'react-native-vector-icons/Fonts/Feather.ttf';
import FontAwesomeFont from 'react-native-vector-icons/Fonts/FontAwesome.ttf';
import FoundationFont from 'react-native-vector-icons/Fonts/Foundation.ttf';
import IoniconsFont from 'react-native-vector-icons/Fonts/Ionicons.ttf';
import MaterialCommunityIconsFont from 'react-native-vector-icons/Fonts/MaterialCommunityIcons.ttf';
import MaterialIconsFont from 'react-native-vector-icons/Fonts/MaterialIcons.ttf';
import OcticonsFont from 'react-native-vector-icons/Fonts/Octicons.ttf';
import SimpleLineIconsFont from 'react-native-vector-icons/Fonts/SimpleLineIcons.ttf';
import ZocialFont from 'react-native-vector-icons/Fonts/Zocial.ttf';
import styled, { keyframes } from 'styled-components';
import get$1 from 'lodash-es/get';
import { MainMenu, contextMenu } from 'builderx-module-context-menu';
import 'builderx-module-context-menu/src/lib/components/utils/ContextMenu.css';
import { Modifier, EditorState, getDefaultKeyBinding, ContentState, Editor } from 'draft-js';
import paper from 'paper';
import LineSegmentSliderInput from 'line-segment-slider-input';

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _taggedTemplateLiteralLoose(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }

  strings.raw = raw;
  return strings;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

var RootRenderer = /*#__PURE__*/function (_React$PureComponent) {
  _inheritsLoose(RootRenderer, _React$PureComponent);

  function RootRenderer() {
    var _this;

    _this = _React$PureComponent.apply(this, arguments) || this;

    _this.onUpdate = function () {
      _this.forceUpdate();
    };

    return _this;
  }

  var _proto = RootRenderer.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.props.layer.on(['type'], this.onUpdate);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.layer.off(['type'], this.onUpdate);
  };

  _proto.render = function render() {
    var layer = this.props.layer;
    var TheChosenOne = this.props.canvas.getRenderer(layer.type);
    return createElement(TheChosenOne, {
      RootRenderer: RootRenderer,
      layer: layer,
      canvas: this.props.canvas
    });
  };

  return RootRenderer;
}(PureComponent);

var ScrollContainer = /*#__PURE__*/function (_React$PureComponent) {
  _inheritsLoose(ScrollContainer, _React$PureComponent);

  function ScrollContainer(props) {
    var _this;

    _this = _React$PureComponent.call(this, props) || this;

    _this.onUpdate = function () {
      var viewport = _this.props.canvas.getViewport();

      _this.viewportState = {
        height: viewport.height,
        width: viewport.width
      };
      _this.baseState = {
        height: _this.props.canvas.layout.get('height'),
        width: _this.props.canvas.layout.get('width')
      };

      _this.forceUpdate();

      _this.centerScrollTo();
    };

    _this.setScroll = function (scroll) {
      _this.state.scroll.x = scroll.scrollX;
      _this.state.scroll.y = scroll.scrollY;
      var scrollX = _this.state.scroll.x * (_this.baseState.width * _this.zoom - _this.viewportState.width);
      var scrollY = _this.state.scroll.y * (_this.baseState.height * _this.zoom - _this.viewportState.height);
      var centerX = (scrollX + _this.viewportState.width / 2) / (_this.baseState.width * _this.zoom);
      var centerY = (scrollY + _this.viewportState.height / 2) / (_this.baseState.height * _this.zoom);
      _this.center = {
        x: centerX,
        y: centerY
      };

      _this.centerScrollTo();
    };

    _this.centerScrollTo = function (emit) {

      var centerX = _this.center.x * (_this.baseState.width * _this.zoom);
      var centerY = _this.center.y * (_this.baseState.height * _this.zoom);
      var scrollY = centerY - _this.viewportState.height / 2;
      var scrollX = centerX - _this.viewportState.width / 2;

      if (_this.scrollContainerRef) {
        _this.scrollContainerRef.scrollLeft(scrollX);

        _this.scrollContainerRef.scrollTop(scrollY);
      }
    };

    _this.onScrollFrame = function (values) {
      if (_this.scrollContainerRef) {
        if (_this.viewportState.height > 0 && _this.viewportState.width > 0) {
          var x = values.scrollLeft / (_this.baseState.width * _this.zoom - _this.viewportState.width);
          var y = values.scrollTop / (_this.baseState.height * _this.zoom - _this.viewportState.height);
          var centerX = (values.scrollLeft + _this.viewportState.width / 2) / (_this.baseState.width * _this.zoom);
          var centerY = (values.scrollTop + _this.viewportState.height / 2) / (_this.baseState.height * _this.zoom);
          _this.center = {
            x: centerX,
            y: centerY
          };
          _this.state.scroll.x = isNaN(x) ? 0 : x;
          _this.state.scroll.y = isNaN(y) ? 0 : y;

          _this.centerScrollTo();

          _this.props.canvas.setScroll(_this.state.scroll);
        }
      }
    };

    _this.moveWithGrabHandle = function (event) {
      if (_this.props.canvas.isMouseDown && _this.props.canvas.moveWithGrabHandle) {
        // window.requestAnimationFrame(() => {
        if (_this.scrollContainerRef) {
          var deltaX = event.nativeEvent.movementX,
              deltaY = event.nativeEvent.movementY,
              currentScrollX = _this.scrollContainerRef.getScrollLeft(),
              currentScrollY = _this.scrollContainerRef.getScrollTop();

          _this.scrollContainerRef.scrollLeft(currentScrollX - deltaX);

          _this.scrollContainerRef.scrollTop(currentScrollY - deltaY);

          event.stopPropagation();
        } // });

      }
    };

    _this.zoom = props.canvas.getZoom();
    _this.scroll = props.canvas.getScroll();
    var scrollFactor = {
      x: 0.5,
      y: 0.5
    };
    var scrollXFactor = scrollFactor.x;
    var scrollYFactor = scrollFactor.y;
    _this.state = {
      scroll: {
        x: scrollXFactor,
        y: scrollYFactor
      }
    };
    return _this;
  }

  var _proto = ScrollContainer.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;

    if (this.scrollContainerRef) {
      this.scrollDom = findDOMNode(this.scrollContainerRef);
    }

    document.addEventListener('keydown', function (e) {
      if (e.keyCode === 32 && e.target === document.body) {
        e.preventDefault();
      }
    });
    this.setCenterPosition();
    this.getCenterPointInCurrentViewport();
    this.centerScrollTo();
    this.props.canvas.addEventListener('setScroll', this.setScroll);
    this.props.canvas.on('zoom', function (e) {
      if (_this2.zoom !== _this2.props.canvas.getZoom()) {
        _this2.zoom = _this2.props.canvas.getZoom();

        _this2.centerScrollTo();
      }
    });
    this.props.canvas.on(['viewport', 'layout', 'mouseCursorType'], this.onUpdate);
    this.props.canvas.on(['moveWithGrabHandle'], this.onUpdate);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.canvas.off(['viewport', 'layout', 'mouseCursorType'], this.onUpdate);
    this.props.canvas.off(['moveWithGrabHandle'], this.onUpdate);
    this.props.canvas.removeEventListener('setScroll', this.setScroll);
  };

  _proto.getScrollPositon = function getScrollPositon(inputScroll) {
    var props = this.props;
    var scroll = inputScroll ? inputScroll : this.scroll;
    var scrollX = scroll.x * (this.baseState.width * this.zoom - this.viewportState.width);
    var scrollY = scroll.y * (this.baseState.height * this.zoom - this.viewportState.height);
    return {
      x: scrollX,
      y: scrollY
    };
  };

  _proto.getCenterPointInCurrentViewport = function getCenterPointInCurrentViewport() {
    var props = this.props;
    var scrollPostion = this.getScrollPositon();
    var centerX = (scrollPostion.x + this.viewportState.width / 2) / (this.baseState.width * this.zoom);
    var centerY = (scrollPostion.y + this.viewportState.height / 2) / (this.baseState.height * this.zoom);
    this.center = {
      x: centerX,
      y: centerY
    };
  };

  _proto.setCenterPosition = function setCenterPosition() {
    this.center = {
      x: (this.state.scroll.x + this.viewportState.width / (this.baseState.width * this.zoom)) / 2,
      y: (this.state.scroll.y + this.viewportState.height / (this.baseState.height * this.zoom)) / 2
    };
  };

  _proto.render = function render() {
    var _this3 = this;

    var spaceKey = this.props.canvas.moveWithGrabHandle;
    this.baseState = {
      height: this.props.canvas.layout.get('height'),
      width: this.props.canvas.layout.get('width')
    };
    var viewport = this.props.canvas.getViewport();
    this.viewportState = {
      height: viewport.height,
      width: viewport.width
    };
    return createElement(Scrollbars, {
      ref: function ref(c) {
        _this3.scrollContainerRef = c;
      },
      autoHide: true,
      onScrollFrame: this.onScrollFrame,
      style: _extends({}, this.props.style, {
        width: this.viewportState.width,
        height: this.viewportState.height,
        cursor: this.props.canvas.mouseCursorType ? this.props.canvas.mouseCursorType : 'initial',
        overflow: 'scroll'
      }),
      onMouseDown: function onMouseDown(e) {
        // @ts-ignore
        if (e.button !== 2 && e.which !== 3) {
          // this.mouseDown = true;
          _this3.props.canvas.setMouseDown(true);
        }
      },
      onMouseUp: function onMouseUp() {
        // this.mouseDown = false;
        _this3.props.canvas.setMouseDown(false);
      },
      onMouseLeave: function onMouseLeave() {
        // this.mouseDown = false;
        _this3.props.canvas.setMouseDown(false);
      },
      onMouseMove: this.moveWithGrabHandle,
      className: "scrollcontainer"
    }, Children.map(this.props.children, function (child) {
      if (child) {
        return cloneElement(child, _extends({}, child.props, {
          style: _extends({}, child.props.style, spaceKey && _this3.props.canvas.isMouseDown ? {
            pointerEvents: 'none'
          } : {})
        }));
      }

      return null;
    }));
  };

  return ScrollContainer;
}(PureComponent);

var ZoomContainer =
/*#__PURE__*/

/** @class */
function () {
  var ZoomContainer = /*#__PURE__*/function (_React$Component) {
    _inheritsLoose(ZoomContainer, _React$Component);

    function ZoomContainer(props) {
      var _this;

      _this = _React$Component.call(this, props) || this;

      _this.onUpdateZoom = function (event) {
        _this.zoom = event.zoom;

        _this.forceUpdate();
      };

      _this.onUpdate = function () {
        _this.forceUpdate();
      };

      _this.zoom = props.canvas.getZoom();
      var scrollFactor = props.initialScroll === undefined ? ZoomContainer.defaultProps.initialScroll : props.initialScroll;
      var scrollXFactor = scrollFactor.x;
      var scrollYFactor = scrollFactor.y;
      _this.state = {
        scroll: {
          x: scrollXFactor,
          y: scrollYFactor
        }
      };
      return _this;
    }

    var _proto = ZoomContainer.prototype;

    _proto.componentDidMount = function componentDidMount() {
      document.addEventListener('keydown', function (e) {
        if (e.keyCode === 32 && e.target === document.body) {
          e.preventDefault();
        }
      });
      this.props.canvas.addEventListener('setZoom', this.onUpdateZoom);
      this.props.canvas.on('children', this.onUpdate);
    };

    _proto.shouldComponentUpdate = function shouldComponentUpdate() {
      return false;
    };

    _proto.componentDidUpdate = function componentDidUpdate() {
      this.props.canvas.setZoom(this.zoom);
    };

    _proto.componentWillMount = function componentWillMount() {
      this.props.canvas.removeEventListener('setZoom', this.onUpdateZoom); // this.props.canvas.off('children', this.onUpdate);
    };

    _proto.getSceneStyle = function getSceneStyle() {
      var style = {
        position: 'absolute'
      };
      style.transform = "scale(" + this.zoom + ")"; // style.zoom = this.zoom;

      style.transformOrigin = '0 0';
      return style;
    };

    _proto.render = function render() {
      var _this2 = this;

      var _this$props = this.props,
          initialScroll = _this$props.initialScroll,
          props = _objectWithoutPropertiesLoose(_this$props, ["initialScroll"]); // console.log(this.zoom, '#####');


      return createElement("div", {
        ref: function ref(c) {
          _this2.containerRef = c;
        },
        onClick: function onClick(e) {},
        style: this.getSceneStyle(),
        className: "zoomContainer"
      }, Children.map(this.props.children, function (child) {
        if (child) {
          return cloneElement(child, _extends({}, child.props, {
            style: _extends({}, child.props.style)
          }));
        }

        return null;
      }));
    };

    return ZoomContainer;
  }(Component);

  ZoomContainer.defaultProps = {
    initialScroll: {
      x: 0,
      y: 0
    }
  };
  return ZoomContainer;
}();

var CanvasRenderer = /*#__PURE__*/function (_React$PureComponent) {
  _inheritsLoose(CanvasRenderer, _React$PureComponent);

  function CanvasRenderer() {
    var _this;

    _this = _React$PureComponent.apply(this, arguments) || this;

    _this.onUpdate = function (keys) {
      _this.forceUpdate();
    };

    return _this;
  }

  var _proto = CanvasRenderer.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.props.canvas.on(['zoom', 'viewport', 'layout'], this.onUpdate);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.canvas.off(['zoom', 'viewport', 'layout'], this.onUpdate);
  };

  _proto.render = function render() {
    var _this2 = this;

    var baseHeight = this.props.canvas.layout.get('height');
    var baseWidth = this.props.canvas.layout.get('width');
    return createElement("div", {
      style: {
        position: 'relative',
        width: baseWidth,
        height: baseHeight,
        backgroundColor: this.props.canvas.style.get('backgroundColor')
      }
    }, this.props.canvas.children.map(function (child, index) {
      return createElement(RootRenderer, {
        layer: child,
        key: index,
        canvas: _this2.props.canvas
      });
    }));
  };

  return CanvasRenderer;
}(PureComponent);

var DesignerReact = /*#__PURE__*/function (_React$PureComponent2) {
  _inheritsLoose(DesignerReact, _React$PureComponent2);

  function DesignerReact() {
    var _this3;

    _this3 = _React$PureComponent2.apply(this, arguments) || this;
    _this3.thisNode = null;

    _this3.onUpdate = function (keys) {
      _this3.forceUpdate();
    };

    _this3.showConstructionLines = function () {
      var canvasDOMElement = document.createElement('canvas');
      canvasDOMElement.setAttribute('height', '2000px');
      canvasDOMElement.setAttribute('width', '2000px');
      canvasDOMElement.setAttribute('class', 'canvas-element');
      canvasDOMElement.style.position = 'absolute';
      canvasDOMElement.style.top = '0px';
      canvasDOMElement.style.left = '0px';
      canvasDOMElement.style.opacity = '1';
      canvasDOMElement.style.pointerEvents = 'none';

      if (_this3.renderCompiledDom) {
        var pane = findDOMNode(_this3.renderCompiledDom);
        var context = canvasDOMElement.getContext('2d');
        var collisionScope = _this3.props.canvas.collisionScope;

        if (pane && context && collisionScope) {
          context.strokeStyle = '#000';
          context.beginPath();
          collisionScope.drawBVH(context);
          context.stroke();
          pane.appendChild(canvasDOMElement);
        }
      }
    };

    _this3.renderDOMStack = function () {
      if (_this3.worldStackRef) {
        while (_this3.worldStackRef.firstChild) {
          _this3.worldStackRef.removeChild(_this3.worldStackRef.firstChild);
        }

        _this3.props.canvas.stackWorldDOM.forEach(function (element) {
          _this3.worldStackRef.appendChild(element);
        });
      }

      if (_this3.viewportStackRef) {
        while (_this3.viewportStackRef.firstChild) {
          _this3.viewportStackRef.removeChild(_this3.viewportStackRef.firstChild);
        }

        _this3.props.canvas.stackViewportDOM.forEach(function (element) {
          _this3.viewportStackRef.appendChild(element);
        });
      }
    };

    _this3.onMouseDown = function (e) {
      if (_this3.thisNode && _this3.thisNode.ownerDocument) {
        _this3.thisNode.ownerDocument.addEventListener('mousemove', _this3.onMouseMove);

        _this3.thisNode.ownerDocument.addEventListener('mouseup', _this3.onMouseUp);

        _this3.thisNode.ownerDocument.addEventListener('contextmenu', _this3.onMouseUp);
      }

      _this3.props.canvas.handleNativeEvent(e);
    };

    _this3.onMouseMove = function (e) {
      // if (!this.props.canvas.dragging) {
      _this3.props.canvas.handleNativeEvent(e); // }

    };

    _this3.onMouseUp = function (e) {
      if (_this3.thisNode && _this3.thisNode.ownerDocument) {
        _this3.thisNode.ownerDocument.removeEventListener('mousemove', _this3.onMouseMove);

        _this3.thisNode.ownerDocument.removeEventListener('mouseup', _this3.onMouseUp);

        _this3.thisNode.ownerDocument.removeEventListener('contextmenu', _this3.onMouseUp);
      }

      _this3.props.canvas.handleNativeEvent(e);
    };

    return _this3;
  }

  var _proto2 = DesignerReact.prototype;

  _proto2.componentDidMount = function componentDidMount() {
    this.renderDOMStack();
    this.props.canvas.on(['zoom', 'viewport', 'layout'], this.onUpdate);
    this.props.canvas.on(['stackWorldDOM', 'stackViewportDOM'], this.renderDOMStack);
  };

  _proto2.componentWillUnmount = function componentWillUnmount() {
    this.props.canvas.off(['zoom', 'viewport', 'layout'], this.onUpdate);
    this.props.canvas.off(['stackWorldDOM', 'stackViewportDOM'], this.renderDOMStack);
  };

  _proto2.render = function render() {
    var _this4 = this;

    var canvas = this.props.canvas;
    var zoom = canvas.getZoom();
    var baseHeight = canvas.layout.get('height');
    var baseWidth = canvas.layout.get('width');
    var viewport = canvas.getViewport();
    var viewportHeight = viewport.height;
    var viewportWidth = viewport.width; // const cursor = canvas.mouseCursorType;

    return createElement("div", {
      style: {
        position: 'absolute'
      },
      ref: function ref(r) {
        return _this4.thisNode = r;
      }
    }, createElement(ScrollContainer, {
      canvas: canvas,
      ref: function ref(c) {
        _this4.props.canvas.setViewportRef(c);
      }
    }, createElement(ZoomContainer, {
      canvas: canvas,
      style: {
        height: baseHeight * zoom,
        width: baseWidth * zoom
      }
    }, createElement(CanvasRenderer, {
      canvas: this.props.canvas
    }), createElement("div", {
      style: {
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      }
    }, createElement("div", {
      style: {
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      },
      // onMouseMove={this.onMouseMove}
      onMouseDown: this.onMouseDown,
      onMouseEnter: function onMouseEnter(e) {
        return canvas.handleNativeEvent(e);
      },
      onMouseMove: function onMouseMove(e) {
        return canvas.handleNativeEvent(e);
      },
      onClick: function onClick(e) {
        return canvas.handleNativeEvent(e);
      },
      onContextMenu: function onContextMenu(e) {
        return canvas.handleNativeEvent(e);
      },
      onDoubleClick: function onDoubleClick(e) {
        return canvas.handleNativeEvent(e);
      },
      onMouseOut: function onMouseOut(e) {
        return canvas.handleNativeEvent(e);
      },
      onDrop: function onDrop(e) {
        return canvas.handleNativeEvent(e);
      },
      onDragOver: function onDragOver(e) {
        return e.preventDefault();
      }
    }), createElement("div", {
      ref: function ref(_ref) {
        if (_this4.worldStackRef && !_ref) {
          // THis means worldStackRef is being set null while it was set correctly earlier
          // We are preventing that here. Don't know the root cause
          return;
        }

        _this4.worldStackRef = _ref;
      },
      style: {
        position: 'absolute',
        pointerEvents: 'none',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      }
    })))), createElement("div", {
      style: {
        position: 'absolute',
        top: 0,
        left: 0,
        height: viewportHeight,
        width: viewportWidth,
        pointerEvents: 'none',
        overflow: 'hidden'
      },
      ref: function ref(_ref2) {
        return _this4.viewportStackRef = _ref2;
      }
    }));
  };

  return DesignerReact;
}(PureComponent);

var Serializable =
/*#__PURE__*/

/** @class */
function () {
  var Serializable = /*#__PURE__*/function () {
    function Serializable() {}

    Serializable.fromJS = function fromJS(snapshot, classObject) {
      var _this = this;

      if (classObject === void 0) {
        classObject = undefined;
      }

      if (!snapshot) {
        return;
      }

      var classInstance = undefined;

      if (classObject) {
        classInstance = new classObject();
      } else {
        classInstance = new this();
      } // const fields: any = classInstance.getFields();


      var fields = Serializable.getAllFields(classInstance);

      forEach(Object.keys(snapshot), function (key) {
        var field = fields[key];

        if (!field) {
          // console.log(fields, "fields");
          console.warn("property " + key + " is not declared in fields of " + classInstance.constructor.name + " ");
          return;
        }

        if (field.type === 'ignore') {
          return;
        }

        if (isNil(snapshot[key])) {
          classInstance[key] = snapshot[key];
        } else if (field.type === 'literal') {
          classInstance[key] = snapshot[key];
        } else if (field.type === 'array') {
          if (isArray(snapshot[key])) {
            classInstance[key] = [];

            forEach(snapshot[key], function (element) {
              if (isArray(element) && field.children.type === 'array') {
                console.log('case not handled -!-!- toJS Serializable');
              } else if (typeof element === 'object') {
                var objectClassInstance = _this.getClassInstanceFromPlainObject(field.children, element);

                if (objectClassInstance) {
                  classInstance[key].push(objectClassInstance);
                }
              } else if (field.children.type === 'literal') {
                classInstance[key].push(element);
              } else {
                console.log('case not handled -!-!- toJS Serializable');
              }
            });
          } else if (typeof snapshot[key] === 'object') {
            // console.log("type declared array but got object");
            console.log('case not handled -!-!- Serializable');
          } else if (classInstance[key]) {
            // console.log("type declared array but got literal");
            classInstance[key] = snapshot[key];
          }
        } else if (field.type === 'map') {
          classInstance[key] = new Map();

          forEach(snapshot[key], function (value, mapKey) {
            if (field.valueType === 'literal') {
              classInstance[key].set(mapKey, value);
            } else if (field.valueType.type === 'array') {
              var valueArray = [];

              forEach(value, function (element) {
                if (isArray(element) && value.children.type === 'array') {
                  console.log('case not handled -!-!- toJS Serializable');
                } else if (typeof element === 'object') {
                  var objectClassInstance = _this.getClassInstanceFromPlainObject(field.valueType.children, element);

                  if (objectClassInstance) {
                    valueArray.push(objectClassInstance);
                  }
                } else if (value.children.type === 'literal') {
                  valueArray.push(element);
                } else {
                  console.log('case not handled -!-!- toJS Serializable');
                }
              });

              classInstance[key].set(mapKey, valueArray);
            } else if (typeof value === 'object') {
              var valueClassInstance = _this.getClassInstanceFromPlainObject(field.valueType, value);

              classInstance[key].set(mapKey, valueClassInstance);
            }
          });
        } else {
          classInstance[key] = _this.getClassInstanceFromPlainObject(field, snapshot[key]);
        }
      });

      return classInstance;
    } // static getAllFields = (instance: any, fields = {}): any => {
    //   if (instance && instance.getFields) {
    //     const newFields = { ...instance.getFields(), ...fields };
    //     // Object.assign(fields, instance.getFields());
    //     const superFields = instance.getSuperFields();
    //     console.log(superFields, "superFields");
    //     return newFields;
    //     // return Serializable.getAllFields(superInstance, newFields);
    //   } else {
    //     return fields;
    //   }
    // };
    // getSuperFields() {
    //   // @ts-ignore
    //   console.log(super());
    //   // @ts-ignore
    //   return super.getFields();
    // }
    ;

    Serializable.getClassInstanceFromPlainObject = function getClassInstanceFromPlainObject(classObject, snapshot) {
      if (classObject.fromJS) {
        return classObject.fromJS(snapshot);
      } else {
        throw new Error(classObject.constructor.name + " is not extended from Serializable");
      }
    };

    var _proto = Serializable.prototype;

    _proto.toJS = function toJS(shallow) {
      var _this2 = this;

      if (shallow === void 0) {
        shallow = false;
      }

      var fields = Serializable.getAllFields(this); // console.log(fields, "All Fields from JS");

      if (!fields) {
        throw new Error('fileds are undefiend');
      }

      var ret = {};

      if (shallow) {
        delete fields.children;
      }

      forEach(fields, function (value, key) {
        if (value.type === 'ignore') {
          return;
        }

        if (!value) {
          throw new Error("type of " + key + " is not defined");
        }

        if (value) {
          if (value.type === 'array') {
            if (isArray(_this2[key])) {
              ret[key] = [];

              forEach(_this2[key], function (element) {
                if (isArray(element) && value.children.type === 'array') {
                  console.log('case not handled -!-!- toJS Serializable');
                } else if (typeof element === 'object') {
                  var object = _this2.getPlainObjectFromClassInstance(element);

                  if (object) {
                    ret[key].push(object);
                  }
                } else if (value.children.type === 'literal') {
                  ret[key].push(element);
                } else {
                  console.log('case not handled -!-!- toJS Serializable');
                }
              });
            } else if (typeof _this2[key] === 'object') {
              // console.log("type declared array but got object");
              ret[key] = _this2.getPlainObjectFromClassInstance(_this2[key]);
            } else {
              // console.log("type declared array but got literal");
              ret[key] = _this2[key];
            }
          } else if (value.type === 'map') {
            ret[key] = _this2.MapToPOJO(_this2[key]);
          } else if (value.type === 'literal') {
            ret[key] = _this2[key];
          } else {
            ret[key] = _this2.getPlainObjectFromClassInstance(_this2[key]);
          }
        } // else {
        //   ret[key] = undefined;
        // }

      });

      return omitBy(ret, isNil);
    };

    _proto.getPlainObjectFromClassInstance = function getPlainObjectFromClassInstance(object) {
      if (object) {
        if (object.toJS) {
          return object.toJS();
        } else {
          throw new Error(object.constructor.name + " is not extended from Serializable");
        }
      } else {
        return undefined;
      }
    };

    _proto.MapToPOJO = function MapToPOJO(mapInstance) {
      var _this3 = this;

      var result = {};

      if (mapInstance) {
        mapInstance.forEach(function (value, key) {
          var valuePlainArray = [];

          if (isArray(value)) {
            forEach(value, function (element) {
              var object = _this3.getPlainObjectFromClassInstance(element);

              if (object) {
                valuePlainArray.push(object);
              }
            });

            result[key] = valuePlainArray;
          } else {
            result[key] = _this3.getPlainObjectFromClassInstance(value);
          }
        });
      }

      return result;
    };

    return Serializable;
  }();

  Serializable.getAllFields = function (instance, fields) {
    if (fields === void 0) {
      fields = {};
    }

    if (instance && instance.getFields) {
      var newFields = _extends({}, instance.getFields(), fields); // Object.assign(fields, instance.getFields());


      var superInstance = Object.getPrototypeOf(instance);
      return Serializable.getAllFields(superInstance, newFields);
    } else {
      return fields;
    }
  };

  return Serializable;
}();
var literal = {
  type: 'literal',
  children: null
};

var array = function array(type) {
  return {
    type: 'array',
    children: type
  };
};

var map = function map(keyType, valueType) {
  return {
    type: 'map',
    keyType: keyType,
    valueType: valueType
  };
};

var ignore = {
  type: 'ignore',
  children: null
};
var types = {
  literal: literal,
  array: array,
  map: map,
  ignore: ignore
};

var rerendererLog = function rerendererLog() {

  return function () {//
  };
};

var stopUpdates = false;
var actionCounter = 0;
var noRerenderCounter = 0;
var pendingUpdates = /*#__PURE__*/new Map();
var action = function action(callback) {
  actionCounter++;
  callback(); // rerendererLog("HHH^&^& action completed", pendingUpdates);
  // console.log(
  //   "HHH^&^& action completed"
  //   // JSON.stringify(pendingUpdates.values(), null, 2)
  // );

  actionCounter--;

  if (actionCounter === 0) {
    pendingUpdates.forEach(function runListenersBatch(updateObject, listener) {
      // console.log("HHH^&^& batch emit", updateObject.properties, listener);
      if (!updateObject.model.disposed && !stopUpdates) {
        listener(updateObject.properties); // @ts-ignore

        if (window['debug']) {
          console.log('DEBUG::', 'Emit:', updateObject.properties);
        }
      }
    });
    pendingUpdates.clear();
  }
};

var Model = /*#__PURE__*/function (_Serializable) {
  _inheritsLoose(Model, _Serializable);

  function Model() {
    var _this;

    _this = _Serializable.apply(this, arguments) || this;
    _this.eventListenersMap = new Map();
    _this.reverseMap = new Map();
    _this.disposed = false;
    return _this;
  }

  var _proto = Model.prototype;

  _proto.getFields = function getFields() {
    return {
      eventListenersMap: types.ignore,
      reverseMap: types.ignore,
      disposed: types.ignore
    };
  };

  _proto.on = function on(properties, listener) {
    var _this2 = this;

    if (typeof properties === 'string') {
      // If a single property is received, wrap it in an Array
      properties = [properties];
    }

    properties.forEach(function (property) {
      var existingArrOfListeners = _this2.eventListenersMap.get(property);

      if (existingArrOfListeners) {
        existingArrOfListeners.push(listener);

        _this2.eventListenersMap.set(property, existingArrOfListeners);
      } else {
        _this2.eventListenersMap.set(property, [listener]);
      }
    }); // rerendererLog(this, "^&^&this");

    var arrayOfProperties = this.reverseMap.get(listener);

    if (arrayOfProperties) {
      arrayOfProperties = arrayOfProperties.concat(properties); // rerendererLog(arrayOfKeys, "arrayOfKeys &*");

      this.reverseMap.set(listener, uniq(arrayOfProperties));
    } else {
      this.reverseMap.set(listener, properties);
    } // rerendererLog(
    //   this.watchersMap.entries(),
    //   this.reverseMap.entries(),
    //   "watch &*"
    // );

  };

  _proto.emit = function emit(properties) {
    var _this3 = this;

    if (noRerenderCounter > 0) {
      return;
    } // console.trace(properties, "propertiesproperties");

    /*if (properties === '*' || properties[0] === '*') {
      throw Error(
        'Emitting * is not allowed. Thodi mehnat kar k saari properties emit kar do.'
      );
    }*/


    if (typeof properties === 'string') {
      // If a single property is received, wrap it in an Array
      properties = [properties];
    }

    properties.push('*');
    rerendererLog('HHH^&^& emitting ', properties, this.eventListenersMap, this.reverseMap);
    var combinedArrayOfListeners = reduce(properties, function (combined, property) {
      var existingArrOfListeners = _this3.eventListenersMap.get(property);

      if (existingArrOfListeners) {
        combined = union(combined, existingArrOfListeners);
      }

      return combined;
    }, []);
    combinedArrayOfListeners.forEach(function (listener) {

      if (listener) {
        if (actionCounter) {
          var existingUpdateObject = pendingUpdates.get(listener);

          if (existingUpdateObject) {
            existingUpdateObject.properties = existingUpdateObject.properties.concat(properties);
            pendingUpdates.set(listener, {
              properties: uniq(existingUpdateObject.properties),
              model: _this3
            });
          } else {
            pendingUpdates.set(listener, {
              properties: properties,
              model: _this3
            });
          }
        } else {
          throw new Error('emitting an event outside of an action');
        } // listener(properties);

      }
    });
  };

  _proto.off = function off(properties, listener) {
    var _this4 = this;

    // rerendererLog(observerComponent, "sufhesfbo sefu esfi ");
    if (typeof properties === 'string') {
      // If a single property is received, wrap it in an Array
      properties = [properties];
    }

    properties.forEach(function () {
      var arrayOfProperties = _this4.reverseMap.get(listener);

      if (arrayOfProperties) {
        arrayOfProperties.forEach(function (key) {
          var existingArrOfListeners = _this4.eventListenersMap.get(key);

          if (!existingArrOfListeners) {
            return;
          }

          remove(existingArrOfListeners, function (n) {
            return n === listener;
          });

          if (existingArrOfListeners.length === 0) {
            _this4.eventListenersMap["delete"](key);
          }
        });

        _this4.reverseMap["delete"](listener);
      }
    }); // rerendererLog(
    //   this.watchersMap.entries(),
    //   this.reverseMap.entries(),
    //   "remove &*"
    // );
  };

  return Model;
}(Serializable);

var ModelUtils = /*#__PURE__*/function () {
  function ModelUtils() {}

  ModelUtils.pointsOverlap = function pointsOverlap(point1, point2) {
    return Math.abs(point1 - point2) <= 1;
  };

  ModelUtils.getDimensionFromPolygon = function getDimensionFromPolygon(points) {
    var height = points[3][1] - points[0][1];
    var width = points[1][0] - points[0][0];
    var y = points[0][1];
    var x = points[0][0];
    return {
      x: x,
      y: y,
      width: width,
      height: height
    };
  };

  ModelUtils.rotatePolygon = function rotatePolygon(poly, angle, centroid) {
    var centroid = centroid ? centroid : ModelUtils.getCentroid(poly);
    poly.map(function (point, key) {
      point = ModelUtils.rotatePoint(point, angle, centroid);
      poly[key] = point;
    });
    return poly;
  };

  ModelUtils.findAngle = function findAngle(A, B, C, range) {
    var AB = Math.sqrt(Math.pow(B[0] - A[0], 2) + Math.pow(B[1] - A[1], 2));
    var BC = Math.sqrt(Math.pow(B[0] - C[0], 2) + Math.pow(B[1] - C[1], 2));
    var AC = Math.sqrt(Math.pow(C[0] - A[0], 2) + Math.pow(C[1] - A[1], 2));
    var value = (BC * BC + AB * AB - AC * AC) / (2 * BC * AB);

    if (value > 1) {
      value = 1;
    }

    if (value < -1) {
      value = -1;
    }

    var angle = Math.acos(value);
    angle = angle * (180 / Math.PI);

    if (range === 360) {
      if (C[0] < A[0]) {
        angle = 360 - angle;
      }
    }

    return angle;
  };

  ModelUtils.getAbsoluteRotation = function getAbsoluteRotation(poly) {
    var centroid = ModelUtils.getCentroid(poly); // get three points of a triangle to get angle between two lines

    var point1 = [centroid[0], centroid[1] - 2];
    var point3 = ModelUtils.middlePoint(poly[0], poly[1]); // get angle created by two lines

    var angle = ModelUtils.findAngle(point1, centroid, point3, 360);
    return angle;
  };

  ModelUtils.middlePoint = function middlePoint(point1, point2) {
    var newX = (point1[0] + point2[0]) / 2;
    var newY = (point1[1] + point2[1]) / 2;
    return [newX, newY];
  };

  ModelUtils.getCentroid = function getCentroid(coord) {
    var center = coord.reduce(function (point1, point2) {
      return [point1[0] + point2[0] / coord.length, point1[1] + point2[1] / coord.length];
    }, [0, 0]);
    return center;
  };

  ModelUtils.distance = function distance(point1, point2) {
    var a = point1[0] - point2[0];
    var b = point1[1] - point2[1];
    var c = Math.sqrt(a * a + b * b);
    return c;
  };

  ModelUtils.rotatePoint = function rotatePoint(point, angle, centroid) {
    angle = angle * Math.PI / 180.0;
    var newX = (point[0] - centroid[0]) * Math.cos(angle) - (point[1] - centroid[1]) * Math.sin(angle) + centroid[0];
    var newY = (point[1] - centroid[1]) * Math.cos(angle) + (point[0] - centroid[0]) * Math.sin(angle) + centroid[1];
    return [newX, newY];
  };

  ModelUtils.getPointsFromBoundingBox = function getPointsFromBoundingBox(box, rotation) {
    if (rotation === void 0) {
      rotation = 0;
    }

    var poly = [[box.x, box.y], [box.x + box.width, box.y], [box.x + box.width, box.y + box.height], [box.x, box.y + box.height]]; // var centroid = getCentroid(poly);

    var rotatedPoly = ModelUtils.rotatePolygon(poly, rotation);
    return rotatedPoly;
  };

  ModelUtils.getPointsFromDims = function getPointsFromDims(dims) {
    var newX = dims.x;
    var newY = dims.y;
    var width = dims.width;
    var height = dims.height;
    var poly = [[newX, newY], [newX + width, newY], [newX + width, newY + height], [newX, newY + height]];
    var transform = reverse([].concat(dims.transform));
    transform.map(function (obj, index) {
      if (obj.rotate && obj.rotate.rotation && obj.rotate.centroid) {
        poly = ModelUtils.rotatePolygon(poly, obj.rotate.rotation, obj.rotate.centroid);
      }
    });
    return poly;
  };

  ModelUtils.depthComparator = function depthComparator(a, b) {
    var activeA = ModelUtils.getActiveDigit(a);
    var activeB = ModelUtils.getActiveDigit(b);

    if (a === b) {
      return 0;
    }

    if (activeA !== null && activeB !== null && activeA !== activeB) {
      if (activeA < activeB) {
        return -1;
      } else {
        return 1;
      }
    } else if (activeA !== null && activeB !== null && activeA === activeB) {
      var nextA = ModelUtils.getNextCharacter(a);
      var nextB = ModelUtils.getNextCharacter(b);
      return ModelUtils.depthComparator(nextA, nextB);
    } else if (activeA !== null) {
      return 1;
    } else {
      return -1;
    }
  };

  ModelUtils.getNextCharacter = function getNextCharacter(a) {
    if (a === null) {
      return '';
    }

    var aIndex = a.indexOf('.');

    if (aIndex === -1) {
      return '';
    }

    return a.substring(aIndex + 1, a.length);
  };

  ModelUtils.getActiveDigit = function getActiveDigit(a) {
    if (a === null || a.length === 0) {
      return null;
    }

    if (!a.includes('.')) {
      return parseInt(a, 10);
    }

    return parseInt(a.substring(0, a.indexOf('.')), 10);
  };

  return ModelUtils;
}();
function getCorrection(orientation, finalOrientation, handle) {
  var rotation = orientation.rotation;
  var angle = rotation * Math.PI / 180.0;
  var x1 = -orientation.width / 2;
  var y1 = orientation.height / 2; // tslint:disable:variable-name

  var new_x1 = y1 * Math.sin(angle) + x1 * Math.cos(angle);
  var new_y1 = y1 * Math.cos(angle) - x1 * Math.sin(angle);
  var diff1 = {
    x: new_x1 - x1,
    y: new_y1 - y1
  }; // only width

  var y2 = orientation.height / 2;
  var x2 = -finalOrientation.width / 2;
  var new_x2 = y2 * Math.sin(angle) + x2 * Math.cos(angle);
  var new_y2 = y2 * Math.cos(angle) - x2 * Math.sin(angle);
  var diff2 = {
    x: new_x2 - x2,
    y: new_y2 - y2
  };
  var offsetWidth = {
    x: diff2.x - diff1.x,
    y: diff2.y - diff1.y
  }; // only height
  // tslint:disable:no-duplicate-variable

  y2 = finalOrientation.height / 2;
  x2 = -orientation.width / 2;
  new_x2 = y2 * Math.sin(angle) + x2 * Math.cos(angle);
  new_y2 = y2 * Math.cos(angle) - x2 * Math.sin(angle);
  diff2 = {
    x: new_x2 - x2,
    y: new_y2 - y2
  };
  var offsetHeight = {
    x: diff2.x - diff1.x,
    y: diff2.y - diff1.y
  };
  var newX = finalOrientation.x;
  var newY = finalOrientation.y;

  if (handle.indexOf('T') !== -1 || handle.indexOf('L') !== -1) {
    newX = finalOrientation.x + (offsetWidth.x + offsetHeight.x);
    newY = finalOrientation.y - (offsetWidth.y + offsetHeight.y);
  }

  if (handle.indexOf('B') !== -1 || handle.indexOf('R') !== -1) {
    newX = finalOrientation.x - (offsetWidth.x + offsetHeight.x);
    newY = finalOrientation.y + (offsetWidth.y + offsetHeight.y);
  }

  if (handle.indexOf('B') !== -1 && handle.indexOf('L') !== -1) {
    newX = finalOrientation.x + offsetWidth.x - offsetHeight.x;
    newY = finalOrientation.y - offsetWidth.y + offsetHeight.y;
  }

  if (handle.indexOf('T') !== -1 && handle.indexOf('R') !== -1) {
    newX = finalOrientation.x - offsetWidth.x + offsetHeight.x;
    newY = finalOrientation.y + offsetWidth.y - offsetHeight.y;
  }

  if (handle.indexOf('C') !== -1) {
    newX = finalOrientation.x;
    newY = finalOrientation.y;
  }

  return {
    x: newX,
    y: newY,
    height: finalOrientation.height,
    width: finalOrientation.width,
    rotation: rotation
  };
}
function getResizerQuad(rotation) {
  rotation = rotation % 360;

  if (rotation < 0) {
    rotation += 360;
  }

  if (!rotation) {
    return '4';
  }

  if (rotation >= 22.5 && rotation < 67.5 || rotation >= 202.5 && rotation < 247.5) {
    return '1';
  }

  if (rotation >= 67.5 && rotation < 112.5 || rotation >= 247.5 && rotation < 292.5) {
    return '2';
  }

  if (rotation >= 112.5 && rotation < 157.5 || rotation >= 292.5 && rotation < 337.5) {
    return '3';
  }

  if (rotation >= 157.5 && rotation < 202.5 || rotation >= 337.5 && rotation < 22.5) {
    return '4';
  }

  return '4';
}
function computeOrientation(layout, delta, handle, shift, alt) {
  if (shift && !alt) {
    return computeOrientationWithDeltaAR(layout, delta, handle);
  } else if (!shift && alt) {
    return computeOrientationWithDeltaAlt(layout, delta, handle);
  } else if (shift && alt) {
    return computeOrientationWithDeltaShiftAlt(layout, delta, handle);
  } else {
    return computeOrientationWithDelta(layout, delta, handle);
  }
}
function computeOrientationMultiple(orientation, delta, handle, boundaryBox, points, shift, alt) {
  if (shift && !alt) {
    return computeOrientationWithDeltaARMultiple(orientation, delta, handle, boundaryBox, points);
  } else if (!shift && alt) {
    return computeOrientationWithDeltaAltMultiple(orientation, delta, handle, boundaryBox, points);
  } else if (shift && alt) {
    return computeOrientationWithDeltaShiftAltMultiple(orientation, delta, handle, boundaryBox, points);
  } else {
    return computeOrientationWithDeltaMultiple(orientation, delta, handle, boundaryBox, points);
  }
}
function computeOrientationWithDelta(layout, delta, handle) {
  var x = layout.x;
  var y = layout.y;
  var width = Math.max(layout.width, 0);
  var height = Math.max(layout.height, 0);
  var deltaX = !isNil(delta.x) ? delta.x : 0;
  var deltaY = !isNil(delta.y) ? delta.y : 0;
  var rotation = layout.rotation;

  if (handle.indexOf('C') !== -1) {
    x += deltaX;
    y += deltaY;
  }

  if (handle.indexOf('B') !== -1) {
    height += deltaY;
  }

  if (handle.indexOf('R') !== -1) {
    width += deltaX;
  }

  if (handle.indexOf('T') !== -1) {
    height -= deltaY;
    y += deltaY;
  }

  if (handle.indexOf('L') !== -1) {
    width -= deltaX;
    x += deltaX;
  }

  var finalOrientation = {
    x: x,
    y: y,
    width: width,
    height: height,
    rotation: rotation
  };
  finalOrientation = getCorrection(layout, finalOrientation, handle);
  return finalOrientation;
}
function computeOrientationWithDeltaMultiple(orientation, delta, handle, boundaryBox, points) {
  var x = orientation.x;
  var y = orientation.y;
  var width = orientation.width;
  var height = orientation.height;
  var deltaX = !isNil(delta.x) ? delta.x : 0;
  var deltaY = !isNil(delta.y) ? delta.y : 0;
  var rotation = orientation.rotation;

  if (handle.indexOf('C') !== -1) {
    x += deltaX;
    y += deltaY;
  } else {
    var newPoints = [].concat(points);
    map$1(newPoints, function (point, index) {
      var pointXDiff = 0;
      var pointYDiff = 0;

      if (handle.indexOf('B') !== -1) {
        pointYDiff = 1 - (boundaryBox.height - (point[1] - boundaryBox.y)) / boundaryBox.height;
      }

      if (handle.indexOf('R') !== -1) {
        pointXDiff = 1 - (boundaryBox.width - (point[0] - boundaryBox.x)) / boundaryBox.width;
      }

      if (handle.indexOf('T') !== -1) {
        pointYDiff = (boundaryBox.height - (point[1] - boundaryBox.y)) / boundaryBox.height;
      }

      if (handle.indexOf('L') !== -1) {
        pointXDiff = (boundaryBox.width - (point[0] - boundaryBox.x)) / boundaryBox.width;
      }

      var pointY = point[1] + pointYDiff * deltaY;
      var pointX = point[0] + pointXDiff * deltaX;
      var pointNew = [pointX, pointY];
      newPoints[index] = pointNew;
    });
    newPoints = ModelUtils.rotatePolygon(newPoints, 360 - rotation);
    var box = ModelUtils.getDimensionFromPolygon(newPoints);
    height = box.height;
    width = box.width;
    y = box.y;
    x = box.x;
  }

  return {
    width: width,
    height: height,
    x: x,
    y: y,
    rotation: rotation
  };
}
function computeOrientationWithDeltaARMultiple(orientation, deltaInp, handle, boundaryBox, points) {
  var x = orientation.x;
  var y = orientation.y;
  var width = orientation.width;
  var height = orientation.height;
  var rotation = orientation.rotation;
  var deltaX = !isNil(deltaInp.x) ? deltaInp.x : 0;
  var deltaY = !isNil(deltaInp.y) ? deltaInp.y : 0;
  var aspectRatio = boundaryBox.width / boundaryBox.height;

  if (handle.indexOf('C') !== -1) {
    x += deltaX;
    y += deltaY;
  } else {
    var newPoints = [].concat(points);
    var initialDims = ModelUtils.getDimensionFromPolygon(newPoints);
    var widthFactor = (boundaryBox.width - initialDims.width) / boundaryBox.width;
    map$1(newPoints, function (point, index) {
      var pointXDiff = 0,
          pointYDiff = 0,
          pointX = 0,
          pointY = 0,
          delta = 0; // for buttom and right

      var pointYDiffDirect = 1 - (boundaryBox.height - (point[1] - boundaryBox.y)) / boundaryBox.height;
      var pointXDiffDirect = 1 - (boundaryBox.width - (point[0] - boundaryBox.x)) / boundaryBox.width; // for top and right

      var pointYDiffOpposite = (boundaryBox.height - (point[1] - boundaryBox.y)) / boundaryBox.height;
      var pointXDiffOpposite = (boundaryBox.width - (point[0] - boundaryBox.x)) / boundaryBox.width;

      if (handle.length > 1) {
        if (handle.indexOf('B') !== -1 && handle.indexOf('L') !== -1) {
          delta = deltaX > -deltaY ? deltaX : deltaY;
          pointYDiff = pointYDiffDirect;
          pointXDiff = pointXDiffOpposite;

          if (deltaX > -deltaY) {
            pointY = point[1] - pointYDiff * delta * (1 / aspectRatio);
            pointX = point[0] + delta * pointXDiff;
          } else {
            pointY = point[1] + pointYDiff * delta;
            pointX = point[0] - delta * pointXDiff * aspectRatio;
          }
        }

        if (handle.indexOf('B') !== -1 && handle.indexOf('R') !== -1) {
          delta = deltaX < deltaY ? deltaX : deltaY;
          pointYDiff = pointYDiffDirect;
          pointXDiff = pointXDiffDirect;

          if (deltaX > deltaY) {
            pointY = point[1] + pointYDiff * delta;
            pointX = point[0] + delta * pointXDiff * aspectRatio;
          } else {
            pointY = point[1] + pointYDiff * delta * (1 / aspectRatio);
            pointX = point[0] + delta * pointXDiff;
          }
        }

        if (handle.indexOf('T') !== -1 && handle.indexOf('R') !== -1) {
          delta = deltaX < -deltaY ? deltaX : deltaY;
          pointYDiff = pointYDiffOpposite;
          pointXDiff = pointXDiffDirect;

          if (deltaX > -deltaY) {
            pointY = point[1] + pointYDiff * delta;
            pointX = point[0] - delta * pointXDiff * aspectRatio;
          } else {
            pointY = point[1] - pointYDiff * delta * (1 / aspectRatio);
            pointX = point[0] + delta * pointXDiff;
          }
        }

        if (handle.indexOf('T') !== -1 && handle.indexOf('L') !== -1) {
          delta = deltaX > deltaY ? deltaX : deltaY;
          pointYDiff = pointYDiffOpposite;
          pointXDiff = pointXDiffOpposite;

          if (deltaX > deltaY) {
            pointY = point[1] + pointYDiff * delta * (1 / aspectRatio);
            pointX = point[0] + delta * pointXDiff;
          } else {
            pointY = point[1] + pointYDiff * delta;
            pointX = point[0] + delta * pointXDiff * aspectRatio;
          }
        }
      } else {
        if (handle.indexOf('B') !== -1) {
          pointYDiff = pointYDiffDirect;
          pointXDiff = pointXDiffDirect;
          pointY = point[1] + pointYDiff * deltaY;
          pointX = point[0] + deltaY * aspectRatio * pointXDiff - deltaY * aspectRatio / 2;
        }

        if (handle.indexOf('T') !== -1) {
          pointYDiff = pointYDiffOpposite;
          pointXDiff = pointXDiffOpposite;
          pointY = point[1] + pointYDiff * deltaY;
          pointX = point[0] + deltaY * pointXDiff * aspectRatio - deltaY * aspectRatio / 2;
        }

        if (handle.indexOf('R') !== -1) {
          pointYDiff = pointYDiffDirect;
          pointXDiff = pointXDiffDirect;
          pointX = point[0] + pointXDiff * deltaX;
          pointY = point[1] + deltaX * pointYDiff * (1 / aspectRatio) - deltaX * (1 / aspectRatio) / 2;
        }

        if (handle.indexOf('L') !== -1) {
          pointYDiff = pointYDiffOpposite;
          pointXDiff = pointXDiffOpposite;
          pointX = point[0] + pointXDiff * deltaX;
          pointY = point[1] + deltaX * pointYDiff * (1 / aspectRatio) - deltaX * (1 / aspectRatio) / 2;
        }
      }

      var pointNew = [pointX, pointY];
      newPoints[index] = pointNew;
    });
    newPoints = ModelUtils.rotatePolygon(newPoints, 360 - rotation);
    var box = ModelUtils.getDimensionFromPolygon(newPoints);
    height = box.height;
    width = box.width;
    y = box.y;
    x = box.x;
  }

  return {
    width: width,
    height: height,
    x: x,
    y: y,
    rotation: rotation
  };
}
function computeOrientationWithDeltaAltMultiple(orientation, delta, handle, boundaryBox, points) {
  var x = orientation.x;
  var y = orientation.y;
  var width = orientation.width;
  var height = orientation.height;
  var rotation = orientation.rotation;
  var deltaX = !isNil(delta.x) ? delta.x : 0;
  var deltaY = !isNil(delta.y) ? delta.y : 0;

  if (handle.indexOf('C') !== -1) {
    x += deltaX;
    y += deltaY;
  } else {
    var newPoints = [].concat(points);
    var initialDims = ModelUtils.getDimensionFromPolygon(newPoints);
    var widthFactor = (boundaryBox.width - initialDims.width) / boundaryBox.width;
    map$1(newPoints, function (point, index) {
      var pointXDiff = 0,
          pointYDiff = 0,
          pointX = 0,
          pointY = 0; // delta = 0;
      // for buttom and right

      var pointYDiffDirect = 1 - (boundaryBox.height - (point[1] - boundaryBox.y)) / boundaryBox.height;
      var pointXDiffDirect = 1 - (boundaryBox.width - (point[0] - boundaryBox.x)) / boundaryBox.width; // for top and right

      var pointYDiffOpposite = (boundaryBox.height - (point[1] - boundaryBox.y)) / boundaryBox.height;
      var pointXDiffOpposite = (boundaryBox.width - (point[0] - boundaryBox.x)) / boundaryBox.width;

      if (handle.indexOf('B') !== -1) {
        pointYDiff = pointYDiffDirect;
        pointXDiff = pointXDiffDirect;
        pointY = point[1] + pointYDiff * deltaY - deltaY / 2;

        if (handle.indexOf('L') === -1 && handle.indexOf('R') === -1) {
          pointX = point[0] + pointXDiff;
        } else {
          pointX = point[0] + pointXDiff * deltaX - deltaX / 2;
        }
      }

      if (handle.indexOf('T') !== -1) {
        pointYDiff = pointYDiffOpposite;
        pointXDiff = pointXDiffDirect;
        pointY = point[1] - pointYDiff * deltaY - deltaY / 2;

        if (handle.indexOf('L') === -1 && handle.indexOf('R') === -1) {
          pointX = point[0] + pointXDiff;
        } else {
          pointX = point[0] + pointXDiff * deltaX - deltaX / 2;
        }
      }

      if (handle.indexOf('R') !== -1) {
        pointXDiff = pointXDiffDirect;
        pointYDiff = pointYDiffDirect;
        pointX = point[0] + pointXDiff * deltaX - deltaX / 2;

        if (handle.indexOf('T') === -1 && handle.indexOf('B') === -1) {
          pointY = point[1] + pointYDiff;
        } else {
          if (handle.indexOf('B') !== -1) {
            pointY = point[1] + pointYDiff * deltaY - deltaY / 2;
          } else {
            pointY = point[1] - pointYDiff * deltaY + deltaY / 2;
          }
        }
      }

      if (handle.indexOf('L') !== -1) {
        pointXDiff = pointXDiffOpposite;
        pointYDiff = pointYDiffDirect;
        pointX = point[0] + pointXDiff * deltaX - deltaX / 2;

        if (handle.indexOf('T') === -1 && handle.indexOf('B') === -1) {
          pointY = point[1] + pointYDiff;
        } else {
          if (handle.indexOf('B') !== -1) {
            pointY = point[1] + pointYDiff * deltaY - deltaY / 2;
          } else {
            pointY = point[1] - pointYDiff * deltaY + deltaY / 2;
          }
        }
      }

      var pointNew = [pointX, pointY];
      newPoints[index] = pointNew;
    });
    newPoints = ModelUtils.rotatePolygon(newPoints, 360 - rotation);
    var box = ModelUtils.getDimensionFromPolygon(newPoints);
    height = box.height;
    width = box.width;
    y = box.y;
    x = box.x;
  }

  return {
    width: width,
    height: height,
    x: x,
    y: y,
    rotation: rotation
  };
}
function computeOrientationWithDeltaShiftAltMultiple(orientation, deltaInp, handle, boundaryBox, points) {
  var x = orientation.x;
  var y = orientation.y;
  var width = orientation.width;
  var height = orientation.height;
  var deltaX = !isNil(deltaInp.x) ? deltaInp.x : 0;
  var deltaY = !isNil(deltaInp.y) ? deltaInp.y : 0;
  var rotation = orientation.rotation;
  var aspectRatio = boundaryBox.width / boundaryBox.height;

  if (handle.indexOf('C') !== -1) {
    x += deltaX;
    y += deltaY;
  } else {
    var newPoints = [].concat(points);
    var initialDims = ModelUtils.getDimensionFromPolygon(newPoints);
    var widthFactor = (boundaryBox.width - initialDims.width) / boundaryBox.width;
    map$1(newPoints, function (point, index) {
      var pointXDiff = 0,
          pointYDiff = 0,
          pointX = 0,
          pointY = 0,
          delta = 0; // for buttom and right

      var pointYDiffDirect = 1 - (boundaryBox.height - (point[1] - boundaryBox.y)) / boundaryBox.height;
      var pointXDiffDirect = 1 - (boundaryBox.width - (point[0] - boundaryBox.x)) / boundaryBox.width; // for top and right

      var pointYDiffOpposite = (boundaryBox.height - (point[1] - boundaryBox.y)) / boundaryBox.height;
      var pointXDiffOpposite = (boundaryBox.width - (point[0] - boundaryBox.x)) / boundaryBox.width;

      if (handle.length > 1) {
        if (handle.indexOf('B') !== -1 && handle.indexOf('L') !== -1) {
          delta = deltaX > -deltaY ? deltaX : deltaY;
          pointYDiff = pointYDiffDirect;
          pointXDiff = pointXDiffOpposite;

          if (deltaX > -deltaY) {
            pointY = point[1] - pointYDiff * delta * (1 / aspectRatio) + delta * (1 / aspectRatio) / 2;
            pointX = point[0] + delta * pointXDiff - delta / 2;
          } else {
            pointY = point[1] + pointYDiff * delta - delta / 2;
            pointX = point[0] - delta * pointXDiff * aspectRatio + delta * aspectRatio / 2;
          }
        }

        if (handle.indexOf('B') !== -1 && handle.indexOf('R') !== -1) {
          delta = deltaX < deltaY ? deltaX : deltaY;
          pointYDiff = pointYDiffDirect;
          pointXDiff = pointXDiffDirect;

          if (deltaX > deltaY) {
            pointY = point[1] + pointYDiff * delta - delta / 2;
            pointX = point[0] + delta * pointXDiff * aspectRatio - delta * aspectRatio / 2;
          } else {
            pointY = point[1] + pointYDiff * delta * (1 / aspectRatio) - delta * (1 / aspectRatio) / 2;
            pointX = point[0] + delta * pointXDiff - delta / 2;
          }
        }

        if (handle.indexOf('T') !== -1 && handle.indexOf('R') !== -1) {
          delta = deltaX < -deltaY ? deltaX : deltaY;
          pointYDiff = pointYDiffOpposite;
          pointXDiff = pointXDiffDirect;

          if (deltaX > -deltaY) {
            pointY = point[1] + pointYDiff * delta - delta / 2;
            pointX = point[0] - delta * pointXDiff * aspectRatio + delta * aspectRatio / 2;
          } else {
            pointY = point[1] - pointYDiff * delta * (1 / aspectRatio) + delta * (1 / aspectRatio) / 2;
            pointX = point[0] + delta * pointXDiff - delta / 2;
          }
        }

        if (handle.indexOf('T') !== -1 && handle.indexOf('L') !== -1) {
          delta = deltaX > deltaY ? deltaX : deltaY;
          pointYDiff = pointYDiffOpposite;
          pointXDiff = pointXDiffOpposite;

          if (deltaX > deltaY) {
            pointY = point[1] + pointYDiff * delta * (1 / aspectRatio) - delta * (1 / aspectRatio) / 2;
            pointX = point[0] + delta * pointXDiff - delta / 2;
          } else {
            pointY = point[1] + pointYDiff * delta - delta / 2;
            pointX = point[0] + delta * pointXDiff * aspectRatio - delta * aspectRatio / 2;
          }
        }
      } else {
        if (handle.indexOf('B') !== -1) {
          pointYDiff = pointYDiffDirect;
          pointXDiff = pointXDiffDirect;
          pointY = point[1] + pointYDiff * deltaY - deltaY / 2;
          pointX = point[0] + deltaY * aspectRatio * pointXDiff - deltaY * aspectRatio / 2;
        }

        if (handle.indexOf('T') !== -1) {
          pointYDiff = pointYDiffOpposite;
          pointXDiff = pointXDiffOpposite;
          pointY = point[1] + pointYDiff * deltaY - deltaY / 2;
          pointX = point[0] + deltaY * pointXDiff * aspectRatio - deltaY * aspectRatio / 2;
        }

        if (handle.indexOf('R') !== -1) {
          pointYDiff = pointYDiffDirect;
          pointXDiff = pointXDiffDirect;
          pointX = point[0] + pointXDiff * deltaX - deltaX / 2;
          pointY = point[1] + deltaX * pointYDiff * (1 / aspectRatio) - deltaX * (1 / aspectRatio) / 2;
        }

        if (handle.indexOf('L') !== -1) {
          pointYDiff = pointYDiffOpposite;
          pointXDiff = pointXDiffOpposite;
          pointX = point[0] + pointXDiff * deltaX - deltaX / 2;
          pointY = point[1] + deltaX * pointYDiff * (1 / aspectRatio) - deltaX * (1 / aspectRatio) / 2;
        }
      }

      var pointNew = [pointX, pointY];
      newPoints[index] = pointNew;
    });
    newPoints = ModelUtils.rotatePolygon(newPoints, 360 - rotation);
    var box = ModelUtils.getDimensionFromPolygon(newPoints);
    height = box.height;
    width = box.width;
    y = box.y;
    x = box.x;
  }

  return {
    width: width,
    height: height,
    x: x,
    y: y,
    rotation: rotation
  };
}
function computeOrientationWithDeltaAR(orientation, delta, handle) {
  var x = orientation.x;
  var y = orientation.y;
  var rotation = orientation.rotation;
  var width = orientation.width;
  var height = orientation.height;
  var deltaX = !isNil(delta.x) ? delta.x : 0;
  var deltaY = !isNil(delta.y) ? delta.y : 0;
  var aspectRatio = width / height;

  if (!width || !height) {
    aspectRatio = 1;
  }

  if (handle.indexOf('C') !== -1) {
    x += deltaX;
    y += deltaY;
  }

  var newX = x,
      newY = y;

  if (handle.length === 1 && handle.indexOf('T') !== -1) {
    // newX = x + (deltaY * aspectRatio) / 2;
    newY = y + deltaY;
    height -= deltaY;
    width = height * aspectRatio;
  }

  if (handle.length === 1 && handle.indexOf('B') !== -1) {
    // newX = x - (deltaY * aspectRatio) / 2;
    height += deltaY;
    width = height * aspectRatio;
  }

  if (handle.length === 1 && handle.indexOf('L') !== -1) {
    newX = x + deltaX; // newY = y + (deltaX * (1 / aspectRatio)) / 2;

    width -= deltaX;
    height = width / aspectRatio;
  }

  if (handle.length === 1 && handle.indexOf('R') !== -1) {
    // newY = y - (deltaX * (1 / aspectRatio)) / 2;
    width += deltaX;
    height = width / aspectRatio;
  }

  if (handle.length === 2 && handle.indexOf('T') !== -1 && handle.indexOf('R') !== -1) {
    if (deltaX > -deltaY) {
      newY = y - deltaX * (1 / aspectRatio);
      height += deltaX * (1 / aspectRatio);
      width += deltaX;
    } else {
      newY = y + deltaY;
      height -= deltaY;
      width -= deltaY * aspectRatio;
    }
  }

  if (handle.length === 2 && handle.indexOf('T') !== -1 && handle.indexOf('L') !== -1) {
    if (deltaX > deltaY) {
      newY = y + deltaY;
      newX = x + deltaY * aspectRatio;
      height -= deltaY;
      width -= deltaY * aspectRatio;
    } else {
      newY = y + deltaX * (1 / aspectRatio);
      newX = x + deltaX;
      width -= deltaX;
      height -= deltaX * (1 / aspectRatio);
    }
  }

  if (handle.length === 2 && handle.indexOf('B') !== -1 && handle.indexOf('R') !== -1) {
    if (deltaX > deltaY) {
      width += deltaX;
      height += deltaX * (1 / aspectRatio);
    } else {
      height += deltaY;
      width += deltaY * aspectRatio;
    }
  }

  if (handle.length === 2 && handle.indexOf('B') !== -1 && handle.indexOf('L') !== -1) {
    if (deltaX > -deltaY) {
      height += deltaY;
      newX = x - deltaY * aspectRatio;
      width += deltaY * aspectRatio;
    } else {
      width -= deltaX;
      newX = x + deltaX;
      height -= deltaX * (1 / aspectRatio);
    }
  } // height = Math.max(height, width);
  // width = Math.max(height, width);


  return {
    width: width,
    height: height,
    x: newX,
    y: newY,
    rotation: rotation
  };
}
function computeOrientationWithDeltaAlt(orientation, delta, handle) {
  var x = orientation.x;
  var y = orientation.y;
  var rotation = orientation.rotation;
  var width = orientation.width;
  var height = orientation.height;
  var deltaX = !isNil(delta.x) ? delta.x : 0;
  var deltaY = !isNil(delta.y) ? delta.y : 0; // let aspectRatio = width / height;

  if (handle.indexOf('C') !== -1) {
    x += deltaX;
    y += deltaY;
  }

  var newX = x,
      newY = y;

  if (handle.indexOf('T') !== -1) {
    height -= deltaY * 2;
    if (height > 0) newY = y + deltaY;
  }

  if (handle.indexOf('B') !== -1) {
    height += deltaY * 2;
    if (height > 0) newY = y - deltaY;
  }

  if (handle.indexOf('R') !== -1) {
    width += deltaX * 2;
    if (width > 0) newX = x - deltaX;
  }

  if (handle.indexOf('L') !== -1) {
    width -= deltaX * 2;
    if (width > 0) newX = x + deltaX;
  }

  return {
    width: width,
    height: height,
    x: newX,
    y: newY,
    rotation: rotation
  };
}
function computeOrientationWithDeltaShiftAlt(orientation, delta, handle) {
  var x = orientation.x;
  var y = orientation.y;
  var rotation = orientation.rotation;
  var width = orientation.width;
  var height = orientation.height;
  var deltaX = !isNil(delta.x) ? delta.x : 0;
  var deltaY = !isNil(delta.y) ? delta.y : 0;
  deltaY = deltaY * 2;
  deltaX = deltaX * 2;
  var aspectRatio = width / height;

  if (!width || !height) {
    aspectRatio = 1;
  }

  if (handle.indexOf('C') !== -1) {
    x += deltaX;
    y += deltaY;
  }

  var newX = x,
      newY = y;

  if (handle.length === 1 && handle.indexOf('T') !== -1) {
    newX = x + deltaY * aspectRatio / 2;
    newY = y + deltaY / 2;
    height -= deltaY;
    width = height * aspectRatio;
  }

  if (handle.length === 1 && handle.indexOf('B') !== -1) {
    newX = x - deltaY * aspectRatio / 2;
    newY = y - deltaY / 2;
    height += deltaY;
    width = height * aspectRatio;
  }

  if (handle.length === 1 && handle.indexOf('L') !== -1) {
    newX = x + deltaX / 2;
    newY = y + deltaX * (1 / aspectRatio) / 2;
    width -= deltaX;
    height = width / aspectRatio;
  }

  if (handle.length === 1 && handle.indexOf('R') !== -1) {
    newY = y - deltaX * (1 / aspectRatio) / 2;
    newX = x - deltaX / 2;
    width += deltaX;
    height = width / aspectRatio;
  }

  if (handle.length === 2 && handle.indexOf('T') !== -1 && handle.indexOf('R') !== -1) {
    // if (deltaX > -deltaY) {
    //   newY = y + deltaY / 2;
    //   newX = x + (deltaY * aspectRatio) / 2;
    //   height -= deltaY;
    //   width -= deltaY * aspectRatio;
    // } else {
    //   newY = y - (deltaX * (1 / aspectRatio)) / 2;
    //   newX = x - deltaX / 2;
    //   height += deltaX * (1 / aspectRatio);
    //   width += deltaX;
    // }
    if (deltaX > -deltaY) {
      newY = y - deltaX * (1 / aspectRatio) / 2;
      newX = x - deltaX / 2;
      height += deltaX * (1 / aspectRatio);
      width += deltaX;
    } else {
      newY = y + deltaY / 2;
      newX = x + deltaY * aspectRatio / 2;
      height -= deltaY;
      width -= deltaY * aspectRatio;
    }
  }

  if (handle.length === 2 && handle.indexOf('T') !== -1 && handle.indexOf('L') !== -1) {
    // if (deltaX > deltaY) {
    //   newY = y + (deltaX * (1 / aspectRatio)) / 2;
    //   newX = x + deltaX / 2;
    //   width -= deltaX;
    //   height -= deltaX * (1 / aspectRatio);
    // } else {
    //   newY = y + deltaY / 2;
    //   newX = x + (deltaY * aspectRatio) / 2;
    //   width -= deltaY * aspectRatio;
    //   height -= deltaY;
    // }
    if (deltaX > deltaY) {
      newY = y + deltaY / 2;
      newX = x + deltaY * aspectRatio / 2;
      width -= deltaY * aspectRatio;
      height -= deltaY;
    } else {
      newY = y + deltaX * (1 / aspectRatio) / 2;
      newX = x + deltaX / 2;
      width -= deltaX;
      height -= deltaX * (1 / aspectRatio);
    }
  }

  if (handle.length === 2 && handle.indexOf('B') !== -1 && handle.indexOf('R') !== -1) {
    // if (deltaX > deltaY) {
    //   newY = y - deltaY / 2;
    //   newX = x - (deltaY * aspectRatio) / 2;
    //   height += deltaY;
    //   width += deltaY * aspectRatio;
    // } else {
    //   newY = y - (deltaX * (1 / aspectRatio)) / 2;
    //   newX = x - deltaX / 2;
    //   height += deltaX * (1 / aspectRatio);
    //   width += deltaX;
    // }
    if (deltaX > deltaY) {
      newY = y - deltaX * (1 / aspectRatio) / 2;
      newX = x - deltaX / 2;
      height += deltaX * (1 / aspectRatio);
      width += deltaX;
    } else {
      newY = y - deltaY / 2;
      newX = x - deltaY * aspectRatio / 2;
      height += deltaY;
      width += deltaY * aspectRatio;
    }
  }

  if (handle.length === 2 && handle.indexOf('B') !== -1 && handle.indexOf('L') !== -1) {
    // if (deltaX > -deltaY) {
    //   height -= deltaX * (1 / aspectRatio);
    //   width -= deltaX;
    //   newX = x + deltaX / 2;
    //   newY = y + (deltaX * (1 / aspectRatio)) / 2;
    // } else {
    //   width += deltaY * aspectRatio;
    //   height += deltaY;
    //   newX = x - (deltaY * aspectRatio) / 2;
    //   newY = y - deltaY / 2;
    // }
    if (deltaX > -deltaY) {
      width += deltaY * aspectRatio;
      height += deltaY;
      newX = x - deltaY * aspectRatio / 2;
      newY = y - deltaY / 2;
    } else {
      height -= deltaX * (1 / aspectRatio);
      width -= deltaX;
      newX = x + deltaX / 2;
      newY = y + deltaX * (1 / aspectRatio) / 2;
    }
  } // height = Math.max(height, width);
  // width = Math.max(height, width);


  return {
    width: width,
    height: height,
    x: newX,
    y: newY,
    rotation: rotation
  };
}
function getBoundingBoxFromOrientation(_ref) {
  var x = _ref.x,
      y = _ref.y,
      width = _ref.width,
      height = _ref.height;
  return {
    minX: x,
    minY: y,
    maxX: x + width,
    maxY: y + height
  };
}
function computeDelta(oldOrientation, newOrientation) {
  var deltaX = 0,
      deltaY = 0;
  var oldBB = getBoundingBoxFromOrientation(oldOrientation);
  var newBB = getBoundingBoxFromOrientation(newOrientation);

  if (oldBB.minX !== newBB.minX) {
    deltaX = newBB.minX - oldBB.minX;
  }

  if (oldBB.minY !== newBB.minY) {
    deltaY = newBB.minY - oldBB.minY;
  }

  if (oldBB.maxX !== newBB.maxX) {
    deltaX = newBB.maxX - oldBB.maxX;
  }

  if (oldBB.maxY !== newBB.maxY) {
    deltaY = newBB.maxY - oldBB.maxY;
  }

  return {
    x: deltaX,
    y: deltaY
  };
}
function getGradientString(gradient, palette) {
  var colors = [];

  if (palette) {
    forEach(palette, function (data, index) {
      colors.push(data.color);
    });
  } else {
    forEach(gradient.stops, function (data, index) {
      colors.push(data.stopColor);
    });
  }

  var vector;

  if (gradient.to && gradient.from) {
    vector = {
      x: gradient.to.x - gradient.from.x,
      y: gradient.to.y - gradient.from.y
    };
  } else {
    vector = {
      x: 0,
      y: 2
    };
  }

  var angleRad = Math.atan2(vector.y, vector.x);
  var angleDeg = angleRad * 180 / Math.PI + 90;
  var realLocations = [];

  if (palette) {
    forEach(palette, function (data, index) {
      realLocations.push(data.pos);
    });
  } else {
    forEach(gradient.stops, function (data, index) {
      realLocations.push(data.offset);
    });
  }

  var colorStrings = colors.map(function (color, i) {
    return color + " " + Math.round(realLocations[i] * 100) + "%";
  }).join(', ');

  if (gradient.gradientType && gradient.gradientType === 'LinearGradient') {
    return "linear-gradient(" + angleDeg + "deg, " + colorStrings + ")";
  } else if (gradient.gradientType && gradient.gradientType === 'RadialGradient') {
    var dist = Math.sqrt((gradient.to.x - gradient.from.x) * (gradient.to.x - gradient.from.x) + (gradient.to.y - gradient.from.y) * (gradient.to.y - gradient.from.y));
    var maxDist = Math.sqrt((1 - gradient.from.x) * (1 - gradient.from.x) + (1 - gradient.from.y) * (1 - gradient.from.y));
    var radialColorStrings = colors.map(function (color, i) {
      return color + " " + Math.round(realLocations[i] * (dist / maxDist) * 100) + "%";
    }).join(', ');
    return "radial-gradient(circle at " + gradient.from.x * 100 + "% " + gradient.from.y * 100 + "%," + radialColorStrings + ")";
  } else if (gradient.gradientType && gradient.gradientType === 'AngularGradient') {
    return "conic-gradient(" + colorStrings + ")";
  } else {
    return "linear-gradient(" + angleDeg + "deg, " + colorStrings + ")";
  }
}

function getHandlePoint(box, handle) {
  if (handle) {
    var point = [box.x + box.width / 2, box.y];

    switch (handle) {
      case 'ROTATETL':
        point = [box.x, box.y];
        break;

      case 'ROTATETR':
        point = [box.x + box.width, box.y];
        break;

      case 'ROTATEL':
        point = [box.x, box.y + box.height / 2];
        break;

      case 'ROTATER':
        point = [box.x + box.width, box.y + box.height / 2];
        break;

      case 'ROTATEBL':
        point = [box.x, box.y + box.height];
        break;

      case 'ROTATEB':
        point = [box.x + box.width / 2, box.y + box.height];
        break;

      case 'ROTATEBR':
        point = [box.x + box.width, box.y + box.height];
        break;
    }

    return point;
  } else return [box.x + box.width / 2, box.y - 28];
}

function getQuotient(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) > 0 ? -1 : 1;
}

function calculateRotation(startValues, session, oldRotation, delta, handle) {
  var deltaInput = {
    x: session.current.x - session.start.x,
    y: session.current.y - session.start.y
  };

  if (delta) {
    deltaInput = delta;
  }

  var rotation = oldRotation ? oldRotation : startValues.rotation;
  var point1 = getHandlePoint(startValues, handle);
  var polygon = ModelUtils.getPointsFromBoundingBox(startValues);
  var centroid = ModelUtils.getCentroid(polygon);
  var point3 = [point1[0] + deltaInput.x, point1[1] + deltaInput.y];
  var angle = ModelUtils.findAngle(point1, centroid, point3, 180);
  angle = rotation + angle * getQuotient(point1, centroid, point3);
  return angle;
}
function getNewLayout(startValues, session, handle) {
  var newLayout;
  var deltaX = session.current.deltaX;
  var deltaY = session.current.deltaY;

  if (handle.indexOf('ROTATE') !== -1) {
    var rotation = calculateRotation(startValues, session, undefined, undefined, handle);
    newLayout = _extends({}, startValues, {
      rotation: rotation
    });
  } else {
    if (handle === 'C') {
      var rotateDelta = ModelUtils.rotatePoint([deltaX, deltaY], startValues.rotation, [0, 0]);
      deltaX = rotateDelta[0];
      deltaY = rotateDelta[1];
      newLayout = computeOrientationWithDelta(startValues, {
        x: deltaX,
        y: deltaY
      }, handle);
    } else {
      newLayout = computeOrientationWithDelta(startValues, {
        x: deltaX,
        y: deltaY
      }, handle);
    }
  }

  if (newLayout.height === 0) {
    newLayout.height = 0;
  }

  if (newLayout.width === 0) {
    newLayout.width = 0;
  }

  return newLayout;
}
function generateRandomString(length) {
  var result = '';
  var characters = 'ABCDEFGHIJKLMNPQRSTUVWXYZabcdefghijklmnpqrstuvwxyz';

  for (var i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }

  return result;
}

var EventCallableRegsitry = /*#__PURE__*/function () {
  function EventCallableRegsitry() {
    this.registry = new Map();
  }

  var _proto = EventCallableRegsitry.prototype;

  _proto.addEventListener = function addEventListener(name, callback) {
    var callbacks = this.registry.get(name);

    if (callbacks) {
      callbacks.push(callback);
    } else {
      this.registry.set(name, [callback]);
    }
  };

  _proto.removeEventListener = function removeEventListener(name, callback) {
    var callbacks = this.registry.get(name);

    if (callbacks) {
      var indexOf = callbacks.indexOf(callback);

      if (indexOf > -1) {
        callbacks.splice(indexOf, 1);
      }
    }
  };

  _proto.dispatchEvent = function dispatchEvent(name, event) {
    // @ts-ignore
    if (window['debug']) {
      console.log('DEBUG::', 'Event:', name);
    }

    var callbacks = this.registry.get(name);

    for (var i in callbacks) {
      callbacks[i](event);
      if (!event.propagate) break;
    }
  };

  return EventCallableRegsitry;
}();

var KeyValueContainer = /*#__PURE__*/function (_Model) {
  _inheritsLoose(KeyValueContainer, _Model);

  function KeyValueContainer() {
    var _this;

    _this = _Model.apply(this, arguments) || this;
    _this.data = {};
    return _this;
  }

  var _proto = KeyValueContainer.prototype;

  _proto.getFields = function getFields() {
    return {
      data: types.literal
    };
  };

  _proto.isValidKey = function isValidKey(key) {
    return true;
  };

  _proto.set = function set$1(key, value) {
    if (typeof key == 'object') {
      for (var prop in key) {
        if (this.isValidKey(prop)) {
          set(this.data, prop, key[prop]); // this.data[prop] = (key as any)[prop];

        } else {
          throw new Error("Model KeyValueContainer Error: Invalid key '" + prop + "'");
        }
      }
    } else {
      if (this.isValidKey(key)) {
        set(this.data, key, value); // this.data[key] = value;

      } else {
        throw new Error("Model KeyValueContainer Error: Invalid key '" + key + "'");
      }
    }
  };

  _proto.get = function get$1(key) {
    return get(this.data, key);
  };

  _proto.getAll = function getAll() {
    return this.data;
  };

  _proto.remove = function remove(key) {
    if (typeof key === 'string' && !isNil(this.data[key])) {
      delete this.data[key];
    } else if (typeof key == 'object' && Array.isArray(key)) {
      for (var i = 0; i < key.length; i++) {
        if (key[i] && this.isValidKey(key[i])) {
          delete this.data[key[i]];
        } else {
          throw new Error("Model KeyValueContainer Error: Invalid key '" + key[i] + "'");
        }
      }
    }
  };

  return KeyValueContainer;
}(Model);

var Style = /*#__PURE__*/function (_KeyValueContainer) {
  _inheritsLoose(Style, _KeyValueContainer);

  function Style() {
    return _KeyValueContainer.apply(this, arguments) || this;
  }

  return Style;
}(KeyValueContainer);

var Props = /*#__PURE__*/function (_KeyValueContainer) {
  _inheritsLoose(Props, _KeyValueContainer);

  function Props() {
    return _KeyValueContainer.apply(this, arguments) || this;
  }

  return Props;
}(KeyValueContainer);

var Layout = /*#__PURE__*/function (_KeyValueContainer) {
  _inheritsLoose(Layout, _KeyValueContainer);

  function Layout() {
    var _this;

    _this = _KeyValueContainer.apply(this, arguments) || this;
    _this.validKeys = ['left', 'right', 'width', 'top', 'bottom', 'height', 'position', 'flex', 'flexDirection', 'marginLeft', 'marginRight', 'marginBottom', 'marginTop', 'margin', 'border', 'justifyContent', 'alignItems', 'flexWrap', 'borderColor', 'borderStyle', 'borderLeftWidth', 'borderRightWidth', 'borderBottomWidth', 'borderTopWidth', 'borderWidth', 'alignSelf', 'alignContent', 'paddingLeft', 'paddingRight', 'paddingBottom', 'paddingTop', 'padding', 'lineHeight', 'transform', 'fontSize', 'fontFamily', 'fontWeight', 'fontStyle', 'fontPostscriptName', 'letterSpacing'];
    return _this;
  }

  var _proto = Layout.prototype;

  _proto.isValidKey = function isValidKey(key) {
    return this.validKeys.indexOf(key) !== -1;
  };

  return Layout;
}(KeyValueContainer);

var Event = /*#__PURE__*/function () {
  function Event(name, target, currentTarget) {
    this.name = name;
    this.target = target;
    this.currentTarget = currentTarget;
    this._propagate = true;
    this._defaults = true;
  }

  var _proto = Event.prototype;

  _proto.stopPropagation = function stopPropagation() {
    this._propagate = false;
  };

  _proto.preventDefault = function preventDefault() {
    this._defaults = false;
  };

  _createClass(Event, [{
    key: "propagate",
    get: function get() {
      return this._propagate;
    }
  }, {
    key: "defaults",
    get: function get() {
      return this._defaults;
    }
  }]);

  return Event;
}();

var SetLayoutEvent = /*#__PURE__*/function (_Event) {
  _inheritsLoose(SetLayoutEvent, _Event);

  function SetLayoutEvent(name, target, currentTarget) {
    return _Event.call(this, name, target, currentTarget) || this;
  }

  return SetLayoutEvent;
}(Event);

var RemoveChildEvent = /*#__PURE__*/function (_Event) {
  _inheritsLoose(RemoveChildEvent, _Event);

  function RemoveChildEvent(name, layer, payload, currentTarget) {
    var _this;

    _this = _Event.call(this, name, payload, currentTarget) || this;
    _this.payload = payload;
    _this.layer = layer;
    return _this;
  }

  return RemoveChildEvent;
}(Event);

var GlobalLayerUpdateController = /*#__PURE__*/function () {
  function GlobalLayerUpdateController() {
    var _this = this;

    this.layerMap = new Map();
    this.shouldBatch = [];
    this.updateLayoutCount = 0;
    this.updateChildrenLayoutCount = 0;
    this.rerenderCount = 0;

    this.shouldAddToBatch = function () {
      return last(_this.shouldBatch);
    };

    this.stopChildrenLayoutUpdates = function () {
      _this.updateChildrenLayoutCount++;
    };

    this.startChildrenLayoutUpdates = function () {
      _this.updateChildrenLayoutCount--;
    };

    this.stopRerender = function () {
      _this.rerenderCount++;
    };

    this.startRerender = function () {
      _this.rerenderCount--;
    };

    this.stopAndBatchLayoutUpdates = function () {
      if (_this.shouldAddToBatch() === false) {
        _this.shouldBatch.push(false);
      } else {
        _this.shouldBatch.push(true);
      }

      _this.updateLayoutCount++;
    };

    this.stopAndForgetLayoutUpdates = function () {
      _this.shouldBatch.push(false);

      _this.updateLayoutCount++;
    };

    this.resumeLayoutUpdates = function () {
      _this.updateLayoutCount--;

      if (_this.updateLayoutCount === 0) {
        _this.layerMap.forEach(function (value, layer) {
          layer.setYogaAfterBatch();
          layer.onUpdateDom();
        });

        _this.shouldBatch = [];

        _this.layerMap.clear();
      }
    };
  }

  _createClass(GlobalLayerUpdateController, [{
    key: "updateLayout",
    get: function get() {
      return this.updateLayoutCount === 0 ? true : false;
    }
  }, {
    key: "updateChildrenLayout",
    get: function get() {
      return this.updateChildrenLayoutCount === 0 ? true : false;
    }
  }, {
    key: "rerender",
    get: function get() {
      return this.rerenderCount === 0 ? true : false;
    }
  }]);

  return GlobalLayerUpdateController;
}();

var globalLayerUpdateController = /*#__PURE__*/new GlobalLayerUpdateController();
var stopChildrenLayoutUpdates = globalLayerUpdateController.stopChildrenLayoutUpdates;
var startChildrenLayoutUpdates = globalLayerUpdateController.startChildrenLayoutUpdates;
var stopRerender = globalLayerUpdateController.stopRerender;
var startRerender = globalLayerUpdateController.startRerender;
var stopAndBatchLayoutUpdates = globalLayerUpdateController.stopAndBatchLayoutUpdates;
var stopAndForgetLayoutUpdates = globalLayerUpdateController.stopAndForgetLayoutUpdates;
var resumeLayoutUpdates = globalLayerUpdateController.resumeLayoutUpdates;

window['ReactDOM'] = ReactDOM__default;
var Layer = /*#__PURE__*/function (_Model) {
  _inheritsLoose(Layer, _Model);

  function Layer(canvas) {
    var _this;

    _this = _Model.call(this) || this;
    _this._thirdParty = false;
    _this._dragging = false;
    _this._eventCallableRegistry = new EventCallableRegsitry();
    _this._id = v4();

    _this.setAspectRatio = function (val) {
      _this._aspectRatio = val;
    };

    _this.setDomRef = function (ref) {
      _this._dom = ref;
    };

    _this.setDragging = function (dragging) {
      _this._dragging = dragging;
    };

    _this.setCollisionScope = function (scope) {
      if (_this._locked) ;

      _this._collisionScope = scope;
    };

    _this.emitLayoutChanges = function () {
      var setLayoutEvent = new SetLayoutEvent('setLayoutEvent', _assertThisInitialized(_this));

      if (globalLayerUpdateController.updateChildrenLayout) {
        if (_this.isFlexChild()) {
          if (_this.parent) {
            _this.setChildrenLayout(_this.parent);
          }
        } else {
          _this.setChildrenLayout(_assertThisInitialized(_this));
        }
      }

      if (globalLayerUpdateController.rerender) {
        if (!_this._dragging) {
          action(function () {
            _this.emit('layout');
          });
        } else {
          if (globalLayerUpdateController.updateLayout) {
            _this.onUpdateDom();
          }
        }
      }

      _this.dispatchEvent('setLayout', setLayoutEvent);
    };

    _this.onUpdateDom = function () {
      var style = _this.layout.getAll();

      if (_this._dom) {
        if (_this._dom.setNativeProps) {
          var updatedStyle = _extends({}, style);

          if (updatedStyle['textDecorationLine']) {
            updatedStyle = _extends({}, updatedStyle, {
              textDecoration: updatedStyle['textDecorationLine']
            });
          }

          _this._dom.setNativeProps({
            style: updatedStyle
          });
        } else {
          try {
            var dom = ReactDOM__default.findDOMNode(_this._dom);

            if (dom) {
              var attributes = ['top', 'left', 'width', 'height', 'right', 'bottom'];
              forEach(style, function (value, key) {
                if (attributes.indexOf(key) !== -1) {
                  dom.style[key] = typeof value === 'string' ? value : value + "px";
                } else if (key === 'transform') {
                  var transform = get(value, '0.rotate');

                  if (!isNil(transform)) {
                    dom.style[key] = "rotate(" + transform + ")";
                  }
                }
              });
            }
          } catch (Error) {//
          }
        }

        action(function () {
          _this.emit('updateDom');
        });
      }
    };

    _this.getDimensions = function (dims, container) {
      var x = dims.x ? dims.x : 0;
      var y = dims.y ? dims.y : 0;
      var width = dims.width ? dims.width : 0;
      var height = dims.height ? dims.height : 0;
      var containerWidth = container.width;
      var containerHeight = container.height;
      var dimensions = {
        left: {
          percent: undefined,
          number: undefined
        },
        right: {
          percent: undefined,
          number: undefined
        },
        top: {
          percent: undefined,
          number: undefined
        },
        bottom: {
          percent: undefined,
          number: undefined
        },
        width: {
          percent: undefined,
          number: undefined
        },
        height: {
          percent: undefined,
          number: undefined
        }
      };
      dimensions.left.number = x;
      dimensions.left.percent = Math.round(dimensions.left.number / containerWidth * 100 * 100) / 100 + '%';
      dimensions.right.number = containerWidth - (x + width);
      dimensions.right.percent = Math.round(dimensions.right.number / containerWidth * 100 * 100) / 100 + '%';
      dimensions.width.number = width;
      dimensions.width.percent = Math.round(dimensions.width.number / containerWidth * 100 * 100) / 100 + '%';
      dimensions.top.number = y;
      dimensions.top.percent = Math.round(dimensions.top.number / containerHeight * 100 * 100) / 100 + '%';
      dimensions.bottom.number = containerHeight - (y + height);
      dimensions.bottom.percent = Math.round(dimensions.bottom.number / containerHeight * 100 * 100) / 100 + '%';
      dimensions.height.number = height;
      dimensions.height.percent = Math.round(dimensions.height.number / containerHeight * 100 * 100) / 100 + '%';
      return dimensions;
    };

    _this._name = 'layer';
    _this._type = 'view';
    _this._parent = null;
    _this._props = new Props();
    _this._children = [];
    _this._style = new Style();
    _this._layout = new Layout();
    _this._collisionScope = null;
    var config = yoga.Config.create();
    config.setPointScaleFactor(0);
    _this._yogaNode = yoga.Node.create(config);

    _this._yogaNode.setType(_this._type);

    var layout = _this._layout.toJS();

    _this._locked = false;
    _this._visible = true;
    _this._aspectRatio = undefined;
    _this._preservedProperties = {
      locked: false,
      opacity: 1,
      hidden: false
    }; // this._yogaNode.setProps(layout.data);

    _this._dims = {
      x: 0,
      y: 0,
      height: 0,
      width: 0,
      rotation: 0
    }; // this._domDims = {
    //   x: 0,
    //   y: 0,
    //   height: 0,
    //   width: 0,
    //   rotation: 0,
    // };

    _this._mouseProps = {}; //@ts-ignore

    _this._canvas = canvas || _assertThisInitialized(_this);

    _this.addEventListener('domDidMount', function (event) {
      event.stopPropagation(); // this._dom = event.target;

      _this._thirdParty = true;

      _this.setYoga();
    });

    _this.addEventListener('domDidUpdate', function (event) {
      event.stopPropagation(); // this._dom = event.target;

      _this._thirdParty = true;

      _this.setYoga();
    });

    return _this;
  }

  var _proto = Layer.prototype;

  _proto.getDomBoundingBox = function getDomBoundingBox(dom, rotation) {
    var left = 0;
    var top = 0;
    var width = 0;
    var height = 0;

    if (dom) {
      left = dom.offsetLeft;
      top = dom.offsetTop;
      width = dom.offsetWidth;
      height = dom.offsetHeight;

      if (isNil(left) || isNil(top) || isNil(width) || isNil(height)) {
        var clientRect = dom.getBoundingClientRect();
        left = clientRect.left;
        top = clientRect.top;
        width = clientRect.width;
        height = clientRect.height;
        var parentDom = dom.parentElement;

        while (parentDom && parentDom.getAttribute('data-virtual') === 'true') {
          parentDom = parentDom.parentElement;
        }

        if (parentDom) {
          var parentClientRect = dom.getBoundingClientRect();
          left = left - parentClientRect.left;
          top = top - parentClientRect.top;
        }
      }
    }

    var rect = {
      top: top,
      left: left,
      width: width,
      height: height
    };
    return rect;
  };

  _proto.updateDomainCompileDimensions = function updateDomainCompileDimensions(ref) {
    if (this.isAutoHeight() || this.isAutoWidth()) {
      try {
        var dom = ReactDOM__default.findDOMNode(ref);

        var dims = _extends({}, this.getDomBoundingBox(dom, 0));

        var width = this.style.get('width') ? this.style.get('width') : dims.width;
        var height = this.style.get('height') ? this.style.get('height') : dims.height;
        this._domDims = {
          width: width,
          height: height,
          x: dims.left,
          y: dims.top,
          rotation: 0
        };
      } catch (Error) {
        // console.error(Error);
        this._domDims = undefined;
      }
    } else {
      this._domDims = undefined;
    }
  };

  _proto.getCanvas = function getCanvas() {
    return this._canvas;
  };

  _proto.getFields = function getFields() {
    return {
      type: types.literal,
      props: Props,
      style: Style,
      layout: Layout
    };
  };

  _proto.setSelectable = function setSelectable(val) {
    if (val) {
      this.unlock();
    } else {
      this.lock();
    }
  };

  _proto.getBoundingClientRect = function getBoundingClientRect() {
    var dims = _extends({}, this._dims);

    if (this.parent) {
      dims.x = dims.x - this.parent.getBorderLeft();
      dims.y = dims.y - this.parent.getBorderTop();
    }

    return _extends({}, dims, {
      rootX: this.rootX,
      rootY: this.rootY
    });
  };

  _proto.getBounds = function getBounds() {
    return this._dims;
  };

  _proto.getMarginLeft = function getMarginLeft() {
    var margin = this.layout.get('marginLeft');

    if (!margin) {
      margin = this.layout.get('margin');
    }

    if (isNil(margin)) {
      margin = 0;
    }

    return margin;
  };

  _proto.getMarginTop = function getMarginTop() {
    var margin = this.layout.get('marginTop');

    if (!margin) {
      margin = this.layout.get('margin');
    }

    if (isNil(margin)) {
      margin = 0;
    }

    return margin;
  };

  _proto.getPaddingLeft = function getPaddingLeft() {
    var padding = this.layout.get('paddingLeft');

    if (!padding) {
      padding = this.layout.get('padding');
    }

    if (isNil(padding)) {
      padding = 0;
    }

    return padding;
  };

  _proto.getPaddingTop = function getPaddingTop() {
    var padding = this.layout.get('paddingTop');

    if (!padding) {
      padding = this.layout.get('padding');
    }

    if (isNil(padding)) {
      padding = 0;
    }

    return padding;
  };

  _proto.getBorderLeft = function getBorderLeft() {
    return this.yogaNode.getComputedBorder(yoga.EDGE_LEFT);
  };

  _proto.getBorderTop = function getBorderTop() {
    return this.yogaNode.getComputedBorder(yoga.EDGE_TOP);
  } // DOC: Layer ops
  ;

  _proto.setType = function setType(type) {
    var _this2 = this;

    if (this._locked) ;

    this._type = type;
    this.yogaNode.setType(type);
    action(function () {
      _this2.emit('type');
    });
  };

  _proto.removeProp = function removeProp(key) {
    var _this3 = this;

    if (key) {
      var _extends2;

      this._props.remove(key);

      var yogaProps = _extends({}, this._yogaNode.props, (_extends2 = {}, _extends2[key] = undefined, _extends2));

      this._yogaNode.setProps(yogaProps);

      this.setYoga();
    } else {
      this._props = new Props();
    }

    action(function () {
      _this3.emit('style');
    });
  };

  _proto.setProp = function setProp(key, value) {
    var _extends3,
        _this4 = this;

    if (this._locked) ;

    this._props.set(key, value);

    var yogaProps = _extends({}, this._yogaNode.props, (_extends3 = {}, _extends3[key] = value, _extends3));

    this._yogaNode.setProps(yogaProps);

    action(function () {
      _this4.emit('props');
    });
    this.setYoga();
  };

  _proto.lock = function lock() {
    var _this5 = this;

    this._locked = true;
    action(function () {
      _this5.emit('locked');
    });
  };

  _proto.unlock = function unlock() {
    var _this6 = this;

    this._locked = false;
    action(function () {
      _this6.emit('locked');
    });
  };

  _proto.show = function show() {
    if (this._preservedProperties.hidden // Only apply show operations when the layer was hidden manually, prevents, applying uninteded default values in case show() is called without ever calling hide() first
    ) {
        this.children.forEach(function (child) {
          return child.show();
        });
        this._visible = true;
        this.unlock();
        this.setStyle('opacity', this._preservedProperties.opacity);

        if (this._preservedProperties.locked) {
          this.lock();
        }

        this._preservedProperties.hidden = false;
      }
  };

  _proto.hide = function hide(noShow) {
    if (!this._preservedProperties.hidden) {
      this._visible = false;
      this._preservedProperties = {
        opacity: this._style.get('opacity'),
        locked: this._locked,
        hidden: true
      };
      this.setStyle('opacity', 0);
      this.lock();
      this.children.forEach(function (child) {
        return child.hide();
      });
    }
  };

  _proto.setName = function setName(name) {
    if (this._locked) ;

    this._name = name;
  };

  _proto.setStyle = function setStyle(key, value) {
    var _this7 = this;

    if (this._locked) ;

    if (key === 'gradient') {
      this._style.set(key, value);

      if (!value) {
        this._style.set('backgroundImage', '');
      } else {
        this._style.set('backgroundImage', getGradientString(value));
      }
    } else {
      this._style.set(key, value);
    }

    action(function () {
      _this7.emit('style');
    });
  };

  _proto.setParent = function setParent(layer) {
    this._parent = layer;
  };

  _proto.executeFunction = function executeFunction(name) {
    var parent;
    var layer = this;

    while (layer.name !== 'canvas' && layer.parent) {
      layer = layer.parent;
    } // @ts-ignore


    parent = layer;

    if (parent) {
      var _parent$functionRegis;

      var context = {
        layer: this,
        canvas: parent
      };

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return (_parent$functionRegis = parent.functionRegistry).executeFunction.apply(_parent$functionRegis, [name, context].concat(args));
    } else {
      return new Promise(function (resolve, reject) {
        return reject('The layer doesnot belong to a canvas.');
      });
    }
  };

  _proto.addChild = function addChild(layer, index) {
    var _this8 = this;

    if (this._locked) ;

    layer.setParent(this);
    layer.setCollisionScope(this._collisionScope);

    if (!isNil(index)) {
      this._children.splice(index, 0, layer);
    } else {
      this._children.push(layer);
    }

    layer.addYogaNode(index);
    layer.setCollisionNode();
    this.calculateLayout(); // if (this._domDims) {
    //   this.yogaNode.setHeight(this._domDims.height);
    //   this.yogaNode.setWidth(this._domDims.width);
    // }

    this.setYoga();
    action(function () {
      _this8.emit('children');
    });
  };

  _proto.removeChild = function removeChild(layer) {
    var _this9 = this;

    if (this._locked) ;

    layer.removeCollisionNode();

    var index = this._children.indexOf(layer);

    if (index !== -1) {
      var removeChildEvent = new RemoveChildEvent('removeChild', layer);

      if (layer.parent) {
        layer.parent.dispatchEvent('removeChild', removeChildEvent);
      }

      this._children.splice(index, 1);

      this._yogaNode.removeChild(layer.yogaNode);

      layer.setCollisionScope(null);
      this.calculateLayout(); // this.setDims();

      if (layer.isFlexChild()) {
        if (layer.parent) {
          layer.parent.children.forEach(function (child) {
            child.setDims();
            child.setCollisionNode();
          });
        }
      }

      action(function () {
        _this9.emit(['children', 'yogaNode']);
      });
    }
  };

  _proto.move = function move(newParent, newIndex) {
    if (this._parent) {
      this._parent.removeChild(this);
    }

    newParent.addChild(this, newIndex);
    newParent.children.forEach(function (child) {
      if (child.isFlexChild()) {
        child.setYoga();
      }
    });
  } // DOC: Yoga ops
  ;

  _proto.getRootLayer = function getRootLayer(node) {
    if (!node) {
      node = this;
    }

    if (node.type === 'canvas') {
      return node;
    }

    if (!node || !node.parent) {
      return undefined;
    }

    return this.getRootLayer(node.parent);
  };

  _proto.addYogaNode = function addYogaNode(index) {
    var parentLayer = this.parent;

    if (parentLayer && parentLayer._yogaNode) {
      if (parentLayer._yogaNode.getChildCount) {
        if (isNil(index)) {
          index = parentLayer.yogaNode.getChildCount();
        }

        if (!isNil(index)) {
          if (parentLayer._yogaNode.insertChild) {
            parentLayer._yogaNode.insertChild(this._yogaNode, index);
          }
        }
      }
    }
  };

  _proto.getComputedLayout = function getComputedLayout() {
    return this._yogaNode.getComputedLayout();
  };

  _proto.calculateLayout = function calculateLayout() {
    // if (this._locked) {
    //   return;
    // }
    var rootLayer = this.getRootLayer();

    if (rootLayer && rootLayer.yogaNode) {
      rootLayer.yogaNode.calculateLayout(yoga.UNDEFINED, yoga.UNDEFINED, yoga.DIRECTION_LTR);
    } else {
      this.yogaNode.calculateLayout(yoga.UNDEFINED, yoga.UNDEFINED, yoga.DIRECTION_LTR);
    }

    return this.getComputedLayout();
  };

  _proto.isFlexChild = function isFlexChild() {
    var elementType = this._layout.get('position');

    if (elementType && elementType === 'absolute') {
      return false;
    } else {
      return true;
    }
  };

  _proto.getTotalFlexOfFlexChildren = function getTotalFlexOfFlexChildren() {
    var sumOfFlex = 0;
    this.children.forEach(function (child, index) {
      var layerFlex = child.getFlexValue();

      if (layerFlex !== undefined) {
        sumOfFlex += layerFlex;
      }
    });
    return sumOfFlex;
  };

  _proto.getParentLayerFlexDirection = function getParentLayerFlexDirection() {
    var parentLayer; // TODO: heavy jugaad

    try {
      parentLayer = this.parent;
    } catch (err) {
      console.log(err);
    }

    if (!parentLayer) {
      return 'column';
    }

    var flexDirection = parentLayer.layout.get('flexDirection');
    return flexDirection ? flexDirection : 'column';
  };

  _proto.isAutoWidth = function isAutoWidth() {
    var position = this.layout.get('position');
    var property = this.layout.get('width');

    if (!isNil(property)) {
      return false;
    }

    if (position === 'absolute') {
      var left, right;
      left = this.layout.get('left');
      right = this.layout.get('right');

      if (!isNil(left) && !isNil(right)) {
        return false;
      } else {
        return true;
      }
    } else {
      var flexDirection = this.getParentLayerFlexDirection();

      if (!flexDirection) {
        return false;
      }

      if (flexDirection === 'row') {
        // Main axis
        var flex = this.layout.get('flex');

        if (isNil(flex) || isNaN(flex)) {
          return true;
        } else {
          return false;
        }
      } else {
        // Cross axis
        var _flex = this.layout.get('flex');

        var alignSelf = this.layout.get('alignSelf');

        if ((isNil(_flex) || isNaN(_flex)) && alignSelf !== 'stretch') {
          return true;
        } else {
          return false;
        }
      }
    }
  };

  _proto.isAutoHeight = function isAutoHeight() {
    var position = this.layout.get('position');
    var property = this.layout.get('height');

    if (!isNil(property)) {
      return false;
    }

    if (position === 'absolute') {
      var top, bottom;
      top = this.layout.get('top');
      bottom = this.layout.get('bottom');

      if (!isNil(top) && !isNil(bottom)) {
        return false;
      } else {
        return true;
      }
    } else {
      var flexDirection = this.getParentLayerFlexDirection();

      if (!flexDirection) {
        return false;
      }

      if (flexDirection !== 'row') {
        // Main axis
        var flex = this.layout.get('flex');

        if (isNil(flex) || isNaN(flex)) {
          return true;
        } else {
          return false;
        }
      } else {
        // Cross axis
        var alignSelf = this.layout.get('alignSelf');

        var _flex2 = this.layout.get('flex');

        if ((isNil(_flex2) || isNaN(_flex2)) && alignSelf !== 'stretch') {
          return true;
        } else {
          return false;
        }
      }
    }
  };

  _proto.isFillWidth = function isFillWidth() {
    var position = this.layout.get('position');
    var property = this.layout.get('width');

    if (!isNil(property)) {
      return false;
    }

    if (position === 'absolute') {
      var left, right;
      left = this.layout.get('left');
      right = this.layout.get('right');

      if (!isNil(left) && !isNil(right)) {
        return true;
      } else {
        return false;
      }
    } else {
      var flexDirection = this.getParentLayerFlexDirection();

      if (!flexDirection) {
        return false;
      }

      if (flexDirection.indexOf('row') !== -1) {
        // Main axis
        var flex = this.layout.get('flex');

        if (flex > 0) {
          return true;
        } else {
          return false;
        }
      } else {
        // Cross axis
        var alignSelf = this.layout.get('alignSelf');

        if (!alignSelf || alignSelf === 'stretch') {
          return true;
        } else {
          return false;
        }
      }
    }
  };

  _proto.isFillHeight = function isFillHeight() {
    var position = this.layout.get('position');
    var property = this.layout.get('height');

    if (!isNil(property)) {
      return false;
    }

    if (position === 'absolute') {
      var top, bottom;
      top = this.layout.get('top');
      bottom = this.layout.get('bottom');

      if (!isNil(top) && !isNil(bottom)) {
        return true;
      } else {
        return false;
      }
    } else {
      var flexDirection = this.getParentLayerFlexDirection();

      if (!flexDirection) {
        return false;
      }

      if (flexDirection.indexOf('column') !== -1) {
        var flex = this.layout.get('flex');

        if (flex > 0) {
          return true;
        } else {
          return false;
        }
      } else {
        var alignSelf = this.layout.get('alignSelf');

        if (!alignSelf || alignSelf === 'stretch') {
          return true;
        } else {
          return false;
        }
      }
    }
  };

  _proto.getFlexValue = function getFlexValue() {
    var flexGrow = this.layout.get('flexGrow');
    var flex = this.layout.get('flex');
    return flexGrow ? flexGrow : flex;
  };

  _proto.getSiblingsWithFlex = function getSiblingsWithFlex() {
    var _this10 = this;

    var siblingsWithFlex = new Array();
    var isFillWidth = this.isFillWidth();
    var isFillHeight = this.isFillHeight();

    if (this.parent instanceof Layer) {
      this.parent.children.forEach(function (childLayer, index) {
        var flex = _this10.getFlexValue();

        if (flex && _this10 !== childLayer) {
          if (childLayer.isFillWidth() === isFillWidth && childLayer.isFillHeight() === isFillHeight) {
            siblingsWithFlex.push(childLayer);
          }
        }
      });
    }

    return siblingsWithFlex;
  };

  _proto.setYoga = function setYoga() {
    // if (this._locked) {
    //   return;
    // }
    if (globalLayerUpdateController.updateLayout) {
      this.setYogaAfterBatch();
    } else if (globalLayerUpdateController.shouldAddToBatch()) {
      globalLayerUpdateController.layerMap.set(this, true);
    }
  };

  _proto.setYogaAfterBatch = function setYogaAfterBatch() {
    var _this11 = this;

    var layout = this._layout.toJS();

    var yogaProps = _extends({}, this._yogaNode.props, {
      style: layout.data
    });

    this._yogaNode.setProps(yogaProps);

    this._yogaNode.updateNode(layout.data);

    if (this._thirdParty) {
      this.updateDomainCompileDimensions(this._dom);

      if (this._domDims) {
        this.yogaNode.setHeight(this._domDims.height);
        this.yogaNode.setWidth(this._domDims.width);
      }
    }

    this.calculateLayout();
    this.setDims();
    this.setCollisionNode(); // handle for special case

    if (globalLayerUpdateController.rerender) {
      action(function () {
        _this11.emit('yoga');
      });
    }
  };

  _proto.setChildrenLayout = function setChildrenLayout(layer) {
    var _this12 = this;

    // if (this._locked) {
    //   return;
    // }
    layer.children.forEach(function (child) {
      child.setYoga();

      _this12.setChildrenLayout(child);
    });
  };

  _proto.setLayout = function setLayout(key, value) {
    if (!this.parent && this.type !== 'canvas') {
      throw new Error('setLayout cannot be called on an orphan layer. Use addChild to add it to another layer first.');
    }

    if (this._locked) ;

    this._layout.set(key, value);

    this.setYoga();
    this.emitLayoutChanges();
  };

  _proto.recalculateLayout = function recalculateLayout() {
    this.setYoga();
    this.emitLayoutChanges();
  };

  _proto.removeLayout = function removeLayout(key) {
    // if (key && !this._layout.isValidKey(key)) {
    //   return;
    // }
    if (key) {
      this._layout.remove(key);
    } else {
      this._layout = new Layout();
    }

    this.setYoga();
    this.emitLayoutChanges();
  };

  _proto.removeStyle = function removeStyle(key) {
    var _this13 = this;

    if (key) {
      this._style.remove(key);
    } else {
      this._style = new Style();
    }

    action(function () {
      _this13.emit('style');
    });
  };

  _proto.isValidLayoutKey = function isValidLayoutKey(key) {
    return this._layout.isValidKey(key);
  };

  _proto.setViewport = function setViewport(key, value) {
    var _this14 = this;

    if (this._locked) ;

    this._layout.set(key, value);

    var layout = this._layout.toJS();

    this._yogaNode.setProps(_extends({}, this._yogaNode.props, {
      style: layout.data
    }));

    this._yogaNode.updateNode(layout.data);

    this.calculateLayout();
    this.setDims();
    action(function () {
      _this14.emit(['layout', 'yogaNode']);
    });
  };

  _proto.setDims = function setDims() {
    var dims = this._yogaNode.getComputedLayout();

    this._dims = {
      x: dims.left,
      y: dims.top,
      height: dims.height || 0,
      width: dims.width || 0,
      rotation: this.rotation
    }; // if (this._yogaNode.parent) {
    //   this._dims.x =
    //     this._dims.x - this._yogaNode.parent.getComputedBorder(yoga.EDGE_LEFT);
    //   this._dims.y =
    //     this._dims.y - this._yogaNode.parent.getComputedBorder(yoga.EDGE_TOP);
    // }
  };

  _proto.setHeight = function setHeight(height) {
    this._dims.height = height;
  };

  _proto.setWidth = function setWidth(width) {
    this._dims.width = width;
  } // DOC: Collision detection ops
  ;

  _proto.getTransform = function getTransform() {
    var newX = this.rootX;
    var newY = this.rootY;
    var points = [[newX, newY], [newX + this._dims.width, newY], [newX + this._dims.width, newY + this._dims.height], [newX, newY + this._dims.height]];
    var centroid = ModelUtils.getCentroid(points);
    var transformObj = {
      rotate: {
        rotation: this.rotation,
        centroid: centroid
      }
    };
    var parent = this.parent;

    if (!parent) {
      return [transformObj];
    }

    var transformArray = [];

    if (parent.getTransform && isArray(parent.getTransform())) {
      [].concat(parent.getTransform()).map(function (transform) {
        transformArray.push(_extends({}, transform));
      });
    }

    var array = [].concat(transformArray);
    array.push(transformObj);
    return array;
  };

  _proto.getAbsoluteRotation = function getAbsoluteRotation() {
    var dims = {
      x: this.rootX || 0,
      y: this.rootY || 0,
      width: this._dims.width || 0,
      height: this._dims.height || 0,
      transform: this.getTransform()
    };
    var poly = ModelUtils.getPointsFromDims(dims);
    var angle = ModelUtils.getAbsoluteRotation(poly);
    return angle;
  };

  _proto.getRotatedDims = function getRotatedDims() {
    var dims = {
      x: this.rootX || 0,
      y: this.rootY || 0,
      rootX: this.rootY || 0,
      rootY: this.rootY || 0,
      width: this._dims.width > 0 ? this._dims.width : 1,
      height: this._dims.height > 0 ? this._dims.height : 1,
      transform: this.getTransform()
    };
    var poly = ModelUtils.getPointsFromDims(dims);
    var angle = this.getAbsoluteRotation ? this.getAbsoluteRotation() : 0;
    var centroid = ModelUtils.getCentroid(poly); // rotate first point of polygon to get original x and y

    var firstPoint = ModelUtils.rotatePoint(poly[0], 360 - angle, centroid);
    var box = {
      x: isNaN(firstPoint[0]) ? poly[0][0] : firstPoint[0],
      y: isNaN(firstPoint[1]) ? poly[0][1] : firstPoint[1],
      height: isNaN(this._dims.height) ? 0 : this._dims.height,
      width: isNaN(this._dims.width) ? 0 : this._dims.width,
      rotation: isNaN(angle) ? 0 : angle
    };
    return box;
  };

  _proto.getRotatedPolygon = function getRotatedPolygon() {
    var dims = {
      x: this.rootX || 0,
      y: this.rootY || 0,
      width: this._dims.width || 0,
      height: this._dims.height || 0,
      transform: this.getTransform()
    };
    var poly = ModelUtils.getPointsFromDims(dims);
    var angle = ModelUtils.getAbsoluteRotation(poly);
    var centroid = ModelUtils.getCentroid(poly); // rotate first point of polygon to get original x and y

    var firstPoint = ModelUtils.rotatePoint(poly[0], 360 - angle, centroid);
    var box = {
      centroid: centroid,
      poly: poly,
      rotation: angle
    };
    return box; // let dims = {
    //   x: this.rootX || 0,
    //   y: this.rootY || 0,
    //   width: this._dims.width || 0,
    //   height: this._dims.height || 0,
    //   transform: this.getTransform(),
    // };
    // let poly = ModelUtils.getPointsFromDims(dims);
    // console.log(poly[0], poly[1], 'poly here');
    // let angle = ModelUtils.getAbsoluteRotation(poly); //? ModelUtils.getAbsoluteRotation : 0;
    // // let angle = 0;
    // // let centroid = ModelUtils.getCentroid(poly); // rotate first point of polygon to get original x and y
    // // let firstPoint = rotatePoint(poly[0], 360 - angle, centroid);
    // let box = {
    //   centroid,
    //   poly,
    //   rotation: angle,
    // };
    // return box;
  };

  _proto.removeCollisionNode = function removeCollisionNode() {
    if (this._collisionNode) {
      this._collisionNode.remove();
    }
  };

  _proto.setCollisionNode = function setCollisionNode() {
    this.removeCollisionNode();
    var dims = this.getRotatedPolygon();
    var updatedPoly = dims.poly.map(function (coord) {
      return [coord[0] - dims.centroid[0], coord[1] - dims.centroid[1]];
    });

    if (this._collisionScope) {
      this._collisionNode = this._collisionScope.createPolygon(dims.centroid[0], dims.centroid[1], updatedPoly, 0, 1, 1);

      this._collisionScope.update();

      this._collisionNode.data = this;
    }
  };

  _proto.getPartialPath = function getPartialPath(node) {
    if (!node) {
      node = this;
    } // if (!node.parent) {
    //   return `0`;
    //   // TODO: add this code + some other condition for center wrapper
    //   // } else if (node.parent) {
    //   //   // added this case for center wrapper, just ignoring it.
    //   //   return `${this.getPartialPath(node.parent)}`;
    // } else


    if (node.parent && node.parent.children) {
      var parentChildren = node.parent.children;
      var childIndex = findIndex(parentChildren, function (child) {
        if (child) {
          return node === child;
        }

        return false;
      });
      var parentPath = this.getPartialPath(node.parent); // if (appendString) {
      //   return `${this.getPath(
      //     node.parent,
      //     appendString
      //   )}.children.${childIndex}`;
      // } else {
      //   return `${this.getPath(node.parent, appendString)}.${childIndex}`;
      // }

      if (parentPath) {
        return parentPath + "." + childIndex;
      } else {
        return "" + childIndex;
      }
    } else {
      return '';
    }
  };

  _proto.getDepth = function getDepth() {
    if (this.parent) {
      var parentDepth = this.parent.getDepth();
      var depth = parentDepth + 1;

      if (this.parent.style.get('pointerEvents') === 'none') {
        depth--;
      }

      return depth;
    }

    return -1;
  };

  _proto.getIndexInParent = function getIndexInParent() {
    var parentLayer = this.parent; // TODO: add this for center wrapper
    // let currentLayer: any = this;
    // if (this._type === 'view' && this._parent) {
    //   currentLayer = this._parent;
    //   parentLayer = this._parent._parent;
    // }

    if (parentLayer && parentLayer.children) {
      return parentLayer.children.indexOf(this);
    }

    return 0;
  };

  _proto.getHitLayer = function getHitLayer(x, y) {
    var hitLayers = this.getHitResult(x, y);
    return hitLayers[hitLayers.length - 1];
  };

  _proto.getHitResult = function getHitResult(x, y) {
    var hitResult;

    if (!this._collisionScope) {
      return [];
    }

    this._collisionScope.update();

    var result = this._collisionScope.createResult(); // Create the player (represented by a Circle)


    var player = this._collisionScope.createPoint(x, y, 1);

    var potentials = player.potentials();
    var layersHit = []; // Loop through the potential wall collisions

    for (var _iterator = _createForOfIteratorHelperLoose(potentials), _step; !(_step = _iterator()).done;) {
      var shape = _step.value;

      // Test if the player collides with the wall
      if (player.collides(shape, result)) {
        // Push the player out of the wall
        // const dataShape = shape as any;
        if (shape && layersHit.indexOf(shape.data) === -1) {
          // const renderFile = dataShape.data.getFile();
          // if (renderFile && renderFile.visible) {
          layersHit.push(shape.data); // }
        }
      }
    }

    this._collisionScope.remove(player);

    layersHit = layersHit.sort(function (layer1, layer2) {
      return ModelUtils.depthComparator(layer1.getPartialPath(), layer2.getPartialPath());
    });
    var newHitLayers = [];

    for (var i = 0; i < layersHit.length; i++) {
      if (!layersHit[i].locked && layersHit[i].style.get('pointerEvents') !== 'none' && ( // ignored layers shoudl not be included in the result
      i === layersHit.length - 1 || // If it's the last layer (i.e. top layer), there is no next layer to compare its depth to
      layersHit[i].getDepth() !== layersHit[i + 1].getDepth() || // If layer has same depth as next layer, that means they are siblings, so don't include the current layer because it is behind the next layer
      layersHit[i + 1].style.get('pointerEvents') === 'none') // If next layer is an ignored layer, we can include the current layer
      ) {
          newHitLayers.push(layersHit[i]);
        }
    }

    hitResult = newHitLayers;
    return this.getCanvas().executeMiddleware('Layer.getHitResult', hitResult, function (hitResult) {
      return hitResult;
    });
  };

  _proto.getHitRectResult = function getHitRectResult(x, y, width, height) {
    if (!this._collisionScope) {
      return [];
    } // for all overlapping layers


    var result = this._collisionScope.createResult(); // Create the player (represented by a Circle)


    var player = this._collisionScope.createPolygon(0, 0, ModelUtils.getPointsFromBoundingBox({
      x: x,
      y: y,
      width: width,
      height: height
    }));

    this._collisionScope.update();

    var potentials = player.potentials();
    var layersHit = []; // Loop through the potential wall collisions

    for (var _iterator2 = _createForOfIteratorHelperLoose(potentials), _step2; !(_step2 = _iterator2()).done;) {
      var shape = _step2.value;

      if (player.collides(shape, result)) {
        if (shape && layersHit.indexOf(shape.data) === -1) {
          var data = shape.data;

          if (!data.locked && !(x > data.rootX && y > data.rootY && width < data.width + data.rootX - x && height < data.height + data.rootY - y)) {
            layersHit.push(data);
          }
        }
      }
    }

    this._collisionScope.remove(player);

    layersHit = orderBy(layersHit, [function (layer) {
      return layer.getDepth();
    }, function (layer) {
      return layer.getIndexInParent();
    }], ['desc', 'desc']);
    remove(layersHit, function (layer) {
      if (layer.style.get('pointerEvents') === 'none') {
        return true;
      }

      return false;
    });
    return this.getCanvas().executeMiddleware('Layer.getHitRectResult', layersHit, function (layersHit) {
      return layersHit;
    });
  };

  _proto.addEventListener = function addEventListener(name, callback) {
    this._eventCallableRegistry.addEventListener(name, callback);
  };

  _proto.removeEventListener = function removeEventListener(name, callback) {
    this._eventCallableRegistry.removeEventListener(name, callback);
  };

  _proto.dispatchEvent = function dispatchEvent(name, event, dispatchedData) {
    // this.getCanvas().executeMiddleware(
    //   'Layer.dispatchEvent',
    //   event,
    //   (data: any) => {
    if (this.style.get('pointerEvents') !== 'none') {
      this._eventCallableRegistry.dispatchEvent(name, event);
    }

    if (event.propagate && this._parent) {
      this._parent.dispatchEvent(name, event, dispatchedData);
    }
  };

  _proto.setInnerText = function setInnerText(text) {
    var _this15 = this;

    if (this._locked) ;

    this._innerText = text;
    this._yogaNode.children = text;
    this.emitLayoutChanges();
    action(function () {
      _this15.emit('innerText');
    });
    this.setYoga();
  };

  _proto.convertLayerDimensions = function convertLayerDimensions(dims) {
    var layer = this;
    var layoutData = {};

    var originalLeft = layer._layout.get('left');

    var originalTop = layer._layout.get('top');

    var originalRight = layer._layout.get('right');

    var originalBottom = layer._layout.get('bottom');

    var originalHeight = layer._layout.get('height');

    var originalWidth = layer._layout.get('width');

    var originalTransform = layer._layout.get('transform');

    var position = layer._layout.get('position');

    var newLeft, newRight, newTop, newBottom, newWidth, newHeight;
    var container = {
      width: this._parent ? this._parent.getBoundingClientRect().width : 1,
      height: this._parent ? this._parent.getBoundingClientRect().height : 1
    };
    var dimensions = this.getDimensions(dims, container);

    if (!isNil(originalLeft)) {
      if (typeof originalLeft === 'number') {
        newLeft = dimensions.left.number;
      }

      if (typeof originalLeft === 'string' && originalLeft.endsWith('%')) {
        newLeft = dimensions.left.percent;
      }
    }

    if (!isNil(originalRight)) {
      if (typeof originalRight === 'number') {
        newRight = dimensions.right.number;
      }

      if (typeof originalRight === 'string' && originalRight.endsWith('%')) {
        newRight = dimensions.right.percent;
      }
    }

    if (!isNil(originalWidth)) {
      if (typeof originalWidth === 'number') {
        newWidth = dimensions.width.number;
      }

      if (typeof originalWidth === 'string' && originalWidth.endsWith('%')) {
        newWidth = dimensions.width.percent;

        if (layer.parent && layer.parent.type === 'thirdParty') {
          newWidth = originalWidth;
        }
      }
    }

    if (!isNil(originalTop)) {
      if (typeof originalTop === 'number') {
        newTop = dimensions.top.number;
      }

      if (typeof originalTop === 'string' && originalTop.endsWith('%')) {
        newTop = dimensions.top.percent;
      }
    }

    if (!isNil(originalBottom)) {
      if (typeof originalBottom === 'number') {
        newBottom = dimensions.bottom.number;
      }

      if (typeof originalBottom === 'string' && originalBottom.endsWith('%')) {
        newBottom = dimensions.bottom.percent;
      }
    }

    if (!isNil(originalHeight)) {
      if (typeof originalHeight === 'number') {
        newHeight = dimensions.height.number;
      }

      if (typeof originalHeight === 'string' && originalHeight.endsWith('%')) {
        newHeight = dimensions.height.percent;
      }
    }

    if (!isNil(newLeft) && !isNil(dims.x)) {
      layoutData.left = newLeft;
    }

    if (!isNil(newRight) && !isNil(dims.x)) {
      layoutData.right = newRight;
    }

    if (isNil(newLeft) && isNil(newRight) && position === 'absolute' && !isNil(dims.x)) {
      layoutData.left = dims.x;
    }

    if (!isNil(newWidth) && !isNil(dims.width)) {
      layoutData.width = newWidth; // if (layer instanceof EllipseLayer) {
      //   noRerender(() => {
      //     const strokeWidth = layer.props.getResolvedProp('strokeWidth') || 0;
      //     this.session.commandManager.executeAndSkip(
      //       new SetProp(this.session, layer, 'cx', dimensions.width.number / 2)
      //     );
      //     this.session.commandManager.executeAndSkip(
      //       new SetProp(
      //         this.session,
      //         layer,
      //         'rx',
      //         dimensions.width.number / 2 - strokeWidth / 2
      //       )
      //     );
      //   });
      // }
    }

    if (!isNil(newTop) && !isNil(dims.y)) {
      layoutData.top = newTop;
    }

    if (!isNil(newBottom) && !isNil(dims.y)) {
      layoutData.bottom = newBottom;
    }

    if (isNil(newTop) && isNil(newBottom) && position === 'absolute' && !isNil(dims.y)) {
      layoutData.top = dims.y;
    }

    if (!isNil(newHeight) && !isNil(dims.height)) {
      layoutData.height = newHeight; // if (layer instanceof EllipseLayer) {
      //   noRerender(() => {
      //     const strokeWidth = layer.props.getResolvedProp('strokeWidth') || 0;
      //     this.session.commandManager.executeAndSkip(
      //       new SetProp(this.session, layer, 'cy', dimensions.height.number / 2)
      //     );
      //     this.session.commandManager.executeAndSkip(
      //       new SetProp(
      //         this.session,
      //         layer,
      //         'ry',
      //         dimensions.height.number / 2 - strokeWidth / 2
      //       )
      //     );
      //   });
      // }
    } // if (layer instanceof EllipseLayer) {
    //   noRerender(() => {
    //     const viewBoxWidth = dimensions.width.number.toFixed(2);
    //     const viewBoxHeight = dimensions.height.number.toFixed(2);
    //     this.session.commandManager.executeAndSkip(
    //       new SetProp(
    //         this.session,
    //         layer,
    //         'viewBox',
    //         `0 0 ${viewBoxWidth} ${viewBoxHeight}`
    //       )
    //     );
    //   });
    // }


    if (!isNil(newLeft) && !isNil(newRight) && position === 'absolute' && !isNil(newWidth)) {
      delete layoutData.right;
    }

    if (!isNil(newTop) && !isNil(newBottom) && position === 'absolute' && !isNil(newHeight)) {
      delete layoutData.bottom;
    } // if (
    //   this.generateGradient &&
    //   (layer instanceof ViewLayer || layer instanceof EllipseLayer) &&
    //   !this.session.currentStage.tools.resizer.dragging
    // ) {
    //   if (layer.gradient && layer.gradient.getGradientType()) {
    //     this.session.commandManager.executeAndSkip(
    //       new GenerateGradientImage(this.session, layer)
    //     );
    //   }
    // }
    // if (
    //   this.session.currentStage.id === 'layer' &&
    //   this.session.currentRootLayer instanceof ScrollViewLayer
    // ) {
    //   CommandUtils.setScrollViewContentContainerStyle(
    //     this.session,
    //     this.session.currentRootLayer
    //   );
    // }
    // TODO: FIXME: temporary fix for text drag color bug, need to see in computeYogaNode()
    // if (color) {
    //   this.session.commandManager.executeAndSkip(
    //     new SetStyleAttribute(this.session, layer, 'color', color)
    //   );
    // }
    // if (!this.session.currentStage.tools.resizer.dragging) {
    //   this.session.commandManager.executeAndSkip(
    //     new SetFileDirty(this.session, true)
    //   );
    // }


    if (layer.isFlexChild()) {
      delete layoutData.top;
      delete layoutData.left;
      delete layoutData.bottom;
      delete layoutData.right;
    }

    var transformValue = undefined;

    if (!isNil(dims.rotation)) {
      transformValue = [{
        rotate: dims.rotation + "deg"
      }];
    }

    return _extends({}, layoutData, {
      transform: transformValue
    });
  };

  _proto.rerenderDescendants = function rerenderDescendants() {
    var _this16 = this;

    action(function () {
      _this16.emit(['layout', 'style', 'children']);
    });

    this._children.forEach(function (c) {
      c.rerenderDescendants();
    });
  };

  _createClass(Layer, [{
    key: "aspectRatio",
    get: function get() {
      return this._aspectRatio;
    }
  }, {
    key: "id",
    get: function get() {
      return this._id;
    }
  }, {
    key: "dragging",
    get: function get() {
      return this._dragging;
    }
  }, {
    key: "name",
    get: function get() {
      return this._name;
    }
  }, {
    key: "parent",
    get: function get() {
      return this._parent;
    }
  }, {
    key: "type",
    get: function get() {
      return this._type;
    }
  }, {
    key: "props",
    get: function get() {
      return this._props;
    }
  }, {
    key: "children",
    get: function get() {
      return this._children;
    }
  }, {
    key: "style",
    get: function get() {
      return this._style;
    }
  }, {
    key: "layout",
    get: function get() {
      return this._layout;
    }
  }, {
    key: "yogaNode",
    get: function get() {
      return this._yogaNode;
    }
  }, {
    key: "collisionScope",
    get: function get() {
      return this._collisionScope;
    }
  }, {
    key: "collisionNode",
    get: function get() {
      return this._collisionNode;
    }
  }, {
    key: "locked",
    get: function get() {
      return this._locked;
    }
  }, {
    key: "visible",
    get: function get() {
      return this._visible;
    }
  }, {
    key: "innerText",
    get: function get() {
      return this._innerText;
    }
  }, {
    key: "eventCallableRegistry",
    get: function get() {
      return this._eventCallableRegistry;
    }
  }, {
    key: "rootX",
    get: function get() {
      var val = 0;
      var parent = this.parent;

      if (parent) {
        var parentX = !isNil(parent.rootX) ? parent.rootX : parent._dims.x;
        val = this._dims.x + parentX;
      } else {
        val = this._dims.x;
      }

      return val;
    }
  }, {
    key: "rootY",
    get: function get() {
      var val = 0;
      var parent = this.parent;

      if (parent) {
        var parentY = !isNil(parent.rootY) ? parent.rootY : parent._dims.y;
        val = this._dims.y + parentY;
      } else {
        val = this._dims.y;
      }

      return val;
    }
  }, {
    key: "rotation",
    get: function get() {
      var styleObj = this.layout.getAll();
      var rotation = 0;

      if (styleObj.transform) {
        var transformValue = isArray(styleObj.transform) ? styleObj.transform : styleObj.transform['value'];
        var index = findIndex(transformValue, function (item) {
          var rotate = keys(item).indexOf('rotate');
          return rotate !== -1 && !isNil(item['rotate']);
        });

        if (index > -1) {
          var value = transformValue[index]['rotate'] && transformValue[index]['rotate'].type ? transformValue[index]['rotate'].value : transformValue[index]['rotate'];

          if (value && value.indexOf) {
            if (value.indexOf('rad') > -1) {
              value = parseFloat(value.slice(0, -3));
              rotation = value * 180 / Math.PI;
            } else {
              value = parseFloat(value.slice(0, -3));
              rotation = value;
            }
          }
        }
      }

      return rotation;
    }
  }]);

  return Layer;
}(Model);
var LayerInstantiable = /*#__PURE__*/function (_Layer) {
  _inheritsLoose(LayerInstantiable, _Layer);

  function LayerInstantiable() {
    return _Layer.apply(this, arguments) || this;
  }

  return LayerInstantiable;
}(Layer);

var MiddlewareRegistry = /*#__PURE__*/function () {
  function MiddlewareRegistry() {
    var _this = this;

    this.addMiddleware = function (type, callback) {
      var middlewares = _this._middlewares.get(type);

      if (middlewares) {
        middlewares.push(callback);
      } else {
        _this._middlewares.set(type, [callback]);
      }
    };

    this._middlewares = new Map();
  }

  var _proto = MiddlewareRegistry.prototype;

  _proto.execute = function execute(middlewareCallbacks, cb, data) {
    var self = this;

    if (middlewareCallbacks.length === 0) {
      return cb(data);
    } else {
      var mw = middlewareCallbacks[0];
      var remainingCbs = [].concat(middlewareCallbacks);
      remainingCbs.splice(0, 1);

      var next = function next(_data) {
        return self.execute(remainingCbs, cb, _data);
      };

      return mw(next, data);
    }
  };

  _proto.executeMiddleware = function executeMiddleware(type, data, callback) {
    var middlewares = this._middlewares.get(type);

    if (middlewares) {
      // @ts-ignore
      if (window['debug'] && window['debugLog']) {
        // @ts-ignore
        window['debugLog']('Middleware: ' + type);
      }

      return this.execute(middlewares, callback, data);
    } else {
      return callback(data);
    }
  };

  return MiddlewareRegistry;
}();

var FunctionRegistry = function FunctionRegistry() {
  var _this = this;

  // Adding to the Map of functions
  this.addFunction = function (name, callback) {
    _this._functions.set(name, callback);
  }; // Executing the callback of the function with the given arguments


  this.executeFunction = function (name) {
    var fn = _this._functions.get(name);

    if (fn) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return fn.apply(void 0, args);
    } else {
      throw new Error("No function with the given name(" + name + ") found.");
    }
  }; // Removing the callback of the given function


  this.removeFunction = function (name) {
    _this._functions["delete"](name);
  };

  this._functions = new Map();
};

var DesignerMouseEvent = /*#__PURE__*/function (_Event) {
  _inheritsLoose(DesignerMouseEvent, _Event);

  function DesignerMouseEvent(name, target, originalEvent, currentTarget) {
    var _this;

    _this = _Event.call(this, name, target, currentTarget) || this;
    var canvas = target.getCanvas();
    var pageX = originalEvent.pageX,
        pageY = originalEvent.pageY;
    _this.originalEvent = originalEvent;
    _this.pageX = pageX;
    _this.pageY = pageY;
    var worldPoints = canvas.convertPoint({
      x: pageX,
      y: pageY
    }, 'page', 'world');
    _this.worldX = worldPoints.x;
    _this.worldY = worldPoints.y;
    var viewportPoints = canvas.convertPoint({
      x: pageX,
      y: pageY
    }, 'page', 'viewport');
    _this.viewportX = viewportPoints.x;
    _this.viewportY = viewportPoints.y;
    return _this;
  }

  var _proto = DesignerMouseEvent.prototype;

  _proto.preventDefault = function preventDefault() {
    _Event.prototype.preventDefault.call(this);

    if (this.originalEvent && this.originalEvent.preventDefault) {
      this.originalEvent.preventDefault();
    }
  };

  return DesignerMouseEvent;
}(Event);

var DesignerDropEvent = /*#__PURE__*/function (_Event) {
  _inheritsLoose(DesignerDropEvent, _Event);

  function DesignerDropEvent(name, target, originalEvent, currentTarget) {
    var _this;

    _this = _Event.call(this, name, target, currentTarget) || this;
    var canvas = target.getCanvas();
    var pageX = originalEvent.pageX,
        pageY = originalEvent.pageY;
    _this.originalEvent = originalEvent;
    _this.pageX = pageX;
    _this.pageY = pageY;
    var worldPoints = canvas.convertPoint({
      x: pageX,
      y: pageY
    }, 'page', 'world');
    _this.worldX = worldPoints.x;
    _this.worldY = worldPoints.y;
    var viewportPoints = canvas.convertPoint({
      x: pageX,
      y: pageY
    }, 'page', 'viewport');
    _this.viewportX = viewportPoints.x;
    _this.viewportY = viewportPoints.y;
    return _this;
  }

  return DesignerDropEvent;
}(Event);

var HoverEvent = /*#__PURE__*/function (_Event) {
  _inheritsLoose(HoverEvent, _Event);

  function HoverEvent(name, target, payload, currentTarget) {
    var _this;

    _this = _Event.call(this, name, target, currentTarget) || this;
    _this.payload = payload;
    return _this;
  }

  return HoverEvent;
}(Event);

var SetScrollEvent = /*#__PURE__*/function (_Event) {
  _inheritsLoose(SetScrollEvent, _Event);

  function SetScrollEvent(name, target, originalEvent, currentTarget) {
    var _this;

    _this = _Event.call(this, name, target, currentTarget) || this;
    _this.scrollX = originalEvent.x;
    _this.scrollY = originalEvent.y;
    return _this;
  }

  return SetScrollEvent;
}(Event);

var SetZoomEvent = /*#__PURE__*/function (_Event) {
  _inheritsLoose(SetZoomEvent, _Event);

  function SetZoomEvent(name, target, zoom, currentTarget) {
    var _this;

    _this = _Event.call(this, name, target, currentTarget) || this;
    _this.zoom = zoom;
    return _this;
  }

  return SetZoomEvent;
}(Event);

var ASSET_URL = 'https://pre-cloud.builderx.io/assets/plugins/designer';

var Canvas = /*#__PURE__*/function (_Layer) {
  _inheritsLoose(Canvas, _Layer);

  function Canvas(dom) {
    var _this;

    _this = _Layer.call(this) || this;
    _this.plugins = new Map();
    _this.zoom = 1;
    _this.scroll = {
      x: 0,
      y: 0
    };
    _this._middlewareRegistry = new MiddlewareRegistry();
    _this._functionRegistry = new FunctionRegistry();
    _this._componentMap = {};
    _this._isMouseDown = false;
    _this._assetURL = ASSET_URL;
    _this._mouseEventsBlocked = false;
    _this.moveWithGrabHandle = false;

    _this.convertPoint = function (point, from, to) {
      var resultPoint = {
        x: 0,
        y: 0
      };

      if (from === 'viewport') {
        switch (to) {
          case 'page':
            resultPoint = _this.convertPointFromViewportToPage(point.x, point.y);
            break;

          case 'world':
            resultPoint = _this.convertPointFromViewportToWorld(point.x, point.y);
            break;
        }
      }

      if (from === 'page') {
        switch (to) {
          case 'viewport':
            resultPoint = _this.convertPointFromPageToViewport(point.x, point.y);
            break;

          case 'world':
            var viewport = _this.convertPointFromPageToViewport(point.x, point.y);

            resultPoint = _this.convertPointFromViewportToWorld(viewport.x, viewport.y);
            break;
        }
      }

      if (from === 'world') {
        switch (to) {
          case 'viewport':
            resultPoint = _this.convertPointFromWorldToViewport(point.x, point.y);
            break;

          case 'page':
            var world = _this.convertPointFromWorldToViewport(point.x, point.y);

            resultPoint = _this.convertPointFromViewportToPage(world.x, world.y);
            break;
        }
      }

      return resultPoint;
    };

    _this.dom = dom;
    _this.viewport = {
      width: 0,
      height: 0
    };

    _this.setType('canvas');

    _this.setCollisionScope(new Collisions());

    _this._hoveredLayers = [];
    _this._selectedLayers = [];
    _this._stackWorldDOM = [];
    _this._stackViewportDOM = [];
    render(createElement(DesignerReact, {
      canvas: _assertThisInitialized(_this)
    }), _this.dom);

    _this.addFunction('setScroll', _this.setScrollCallback.bind(_assertThisInitialized(_this)));

    _this.addFunction('setZoom', _this.setZoomCallback.bind(_assertThisInitialized(_this)));

    return _this;
  }

  var _proto = Canvas.prototype;

  _proto.setMouseCursor = function setMouseCursor(mouseCursorType) {
    var _this2 = this;

    this._mouseCursorType = mouseCursorType;
    action(function () {
      _this2.emit('mouseCursorType');
    });
  };

  _proto.setScrollCallback = function setScrollCallback(context, scrollDims) {
    this.dispatchEvent('setScroll', new SetScrollEvent('setScroll', this, scrollDims));
  };

  _proto.setZoomCallback = function setZoomCallback(context, zoom) {
    this.dispatchEvent('setZoom', new SetZoomEvent('setZoom', this, zoom));
  };

  _proto.blockMouseEvents = function blockMouseEvents() {
    var _this3 = this;

    this._mouseEventsBlocked = true;
    action(function () {
      _this3.emit('mouseEventsBlocked');
    });
  };

  _proto.unblockMouseEvents = function unblockMouseEvents() {
    var _this4 = this;

    this._mouseEventsBlocked = false;
    action(function () {
      _this4.emit('mouseEventsBlocked');
    });
  };

  _proto.createLayer = function createLayer() {
    return new LayerInstantiable(this);
  };

  _proto.addMiddleware = function addMiddleware(name, callback) {
    this._middlewareRegistry.addMiddleware(name, callback);
  };

  _proto.executeMiddleware = function executeMiddleware(name, data, callback) {
    return this._middlewareRegistry.executeMiddleware(name, data, callback);
  } // dispatchEvent(name: string, event: Event) {
  //   this._eventCallableRegistry.dispatchEvent(name, event);
  //   if (event.propagate)
  //     if (this._parent) this._parent.dispatchEvent(name, event);
  // }
  ;

  _proto.addFunction = function addFunction(name, callback) {
    this._functionRegistry.addFunction(name, callback);
  };

  _proto.removeFunction = function removeFunction(name) {
    this._functionRegistry.removeFunction(name);
  };

  _proto.setAssetUrl = function setAssetUrl(url) {
    this._assetURL = url;
  } // DOC: canvas ops
  ;

  _proto.setViewport = function setViewport(dims) {
    var _this5 = this;

    this.viewport.width = dims.width;
    this.viewport.height = dims.height;
    action(function () {
      _this5.emit('viewport');
    });
  };

  _proto.setViewportRef = function setViewportRef(ref) {
    this._viewportRef = ref;
  };

  _proto.getViewport = function getViewport() {
    return this.viewport;
  };

  _proto.setZoom = function setZoom(zoom) {
    var _this6 = this;

    this.zoom = zoom;
    action(function () {
      _this6.emit('zoom');
    });
  };

  _proto.getZoom = function getZoom() {
    return this.zoom;
  };

  _proto.setScroll = function setScroll(scroll) {
    var _this7 = this;

    this.scroll = scroll;
    action(function () {
      _this7.emit('scroll');
    });
  };

  _proto.getScroll = function getScroll() {
    return this.scroll;
  };

  _proto.setMouseDown = function setMouseDown(val) {
    this._isMouseDown = val;

    if (this.moveWithGrabHandle) {
      this.setMouseCursor(val ? '-webkit-grabbing' : '-webkit-grab');
    }
  };

  _proto.setHoverLayers = function setHoverLayers(layers) {
    var _this8 = this;

    this._hoveredLayers = [];

    if (layers) {
      if (Array.isArray(layers)) {
        layers.forEach(function (layer) {
          if (!layer.locked) {
            _this8._hoveredLayers.push(layer);
          }
        });
      } else if (!layers.locked) {
        this._hoveredLayers = [layers];
      }
    }

    action(function () {
      _this8.emit('hoveredLayers');
    });
  };

  _proto.selectLayers = function selectLayers(layers) {
    var _this9 = this;

    this._selectedLayers = [];

    if (layers) {
      if (Array.isArray(layers)) {
        layers.forEach(function (layer) {
          if (!layer.locked) {
            _this9._selectedLayers.push(layer);
          }
        });
      } else if (!layers.locked) {
        this._selectedLayers = [layers];
      }
    }

    if (globalLayerUpdateController.rerender) {
      action(function () {
        _this9.emit('selectedLayers');
      });
    }
  };

  _proto.convertPointFromViewportToWorld = function convertPointFromViewportToWorld(x, y) {
    var viewPortLeftPos = (this.layout.get('width') - this.viewport.width / this.zoom) * this.scroll.x;
    var viewPortTopPos = (this.layout.get('height') - this.viewport.height / this.zoom) * this.scroll.y;
    return {
      x: viewPortLeftPos + x / this.zoom,
      y: viewPortTopPos + y / this.zoom
    };
  };

  _proto.convertPointFromWorldToViewport = function convertPointFromWorldToViewport(x, y) {
    var viewPortLeftPos = (this.layout.get('width') - this.viewport.width / this.zoom) * this.scroll.x;
    var viewPortTopPos = (this.layout.get('height') - this.viewport.height / this.zoom) * this.scroll.y;
    return {
      x: (x - viewPortLeftPos) * this.zoom,
      y: (y - viewPortTopPos) * this.zoom
    };
  };

  _proto.convertPointFromPageToViewport = function convertPointFromPageToViewport(x, y) {
    var pageScrollY = document.documentElement.scrollTop;
    var pageScrollX = document.documentElement.scrollLeft;
    var viewportDom = findDOMNode(this._viewportRef);
    var offsetLeft = 0;
    var offsetTop = 0;

    if (viewportDom) {
      // @ts-ignore
      var clientRect = viewportDom.getBoundingClientRect();
      offsetLeft = clientRect.x;
      offsetTop = clientRect.y;
    }

    return {
      x: x - pageScrollX - offsetLeft,
      y: y - pageScrollY - offsetTop
    };
  };

  _proto.convertPointFromViewportToPage = function convertPointFromViewportToPage(x, y) {
    var pageScrollY = document.documentElement.scrollTop;
    var pageScrollX = document.documentElement.scrollLeft;
    var viewportDom = findDOMNode(this._viewportRef);
    var offsetLeft = 0;
    var offsetTop = 0;

    if (viewportDom) {
      // @ts-ignore
      var clientRect = viewportDom.getBoundingClientRect();
      offsetLeft = clientRect.x;
      offsetTop = clientRect.y;
    }

    return {
      x: x + pageScrollX + offsetLeft,
      y: y + pageScrollY + offsetTop
    };
  };

  _proto.installPlugin = function installPlugin(plugin) {
    this.plugins.set(plugin.name, plugin);
    plugin.init(this);
    plugin.activate();
  };

  _proto.dispatchEventOnHitLayer = function dispatchEventOnHitLayer(name, event, dispatchedData) {
    var _this10 = this;

    // @ts-ignore
    if (window['debug'] && window['debugLog']) {
      // @ts-ignore
      window['debugLog']('CanvasEvent:HitLayer ' + name);
    }

    var layer;

    if (name !== 'drag') {
      layer = this.getHitLayer(event.worldX, event.worldY);
    }

    if (layer) {
      event.target = layer;

      this._middlewareRegistry.executeMiddleware('Canvas.dispatchEventOnHitLayer', event, function (event) {
        if (name === 'mousemove') {
          if (!_this10.dragging) {
            _this10.dispatchEvent('Canvas.hoverLayers', new HoverEvent('Canvas.hoverLayers', _this10, event.target ? [event.target] : []));
          }
        }

        layer.dispatchEvent(name, event, dispatchedData);
      });
    } else {
      this.dispatchEvent(name, event, dispatchedData);
    }
  };

  _proto.addComponent = function addComponent(type, ReactComponent, componentDefinition) {
    this.componentMap[type] = {
      renderer: ReactComponent,
      definition: componentDefinition
    };
  };

  _proto.getComponentDefinition = function getComponentDefinition(type) {
    try {
      return this.componentMap[type].definition;
    } catch (err) {
      throw new Error("Component Definition for " + type + " not found");
    }
  };

  _proto.getRenderer = function getRenderer(type) {
    try {
      return this.componentMap[type].renderer;
    } catch (err) {
      throw new Error('Renderer not found');
    }
  };

  _proto.addDomToWorld = function addDomToWorld(domElement, maintainScale, zIndex) {
    var _this11 = this;

    if (maintainScale === void 0) {
      maintainScale = false;
    }

    var wrapperLayer = domElement;

    if (maintainScale) {
      var canvasDims = this.getBoundingClientRect();
      wrapperLayer = document.createElement('div'); // wrapperLayer.style.background = 'rgba(255, 0,0,0.4)';

      wrapperLayer.style.height = canvasDims.height + 'px';
      wrapperLayer.style.width = canvasDims.width + 'px';
      wrapperLayer.style.top = canvasDims.y + 'px';
      wrapperLayer.style.left = canvasDims.x + 'px';
      wrapperLayer.style.pointerEvents = 'none';
      wrapperLayer.style.position = 'absolute';
      wrapperLayer.style.zIndex = zIndex ? zIndex : undefined;
      this.on('zoom', function (e) {
        wrapperLayer.style.transform = "scale(" + 1 / _this11.getZoom() + ")";
        wrapperLayer.style.zoom = _this11.getZoom();
      });
      wrapperLayer.style.transform = "scale(" + 1 / this.getZoom() + ")";
      wrapperLayer.style.transformOrigin = "0 0";
      wrapperLayer.style.zoom = this.getZoom();
      wrapperLayer.appendChild(domElement);
    }

    this._stackWorldDOM.push(wrapperLayer);

    domElement.style.pointerEvents = 'all';
    action(function () {
      _this11.emit('stackWorldDOM');
    });
    return this.removeDomFromWorld.bind(this, wrapperLayer);
  };

  _proto.removeDomFromWorld = function removeDomFromWorld(ele) {
    var _this12 = this;

    var index = this._stackWorldDOM.indexOf(ele);

    if (index !== -1) {
      this._stackWorldDOM.splice(index, 1);

      action(function () {
        _this12.emit('stackWorldDOM');
      });
    }
  };

  _proto.addDomToViewport = function addDomToViewport(domElement) {
    var _this13 = this;

    this._stackViewportDOM.push(domElement);

    domElement.style.pointerEvents = 'all';
    action(function () {
      _this13.emit('stackViewportDOM');
    });
    return this.removeDomFromViewport.bind(this, domElement);
  };

  _proto.removeDomFromViewport = function removeDomFromViewport(ele) {
    var _this14 = this;

    var index = this._stackViewportDOM.indexOf(ele);

    if (index !== -1) {
      this._stackViewportDOM.splice(index, 1);

      action(function () {
        _this14.emit('stackViewportDOM');
      });
    }
  };

  _proto.dispatchHandledEvent = function dispatchHandledEvent(event) {
    var originalEvent = event.nativeEvent ? event.nativeEvent : event;
    this.dispatchEventOnHitLayer(event.type, new DesignerMouseEvent(event.type, this, originalEvent, this), event);
  };

  _proto.handleNativeEvent = function handleNativeEvent(event) {
    var _this15 = this;

    this._middlewareRegistry.executeMiddleware('Canvas.handleNativeEvent', event, function (event) {
      switch (event.type) {
        case 'click':
          // if (!this.dragging) {
          //   this.dispatchHandledEvent(event);
          // }
          break;

        case 'mousemove':
          if (_this15.isMouseDown && !_this15.dragging) {
            _this15.setDragging(true);
          } // if (!this.dragging) {


          _this15.dispatchHandledEvent(event); // }


          break;

        case 'mousedown':
          _this15.setMouseDown(true);

          _this15.dispatchHandledEvent(event);

          break;

        case 'mouseenter':
          _this15.dispatchHandledEvent(event);

          break;

        case 'mouseup':
          // event.type = 'click';
          _this15.dispatchHandledEvent(event);

          _this15.setMouseDown(false);

          if (!_this15.dragging) {
            event = new MouseEvent('click', event); // event.type = 'click';

            _this15.dispatchHandledEvent(event);
          }

          _this15.setDragging(false);

          break;

        case 'contextmenu':
        case 'dblclick':
          _this15.dispatchHandledEvent(event);

          break;

        case 'drop':
          _this15.dispatchEvent(event.type, new DesignerDropEvent(event.type, _this15, event.nativeEvent, _this15), event);

          break;
        //   e.type,
        //   new Event(e.type, this, this),
        //   data
        // );
        // break;

      }
    }); // if (beforeHandleNativeEventMiddleware) {
    // });
    // beforeHandleNativeEventMiddleware[0](next);
    // console.log('middleware:: here', beforeHandleNativeEventMiddleware);
    // } else {
    //   this.handleEvent(e);
    // }

  };

  _proto.getContainerBoundingBox = function getContainerBoundingBox(layers) {
    return this.getBoundingBox(layers, true);
  };

  _proto.getContainerBoundingBoxWRTParent = function getContainerBoundingBoxWRTParent(layers) {
    return this.getBoundingBoxWRTParent(layers, true);
  };

  _proto.getBoundingBox = function getBoundingBox(layers, withoutRotation, wrtParent) {
    if (withoutRotation === void 0) {
      withoutRotation = false;
    }

    if (wrtParent === void 0) {
      wrtParent = false;
    }

    var box = {
      x: 0,
      y: 0,
      height: 0,
      width: 0,
      rotation: 0
    };

    if (isEmpty(layers)) {
      return box;
    } else if (layers.length > 1 || withoutRotation) {
      var layerPoints = [];
      layers.map(function (layer) {
        var dims = layer.getBoundingClientRect();
        var localBox = {
          x: dims.rootX,
          y: dims.rootY,
          width: dims.width,
          height: dims.height
        };
        var rotation = layer.rotation; // let points = ModelUtils(
        //   layer.getRotatedDims(),
        //   0
        // );

        var points = layer.getRotatedPolygon().poly;

        if (wrtParent) {
          points = ModelUtils.getPointsFromBoundingBox(localBox, rotation);
        } // layer.getRotatedDims(); //ModelUtils.getPointsFromBoundingBox(localBox, rotation);


        layerPoints = layerPoints.concat(points);
      });
      var minXLayer = minBy(layerPoints, function (layer) {
        return layer[0];
      });
      var minYLayer = minBy(layerPoints, function (layer) {
        return layer[1];
      });
      var maxXLayer = maxBy(layerPoints, function (layer) {
        return layer[0];
      });
      var maxYLayer = maxBy(layerPoints, function (layer) {
        return layer[1];
      });
      minXLayer = minXLayer ? minXLayer[0] : 0;
      minYLayer = minYLayer ? minYLayer[1] : 0;
      maxXLayer = maxXLayer ? maxXLayer[0] : 0;
      maxYLayer = maxYLayer ? maxYLayer[1] : 0;
      box.x = minXLayer;
      box.y = minYLayer;
      box.width = maxXLayer ? maxXLayer - minXLayer : 0;
      box.height = maxYLayer ? maxYLayer - minYLayer : 0;
      box.rotation = 0;
    } else if (layers.length === 1) {
      var layer = layers[0];
      return layer.getRotatedDims();
    }

    return box;
  };

  _proto.getBoundingBoxWRTParent = function getBoundingBoxWRTParent(layers, withoutRotation) {
    if (withoutRotation === void 0) {
      withoutRotation = false;
    }

    var dims = this.getBoundingBox(layers, withoutRotation, true);
    var parentDims = layers.length && layers[0].parent ? layers[0].parent.getBoundingClientRect() : {
      rootX: 0,
      rootY: 0
    };
    return _extends({}, dims, {
      x: dims.x - parentDims.rootX,
      y: dims.y - parentDims.rootY,
      rootX: dims.x,
      rootY: dims.y
    });
  };

  _proto.enableMoveWithGrabHandle = function enableMoveWithGrabHandle() {
    var _this16 = this;

    if (!this.mouseEventsBlocked) {
      this.moveWithGrabHandle = true;
      this.setMouseCursor(this.isMouseDown ? '-webkit-grabbing' : '-webkit-grab');
      this.blockMouseEvents();
      action(function () {
        _this16.emit('moveWithGrabHandle');
      });
    }
  };

  _proto.disableMoveWithGrabHandle = function disableMoveWithGrabHandle() {
    var _this17 = this;

    if (this.moveWithGrabHandle) {
      this.moveWithGrabHandle = false;
      this.setMouseCursor('default');
      this.unblockMouseEvents();
      action(function () {
        _this17.emit('moveWithGrabHandle');
      });
    }
  };

  _createClass(Canvas, [{
    key: "mouseEventsBlocked",
    get: function get() {
      return this._mouseEventsBlocked;
    }
  }, {
    key: "functionRegistry",
    get: function get() {
      return this._functionRegistry;
    }
  }, {
    key: "assetURL",
    get: function get() {
      return this._assetURL;
    }
  }, {
    key: "hoveredLayers",
    get: function get() {
      return this._hoveredLayers;
    }
  }, {
    key: "mouseCursorType",
    get: function get() {
      return this._mouseCursorType;
    }
  }, {
    key: "selectedLayers",
    get: function get() {
      return this._selectedLayers;
    }
  }, {
    key: "stackWorldDOM",
    get: function get() {
      return this._stackWorldDOM;
    }
  }, {
    key: "stackViewportDOM",
    get: function get() {
      return this._stackViewportDOM;
    }
  }, {
    key: "componentMap",
    get: function get() {
      return this._componentMap;
    }
  }, {
    key: "isMouseDown",
    get: function get() {
      return this._isMouseDown;
    }
  }]);

  return Canvas;
}(LayerInstantiable);

var Gradient = /*#__PURE__*/function () {
  function Gradient(gradientType, from, to, stops, activeIndex, elipseLength) {
    var _this = this;

    this.activeIndex = 0;

    this.getGradientString = function (palette) {
      var colors = [];

      if (palette) {
        forEach(palette, function (data, index) {
          colors.push(data.color);
        });
      } else {
        forEach(_this.stops, function (data, index) {
          colors.push(data.stopColor);
        });
      }

      var vector;

      if (_this.to && _this.from) {
        vector = {
          x: _this.to.x - _this.from.x,
          y: _this.to.y - _this.from.y
        };
      } else {
        vector = {
          x: 0,
          y: 2
        };
      }

      var angleRad = Math.atan2(vector.y, vector.x);
      var angleDeg = angleRad * 180 / Math.PI + 90;
      var realLocations = [];

      if (palette) {
        forEach(palette, function (data, index) {
          realLocations.push(data.pos);
        });
      } else {
        forEach(_this.stops, function (data, index) {
          realLocations.push(data.offset);
        });
      }

      var colorStrings = colors.map(function (color, i) {
        return color + " " + Math.round(realLocations[i] * 100) + "%";
      }).join(', ');

      if (_this.gradientType && _this.gradientType === 'LinearGradient') {
        return "linear-gradient(" + angleDeg + "deg, " + colorStrings + ")";
      } else if (_this.gradientType && _this.gradientType === 'RadialGradient') {
        return "radial-gradient(" + colorStrings + ")";
      } else if (_this.gradientType && _this.gradientType === 'AngularGradient') {
        return "conic-gradient(" + colorStrings + ")";
      } else {
        return "linear-gradient(" + angleDeg + "deg, " + colorStrings + ")";
      }
    };

    this.gradientType = gradientType;
    this.from = from;
    this.to = to;
    this.stops = stops;
    this.activeIndex = activeIndex;
    this.elipseLength = elipseLength;
  }

  var _proto = Gradient.prototype;

  _proto.toJS = function toJS() {
    var gradientJSON = {};
    forEach(this, function (value, key) {
      // if (![""].includes(key)) {
      if (!isFunction(value)) {
        gradientJSON[key] = value && value.toJS ? value.toJS() : value;
      } // }
      // }

    });
    return gradientJSON;
  };

  _proto.rotate = function rotate(cx, cy, x, y, angle) {
    var radians = Math.PI / 180 * angle;
    var cos = Math.cos(radians);
    var sin = Math.sin(radians);
    var nx = cos * (x - cx) + sin * (y - cy) + cx;
    var ny = cos * (y - cy) - sin * (x - cx) + cy;
    return {
      x: Math.round(nx),
      y: Math.round(ny)
    };
  };

  _proto.rotateGradient = function rotateGradient(angle) {
    var cx = (this.from.x + this.to.x) / 2;
    var cy = (this.from.y + this.to.y) / 2;
    var nFrom = this.rotate(cx, cy, this.from.x, this.from.y, angle);
    var nTo = this.rotate(cx, cy, this.to.x, this.to.y, angle);
    var rotatedFrom = {
      x: nFrom.x,
      y: nFrom.y
    };
    var rotatedTo = {
      x: nTo.x,
      y: nTo.y
    };
    this.from = rotatedFrom;
    this.to = rotatedTo;
  };

  return Gradient;
}();

var HoverPlugin = /*#__PURE__*/function () {
  function HoverPlugin() {
    this.name = 'HoverPlugin';
    this.forbiddenLayers = [];
    this.hoverLayers = [];
  }

  var _proto = HoverPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
    this.dispose = null;
  };

  _proto.hideLayerHover = function hideLayerHover(context) {
    if (!this.forbiddenLayers.includes(context.layer)) {
      this.forbiddenLayers.push(context.layer);
    }
  };

  _proto.showLayerHover = function showLayerHover(context) {
    if (this.forbiddenLayers.includes(context.layer)) {
      this.forbiddenLayers.splice(this.forbiddenLayers.indexOf(context.layer), 1);
    }
  };

  _proto.hideAllHoverBoxes = function hideAllHoverBoxes(context) {
    this.hoverWrapperLayer.style.display = 'none';
  };

  _proto.showAllHoverBoxes = function showAllHoverBoxes(context) {
    this.hoverWrapperLayer.style.display = 'block';
  };

  _proto.showHover = function showHover(layer) {
    return !this.forbiddenLayers.includes(layer) && layer.type !== 'canvas' && !this.canvas.selectedLayers.includes(layer);
  };

  _proto.renderBoxes = function renderBoxes() {
    for (var index = 0; index < this.canvas.hoveredLayers.length; index++) {
      var layer = this.canvas.hoveredLayers[index];

      if (this.showHover(layer)) {
        var hoverBox = void 0;

        if (this.hoverLayers[index]) {
          hoverBox = this.hoverLayers[index];
        } else {
          hoverBox = document.createElement('div');
          this.hoverWrapperLayer.appendChild(hoverBox);
        }

        hoverBox.style.position = 'absolute';
        hoverBox.style.pointerEvents = 'none';
        var dims = layer.getBoundingClientRect();
        var box = this.canvas.getBoundingBox([layer]);
        hoverBox.style.top = box.y + 'px';
        hoverBox.style.left = box.x + 'px';
        hoverBox.style.height = dims.height + 'px';
        hoverBox.style.width = dims.width + 'px'; // hoverBox.style.width = box.rotation + 'px';

        hoverBox.style.transform = box.rotation ? "rotate(" + box.rotation + "deg)" : '';
        hoverBox.id = 'hover' + index;
        hoverBox.style.border = 1 / this.canvas.getZoom() + "px solid #25B9D1";
        this.hoverLayers[index] = hoverBox;
      } else {
        if (this.hoverLayers[index] && this.hoverLayers[index].remove) {
          this.hoverLayers[index].remove();
          this.hoverLayers.splice(index, 1);
          index--;
        }
      }
    }

    var breakIndex = this.canvas.hoveredLayers.length;

    if (breakIndex < this.hoverLayers.length) {
      for (var i = breakIndex; i < this.hoverLayers.length; i++) {
        if (this.hoverLayers[i] && this.hoverLayers[i].remove) {
          this.hoverLayers[i].remove();
          this.hoverLayers.splice(i, 1);
          i--;
        }
      }
    }
  };

  _proto.activate = function activate() {
    var _this = this;

    this.hoverWrapperLayer = document.createElement('div');
    this.dispose = this.canvas.addDomToWorld(this.hoverWrapperLayer, true, 102);
    this.hoverWrapperLayer.style.pointerEvents = 'none';
    this.canvas.on('hoveredLayers', function (e) {
      _this.renderBoxes();
    });
    this.canvas.on('selectedLayers', function (e) {
      _this.renderBoxes();
    });
    this.canvas.on('zoom', function (e) {
      _this.renderBoxes();
    });
    this.canvas.addFunction('Hover.hideLayer', this.hideLayerHover.bind(this));
    this.canvas.addFunction('Hover.showLayer', this.showLayerHover.bind(this));
    this.canvas.addFunction('Hover.hideAllHoverBoxes', this.hideAllHoverBoxes.bind(this));
    this.canvas.addFunction('Hover.showAllHoverBoxes', this.showAllHoverBoxes.bind(this));
  };

  _proto.deactivate = function deactivate() {
    this.dispose();
  };

  return HoverPlugin;
}();

var DragEvent = /*#__PURE__*/function (_DesignerMouseEvent) {
  _inheritsLoose(DragEvent, _DesignerMouseEvent);

  function DragEvent(name, target, originalEvent, payload, currentTarget) {
    var _this;

    _this = _DesignerMouseEvent.call(this, name, target, originalEvent, currentTarget) || this;
    var canvas = target.getCanvas();
    _this.worldDx = payload.worldDx;
    _this.worldDy = payload.worldDy;
    _this.worldX = payload.worldX;
    _this.worldY = payload.worldY;
    var pagePoints = canvas.convertPoint({
      x: payload.worldDx,
      y: payload.worldDy
    }, 'world', 'page');
    _this.pageDx = pagePoints.x;
    _this.pageDy = pagePoints.y;
    var viewportPoints = canvas.convertPoint({
      x: _this.pageDx,
      y: _this.pageDy
    }, 'page', 'viewport');
    _this.viewportDx = viewportPoints.x;
    _this.viewportDy = viewportPoints.y;
    return _this;
  }

  return DragEvent;
}(DesignerMouseEvent);

var Drag = /*#__PURE__*/function () {
  function Drag() {
    this.name = 'Drag';
    this.mouseDown = false;
    this.dragStarted = false;
    this.offsetPageX = 0;
    this.offsetPageY = 0;
    this.lastPageX = 0;
    this.lastPageY = 0;
  }

  var _proto = Drag.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
    this.dispose = null;
    this.offsetPageX = 0;
    this.offsetPageY = 0;
  };

  _proto.activate = function activate() {
    var _this = this;

    var relPos = {
      x: 0,
      y: 0
    };
    this.canvas.addEventListener('mousedown', function (event) {
      if (event.originalEvent.button !== 2 && event.originalEvent.which !== 3) {
        // Ignore right click mousedown
        _this.mouseDown = true;
        _this.dragStarted = false;
        _this.lastPageX = event.worldX;
        _this.lastPageY = event.worldY;
      }
    });
    this.canvas.addEventListener('mousemove', function (event) {
      relPos = {
        x: event.worldX - _this.lastPageX,
        y: event.worldY - _this.lastPageY
      };

      if (_this.mouseDown && !_this.dragStarted) {
        _this.dragStarted = true;
        var payload = {
          worldDx: relPos.x,
          worldDy: relPos.y,
          worldX: _this.lastPageX,
          worldY: _this.lastPageY
        };
        var dragStartEvent = new DragEvent('dragStart', _this.canvas, event.originalEvent, payload);

        _this.canvas.dispatchEventOnHitLayer('dragStart', dragStartEvent, event);
      } else if (_this.dragStarted) {
        var _payload = {
          worldDx: relPos.x,
          worldDy: relPos.y,
          worldX: event.worldX,
          worldY: event.worldY
        };
        var dragEvent = new DragEvent('drag', _this.canvas, event.originalEvent, _payload);

        _this.canvas.dispatchEventOnHitLayer('drag', dragEvent, event);

        _this.lastPageX = event.worldX;
        _this.lastPageY = event.worldY;
      }
    });
    this.canvas.addEventListener('mouseup', function (event) {
      relPos = {
        x: event.worldX - _this.lastPageX,
        y: event.worldY - _this.lastPageY
      };
      var payload = {
        worldDx: 0,
        worldDy: 0,
        worldX: event.worldX,
        worldY: event.worldY
      };

      if (_this.dragStarted) {
        var dragEndEvent = new DragEvent('dragEnd', _this.canvas, event.originalEvent, payload);

        _this.canvas.dispatchEventOnHitLayer('dragEnd', dragEndEvent, event);
      }

      _this.lastPageX = 0;
      _this.lastPageY = 0;
      _this.mouseDown = false;
      _this.dragStarted = false;
    });
  };

  _proto.deactivate = function deactivate() {
    this.dispose();
  };

  return Drag;
}();

var rerenderProps = ['layout', 'children', 'props', 'style', 'visible', 'gradient'];

var ViewRenderer = /*#__PURE__*/function (_React$PureComponent) {
  _inheritsLoose(ViewRenderer, _React$PureComponent);

  function ViewRenderer() {
    var _this;

    _this = _React$PureComponent.apply(this, arguments) || this;
    _this._ref = null;

    _this.onUpdate = function () {
      _this.forceUpdate();
    };

    _this.getStyles = function (layer) {
      var styles = _extends({}, layer.style.getAll());

      delete styles['gradient'];

      var returnStyles = _extends({}, styles, layer.layout.getAll());

      delete returnStyles['pointerEvents'];

      if (returnStyles.overflow === 'scroll') {
        returnStyles.overflow = 'hidden';
      } else {
        returnStyles.overflow = returnStyles.overflow;
      }

      return returnStyles;
    };

    return _this;
  }

  var _proto = ViewRenderer.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.props.layer.on(rerenderProps, this.onUpdate);
    this.props.layer.setDomRef(this._ref);
    var domNode = findNodeHandle(this._ref);
    domNode.setAttribute('class', 'view-render ' + domNode.className);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.layer.off(rerenderProps, this.onUpdate); // this.props.layer.parent.off('*', this.onUpdate);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    prevProps.layer.off(rerenderProps, this.onUpdate);
    this.props.layer.on(rerenderProps, this.onUpdate);
    this.props.layer.setDomRef(this._ref);
  };

  _proto.render = function render() {
    var _this2 = this;

    var layer = this.props.layer;
    var RootRenderer = this.props.RootRenderer;

    var layerProps = _extends({}, layer.props.getAll());

    var layerId = layerProps['id'];
    delete layerProps['id'];
    return createElement(View, Object.assign({
      ref: function ref(component) {
        return _this2._ref = component;
      },
      style: this.getStyles(layer)
    }, layerProps, {
      nativeID: layerId
    }), layer.children.map(function (child, index) {
      return createElement(RootRenderer, Object.assign({}, _this2.props, {
        key: child.id,
        layer: child
      }));
    }));
  };

  return ViewRenderer;
}(PureComponent);

var ViewComponentDefinition = {
  version: '0.0.1',
  template: {
    type: 'view',
    children: [],
    "import": {
      layerName: 'View',
      packageName: 'native',
      isDefaultImport: false,
      asName: ''
    },
    locked: false,
    template: {
      centerVertical: false,
      centerHorizontal: false
    },
    layout: {
      top: 50,
      left: 100,
      width: 100,
      height: 100,
      position: 'absolute'
    },
    style: {
      backgroundColor: '#E6E6E6'
    },
    props: {// style: {
      //   top: 0,
      //   left: 150,
      //   width: 150,
      //   height: 150,
      //   position: 'absolute',
      //   backgroundColor: 'rgba(230, 230, 230,1)',
      // },
    }
  },
  thumbnail: // tslint:disable-next-line:max-line-length
  '',
  name: 'Rect',
  controlsProperty: [{
    type: 'AlignmentEditor',
    title: 'Alignment Editor',
    value: {},
    showForMultiple: true
  }, {
    type: 'OrientationEditor',
    title: 'Orientation Editor',
    value: {},
    showForMultiple: true
  }, {
    type: 'ResizingTypeEditor',
    title: 'ResizingType Editor',
    value: {}
  }, {
    type: 'TouchableOpacityEditor',
    title: 'TouchableOpacity Editor',
    value: {}
  }, {
    type: 'ScrollViewEditor',
    title: 'Scroll View Editor',
    value: {}
  }, {
    type: 'group',
    title: 'Styling',
    value: {},
    properties: [{
      propertyName: 'opacity',
      type: 'range',
      title: 'Opacity',
      value: {
        defaultValue: 1,
        min: 0,
        max: 1
      },
      category: 'style'
    }, {
      propertyName: 'backgroundColor',
      type: 'color',
      title: 'Fill',
      value: {
        defaultValue: '#fff'
      },
      category: 'style'
    }, {
      type: 'BorderWidthEditor',
      title: 'BorderWidth Editor',
      value: {
        defaultValue: 1
      }
    }, {
      type: 'BorderRadiusEditor',
      title: 'BorderRadius Editor',
      value: {}
    }, {
      type: 'ShadowEditor',
      title: 'Shadow Editor',
      value: {},
      properties: [{
        type: 'shadowColor',
        title: 'Shadow Color',
        value: {
          defaultValue: 'rgba(0,0,0,1)'
        }
      }, {
        type: 'shadowOffset',
        title: 'Shadow Offset',
        value: {
          defaultValue: 3
        }
      }, {
        type: 'shadowOpacity',
        title: 'Shadow Opacity',
        value: {
          defaultValue: 0.25
        }
      }, {
        type: 'elevation',
        title: 'elevation',
        value: {
          defaultValue: 5
        }
      }]
    }, {
      propertyName: 'overflow',
      title: 'Overflow',
      type: 'enum',
      value: {
        options: ['visible', 'hidden', 'scroll'],
        defaultValue: 'visible'
      }
    }]
  }, {
    type: 'group',
    title: 'Layout',
    value: {},
    properties: [{
      type: 'FlexboxEditor',
      title: 'Flexbox Editor',
      value: {}
    }, {
      type: 'MarginPaddingEditor',
      title: 'MarginPadding Editor',
      value: {}
    }, {
      type: 'LayoutEditor',
      title: 'Layout Editor',
      value: {}
    }]
  }]
};

var ViewRendererPlugin = /*#__PURE__*/function () {
  function ViewRendererPlugin() {
    this.name = 'ViewRenderer';
  }

  var _proto = ViewRendererPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
  };

  _proto.activate = function activate() {
    this.canvas.addComponent('view', ViewRenderer, ViewComponentDefinition);
  };

  _proto.deactivate = function deactivate() {};

  return ViewRendererPlugin;
}();

var rerenderProps$1 = ['layout', 'children', 'props', 'style', 'visible', 'gradient'];

var TouchableOpacityRenderer = /*#__PURE__*/function (_React$PureComponent) {
  _inheritsLoose(TouchableOpacityRenderer, _React$PureComponent);

  function TouchableOpacityRenderer() {
    var _this;

    _this = _React$PureComponent.apply(this, arguments) || this;

    _this.onUpdate = function () {
      _this.forceUpdate();
    };

    _this.getStyles = function (layer) {
      var styles = _extends({}, layer.style.getAll());

      delete styles['gradient'];

      var returnStyles = _extends({}, styles, layer.layout.getAll());

      if (returnStyles.overflow === 'scroll') {
        returnStyles.overflow = 'hidden';
      } else {
        returnStyles.overflow = returnStyles.overflow || 'hidden';
      }

      return returnStyles;
    };

    return _this;
  }

  var _proto = TouchableOpacityRenderer.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.props.layer.on(rerenderProps$1, this.onUpdate);
    this.props.layer.setDomRef(this._ref);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.layer.off(rerenderProps$1, this.onUpdate);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    prevProps.layer.off(rerenderProps$1, this.onUpdate);
    this.props.layer.on(rerenderProps$1, this.onUpdate);
    this.props.layer.setDomRef(this._ref);
  };

  _proto.render = function render() {
    var _this2 = this;

    var layer = this.props.layer;
    var RootRenderer = this.props.RootRenderer;

    var layerProps = _extends({}, layer.props.getAll());

    var layerId = layerProps['id'];
    delete layerProps['id'];
    return createElement(View, Object.assign({
      ref: function ref(c) {
        _this2._ref = c;
      },
      style: this.getStyles(layer)
    }, layerProps, {
      nativeID: layerId
    }), layer.children.map(function (child, index) {
      return createElement(RootRenderer, Object.assign({}, _this2.props, {
        key: child.id,
        layer: child
      }));
    }));
  };

  return TouchableOpacityRenderer;
}(PureComponent);

var componentDefinition = {
  version: '0.0.1',
  template: {
    type: 'touchableOpacity',
    children: [],
    "import": {
      layerName: 'TouchableOpacity',
      packageName: 'native',
      isDefaultImport: false,
      asName: ''
    },
    locked: false,
    template: {
      centerVertical: false,
      centerHorizontal: false
    },
    layout: {
      top: 50,
      left: 100,
      width: 100,
      height: 100,
      position: 'absolute'
    },
    style: {
      backgroundColor: '#E6E6E6'
    },
    props: {//
    }
  },
  thumbnail: // tslint:disable-next-line:max-line-length
  '',
  name: 'Rect',
  controlsProperty: [{
    type: 'AlignmentEditor',
    title: 'Alignment Editor',
    value: {},
    showForMultiple: true
  }, {
    type: 'OrientationEditor',
    title: 'Orientation Editor',
    value: {},
    showForMultiple: true
  }, {
    type: 'ResizingTypeEditor',
    title: 'ResizingType Editor',
    value: {}
  }, {
    type: 'TouchableOpacityEditor',
    title: 'TouchableOpacity Editor',
    value: {}
  }, {
    type: 'NavigationEditor',
    title: 'Navigation Editor',
    value: {}
  }, {
    type: 'group',
    title: 'Styling',
    value: {},
    properties: [{
      propertyName: 'opacity',
      type: 'range',
      title: 'Opacity',
      value: {
        defaultValue: 1,
        min: 0,
        max: 1
      },
      category: 'style'
    }, {
      propertyName: 'backgroundColor',
      type: 'color',
      title: 'Fill',
      value: {
        defaultValue: '#fff'
      },
      additionalOptions: {
        showGradient: false
      },
      category: 'style'
    }, {
      type: 'BorderWidthEditor',
      title: 'BorderWidth Editor',
      value: {}
    }, {
      type: 'BorderRadiusEditor',
      title: 'BorderRadius Editor',
      value: {}
    }, {
      type: 'ShadowEditor',
      title: 'Shadow Editor',
      value: {}
    }, {
      propertyName: 'overflow',
      title: 'Overflow',
      type: 'enum',
      value: {
        options: ['visible', 'hidden', 'scroll'],
        defaultValue: 'visible'
      }
    }]
  }, {
    type: 'group',
    title: 'Layout',
    value: {},
    properties: [{
      type: 'FlexboxEditor',
      title: 'Flexbox Editor',
      value: {}
    }, {
      type: 'MarginPaddingEditor',
      title: 'MarginPadding Editor',
      value: {}
    }, {
      type: 'LayoutEditor',
      title: 'Layout Editor',
      value: {}
    }]
  }]
};

var TouchableOpacityRendererPlugin = /*#__PURE__*/function () {
  function TouchableOpacityRendererPlugin() {
    this.name = 'TouchableOpacityRenderer';
  }

  var _proto = TouchableOpacityRendererPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
  };

  _proto.activate = function activate() {
    this.canvas.addComponent('touchableOpacity', TouchableOpacityRenderer, componentDefinition);
  };

  _proto.deactivate = function deactivate() {};

  return TouchableOpacityRendererPlugin;
}();

var rerenderProps$2 = ['layout', 'children', 'props', 'style', 'visible', 'gradient'];

var ScrollViewRenderer = /*#__PURE__*/function (_React$PureComponent) {
  _inheritsLoose(ScrollViewRenderer, _React$PureComponent);

  function ScrollViewRenderer() {
    var _this;

    _this = _React$PureComponent.apply(this, arguments) || this;

    _this.onUpdate = function () {
      _this.forceUpdate();
    };

    _this.getStyles = function (layer) {
      var styles = _extends({}, layer.style.getAll());

      delete styles['gradient'];

      var returnStyles = _extends({}, styles, layer.layout.getAll());

      if (returnStyles.overflow === 'scroll') {
        returnStyles.overflow = 'hidden';
      } else {
        returnStyles.overflow = returnStyles.overflow || 'hidden';
      }

      return returnStyles;
    };

    return _this;
  }

  var _proto = ScrollViewRenderer.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.props.layer.on(rerenderProps$2, this.onUpdate);
    this.props.layer.setDomRef(this._ref);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.layer.off(rerenderProps$2, this.onUpdate);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    prevProps.layer.off(rerenderProps$2, this.onUpdate);
    this.props.layer.on(rerenderProps$2, this.onUpdate);
    this.props.layer.setDomRef(this._ref);
  };

  _proto.render = function render() {
    var _this2 = this;

    var layer = this.props.layer;
    var RootRenderer = this.props.RootRenderer;

    var layerProps = _extends({}, layer.props.getAll());

    var layerId = layerProps['id'];
    delete layerProps['id'];
    return createElement(View, Object.assign({
      ref: function ref(c) {
        _this2._ref = c;
      },
      style: this.getStyles(layer)
    }, layerProps, {
      nativeID: layerId
    }), layer.children.map(function (child, index) {
      return createElement(RootRenderer, Object.assign({}, _this2.props, {
        key: child.id,
        layer: child
      }));
    }));
  };

  return ScrollViewRenderer;
}(PureComponent);

var componentDefinition$1 = {
  version: '0.0.1',
  template: {
    type: 'scrollView',
    children: [],
    "import": {
      layerName: 'ScrollView',
      packageName: 'native',
      isDefaultImport: false,
      asName: ''
    },
    locked: false,
    template: {
      centerVertical: false,
      centerHorizontal: false
    },
    layout: {
      top: 150,
      left: 150,
      width: 150,
      height: 150,
      position: 'absolute'
    },
    style: {
      backgroundColor: 'rgba(230, 230, 230,1)'
    },
    props: {
      contentContainerStyle: {
        width: 150,
        height: 150
      }
    }
  },
  thumbnail: // tslint:disable-next-line:max-line-length
  '',
  name: 'Rect',
  controlsProperty: [{
    type: 'AlignmentEditor',
    title: 'Alignment Editor',
    value: {},
    showForMultiple: true
  }, {
    type: 'OrientationEditor',
    title: 'Orientation Editor',
    value: {},
    showForMultiple: true
  }, {
    type: 'ResizingTypeEditor',
    title: 'ResizingType Editor',
    value: {}
  }, {
    type: 'ScrollViewEditor',
    title: 'Scroll View Editor',
    value: {}
  }, {
    type: 'group',
    title: 'Styling',
    value: {},
    properties: [{
      propertyName: 'opacity',
      type: 'range',
      title: 'Opacity',
      value: {
        defaultValue: 1,
        min: 0,
        max: 1
      },
      category: 'style'
    }, {
      propertyName: 'backgroundColor',
      type: 'color',
      title: 'Fill',
      value: {
        defaultValue: '#fff'
      },
      additionalOptions: {
        showGradient: false
      },
      category: 'style'
    }, {
      type: 'BorderWidthEditor',
      title: 'BorderWidth Editor',
      value: {}
    }, {
      type: 'BorderRadiusEditor',
      title: 'BorderRadius Editor',
      value: {}
    }, {
      type: 'ShadowEditor',
      title: 'Shadow Editor',
      value: {}
    }, {
      propertyName: 'overflow',
      title: 'Overflow',
      type: 'enum',
      value: {
        options: ['visible', 'hidden'],
        defaultValue: 'visible'
      }
    }]
  }, {
    type: 'group',
    title: 'Layout',
    value: {},
    properties: [{
      type: 'FlexboxEditor',
      title: 'Flexbox Editor',
      value: {}
    }, {
      type: 'MarginPaddingEditor',
      title: 'MarginPadding Editor',
      value: {}
    }, {
      type: 'LayoutEditor',
      title: 'Layout Editor',
      value: {}
    }]
  }]
};

var ScrollViewRendererPlugin = /*#__PURE__*/function () {
  function ScrollViewRendererPlugin() {
    this.name = 'ScrollViewRenderer';
  }

  var _proto = ScrollViewRendererPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
  };

  _proto.activate = function activate() {
    this.canvas.addComponent('scrollView', ScrollViewRenderer, componentDefinition$1);
  };

  _proto.deactivate = function deactivate() {};

  return ScrollViewRendererPlugin;
}();

var RenderEvent = /*#__PURE__*/function (_Event) {
  _inheritsLoose(RenderEvent, _Event);

  function RenderEvent(name, target) {
    return _Event.call(this, name, target) || this;
  }

  return RenderEvent;
}(Event);

var rerenderProps$3 = ['layout', 'children', 'props', 'innerText', 'style', 'visible'];

var TextRenderer = /*#__PURE__*/function (_React$PureComponent) {
  _inheritsLoose(TextRenderer, _React$PureComponent);

  function TextRenderer() {
    var _this;

    _this = _React$PureComponent.apply(this, arguments) || this;

    _this.onUpdate = function () {
      _this.forceUpdate();
    };

    _this.getStyles = function (layer) {
      // let maxWidth = get(layer, 'parent.width', undefined);
      var updatedStyle = _extends({
        color: 'black'
      }, layer.style.getAll(), layer.layout.getAll(), {
        WebkitFontSmoothing: 'antialiased',
        wordBreak: 'break-all'
      });

      delete updatedStyle['fontPostscriptName'];
      delete updatedStyle['wordBreak']; // TODO: heavy jugaad
      // if (layer.parent && maxWidth) {
      //   updatedStyle.maxWidth = Math.max(maxWidth, updatedStyle.width);
      // }

      if (updatedStyle.textDecoration) {
        updatedStyle.textDecorationLine = updatedStyle.textDecoration;
      }

      return updatedStyle;
    };

    return _this;
  }

  var _proto = TextRenderer.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.props.layer.on(rerenderProps$3, this.onUpdate);
    this.props.layer.setDomRef(this.textRef);
    this.whiteSpaceTo('noWrap');
    this.props.layer.dispatchEvent('domDidMount', new RenderEvent('domDidMount', this));
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.layer.off(rerenderProps$3, this.onUpdate);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    prevProps.layer.off(rerenderProps$3, this.onUpdate);
    this.props.layer.on(rerenderProps$3, this.onUpdate);
    this.props.layer.setDomRef(this.textRef);
    this.props.layer.dispatchEvent('domDidUpdate', new RenderEvent('domDidUpdate', this));
  };

  _proto.whiteSpaceTo = function whiteSpaceTo(value) {
    // Redacted: animation related code
    this.textRef.setNativeProps({
      whiteSpace: value
    });
  };

  _proto.render = function render() {
    var _this2 = this;

    var layer = this.props.layer;
    var innerText = layer.innerText;

    if (innerText && includes(innerText, "{'\n'}")) {
      innerText = replace(innerText, new RegExp("{'\n'}", 'g'), '\n');
    }

    if (innerText && includes(innerText, "{'\t'}")) {
      innerText = replace(innerText, new RegExp("{'\t'}", 'g'), '\t');
    }

    var layerProps = _extends({}, layer.props.getAll());

    var layerId = layerProps['id'];
    delete layerProps['id'];
    var style = this.getStyles(layer);
    var whiteSpace = undefined;
    var height = undefined;
    var width = undefined;

    if (layer.isAutoWidth()) {
      whiteSpace = 'pre';
    }

    if (layer.isFlexChild()) {
      height = 'fit-content';
      width = 'fit-content';
    } else {
      if (!layer.isFillHeight()) {
        height = 'fit-content';
      }

      if (!layer.isFillWidth()) {
        width = 'fit-content';
      }
    }

    return createElement(Text, Object.assign({
      webkit: "true"
    }, layerProps, {
      style: _extends({
        fontSize: 14,
        height: height,
        width: width
      }, style, {
        whiteSpace: whiteSpace
      }),
      nativeID: layerId,
      ref: function ref(c) {
        _this2.textRef = c;
      }
    }), innerText);
  };

  return TextRenderer;
}(PureComponent);

var componentDefinition$2 = {
  version: '0.0.1',
  template: {
    type: 'text',
    children: [{
      type: 'literal',
      value: 'Lorem Ipsum'
    }],
    "import": {
      layerName: 'Text',
      packageName: 'native',
      isDefaultImport: false,
      asName: ''
    },
    locked: false,
    template: {
      centerVertical: false,
      centerHorizontal: false
    },
    layout: {
      top: 0,
      left: 0,
      position: 'absolute'
    },
    style: {
      fontFamily: 'Roboto',
      fontPostscriptName: 'roboto-regular',
      fontStyle: 'normal',
      fontWeight: '400',
      color: '#121212'
    },
    props: {}
  },
  thumbnail: // tslint:disable-next-line:max-line-length
  '',
  name: 'Text',
  controlsProperty: [{
    type: 'AlignmentEditor',
    title: 'Alignment Editor',
    value: {},
    showForMultiple: true
  }, {
    type: 'OrientationEditor',
    title: 'Orientation Editor',
    value: {},
    showForMultiple: true
  }, {
    type: 'ResizingTypeEditor',
    title: 'ResizingType Editor',
    value: {}
  }, {
    type: 'TextToTextInputEditor',
    title: 'Text To TextInput Editor',
    value: {}
  }, {
    type: 'group',
    title: 'Styling',
    value: {},
    properties: [{
      propertyName: 'opacity',
      type: 'range',
      title: 'Opacity',
      value: {
        defaultValue: 1,
        min: 0,
        max: 1
      },
      category: 'style'
    }, {
      type: 'TextPropEditor',
      title: 'Text Prop Editor',
      value: {}
    }]
  }, {
    type: 'group',
    title: 'Layout',
    value: {},
    properties: [{
      type: 'MarginPaddingEditor',
      title: 'MarginPadding Editor',
      value: {}
    }]
  }]
};

var TextRendererPlugin = /*#__PURE__*/function () {
  function TextRendererPlugin() {
    this.name = 'TextRenderer';
  }

  var _proto = TextRendererPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
  };

  _proto.activate = function activate() {
    this.canvas.addComponent('text', TextRenderer, componentDefinition$2);
  };

  _proto.deactivate = function deactivate() {};

  return TextRendererPlugin;
}();

var rerenderProps$4 = ['layout', 'children', 'props', 'style', 'visible'];

var TextInputRenderer = /*#__PURE__*/function (_React$PureComponent) {
  _inheritsLoose(TextInputRenderer, _React$PureComponent);

  function TextInputRenderer() {
    var _this;

    _this = _React$PureComponent.apply(this, arguments) || this;

    _this.onUpdate = function () {
      _this.forceUpdate();
    };

    _this.getStyles = function (layer) {
      var appliedStyles = _extends({}, layer.style.getAll(), layer.layout.getAll());

      delete appliedStyles['fontPostscriptName'];
      delete appliedStyles['wordBreak'];
      return appliedStyles;
    };

    return _this;
  }

  var _proto = TextInputRenderer.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.props.layer.on(rerenderProps$4, this.onUpdate);
    this.props.layer.setDomRef(this._ref);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    prevProps.layer.off(rerenderProps$4, this.onUpdate);
    this.props.layer.on(rerenderProps$4, this.onUpdate);
    this.props.layer.setDomRef(this._ref);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.layer.off(rerenderProps$4, this.onUpdate);
  };

  _proto.render = function render() {
    var _this2 = this;

    var layer = this.props.layer;

    var layerProps = _extends({}, layer.props.getAll());

    var filteredProps = pick(layerProps, ['defaultValue', 'numberOfLines', 'multiline', 'maxLength', 'placeholder', 'placeholderTextColor', 'value']);
    var layerId = layerProps['id'];
    delete layerProps['id'];
    return createElement(TextInput, Object.assign({
      ref: function ref(c) {
        _this2._ref = c;
      }
    }, filteredProps, {
      style: this.getStyles(layer),
      nativeID: layerId
    }));
  };

  return TextInputRenderer;
}(PureComponent);

var componentDefinition$3 = {
  version: '0.0.1',
  template: {
    type: 'textInput',
    children: [],
    "import": {
      layerName: 'TextInput',
      packageName: 'native',
      isDefaultImport: false,
      asName: ''
    },
    locked: false,
    template: {
      centerVertical: false,
      centerHorizontal: false
    },
    layout: {
      top: 0,
      left: 0,
      position: 'absolute'
    },
    style: {
      fontFamily: 'Roboto',
      fontPostscriptName: 'roboto-regular',
      fontStyle: 'normal',
      fontWeight: '400',
      color: '#121212'
    },
    props: {
      placeholder: 'placeholder'
    }
  },
  thumbnail: // tslint:disable-next-line:max-line-length
  '',
  name: 'TextInput',
  controlsProperty: [{
    type: 'AlignmentEditor',
    title: 'Alignment Editor',
    value: {},
    showForMultiple: true
  }, {
    type: 'OrientationEditor',
    title: 'Orientation Editor',
    value: {},
    showForMultiple: true
  }, {
    type: 'ResizingTypeEditor',
    title: 'ResizingType Editor',
    value: {}
  }, {
    type: 'group',
    title: 'Styling',
    value: {},
    properties: [{
      propertyName: 'opacity',
      type: 'range',
      title: 'Opacity',
      value: {
        defaultValue: 1,
        min: 0,
        max: 1
      },
      category: 'style'
    }, {
      type: 'TextPropEditor',
      title: 'Text Prop Editor',
      value: {}
    }, {
      propertyName: 'backgroundColor',
      type: 'color',
      title: 'Fill',
      value: {
        defaultValue: '#fff'
      },
      additionalOptions: {
        showGradient: false
      },
      category: 'style'
    }, {
      type: 'BorderWidthEditor',
      title: 'BorderWidth Editor',
      value: {
        defaultValue: 1
      }
    }, {
      type: 'BorderRadiusEditor',
      title: 'BorderRadius Editor',
      value: {}
    }, {
      type: 'ShadowEditor',
      title: 'Shadow Editor',
      value: {},
      properties: [{
        type: 'shadowColor',
        title: 'Shadow Color',
        value: {
          defaultValue: 'rgba(0,0,0,1)'
        }
      }, {
        type: 'shadowOffset',
        title: 'Shadow Offset',
        value: {
          defaultValue: 3
        }
      }, {
        type: 'shadowOpacity',
        title: 'Shadow Opacity',
        value: {
          defaultValue: 0.25
        }
      }, {
        type: 'elevation',
        title: 'elevation',
        value: {
          defaultValue: 5
        }
      }]
    }]
  }, {
    type: 'group',
    title: 'Layout',
    value: {},
    properties: [{
      type: 'MarginPaddingEditor',
      title: 'MarginPadding Editor',
      value: {}
    }]
  }, {
    type: 'TextToTextInputEditor',
    title: 'Text To TextInput Editor',
    value: {}
  }, // {
  //   type: "group",
  //   title: "Conditionals",
  //   value: {},
  //   properties: [
  //     {
  //       type: "ResetConditionalEditor",
  //       title: "Conditional Editor",
  //       value: {}
  //     }
  //   ]
  // },
  {
    type: 'group',
    title: 'TextInput',
    value: {},
    properties: [{
      propertyName: 'placeholder',
      type: 'string',
      title: 'Placeholder',
      value: {
        placeholder: '',
        defaultValue: ''
      },
      category: 'props'
    }, {
      propertyName: 'textBreakStrategy',
      title: 'Text Break Strategy',
      type: 'enum',
      value: {
        options: ['simple', 'highQuality', 'balanced'],
        defaultValue: 'simple'
      },
      category: 'props'
    }, {
      propertyName: 'clearButtonMode',
      type: 'enum',
      title: 'Clear Button Mode',
      value: {
        options: ['never', 'while-editing', 'unless-editing', 'always'],
        defaultValue: 'never'
      },
      category: 'props'
    }, {
      propertyName: 'keyboardAppearance',
      title: 'Keyboard Appearance',
      type: 'enum',
      value: {
        options: ['default', 'light', 'dark'],
        defaultValue: 'default'
      },
      category: 'props'
    }, {
      propertyName: 'dataDetector',
      title: 'Data Detector Types',
      type: 'enum',
      value: {
        options: ['phoneNumber', 'link', 'address', 'calendarEvent', 'none', 'all', 'phoneNumber', 'link', 'address', 'calendarEvent', 'none', 'all'],
        defaultValue: 'none'
      },
      category: 'props'
    }, {
      propertyName: 'placeholderTextColor',
      type: 'bareColor',
      title: 'Placeholder Text Color',
      value: {
        defaultValue: '#fff'
      },
      additionalOptions: {
        showGradient: false,
        uiOptions: {
          size: 's'
        }
      },
      category: 'props'
    }, // {
    //   propertyName: 'underlineColorAndroid',
    //   type: 'bareColor',
    //   title: 'Underline Color',
    //   value: {
    //     defaultValue: '#fff',
    //   },
    //   additionalOptions: {
    //     showGradient: false,
    //     uiOptions: {
    //       size: 's',
    //     },
    //   },
    //   category: 'props',
    // },
    {
      propertyName: 'selectionColor',
      type: 'bareColor',
      title: 'Selection color',
      value: {
        defaultValue: '#fff'
      },
      additionalOptions: {
        showGradient: false,
        uiOptions: {
          size: 's'
        }
      },
      category: 'props'
    }]
  }, {
    type: 'group',
    title: 'Other Props',
    value: {},
    properties: [{
      propertyName: 'autoCapitalize',
      title: 'Auto Capitalize',
      type: 'enum',
      value: {
        options: ['none', 'sentences', 'words', 'characters'],
        defaultValue: 'none'
      },
      category: 'props'
    }, {
      propertyName: 'keyboardType',
      type: 'enum',
      title: 'Keyboard Type',
      value: {
        options: ['default', 'email-address', 'numeric', 'phone-pad', 'ascii-capable', 'numbers-and-punctuation', 'url', 'number-pad', 'name-phone-pad', 'decimal-pad', 'twitter', 'web-search'],
        defaultValue: 'default'
      },
      category: 'props'
    }, {
      propertyName: 'returnKeyType',
      title: 'Return Key Type',
      type: 'enum',
      value: {
        options: ['done', 'go', 'next', 'search', 'send', 'none', 'previous', 'default', 'emergency-call', 'google', 'join', 'route', 'yahoo'],
        defaultValue: 'default'
      },
      category: 'props'
    }, {
      propertyName: 'defaultValue',
      type: 'string',
      title: 'Default value',
      value: {
        defaultValue: ''
      },
      category: 'props'
    }, {
      propertyName: 'maxLength',
      type: 'number',
      title: 'Max length',
      value: {
        defaultValue: 140
      },
      category: 'props'
    }, {
      propertyName: 'inlineImageLeft',
      type: 'string',
      title: 'Inline Image Left',
      value: {
        defaultValue: ''
      }
    }, {
      propertyName: 'inlineImagePadding',
      type: 'number',
      title: 'Inline Image Padding',
      value: {
        defaultValue: 0
      },
      category: 'props'
    }, {
      propertyName: 'numberOfLines',
      type: 'number',
      title: 'Number of Lines',
      value: {
        defaultValue: 1
      },
      category: 'props'
    }, {
      propertyName: 'returnKeyLabel',
      type: 'string',
      title: 'Return Key Label',
      value: {
        defaultValue: ''
      },
      category: 'props'
    }]
  }, {
    type: 'group',
    title: 'Booleans',
    value: {},
    properties: [{
      propertyName: 'clearTextOnFocus',
      type: 'boolean',
      title: 'Clear Text onFocus',
      value: {
        defaultValue: false
      },
      category: 'props'
    }, {
      propertyName: 'enablesReturnKeyAutomatically',
      type: 'boolean',
      title: 'Enables Return Key Automatically',
      value: {
        defaultValue: false
      },
      category: 'props'
    }, {
      propertyName: 'spellCheck',
      type: 'boolean',
      title: 'Spell Check',
      value: {
        defaultValue: false
      },
      category: 'props'
    }, {
      propertyName: 'disableFullscreenUI',
      type: 'boolean',
      title: 'Disable Full Screen UI',
      value: {
        defaultValue: false
      },
      category: 'props'
    }, {
      propertyName: 'autoCorrect',
      type: 'boolean',
      title: 'Auto Correct',
      value: {
        defaultValue: false
      },
      category: 'props'
    }, {
      propertyName: 'autoFocus',
      type: 'boolean',
      title: 'Auto Focus',
      value: {
        defaultValue: false
      },
      category: 'props'
    }, {
      propertyName: 'blurOnSubmit',
      type: 'boolean',
      title: 'Blur on submit',
      value: {
        defaultValue: false
      },
      category: 'props'
    }, {
      propertyName: 'caretHidden',
      type: 'boolean',
      title: 'Caret hidden',
      value: {
        defaultValue: false
      },
      category: 'props'
    }, {
      propertyName: 'editable',
      type: 'boolean',
      title: 'Editable',
      value: {
        defaultValue: true
      },
      category: 'props'
    }, {
      propertyName: 'multiline',
      type: 'boolean',
      title: 'Multiline',
      value: {
        defaultValue: false
      },
      category: 'props'
    }, {
      propertyName: 'secureTextEntry',
      type: 'boolean',
      title: 'Password Input',
      value: {
        defaultValue: false
      },
      category: 'props'
    }, {
      propertyName: 'selectTextOnFocus',
      type: 'boolean',
      title: 'Select text on focus',
      value: {
        defaultValue: false
      },
      category: 'props'
    }]
  }]
};

var TextInputRendererPlugin = /*#__PURE__*/function () {
  function TextInputRendererPlugin() {
    this.name = 'TextInputRenderer';
  }

  var _proto = TextInputRendererPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
  };

  _proto.activate = function activate() {
    this.canvas.addComponent('textInput', TextInputRenderer, componentDefinition$3);
  };

  _proto.deactivate = function deactivate() {};

  return TextInputRendererPlugin;
}();

var rerenderProps$5 = ['layout', 'children', 'props', 'style', 'visible'];

var ImageRenderer = /*#__PURE__*/function (_React$PureComponent) {
  _inheritsLoose(ImageRenderer, _React$PureComponent);

  function ImageRenderer() {
    var _this;

    _this = _React$PureComponent.apply(this, arguments) || this;

    _this.onUpdate = function () {
      _this.forceUpdate();
    };

    return _this;
  }

  var _proto = ImageRenderer.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.props.layer.on(rerenderProps$5, this.onUpdate);

    if (this._ref) {
      this.props.layer.setDomRef(this._ref);
    } else {
      this.props.layer.setDomRef(this);
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.layer.off(rerenderProps$5, this.onUpdate);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    prevProps.layer.off(rerenderProps$5, this.onUpdate);
    this.props.layer.on(rerenderProps$5, this.onUpdate);

    if (this._ref) {
      this.props.layer.setDomRef(this._ref);
    } else {
      this.props.layer.setDomRef(this);
    }
  };

  _proto.render = function render() {
    var _this2 = this;

    var layer = this.props.layer;

    var layerProps = _extends({}, layer.props.getAll());

    var layerId = layerProps['id'];
    delete layerProps['id'];
    var transform = layer.rotation ? "rotate(" + layer.rotation + "deg)" : undefined;

    var imageStyle = _extends({}, layer.style.getAll(), layer.layout.getAll(), {
      transform: transform
    });

    var sourceUri = get(layerProps, 'source.uri', undefined);
    var imageURI = layer.props.get('blobURL') ? layer.props.get('blobURL') : sourceUri ? sourceUri : undefined;

    if (this.maskPath) {
      var imageMaskId = generateRandomString(6);
      return createElement(Svg // @ts-ignore
      , {
        // @ts-ignore
        id: layerId,
        style: imageStyle,
        key: layer.id,
        viewBox: layerProps.viewBox,
        preserveAspectRatio: "none",
        ref: function ref(c) {
          _this2._ref = c;
        }
      }, createElement(Defs, null, createElement(Mask, {
        id: imageMaskId,
        x: "0",
        y: "0"
      }, createElement(Path, {
        fill: "white" // DOC: hard-coded acc. to the masking behaviour in sketch
        ,
        d: this.maskPath
      }))), createElement(Image, {
        x: layerProps.svgDims.x,
        y: layerProps.svgDims.y,
        width: layerProps.svgDims.width,
        height: layerProps.svgDims.height,
        href: imageURI,
        preserveAspectRatio: "none",
        mask: "url(#" + imageMaskId + ")"
      }));
    } else if (layerProps.resizeMode === 'center') {
      return createElement("img", Object.assign({
        ref: function ref(c) {
          _this2._ref = c;
        },
        src: imageURI
      }, layerProps, {
        style: _extends({}, imageStyle, {
          objectFit: 'none'
        }),
        id: layerId
      }));
    }

    return createElement(Image$1, Object.assign({}, layerProps, {
      style: imageStyle,
      source: {
        uri: imageURI
      },
      resizeMode: layerProps['resizeMode'] ? layerProps['resizeMode'] : undefined,
      nativeID: layerId
    }));
  };

  _createClass(ImageRenderer, [{
    key: "maskPath",
    get: function get() {
      var layer = this.props.layer;
      var imageMask = layer.props.get('mask');

      if (!imageMask) {
        return '';
      }

      return generateSVGPath(imageMask || [], 1, true, layer.props.get('viewBox'));
    }
  }]);

  return ImageRenderer;
}(PureComponent);

var componentDefinition$4 = {
  version: '0.0.1',
  template: {
    type: 'image',
    "import": {
      layerName: 'Image',
      packageName: 'native',
      isDefaultImport: false,
      asName: ''
    },
    locked: false,
    template: {
      centerVertical: false,
      centerHorizontal: false
    },
    layout: {
      top: 50,
      left: 50,
      width: 200,
      height: 200,
      position: 'absolute'
    },
    style: {},
    props: {
      source: {
        uri: ""
      },
      resizeMode: 'contain'
    },
    children: []
  },
  thumbnail: // tslint:disable-next-line:max-line-length
  '',
  name: 'Image',
  controlsProperty: [{
    type: 'AlignmentEditor',
    title: 'Alignment Editor',
    value: {},
    showForMultiple: true
  }, {
    type: 'OrientationEditor',
    title: 'Orientation Editor',
    value: {},
    showForMultiple: true
  }, {
    type: 'ResizingTypeEditor',
    title: 'ResizingType Editor',
    value: {}
  }, {
    type: 'group',
    title: 'Styling',
    value: {},
    properties: [{
      propertyName: 'opacity',
      type: 'range',
      title: 'Opacity',
      value: {
        defaultValue: 1,
        min: 0,
        max: 1
      },
      category: 'style'
    }, {
      propertyName: 'backgroundColor',
      type: 'color',
      title: 'Fill',
      value: {
        defaultValue: '#fff'
      },
      additionalOptions: {
        showGradient: false
      },
      category: 'style'
    }, {
      type: 'BorderWidthEditor',
      title: 'BorderWidth Editor',
      value: {
        defaultValue: 1
      }
    }, {
      type: 'BorderRadiusEditor',
      title: 'BorderRadius Editor',
      value: {}
    }, {
      type: 'AccessibilityLabel',
      title: 'Accessibility Label',
      value: {}
    }]
  }, {
    type: 'group',
    title: 'Image',
    value: {},
    properties: [{
      type: 'ImageEditor',
      title: 'Image',
      value: {}
    }]
  }, // {
  //   type: "group",
  //   title: "Conditionals",
  //   value: {},
  //   properties: [
  //     {
  //       type: "ResetConditionalEditor",
  //       title: "Conditional Editor",
  //       value: {}
  //     }
  //   ]
  // },
  {
    type: 'group',
    title: 'Layout',
    value: {},
    properties: [{
      type: 'FlexboxEditor',
      title: 'Flexbox Editor',
      value: {}
    }, {
      type: 'MarginPaddingEditor',
      title: '',
      value: {}
    }]
  }]
};

var ImageRendererPlugin = /*#__PURE__*/function () {
  function ImageRendererPlugin() {
    this.name = 'ImageRenderer';
  }

  var _proto = ImageRendererPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
  };

  _proto.activate = function activate() {
    this.canvas.addComponent('image', ImageRenderer, componentDefinition$4);
  };

  _proto.deactivate = function deactivate() {};

  return ImageRendererPlugin;
}();

var rerenderProps$6 = ['layout', 'children', 'props', 'style', 'visible'];

var PathRenderer = /*#__PURE__*/function (_React$PureComponent) {
  _inheritsLoose(PathRenderer, _React$PureComponent);

  function PathRenderer() {
    var _this;

    _this = _React$PureComponent.apply(this, arguments) || this;

    _this.onUpdate = function () {
      _this.forceUpdate();
    };

    return _this;
  }

  var _proto = PathRenderer.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.props.layer.on(rerenderProps$6, this.onUpdate);
    this.props.layer.setDomRef(this);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.layer.off(rerenderProps$6, this.onUpdate);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    prevProps.layer.off(rerenderProps$6, this.onUpdate);
    this.props.layer.on(rerenderProps$6, this.onUpdate);
    this.props.layer.setDomRef(this);
  };

  _proto.render = function render() {
    var layer = this.props.layer;

    var layerProps = _extends({}, layer.props.getAll());

    var layerId = layerProps['id'];
    delete layerProps['id'];
    var transform = layer.rotation ? "rotate(" + layer.rotation + "deg)" : undefined;

    var pathStyle = _extends({}, layer.style.getAll(), layer.layout.getAll(), {
      transform: transform
    });

    delete pathStyle['backgroundImage'];
    var gradient = layer.style.get('gradient') || {};
    var mask = layer.props.get('mask');
    var maskId = generateRandomString(6);
    var gradientId = generateRandomString(6);
    return createElement(Svg // @ts-ignore
    , {
      // @ts-ignore
      id: layerId,
      style: pathStyle,
      viewBox: layerProps.viewBox,
      preserveAspectRatio: "none"
    }, !isEmpty(gradient) || mask && !isEmpty(mask) ? createElement(Defs, null, mask && !isEmpty(mask) && createElement(Mask, {
      id: maskId,
      x: "0",
      y: "0"
    }, createElement(Path, {
      fill: "white" // DOC: hard-coded acc. to the masking behaviour in sketch
      ,
      d: this.maskPath
    })), !isEmpty(gradient) && createElement(LinearGradient, {
      id: gradientId,
      x1: gradient.from.x,
      y1: gradient.from.y,
      x2: gradient.to.x,
      y2: gradient.to.y
    }, gradient.stops.map(function (stop, index) {
      return createElement(Stop, {
        key: "gradient-" + gradient.id + "-stop-" + index,
        offset: stop.offset,
        stopColor: stop.stopColor
      });
    }))) : null, createElement(Path, {
      stroke: layerProps.stroke,
      // transform={layerProps.rotation ? transform : undefined}
      fill: !isEmpty(gradient) ? "url(#" + gradientId + ")" : layerProps.fill,
      strokeWidth: layerProps.strokeWidth,
      fillOpacity: layerProps.fillOpacity,
      strokeOpacity: layerProps.strokeOpacity,
      clipPath: layerProps.clipPath,
      d: this.svgPath,
      // rotation={layerProps.rotation}
      mask: mask && !isEmpty(mask) ? "url(#" + maskId + ")" : undefined
    }));
  };

  _createClass(PathRenderer, [{
    key: "svgPath",
    get: function get() {
      var layer = this.props.layer;
      var pathProps = layer.props.getAll();
      return generateSVGPath(pathProps.points, pathProps.strokeWidth, pathProps.isClosed, pathProps.viewBox);
    }
  }, {
    key: "maskPath",
    get: function get() {
      var layer = this.props.layer;
      var imageMask = layer.props.get('mask');

      if (!imageMask) {
        return '';
      }

      return generateSVGPath(imageMask || [], 1, true, layer.props.get('viewBox'));
    }
  }]);

  return PathRenderer;
}(PureComponent);

var componentDefinition$5 = {
  version: '0.0.1',
  template: {
    type: 'path',
    children: [],
    "import": {
      layerName: 'Path',
      packageName: 'react-native-svg',
      isDefaultImport: false,
      asName: ''
    },
    locked: false,
    template: {
      centerVertical: false,
      centerHorizontal: false
    },
    layout: {
      top: 50,
      left: 50,
      width: 50,
      height: 50,
      position: 'absolute'
    },
    style: {},
    props: {
      points: [],
      isClosed: true,
      strokeWidth: 0,
      stroke: 'rgba(230, 230, 230,1)',
      fill: 'rgba(230, 230, 230,1)'
    }
  },
  thumbnail: // tslint:disable-next-line:max-line-length
  '',
  name: 'Path',
  controlsProperty: [{
    type: 'AlignmentEditor',
    title: 'Alignment Editor',
    value: {},
    showForMultiple: true
  }, {
    type: 'OrientationEditor',
    title: 'Orientation Editor',
    value: {},
    showForMultiple: true
  }, // {
  //   type: "LoopEditor",
  //   title: "Loop Editor",
  //   value: {}
  // },
  {
    type: 'group',
    title: 'Styling',
    value: {},
    properties: [{
      propertyName: 'opacity',
      type: 'range',
      title: 'Opacity',
      value: {
        defaultValue: 1,
        min: 0,
        max: 1
      },
      category: 'style'
    }, {
      type: 'PathCurveTypeEditor',
      title: 'Point Mode',
      value: {}
    }, {
      propertyName: 'fill',
      type: 'simpleColor',
      title: 'Fill',
      value: {
        defaultValue: '#fff'
      },
      category: 'props'
    }, {
      propertyName: 'stroke',
      type: 'simpleColor',
      title: 'Stroke',
      value: {
        defaultValue: '#fff'
      },
      category: 'props'
    }, {
      propertyName: 'strokeWidth',
      type: 'range',
      title: 'Stroke Width',
      value: {
        defaultValue: 1,
        min: 0,
        max: 100
      },
      category: 'props'
    }]
  }]
};

var PathRendererPlugin = /*#__PURE__*/function () {
  function PathRendererPlugin() {
    this.name = 'PathRenderer';
  }

  var _proto = PathRendererPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
  };

  _proto.activate = function activate() {
    this.canvas.addComponent('path', PathRenderer, componentDefinition$5);
  };

  _proto.deactivate = function deactivate() {};

  return PathRendererPlugin;
}();

//@ts-nocheck
var Icons = {
  EntypoIcon: EntypoIcon,
  AntDesignIcon: AntDesignIcon,
  EvilIconsIcon: EvilIconsIcon,
  FeatherIcon: FeatherIcon,
  FontAwesomeIcon: FontAwesomeIcon,
  FoundationIcon: FoundationIcon,
  IoniconsIcon: IoniconsIcon,
  MaterialCommunityIconsIcon: MaterialCommunityIconsIcon,
  MaterialIconsIcon: MaterialIconsIcon,
  OcticonsIcon: OcticonsIcon,
  SimpleLineIconsIcon: SimpleLineIconsIcon,
  ZocialIcon: ZocialIcon
};
var Fonts = {
  EntypoFont: EntypoFont,
  AntDesignFont: AntDesignFont,
  EvilIconsFont: EvilIconsFont,
  FeatherFont: FeatherFont,
  FontAwesomeFont: FontAwesomeFont,
  FoundationFont: FoundationFont,
  IoniconsFont: IoniconsFont,
  MaterialCommunityIconsFont: MaterialCommunityIconsFont,
  MaterialIconsFont: MaterialIconsFont,
  OcticonsFont: OcticonsFont,
  SimpleLineIconsFont: SimpleLineIconsFont,
  ZocialFont: ZocialFont
};

var rerenderProps$7 = ['layout', 'children', 'props', 'style', 'innerText', 'visible'];

var IconRenderer = /*#__PURE__*/function (_React$PureComponent) {
  _inheritsLoose(IconRenderer, _React$PureComponent);

  function IconRenderer() {
    var _this;

    _this = _React$PureComponent.apply(this, arguments) || this;

    _this.onUpdate = function () {
      _this.forceUpdate();
    };

    return _this;
  }

  var _proto = IconRenderer.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.props.layer.on(rerenderProps$7, this.onUpdate);
    this.props.layer.setDomRef(this._ref);
    this.props.layer.dispatchEvent('domDidMount', new RenderEvent('domDidMount', this));
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.layer.off(rerenderProps$7, this.onUpdate);
  };

  _proto.componentWillUpdate = function componentWillUpdate() {
    this.props.layer.dispatchEvent('domWillUpdate', new RenderEvent('domWillUpdate', this));
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    prevProps.layer.off(rerenderProps$7, this.onUpdate);
    this.props.layer.on(rerenderProps$7, this.onUpdate);
    this.props.layer.setDomRef(this._ref);
    this.props.layer.dispatchEvent('domDidUpdate', new RenderEvent('domDidUpdate', this));
  };

  _proto.render = function render() {
    var _this2 = this;

    var layer = this.props.layer;

    var layerProps = _extends({}, layer.props.getAll());

    var layerId = layerProps['id'];
    delete layerProps['id'];

    var iconStyle = _extends({}, layer.style.getAll(), layer.layout.getAll());

    iconStyle = _extends({}, iconStyle, {
      overflow: iconStyle.overflow ? iconStyle.overflow : 'hidden',
      height: 'fit-content',
      width: 'fit-content'
    });
    delete iconStyle['fontPostscriptName'];
    var iconType = layerProps.type ? layerProps.type : 'Entypo';
    var Icon = Icons[iconType + "Icon"] || Icons["EntypoIcon"];
    return createElement(Icon, Object.assign({
      ref: function ref(c) {
        _this2._ref = c;
      }
    }, layerProps, {
      style: iconStyle,
      nativeID: layerId
    }));
  };

  return IconRenderer;
}(PureComponent);

var IconComponentDefinition = {
  version: '0.0.1',
  template: {
    type: 'icon',
    children: [],
    "import": {
      layerName: 'Icon',
      packageName: '@builderx/icons',
      isDefaultImport: true,
      asName: ''
    },
    locked: false,
    template: {
      centerVertical: false,
      centerHorizontal: false
    },
    layout: {
      top: 150,
      left: 150,
      position: 'absolute'
    },
    style: {
      color: 'rgba(128,128,128,1)',
      fontSize: 40
    },
    props: {
      type: 'MaterialCommunityIcons',
      name: 'home'
    }
  },
  thumbnail: '',
  name: 'Icon',
  controlsProperty: [{
    type: 'AlignmentEditor',
    title: 'Alignment Editor',
    value: {},
    showForMultiple: true
  }, {
    type: 'OrientationEditor',
    title: 'Orientation Editor',
    value: {},
    showForMultiple: true,
    additionalOptions: {
      hideSize: true
    }
  }, {
    type: 'ResizingTypeEditor',
    title: 'ResizingType Editor',
    value: {},
    additionalOptions: {
      hideSize: true
    }
  }, {
    type: 'IconEditor',
    title: 'Icon Editor',
    value: {}
  }, {
    type: 'group',
    title: 'Layout',
    value: {},
    properties: [{
      type: 'FlexboxEditor',
      title: 'Flexbox Editor',
      value: {}
    }, {
      type: 'MarginPaddingEditor',
      title: 'MarginPadding Editor',
      value: {}
    }]
  }, {
    type: 'group',
    title: 'Styling',
    value: {},
    properties: [{
      propertyName: 'color',
      type: 'color',
      title: 'Color',
      value: {
        defaultValue: 'rgba(128,128,128,1)'
      },
      category: 'style'
    }, {
      propertyName: 'fontSize',
      type: 'range',
      title: 'Size',
      value: {
        defaultValue: 40,
        min: 0,
        max: 200
      },
      category: 'style'
    }, {
      propertyName: 'opacity',
      type: 'range',
      title: 'Opacity',
      value: {
        defaultValue: 1,
        min: 0,
        max: 1
      },
      category: 'style'
    }]
  }]
};

var IconRendererPlugin = /*#__PURE__*/function () {
  function IconRendererPlugin() {
    this.name = 'IconRendererPlugin';
  }

  var _proto = IconRendererPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
  };

  _proto.activate = function activate() {
    this.canvas.addComponent('icon', IconRenderer, IconComponentDefinition);
  };

  _proto.deactivate = function deactivate() {};

  return IconRendererPlugin;
}();

var rerenderProps$8 = ['layout', 'props', 'style', 'visible'];

var AndroidSwitchRenderer = /*#__PURE__*/function (_React$PureComponent) {
  _inheritsLoose(AndroidSwitchRenderer, _React$PureComponent);

  function AndroidSwitchRenderer() {
    var _this;

    _this = _React$PureComponent.apply(this, arguments) || this;

    _this.onUpdate = function () {
      _this.forceUpdate();
    };

    return _this;
  }

  var _proto = AndroidSwitchRenderer.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.props.layer.on(rerenderProps$8, this.onUpdate);
    this.props.layer.setDomRef(this._ref);
    this.props.layer.dispatchEvent('domDidMount', new RenderEvent('domDidMount', this));
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    prevProps.layer.off(rerenderProps$8, this.onUpdate);
    this.props.layer.on(rerenderProps$8, this.onUpdate);
    this.props.layer.setDomRef(this._ref);
    this.props.layer.dispatchEvent('domDidUpdate', new RenderEvent('domDidUpdate', this));
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.layer.off(rerenderProps$8, this.onUpdate);
  };

  _proto.render = function render() {
    var _this2 = this;

    var layer = this.props.layer;

    var switchStyle = _extends({}, layer.style.getAll(), layer.layout.getAll());

    var layerProps = _extends({}, layer.props.getAll());

    var layerId = layerProps['id'];
    delete layerProps['id'];
    return createElement(Switch, Object.assign({
      ref: function ref(c) {
        _this2._ref = c;
      }
    }, layerProps, {
      activeThumbColor: layerProps.thumbTintColor,
      trackColor: {
        "true": layerProps.onTintColor,
        "false": layerProps.tintColor
      },
      style: _extends({}, switchStyle, {
        width: undefined,
        height: undefined
      }),
      nativeID: layerId
    }));
  };

  return AndroidSwitchRenderer;
}(PureComponent);

function _templateObject() {
  var data = _taggedTemplateLiteralLoose(["\n  cursor: ", ";\n  -webkit-appearance: none;\n  font-size: 5px;\n  position: relative;\n  display: inline-block;\n  width: 9em;\n  height: 4.6em;\n  line-height: 4.6em;\n  border-radius: 2.3em;\n  margin: 0;\n  padding: 0;\n  transform: ", ";\n  box-shadow: ", ";\n  outline: 1px solid transparent !important;\n  border: none;\n  background: transparent;\n  user-select: none;\n  -webkit-tap-highlight-color: transparent;\n  -webkit-touch-callout: none;\n  :checked {\n    content: '';\n    box-shadow: ", ";\n    padding-left: 4.4em;\n  }\n  :before {\n    content: '';\n    display: inline-block;\n    height: 4.2em;\n    width: 4.2em;\n    margin: 0.2em 0 0 0.2em;\n    background-color: ", ";\n    border-radius: 2.1em;\n    box-shadow: 0 0.2em 0.4em 0 rgba(0, 0, 0, 0.2),\n      0 0 0.1em 0.1em rgba(0, 0, 0, 0.1);\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}
var IOSSwitch = /*#__PURE__*/styled.input( /*#__PURE__*/_templateObject(), function (props) {
  return props.disabled !== undefined && props.disabled ? 'not-allowed' : 'pointer';
}, function (props) {
  return props.style.transform ? "rotate(" + props.style.transform[0].rotate + ")" : "rotate(0deg);";
}, function (props) {
  return props.disabled ? 'inset 0 0 0 0.2em #bbb;' : props.tintColor ? 'inset 0 0 0 0.2em ' + props.tintColor : 'inset 0 0 0 0.2em #ddd;';
}, function (props) {
  return props.disabled ? 'inset 0 0 0 2.62857em #ddd !important;' : props.onTintColor ? 'inset 0 0 0 2.62857em ' + props.onTintColor + '!important;' : 'inset 0 0 0 2.62857em #00c169 !important;';
}, function (props) {
  return props.disabled ? '#ccc' : props.thumbTintColor ? props.thumbTintColor : '#fff';
});

var rerenderProps$9 = ['layout', 'props', 'style', 'visible'];

var IOSSwitchRenderer = /*#__PURE__*/function (_React$PureComponent) {
  _inheritsLoose(IOSSwitchRenderer, _React$PureComponent);

  function IOSSwitchRenderer() {
    var _this;

    _this = _React$PureComponent.apply(this, arguments) || this;

    _this.onUpdate = function () {
      _this.forceUpdate();
    };

    return _this;
  }

  var _proto = IOSSwitchRenderer.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.props.layer.on(rerenderProps$9, this.onUpdate);
    this.props.layer.setDomRef(this._ref);
    this.props.layer.dispatchEvent('domDidMount', new RenderEvent('domDidMount', this));
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.layer.off(rerenderProps$9, this.onUpdate);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    prevProps.layer.off(rerenderProps$9, this.onUpdate);
    this.props.layer.on(rerenderProps$9, this.onUpdate);
    this.props.layer.setDomRef(this._ref);
    this.props.layer.dispatchEvent('domDidUpdate', new RenderEvent('domDidUpdate', this));
  };

  _proto.render = function render() {
    var _this2 = this;

    var layer = this.props.layer;

    var switchStyle = _extends({}, layer.style.getAll(), layer.layout.getAll());

    var layerProps = _extends({}, layer.props.getAll());

    var layerId = layerProps['id'];
    delete layerProps['id'];
    return createElement(IOSSwitch, Object.assign({
      ref: function ref(c) {
        _this2._ref = c;
      },
      type: "checkbox"
    }, layerProps, {
      checked: layerProps.value,
      onChange: function onChange() {//
      },
      style: _extends({}, switchStyle, {
        width: undefined,
        height: undefined
      }),
      nativeID: layerId
    }));
  };

  return IOSSwitchRenderer;
}(PureComponent);

var rerenderProps$a = ['layout', 'props', 'style', 'visible'];

var SwitchRenderer = /*#__PURE__*/function (_React$PureComponent) {
  _inheritsLoose(SwitchRenderer, _React$PureComponent);

  function SwitchRenderer() {
    var _this;

    _this = _React$PureComponent.apply(this, arguments) || this;

    _this.onUpdate = function () {
      _this.forceUpdate();
    };

    return _this;
  }

  var _proto = SwitchRenderer.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.props.layer.on(rerenderProps$a, this.onUpdate);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.layer.off(rerenderProps$a, this.onUpdate);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    prevProps.layer.off(rerenderProps$a, this.onUpdate);
    this.props.layer.on(rerenderProps$a, this.onUpdate);
  };

  _proto.render = function render() {
    var platform = 'iOS';
    var deviceData = this.props.layer.executeFunction('getDeviceData');

    if (deviceData) {
      platform = deviceData.platform;
    }

    return platform === 'Android' ? createElement(AndroidSwitchRenderer, Object.assign({}, this.props)) : createElement(IOSSwitchRenderer, Object.assign({}, this.props));
  };

  return SwitchRenderer;
}(PureComponent);

var AndroidSwitchComponentDefinition = {
  version: '0.0.1',
  template: {
    type: 'switch',
    "import": {
      layerName: 'Switch',
      packageName: 'react-native',
      isDefaultImport: false,
      asName: ''
    },
    locked: false,
    template: {
      centerVertical: false,
      centerHorizontal: false
    },
    layout: {
      position: 'absolute',
      top: 50,
      left: 50
    },
    style: {},
    props: {
      value: true
    },
    children: []
  },
  thumbnail: '',
  name: 'Switch',
  controlsProperty: [{
    type: 'AlignmentEditor',
    title: 'Alignment Editor',
    value: {},
    showForMultiple: true
  }, {
    type: 'OrientationEditor',
    title: 'Orientation Editor',
    value: {},
    showForMultiple: true,
    additionalOptions: {
      hideSize: true
    }
  }, {
    type: 'ResizingTypeEditor',
    title: 'ResizingType Editor',
    value: {},
    additionalOptions: {
      hideSize: true
    }
  }, {
    type: 'group',
    title: 'Styling',
    value: {},
    properties: [{
      propertyName: 'opacity',
      type: 'range',
      title: 'Opacity',
      value: {
        defaultValue: 1,
        min: 0,
        max: 1
      },
      category: 'style'
    }]
  }, {
    type: 'group',
    title: 'Switch',
    value: {},
    properties: [{
      propertyName: 'value',
      category: 'props',
      type: 'boolean',
      title: 'Value',
      value: {
        defaultValue: false
      }
    }, {
      propertyName: 'disabled',
      category: 'props',
      type: 'boolean',
      title: 'Disabled',
      value: {
        defaultValue: false
      }
    }, {
      propertyName: 'thumbTintColor',
      type: 'bareColor',
      title: 'Grip',
      value: {
        defaultValue: '#fff'
      },
      category: 'props'
    }, {
      propertyName: 'onTintColor',
      type: 'bareColor',
      title: 'Turned On',
      value: {
        defaultValue: '#fff'
      },
      category: 'props'
    }, {
      propertyName: 'tintColor',
      type: 'bareColor',
      title: 'Turned Off',
      value: {
        defaultValue: '#fff'
      },
      category: 'props'
    }]
  }]
};

var IOSSwitchRendererPlugin = /*#__PURE__*/function () {
  function IOSSwitchRendererPlugin() {
    this.name = 'IOSSwitchRenderer';
  }

  var _proto = IOSSwitchRendererPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
  };

  _proto.activate = function activate() {
    this.canvas.addComponent('switch', SwitchRenderer, AndroidSwitchComponentDefinition);
  };

  _proto.deactivate = function deactivate() {};

  return IOSSwitchRendererPlugin;
}();

var rerenderProps$b = ['layout', 'props', 'style', 'visible'];

var AndroidActivityIndicatorRenderer = /*#__PURE__*/function (_React$PureComponent) {
  _inheritsLoose(AndroidActivityIndicatorRenderer, _React$PureComponent);

  function AndroidActivityIndicatorRenderer() {
    var _this;

    _this = _React$PureComponent.apply(this, arguments) || this;

    _this.onUpdate = function () {
      _this.forceUpdate();
    };

    return _this;
  }

  var _proto = AndroidActivityIndicatorRenderer.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.props.layer.on(rerenderProps$b, this.onUpdate);
    this.props.layer.setDomRef(this._ref);
    this.props.layer.dispatchEvent('domDidMount', new RenderEvent('domDidMount', this));
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    prevProps.layer.off(rerenderProps$b, this.onUpdate);
    this.props.layer.on(rerenderProps$b, this.onUpdate);
    this.props.layer.setDomRef(this._ref);
    this.props.layer.dispatchEvent('domDidUpdate', new RenderEvent('domDidUpdate', this));
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.layer.off(rerenderProps$b, this.onUpdate);
  };

  _proto.render = function render() {
    var _this2 = this;

    var layer = this.props.layer;

    var layerProps = _extends({}, layer.props.getAll());

    var layerId = layerProps['id'];
    delete layerProps['id'];

    var activityIndicatorStyle = _extends({}, layer.style.getAll(), layer.layout.getAll());

    var height = layerProps.size === 'large' ? 40 : 22;
    var width = layerProps.size === 'large' ? 39 : 22;
    return createElement(ActivityIndicator, Object.assign({
      ref: function ref(c) {
        _this2._ref = c;
      }
    }, layerProps, {
      style: _extends({}, activityIndicatorStyle, {
        height: height,
        width: width
      }),
      nativeID: layerId
    }));
  };

  return AndroidActivityIndicatorRenderer;
}(PureComponent);

function _templateObject3() {
  var data = _taggedTemplateLiteralLoose(["\n  position: relative;\n  display: inline-block;\n"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteralLoose(["\n  width: 6%;\n  height: 16%;\n  background: #000;\n  position: absolute;\n  left: 49%;\n  top: 43%;\n  opacity: 0;\n  -webkit-border-radius: 50px;\n  -webkit-box-shadow: 0 0 3px rgba(0, 0, 0, 0.2);\n  -webkit-animation: ", " 1s linear infinite;\n  background: ", ";\n"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject$1() {
  var data = _taggedTemplateLiteralLoose(["\nfrom {\n  opacity: 1;\n}\nto {\n  opacitfy: 0.25;\n}\n"]);

  _templateObject$1 = function _templateObject() {
    return data;
  };

  return data;
}
var defaultSpinnerColor = '#353940';
var keyFrameFade = /*#__PURE__*/keyframes( /*#__PURE__*/_templateObject$1());
var Bar = /*#__PURE__*/styled.div( /*#__PURE__*/_templateObject2(), keyFrameFade, function (props) {
  return props.color ? props.color : defaultSpinnerColor;
});
var SpinnerWrapper = /*#__PURE__*/styled.div( /*#__PURE__*/_templateObject3());
var IOSSpinner = /*#__PURE__*/forwardRef(function (props, ref) {
  var size = props.size,
      color = props.color,
      remainingProps = _objectWithoutPropertiesLoose(props, ["size", "color"]);

  var height = size === 'large' ? 40 : 22;
  var width = size === 'large' ? 40 : 22;
  return createElement(SpinnerWrapper, Object.assign({
    ref: ref,
    style: {
      height: height,
      width: width
    }
  }, remainingProps), createElement(Bar, {
    color: color,
    style: {
      transform: 'rotate(0deg) translate(0, -130%)',
      animationDelay: '0s'
    }
  }), createElement(Bar, {
    color: color,
    style: {
      transform: 'rotate(30deg) translate(0, -130%)',
      animationDelay: '-0.9167s'
    }
  }), createElement(Bar, {
    color: color,
    style: {
      transform: 'rotate(60deg) translate(0, -130%)',
      animationDelay: '-0.833s'
    }
  }), createElement(Bar, {
    color: color,
    style: {
      transform: 'rotate(90deg) translate(0, -130%)',
      animationDelay: '-0.7497s'
    }
  }), createElement(Bar, {
    color: color,
    style: {
      transform: 'rotate(120deg) translate(0, -130%)',
      animationDelay: '-0.667s'
    }
  }), createElement(Bar, {
    color: color,
    style: {
      transform: 'rotate(150deg) translate(0, -130%)',
      animationDelay: '-0.5837s'
    }
  }), createElement(Bar, {
    color: color,
    style: {
      transform: 'rotate(180deg) translate(0, -130%)',
      animationDelay: '-0.5s'
    }
  }), createElement(Bar, {
    color: color,
    style: {
      transform: 'rotate(210deg) translate(0, -130%)',
      animationDelay: '-0.4167s'
    }
  }), createElement(Bar, {
    color: color,
    style: {
      transform: 'rotate(240deg) translate(0, -130%)',
      animationDelay: '-0.333s'
    }
  }), createElement(Bar, {
    color: color,
    style: {
      transform: 'rotate(270deg) translate(0, -130%)',
      animationDelay: '-0.2497s'
    }
  }), createElement(Bar, {
    color: color,
    style: {
      transform: 'rotate(300deg) translate(0, -130%)',
      animationDelay: '-0.167s'
    }
  }), createElement(Bar, {
    color: color,
    style: {
      transform: 'rotate(330deg) translate(0, -130%)',
      animationDelay: '-0.0833s'
    }
  }));
});

var rerenderProps$c = ['layout', 'props', 'style', 'visible'];

var IOSActivityIndicatorRenderer = /*#__PURE__*/function (_React$PureComponent) {
  _inheritsLoose(IOSActivityIndicatorRenderer, _React$PureComponent);

  function IOSActivityIndicatorRenderer() {
    var _this;

    _this = _React$PureComponent.apply(this, arguments) || this;

    _this.onUpdate = function () {
      _this.forceUpdate();
    };

    return _this;
  }

  var _proto = IOSActivityIndicatorRenderer.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.props.layer.on(rerenderProps$c, this.onUpdate);
    this.props.layer.setDomRef(this._ref);
    this.props.layer.dispatchEvent('domDidMount', new RenderEvent('domDidMount', this));
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    prevProps.layer.off(rerenderProps$c, this.onUpdate);
    this.props.layer.on(rerenderProps$c, this.onUpdate);
    this.props.layer.setDomRef(this._ref);
    this.props.layer.dispatchEvent('domDidUpdate', new RenderEvent('domDidUpdate', this));
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.layer.off(rerenderProps$c, this.onUpdate);
  };

  _proto.render = function render() {
    var _this2 = this;

    var layer = this.props.layer;

    var layerProps = _extends({}, layer.props.getAll());

    var layerId = layerProps['id'];
    delete layerProps['id'];

    var layerStyle = _extends({}, layer.style.getAll(), layer.layout.getAll());

    var height = layerProps.size === 'large' ? 40 : 22;
    var width = layerProps.size === 'large' ? 39 : 22;
    return createElement(IOSSpinner, Object.assign({
      ref: function ref(c) {
        _this2._ref = c;
      }
    }, layerProps, {
      color: layerProps.color,
      style: _extends({}, layerStyle, {
        height: height,
        width: width
      }),
      className: layerId
    }));
  };

  return IOSActivityIndicatorRenderer;
}(PureComponent);

var rerenderProps$d = ['layout', 'props', 'style', 'visible'];

var ActivityIndicatorRenderer = /*#__PURE__*/function (_React$PureComponent) {
  _inheritsLoose(ActivityIndicatorRenderer, _React$PureComponent);

  function ActivityIndicatorRenderer() {
    var _this;

    _this = _React$PureComponent.apply(this, arguments) || this;

    _this.onUpdate = function () {
      _this.forceUpdate();
    };

    return _this;
  }

  var _proto = ActivityIndicatorRenderer.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.props.layer.on(rerenderProps$d, this.onUpdate);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.layer.off(rerenderProps$d, this.onUpdate);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    prevProps.layer.off(rerenderProps$d, this.onUpdate);
    this.props.layer.on(rerenderProps$d, this.onUpdate);
  };

  _proto.render = function render() {
    var platform = 'iOS';
    var deviceData = this.props.layer.executeFunction('getDeviceData');

    if (deviceData) {
      platform = deviceData.platform;
    }

    return platform === 'Android' ? createElement(AndroidActivityIndicatorRenderer, Object.assign({}, this.props)) : createElement(IOSActivityIndicatorRenderer, Object.assign({}, this.props));
  };

  return ActivityIndicatorRenderer;
}(PureComponent);

var ActivityIndicatorComponentDefinition = {
  version: '0.0.1',
  template: {
    type: 'activityIndicator',
    "import": {
      layerName: 'ActivityIndicator',
      packageName: 'react-native',
      isDefaultImport: false,
      asName: ''
    },
    locked: false,
    template: {
      centerVertical: false,
      centerHorizontal: false
    },
    layout: {
      position: 'absolute',
      top: 50,
      left: 50
    },
    style: {},
    props: {},
    children: []
  },
  thumbnail: '',
  name: 'ActivityIndicator',
  controlsProperty: [{
    type: 'AlignmentEditor',
    title: 'Alignment Editor',
    value: {},
    showForMultiple: true
  }, {
    type: 'OrientationEditor',
    title: 'Orientation Editor',
    value: {},
    showForMultiple: true,
    additionalOptions: {
      hideSize: true
    }
  }, {
    type: 'ResizingTypeEditor',
    title: 'ResizingType Editor',
    value: {},
    additionalOptions: {
      hideSize: true
    }
  }, {
    type: 'group',
    title: 'Activity Indicator',
    value: {},
    properties: [{
      propertyName: 'color',
      type: 'simpleColor',
      title: 'Color',
      value: {
        defaultValue: '#fff'
      },
      category: 'props'
    }, {
      propertyName: 'size',
      type: 'enum',
      title: 'Size',
      value: {
        options: ['small', 'large'],
        defaultValue: 'small'
      },
      category: 'props'
    }, {
      propertyName: 'opacity',
      type: 'range',
      title: 'Opacity',
      value: {
        defaultValue: 1,
        min: 0,
        max: 1
      },
      category: 'style'
    }]
  }]
};

var ActivityIndicatorRendererPlugin = /*#__PURE__*/function () {
  function ActivityIndicatorRendererPlugin() {
    this.name = 'ActivityIndicatorRenderer';
  }

  var _proto = ActivityIndicatorRendererPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
  };

  _proto.activate = function activate() {
    this.canvas.addComponent('activityIndicator', ActivityIndicatorRenderer, ActivityIndicatorComponentDefinition);
  };

  _proto.deactivate = function deactivate() {};

  return ActivityIndicatorRendererPlugin;
}();

var rerenderProps$e = ['layout', 'children', 'props', 'style', 'visible', 'gradient'];

var EllipseRenderer = /*#__PURE__*/function (_React$PureComponent) {
  _inheritsLoose(EllipseRenderer, _React$PureComponent);

  function EllipseRenderer() {
    var _this;

    _this = _React$PureComponent.apply(this, arguments) || this;

    _this.onUpdate = function () {
      _this.forceUpdate();
    };

    return _this;
  }

  var _proto = EllipseRenderer.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.props.layer.on(rerenderProps$e, this.onUpdate);
    this.props.layer.setDomRef(this);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.layer.off(rerenderProps$e, this.onUpdate);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    prevProps.layer.off(rerenderProps$e, this.onUpdate);
    this.props.layer.on(rerenderProps$e, this.onUpdate);
    this.props.layer.setDomRef(this);
  };

  _proto.render = function render() {
    var _this2 = this;

    var layer = this.props.layer;

    var ellipseProps = _extends({}, layer.props.getAll());

    var layerId = ellipseProps['id'];
    delete ellipseProps['id'];
    var transform = layer.rotation ? "rotate(" + layer.rotation + "deg)" : undefined;

    var ellipseStyle = _extends({}, layer.style.getAll(), layer.layout.getAll(), {
      transform: transform
    });

    var strokeWidth = Number(get$1(ellipseProps, 'strokeWidth', 0));
    var appliedProps = {
      cx: ellipseProps.cx,
      cy: ellipseProps.cy,
      rx: ellipseProps.rx,
      ry: ellipseProps.ry,
      fill: get$1(ellipseProps, 'fill', 'transparent'),
      // fill: gradientType ? `url(#${gradientId})` : extractedProps.fill,
      fillOpacity: ellipseProps.fillOpacity,
      strokeOpacity: ellipseProps.strokeOpacity,
      stroke: ellipseProps.stroke,
      strokeWidth: strokeWidth
    };
    return createElement(Svg, {
      ref: function ref(c) {
        _this2._ref = c;
      },
      // @ts-ignore
      getRef: function getRef(c) {
        console.log(c, 'ref here');
      },
      // @ts-ignore
      id: layerId,
      style: ellipseStyle,
      viewBox: ellipseProps.viewBox,
      preserveAspectRatio: "none"
    }, createElement(Ellipse, Object.assign({}, appliedProps)));
  };

  return EllipseRenderer;
}(PureComponent);

var componentDefinition$6 = {
  version: '0.0.1',
  template: {
    type: 'ellipse',
    "import": {
      layerName: 'Ellipse',
      packageName: 'react-native-svg',
      isDefaultImport: false,
      asName: ''
    },
    locked: false,
    template: {
      centerVertical: false,
      centerHorizontal: false
    },
    layout: {
      top: 50,
      left: 50,
      width: 100,
      height: 100,
      position: 'absolute'
    },
    style: {},
    props: {
      stroke: 'rgba(230, 230, 230,1)',
      strokeWidth: 0,
      fill: 'rgba(230, 230, 230,1)'
    },
    children: []
  },
  thumbnail: // tslint:disable-next-line:max-line-length
  '',
  name: 'Ellipse',
  controlsProperty: [{
    type: 'AlignmentEditor',
    title: 'Alignment Editor',
    value: {},
    showForMultiple: true
  }, {
    type: 'OrientationEditor',
    title: 'Orientation Editor',
    value: {},
    showForMultiple: true
  }, {
    type: 'group',
    title: 'Styling',
    value: {},
    properties: [{
      propertyName: 'opacity',
      type: 'range',
      title: 'Opacity',
      value: {
        defaultValue: 1,
        min: 0,
        max: 1
      },
      category: 'style'
    }, {
      propertyName: 'fill',
      type: 'simpleColor',
      title: 'Fill',
      value: {
        defaultValue: '#fff'
      },
      additionalOptions: {
        showGradient: false
      },
      category: 'props'
    }, {
      propertyName: 'stroke',
      type: 'simpleColor',
      title: 'Stroke',
      value: {
        defaultValue: '#000'
      },
      category: 'props'
    }, {
      propertyName: 'strokeWidth',
      type: 'range',
      title: 'Width',
      value: {
        defaultValue: 1,
        min: 0,
        max: 100
      },
      category: 'props'
    }]
  }, {
    type: 'group',
    title: 'Layout',
    value: {},
    properties: [{
      type: 'FlexboxEditor',
      title: 'Flexbox Editor',
      value: {}
    }, {
      type: 'MarginPaddingEditor',
      title: '',
      value: {}
    }]
  }]
};

var EllipseRendererPlugin = /*#__PURE__*/function () {
  function EllipseRendererPlugin() {
    this.name = 'EllipseRenderer';
  }

  var _proto = EllipseRendererPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas; // canvas.registerDataStore("MyPlugin")
  };

  _proto.activate = function activate() {
    this.canvas.addComponent('ellipse', EllipseRenderer, componentDefinition$6); // this.canvas.addEventListener('click', e => {
    //   console.log(e);
    // });
  };

  _proto.deactivate = function deactivate() {};

  return EllipseRendererPlugin;
}();

function _templateObject5() {
  var data = _taggedTemplateLiteralLoose(["\n  height: 2px;\n  border-radius: 2px;\n  position: relative;\n  top: -2px;\n  -webkit-appearance: none;\n\n  background-image: ", ";\n"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteralLoose(["\n  webkit-appearance: none;\n  background-color: #666;\n  display: block;\n  width: 28px;\n  height: 28px;\n  // z-index:2;\n  border-radius: 50%;\n  background: #fff;\n  box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.2);\n  cursor: pointer;\n  position: relative;\n  top: -12.5px;\n\n  left: ", ";\n"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3$1() {
  var data = _taggedTemplateLiteralLoose(["\n  height: 2px;\n  border-radius: 2px;\n  position: relative;\n  -webkit-appearance: none;\n\n  background-image: ", ";\n"]);

  _templateObject3$1 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2$1() {
  var data = _taggedTemplateLiteralLoose(["\n  -webkit-appearance: none;\n  background-color: #666;\n  width: 14px;\n  height: 14px;\n  // z-index:2;\n  border-radius: 50%;\n  box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.2);\n  cursor: pointer;\n  position: relative;\n  top: -5.5px;\n  background: ", ";\n  left: ", ";\n  box-shadow: ", ";\n"]);

  _templateObject2$1 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject$2() {
  var data = _taggedTemplateLiteralLoose([""]);

  _templateObject$2 = function _templateObject() {
    return data;
  };

  return data;
}
var SliderWrapper = /*#__PURE__*/styled.div( /*#__PURE__*/_templateObject$2());
var AndroidSliderButton = /*#__PURE__*/styled.div( /*#__PURE__*/_templateObject2$1(), function (props) {
  var disabled = props.disabled,
      thumbTintColor = props.thumbTintColor;
  return disabled ? '#666' : thumbTintColor ? thumbTintColor : '#00897b';
}, function (props) {
  var value = props.value;
  return value ? value + "px" : '0px';
}, function (props) {
  return props.disabled ? '0px 2px 4px transparent' : '0px 2px 4px rgba(0,0,0,.2)';
});
var AndroidSliderProgressBar = /*#__PURE__*/styled.div( /*#__PURE__*/_templateObject3$1(), function (props) {
  var value = props.value,
      minimumTrackTintColor = props.minimumTrackTintColor,
      maximumTrackTintColor = props.maximumTrackTintColor;
  return value ? "-webkit-gradient(\n              linear,\n              left top,\n              right top,\n              color-stop(" + value + ", " + (minimumTrackTintColor ? minimumTrackTintColor : '#00897b') + "),\n              color-stop(" + value + ", " + (maximumTrackTintColor ? maximumTrackTintColor : '#b7b7b7') + "))" : "-webkit-gradient(\n              linear,\n              left top,\n              right top,\n              color-stop(0, #00897b),\n              color-stop(0, #b7b7b7))";
});
var IOSSliderButton = /*#__PURE__*/styled.div( /*#__PURE__*/_templateObject4(), function (props) {
  var value = props.value;
  return value ? value + "px" : '0px';
});
var IOSSliderProgressBar = /*#__PURE__*/styled.div( /*#__PURE__*/_templateObject5(), function (props) {
  var value = props.value,
      minimumTrackTintColor = props.minimumTrackTintColor,
      maximumTrackTintColor = props.maximumTrackTintColor;
  return value ? "-webkit-gradient(\n          linear,\n          left top,\n          right top,\n          color-stop(" + value + ", " + (minimumTrackTintColor ? minimumTrackTintColor : '#007aff') + "),\n          color-stop(" + value + ", " + (maximumTrackTintColor ? maximumTrackTintColor : '#b7b7b7') + "))" : "-webkit-gradient(\n          linear,\n          left top,\n          right top,\n          color-stop(0, #007aff),\n          color-stop(0, #b7b7b7))";
});

var Slider = /*#__PURE__*/function (_React$PureComponent) {
  _inheritsLoose(Slider, _React$PureComponent);

  function Slider() {
    return _React$PureComponent.apply(this, arguments) || this;
  }

  var _proto = Slider.prototype;

  _proto.render = function render() {
    var isAndroid = this.props.platform === 'Android';
    var SliderProgressBar = isAndroid ? AndroidSliderProgressBar : IOSSliderProgressBar;
    var SliderButton = isAndroid ? AndroidSliderButton : IOSSliderButton;
    var value = isNil(this.props.value) ? 0 : this.props.value;
    var maximumValue = isNil(this.props.maximumValue) ? 100 : this.props.maximumValue;
    var minimumValue = this.props.minimumValue || 0;
    var sliderRange = maximumValue - minimumValue;
    var sliderValue = value - minimumValue >= 0 ? value - minimumValue : 0;
    var sliderButtonPosition = ((this.props.style.width || 0) - (isAndroid ? 12 : 28)) * (sliderValue / sliderRange);
    return createElement(SliderWrapper, {
      style: _extends({}, this.props.style, {
        paddingTop: this.props.style.height ? this.props.style.height / 2 : 0
      }),
      className: this.props.className ? this.props.className : undefined
    }, createElement(SliderProgressBar, {
      style: {
        width: '100%',
        height: 2,
        opacity: this.props.disabled ? isAndroid ? 0.7 : 0.5 : 1
      },
      value: sliderValue / sliderRange,
      minimumTrackTintColor: this.props.minimumTrackTintColor,
      maximumTrackTintColor: this.props.maximumTrackTintColor
    }, createElement(SliderButton, {
      value: sliderButtonPosition,
      thumbTintColor: isAndroid ? this.props.thumbTintColor : undefined
    })));
  };

  return Slider;
}(PureComponent);

var rerenderProps$f = ['layout', 'props', 'style', 'visible'];

var SliderRenderer = /*#__PURE__*/function (_React$PureComponent) {
  _inheritsLoose(SliderRenderer, _React$PureComponent);

  function SliderRenderer() {
    var _this;

    _this = _React$PureComponent.apply(this, arguments) || this;

    _this.onUpdate = function () {
      _this.forceUpdate();
    };

    return _this;
  }

  var _proto = SliderRenderer.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.props.layer.on(rerenderProps$f, this.onUpdate);
    this.props.layer.setDomRef(this._ref);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    prevProps.layer.off(rerenderProps$f, this.onUpdate);
    this.props.layer.on(rerenderProps$f, this.onUpdate);
    this.props.layer.setDomRef(this._ref);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.layer.off(rerenderProps$f, this.onUpdate);
  };

  _proto.render = function render() {
    var _this2 = this;

    var layer = this.props.layer;

    var sliderProps = _extends({}, layer.props.getAll());

    var sliderStyle = _extends({}, layer.style.getAll(), layer.layout.getAll(), {
      width: layer.getBoundingClientRect().width,
      height: layer.getBoundingClientRect().height
    });

    var platform = 'iOS';
    var deviceData = this.props.layer.executeFunction('getDeviceData');

    if (deviceData) {
      platform = deviceData.platform;
    }

    return createElement(Slider, Object.assign({
      ref: function ref(c) {
        _this2._ref = c;
      }
    }, sliderProps, {
      platform: platform,
      style: sliderStyle
    }));
  };

  return SliderRenderer;
}(PureComponent);

var SliderComponentDefinition = {
  version: '0.0.1',
  template: {
    type: 'slider',
    "import": {
      layerName: 'Slider',
      packageName: 'react-native',
      isDefaultImport: false,
      asName: ''
    },
    locked: false,
    template: {
      centerVertical: false,
      centerHorizontal: false
    },
    layout: {
      position: 'absolute',
      top: 50,
      left: 50,
      height: 50,
      width: 50
    },
    style: {},
    props: {
      value: 50
    },
    children: []
  },
  thumbnail: '',
  name: 'Slider',
  controlsProperty: [{
    type: 'AlignmentEditor',
    title: 'Alignment Editor',
    value: {},
    showForMultiple: true
  }, {
    type: 'OrientationEditor',
    title: 'Orientation Editor',
    value: {},
    showForMultiple: true
  }, {
    type: 'ResizingTypeEditor',
    title: 'ResizingType Editor',
    value: {}
  }, {
    type: 'group',
    title: 'Styling',
    value: {},
    properties: [{
      propertyName: 'opacity',
      type: 'range',
      title: 'Opacity',
      value: {
        defaultValue: 1,
        min: 0,
        max: 1
      },
      category: 'style'
    }]
  }, {
    type: 'group',
    title: 'Slider',
    value: {},
    properties: [{
      propertyName: 'disabled',
      type: 'boolean',
      title: 'Disabled',
      value: {
        defaultValue: false
      },
      category: 'props'
    }, {
      propertyName: 'value',
      type: 'range',
      title: 'Value',
      value: {
        defaultValue: 0,
        min: 0,
        max: 100
      },
      category: 'props'
    }, {
      propertyName: 'minimumValue',
      type: 'number',
      title: 'Minimum Value',
      value: {
        defaultValue: 0
      },
      category: 'props'
    }, {
      propertyName: 'maximumValue',
      type: 'number',
      title: 'Maximum Value',
      value: {
        defaultValue: 100
      },
      category: 'props'
    }, {
      propertyName: 'step',
      type: 'number',
      title: 'Step',
      value: {
        defaultValue: 0
      },
      category: 'props'
    }, {
      propertyName: 'minimumTrackTintColor',
      type: 'bareColor',
      title: 'Minimum Track',
      value: {
        defaultValue: '#000'
      },
      category: 'props'
    }, {
      propertyName: 'maximumTrackTintColor',
      type: 'bareColor',
      title: 'Maximum Track',
      value: {
        defaultValue: '#000'
      },
      category: 'props'
    }, {
      propertyName: 'thumbTintColor',
      type: 'bareColor',
      title: 'Thumb',
      value: {
        defaultValue: '#000'
      },
      category: 'props'
    }]
  }]
};

var SliderRendererPlugin = /*#__PURE__*/function () {
  function SliderRendererPlugin() {
    this.name = 'SliderRenderer';
  }

  var _proto = SliderRendererPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas; // canvas.registerDataStore("MyPlugin")
  };

  _proto.activate = function activate() {
    this.canvas.addComponent('slider', SliderRenderer, SliderComponentDefinition); // this.canvas.addEventListener('click', e => {
    //   console.log(e);
    // });
  };

  _proto.deactivate = function deactivate() {};

  return SliderRendererPlugin;
}();

var rerenderProps$g = ['layout', 'children', 'props', 'style', 'visible'];

var MapViewRenderer = /*#__PURE__*/function (_React$PureComponent) {
  _inheritsLoose(MapViewRenderer, _React$PureComponent);

  function MapViewRenderer() {
    var _this;

    _this = _React$PureComponent.apply(this, arguments) || this;

    _this.onUpdate = function () {
      _this.forceUpdate();
    };

    return _this;
  }

  var _proto = MapViewRenderer.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.props.layer.on(rerenderProps$g, this.onUpdate);
    this.props.layer.setDomRef(this._ref);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.layer.off(rerenderProps$g, this.onUpdate);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    prevProps.layer.off(rerenderProps$g, this.onUpdate);
    this.props.layer.on(rerenderProps$g, this.onUpdate);
    this.props.layer.setDomRef(this._ref);
  };

  _proto.render = function render() {
    var _this2 = this;

    var layer = this.props.layer;

    var layerProps = _extends({}, layer.props.getAll());

    var layerId = layerProps['id'];
    delete layerProps['id'];

    var mapViewStyles = _extends({}, layer.style.getAll(), layer.layout.getAll());

    var mapStyle = layerProps.customMapStyle ? layerProps.customMapStyle : 'Standard';
    var canvas = layer.getCanvas();

    try {
      return createElement(Image$1, Object.assign({
        ref: function ref(c) {
          _this2._ref = c;
        }
      }, layerProps, {
        style: _extends({
          resizeMode: 'cover'
        }, mapViewStyles),
        source: {
          uri: canvas.assetURL + "/" + mapStyle + ".png"
        },
        nativeID: layerId
      }));
    } catch (Error) {
      return createElement(Image$1, Object.assign({
        ref: function ref(c) {
          _this2._ref = c;
        }
      }, layerProps, {
        style: _extends({
          resizeMode: 'cover'
        }, mapViewStyles),
        source: {
          uri: canvas.assetURL + "/Standard.png"
        },
        nativeID: layerId
      }));
    }
  };

  return MapViewRenderer;
}(PureComponent);

var MapViewComponentDefinition = {
  version: '0.0.1',
  template: {
    type: 'mapView',
    "import": {
      layerName: 'MapView',
      packageName: 'expo',
      isDefaultImport: false,
      asName: ''
    },
    locked: false,
    template: {
      centerVertical: false,
      centerHorizontal: false
    },
    layout: {
      position: 'absolute',
      top: 50,
      left: 50
    },
    style: {},
    props: {
      provider: 'MapView.PROVIDER_GOOGLE',
      initialRegion: {
        latitude: 37.78825,
        longitude: -122.4324,
        latitudeDelta: 0.0922,
        longitudeDelta: 0.0421
      },
      customMapStyle: 'Standard'
    },
    children: []
  },
  thumbnail: '',
  name: 'MapView',
  controlsProperty: [{
    type: 'AlignmentEditor',
    title: 'Alignment Editor',
    value: {},
    showForMultiple: true
  }, {
    type: 'OrientationEditor',
    title: 'Orientation Editor',
    value: {},
    showForMultiple: true
  }, {
    type: 'ResizingTypeEditor',
    title: 'ResizingType Editor',
    value: {}
  }, {
    type: 'group',
    title: 'Styling',
    value: {},
    properties: [{
      propertyName: 'opacity',
      type: 'range',
      title: 'Opacity',
      value: {
        defaultValue: 1,
        min: 0,
        max: 1
      },
      category: 'style'
    }, {
      propertyName: 'customMapStyle',
      title: 'Map View Style',
      type: 'enum',
      value: {
        options: ['Standard', 'Silver', 'Retro', 'Dark', 'Night', 'Aubergine'],
        defaultValue: 'Standard'
      },
      category: 'props'
    }]
  }]
};

var MapViewRendererPlugin = /*#__PURE__*/function () {
  function MapViewRendererPlugin() {
    this.name = 'MapViewRenderer';
  }

  var _proto = MapViewRendererPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
  };

  _proto.activate = function activate() {
    this.canvas.addComponent('mapView', MapViewRenderer, MapViewComponentDefinition);
  };

  _proto.deactivate = function deactivate() {};

  return MapViewRendererPlugin;
}();

var PopoverMenuPlugin = /*#__PURE__*/function () {
  function PopoverMenuPlugin() {
    this.name = 'PopoverMenu';
  }

  var _proto = PopoverMenuPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
    this.dispose = null;
  };

  _proto.showMenu = function showMenu(context, json, event) {
    this.dispose();
    event.originalEvent.preventDefault();
    this.containerElement = document.createElement('div');
    this.dispose = this.canvas.addDomToViewport(this.containerElement);
    var randomId = generateRandomString(4);
    var menuReactElement = createElement(MainMenu, {
      menuId: "menuId-" + randomId,
      data: json
    });
    ReactDOM__default.render(menuReactElement, this.containerElement);
    contextMenu.show({
      id: "menuId-" + randomId,
      event: event.originalEvent
    });
  };

  _proto.activate = function activate() {
    this.containerElement = document.createElement('div');
    this.dispose = this.canvas.addDomToViewport(this.containerElement);
    this.canvas.addFunction('showPopoverMenu', this.showMenu.bind(this));
  };

  _proto.deactivate = function deactivate() {
    this.canvas.removeFunction('showPopoverMenu');
    this.dispose();
  };

  return PopoverMenuPlugin;
}();

function getAllSiblingLayerPoints(config, context, layers, parent) {
  var snapPoints = {
    x: [],
    y: []
  }; // if (!layers || layers.length === 0) {
  //   return snapPoints;
  // }
  // let selectedLayer = layers[0];

  if (!parent || !config.snap || !config.siblingSnap) {
    return {
      x: [],
      y: []
    };
  }

  if (parent) {
    forEach(parent.children, function (layer) {
      try {
        if (layers.includes(layer)) {
          return Promise.resolve();
        } // TODO: Figure out what this was for
        // if (
        //   layers.indexOf(layer) > -1 ||
        //   layer.domainCompiledRef.type === 'fileHeader'
        // ) {
        //   return;
        // }


        var layerPoints = getLayerPoints(context, layer);
        snapPoints.x = snapPoints.x.concat(layerPoints.x);
        snapPoints.y = snapPoints.y.concat(layerPoints.y);
        return Promise.resolve();
      } catch (e) {
        return Promise.reject(e);
      }
    });
  }

  return snapPoints;
}

function getLayerPoints(context, layer) {
  var x = [];
  var y = [];
  var minX = undefined;
  var maxX = undefined;
  var minY = undefined;
  var maxY = undefined;
  var layerBox = context.canvas.getBoundingBoxWRTParent([layer], true);
  var xSnapPoint1 = {
    value: layerBox.x,
    rootValue: layerBox.rootX,
    minY: minY,
    maxY: maxY,
    snapTo: {
      center: true,
      start: true,
      end: true
    }
  };
  var xSnapPoint2 = {
    value: layerBox.x + layerBox.width,
    rootValue: layerBox.rootX + layerBox.width,
    minY: minY,
    maxY: maxY,
    snapTo: {
      center: true,
      start: true,
      end: true
    }
  };
  var xSnapPoint3 = {
    value: layerBox.x + layerBox.width / 2,
    rootValue: layerBox.rootX + layerBox.width / 2,
    minY: minY,
    maxY: maxY,
    snapTo: {
      center: true,
      start: true,
      end: true
    }
  };
  var ySnapPoint1 = {
    value: layerBox.y,
    rootValue: layerBox.rootY,
    minX: minX,
    maxX: maxX,
    snapTo: {
      center: true,
      start: true,
      end: true
    }
  };
  var ySnapPoint2 = {
    value: layerBox.y + layerBox.height,
    rootValue: layerBox.rootY + layerBox.height,
    minX: minX,
    maxX: maxX,
    snapTo: {
      center: true,
      start: true,
      end: true
    }
  };
  var ySnapPoint3 = {
    value: layerBox.y + layerBox.height / 2,
    rootValue: layerBox.rootY + layerBox.height / 2,
    minX: minX,
    maxX: maxX,
    snapTo: {
      center: true,
      start: true,
      end: true
    }
  };
  x.push(xSnapPoint1);
  x.push(xSnapPoint2);
  x.push(xSnapPoint3);
  y.push(ySnapPoint1);
  y.push(ySnapPoint2);
  y.push(ySnapPoint3);
  return {
    x: x,
    y: y
  };
}

// TODO: Add typing to it
// the arguments need to be the highest parent or whichever is the artboard
function getParentSnapPoints(config, context, layers) {
  if (!layers || layers.length === 0 || !config.snap || !config.parentSnap) {
    return {
      x: [],
      y: []
    };
  }

  var layer = layers[0];
  var x = [];
  var y = [];
  var minX = undefined;
  var maxX = undefined;
  var minY = undefined;
  var maxY = undefined;
  var layerDimensions = layer.getBoundingClientRect();
  var xSnapPoint1 = {
    value: 0,
    rootValue: layerDimensions.rootX,
    minY: minY,
    maxY: maxY,
    snapTo: {
      center: false,
      start: true,
      end: false
    }
  };
  var xSnapPoint2 = {
    value: layerDimensions.width,
    rootValue: layerDimensions.rootX + layerDimensions.width,
    minY: minY,
    maxY: maxY,
    snapTo: {
      center: false,
      start: false,
      end: true
    }
  };
  var xSnapPoint3 = {
    value: layerDimensions.width / 2,
    rootValue: layerDimensions.rootX + layerDimensions.width / 2,
    minY: minY,
    maxY: maxY,
    snapTo: {
      center: true,
      start: true,
      end: true
    }
  };
  var ySnapPoint1 = {
    value: 0,
    rootValue: layerDimensions.rootY,
    minX: minX,
    maxX: maxX,
    snapTo: {
      center: false,
      start: true,
      end: false
    }
  };
  var ySnapPoint2 = {
    value: layerDimensions.height,
    rootValue: layerDimensions.rootY + layerDimensions.height,
    minX: minX,
    maxX: maxX,
    snapTo: {
      center: false,
      start: false,
      end: true
    }
  };
  var ySnapPoint3 = {
    value: layerDimensions.height / 2,
    rootValue: layerDimensions.rootY + layerDimensions.height / 2,
    minX: minX,
    maxX: maxX,
    snapTo: {
      center: true,
      start: true,
      end: true
    }
  };
  x.push(xSnapPoint1);
  x.push(xSnapPoint2);
  x.push(xSnapPoint3);
  y.push(ySnapPoint1);
  y.push(ySnapPoint2);
  y.push(ySnapPoint3);
  return {
    x: x,
    y: y
  };
}

function getDistance(axis, box1, box2) {
  if (axis === 'x') {
    return box2.x - (box1.x + box1.width);
  } else {
    return box2.y - (box1.y + box1.height);
  }
}

function getDistanceBetweenLayers(axis, layer1, layer2) {
  var distance = 0;
  var box1 = layer1.getBoundingClientRect();
  var box2 = layer2.getBoundingClientRect();

  if (axis === 'x') {
    // In case of overlap
    if (box1.x < box2.x && box1.x + box1.width > box2.x) {
      return -1;
    } // In case of overlap


    if (box2.x < box1.x && box2.x + box2.width > box1.x) {
      return -1;
    }

    if (box1.x < box2.x) {
      distance = getDistance('x', box1, box2);
    } else {
      distance = getDistance('x', box2, box1);
    }
  } else {
    if (box1.y < box2.y && box1.y + box1.height > box2.y) {
      return -1;
    } // In case of overlap


    if (box2.y < box1.y && box2.y + box2.height > box1.y) {
      return -1;
    }

    if (box1.y < box2.y) {
      distance = getDistance('y', box1, box2);
    } else {
      distance = getDistance('y', box2, box1);
    }
  }

  return distance;
}

function isAlignedOnAxis(axis, layerDims, otherLayerDims) {
  if (axis === 'x') {
    if (otherLayerDims.rootY > layerDims.rootY + layerDims.height || layerDims.rootY > otherLayerDims.rootY + otherLayerDims.height) {
      return false;
    }

    return true;
  } else if (axis === 'y') {
    if (otherLayerDims.rootX > layerDims.rootX + layerDims.width || layerDims.rootX > otherLayerDims.rootX + otherLayerDims.width) {
      return false;
    }

    return true;
  }

  return false;
}

function getOverlapBetweenLayers(axis, layerDims, otherLayerDims) {
  var extremities = {
    min: 0,
    max: 0
  };

  if (axis === 'y') {
    extremities.min = layerDims.rootX > otherLayerDims.rootX ? layerDims.rootX : otherLayerDims.rootX;
    extremities.max = layerDims.rootX + layerDims.width > otherLayerDims.rootX + otherLayerDims.width ? otherLayerDims.rootX + otherLayerDims.width : layerDims.rootX + layerDims.width;
  } else {
    extremities.min = layerDims.rootY > otherLayerDims.rootY ? layerDims.rootY : otherLayerDims.rootY;
    extremities.max = layerDims.rootY + layerDims.height > otherLayerDims.rootY + otherLayerDims.height ? otherLayerDims.rootY + otherLayerDims.height : layerDims.rootY + layerDims.height;
  }

  return extremities;
}

function getDisconnectedGutterPointsForX(snapXPoints, restrictedLayers, originalAllLayers, distance) {
  var points = [];
  var axis = 'x';
  var layer1 = restrictedLayers[0];
  var dims1 = layer1.getBoundingClientRect();
  var layer2 = restrictedLayers[1];
  var dims2 = layer2.getBoundingClientRect();
  var allLayers = originalAllLayers.filter(function (layer) {
    return !restrictedLayers.includes(layer);
  });
  allLayers.forEach(function (layer) {
    var dims = layer.getBoundingClientRect();

    if (isAlignedOnAxis(axis, dims1, dims) && isAlignedOnAxis(axis, dims2, dims)) {
      var leftMostPoint = dims.x - distance;
      var leftMostRootPoint = dims.rootX - distance;
      var rightMostPoint = dims.x + dims.width + distance;
      var rightMostRootPoint = dims.rootX + dims.width + distance;
      var minY = dims.rootY;
      var maxY = dims.rootY + dims.height;
      addToSnapXPoint(snapXPoints, rightMostPoint, rightMostRootPoint, minY, maxY, distance);
      addToSnapXPoint(snapXPoints, leftMostPoint, leftMostRootPoint, minY, maxY, distance);
    }
  });
  return points;
}

function getDisconnectedGutterPointsForY(snapYPoints, restrictedLayers, originalAllLayers, distance) {
  var points = [];
  var axis = 'y';
  var layer1 = restrictedLayers[0];
  var dims1 = layer1.getBoundingClientRect();
  var layer2 = restrictedLayers[1];
  var dims2 = layer2.getBoundingClientRect();
  var allLayers = originalAllLayers.filter(function (layer) {
    return !restrictedLayers.includes(layer);
  });
  allLayers.forEach(function (layer) {
    var dims = layer.getBoundingClientRect();

    if (isAlignedOnAxis(axis, dims1, dims) && isAlignedOnAxis(axis, dims2, dims)) {
      var topMostPoint = dims.y - distance;
      var topMostRootPoint = dims.rootY - distance;
      var bottomMostPoint = dims.y + dims.height + distance;
      var bottomMostRootPoint = dims.rootY + dims.height + distance;
      var minX = dims.rootX;
      var maxX = dims.rootX + dims.width;
      addToSnapYPoint(snapYPoints, bottomMostPoint, bottomMostRootPoint, minX, maxX, distance);
      addToSnapYPoint(snapYPoints, topMostPoint, topMostRootPoint, minX, maxX, distance);
    }
  });
  return points;
}

function addToSnapXPoint(snapXPoints, value, rootValue, min, max, distance) {
  if (!find(snapXPoints, function (val) {
    return val.value === value && val.rootValue === rootValue && val.minY === min && val.maxY === max;
  })) {
    snapXPoints.push({
      value: value,
      rootValue: rootValue,
      minY: min,
      maxY: max,
      snapLines: {
        distance: distance
      }
    });
  }
}

function addToSnapYPoint(snapYPoints, value, rootValue, min, max, distance) {
  if (!find(snapYPoints, function (val) {
    return val.value === value && val.rootValue === rootValue && val.minY === min && val.maxY === max;
  })) {
    snapYPoints.push({
      value: value,
      rootValue: rootValue,
      minX: min,
      maxX: max,
      snapLines: {
        distance: distance
      }
    });
  }
}

function getGutterSnapPoints(config, context, layers) {
  if (!layers || layers.length === 0 || !config.snap || !config.gutterSnap) {
    return {
      x: [],
      y: []
    };
  }

  var layer = layers[0];
  var snapXPoints = [];
  var snapYPoints = [];

  if (!layer.parent) {
    return {
      x: [],
      y: []
    };
  }

  var parent = layer.parent;
  parent.children.forEach(function (layer1) {
    // Don't need the distance with this layer as it is being moved
    if (layers.includes(layer1)) {
      return;
    }

    parent.children.forEach(function (layer2) {
      // No need of comparison between the same layers
      if (layer1 === layer2) return; // No need to do comparison as this layer is being moved

      if (layers.includes(layer2)) return;

      if (isAlignedOnAxis('x', layer1.getBoundingClientRect(), layer2.getBoundingClientRect())) {
        var distance = getDistanceBetweenLayers('x', layer1, layer2);

        if (distance > 0) {
          var allGutterPoints = getDisconnectedGutterPointsForX(snapXPoints, [layer1, layer2].concat(layers), parent.children, distance);
          snapXPoints.push.apply(snapXPoints, allGutterPoints);
          var overlapX = getOverlapBetweenLayers('x', layer1.getBoundingClientRect(), layer2.getBoundingClientRect());
          var box1 = layer1.getBoundingClientRect();
          var box2 = layer2.getBoundingClientRect();
          var rightMostPoint = 0;
          var rightMostRootPoint = 0;
          var leftMostPoint = 0;
          var leftMostRootPoint = 0;

          if (box1.x + box1.width > box2.x + box2.width) {
            rightMostPoint = box1.x + box1.width;
            rightMostRootPoint = box1.rootX + box1.width;
            leftMostPoint = box2.x - distance;
            leftMostRootPoint = box2.rootX - distance;
          } else {
            rightMostPoint = box2.x + box2.width;
            rightMostRootPoint = box2.rootX + box2.width;
            leftMostPoint = box1.x - distance;
            leftMostRootPoint = box1.rootX - distance;
          }

          rightMostPoint = rightMostPoint + distance;
          rightMostRootPoint = rightMostRootPoint + distance;
          addToSnapXPoint(snapXPoints, rightMostPoint, rightMostRootPoint, overlapX.min, overlapX.max, distance);
          addToSnapXPoint(snapXPoints, leftMostPoint, leftMostRootPoint, overlapX.min, overlapX.max, distance);
        }
      }

      if (isAlignedOnAxis('y', layer1.getBoundingClientRect(), layer2.getBoundingClientRect())) {
        var _distance = getDistanceBetweenLayers('y', layer1, layer2);

        if (_distance > 0) {
          var _allGutterPoints = getDisconnectedGutterPointsForY(snapYPoints, [layer1, layer2].concat(layers), parent.children, _distance);

          snapYPoints.push.apply(snapYPoints, _allGutterPoints);
          var overlapY = getOverlapBetweenLayers('y', layer1.getBoundingClientRect(), layer2.getBoundingClientRect());

          var _box = layer1.getBoundingClientRect();

          var _box2 = layer2.getBoundingClientRect();

          var bottomMostPoint = 0;
          var bottomMostRootPoint = 0;
          var topMostPoint = 0;
          var topMostRootPoint = 0;

          if (_box.y + _box.height > _box2.y + _box2.height) {
            bottomMostPoint = _box.y + _box.height;
            bottomMostRootPoint = _box.rootY + _box.height;
            topMostPoint = _box2.y - _distance;
            topMostRootPoint = _box2.rootY - _distance;
          } else {
            bottomMostPoint = _box2.y + _box2.height;
            bottomMostRootPoint = _box2.rootY + _box2.height;
            topMostPoint = _box.y - _distance;
            topMostRootPoint = _box.rootY - _distance;
          }

          bottomMostPoint = bottomMostPoint + _distance;
          bottomMostRootPoint = bottomMostRootPoint + _distance;
          addToSnapYPoint(snapYPoints, bottomMostPoint, bottomMostRootPoint, overlapY.min, overlapY.max, _distance);
          addToSnapYPoint(snapYPoints, topMostPoint, topMostRootPoint, overlapY.min, overlapY.max, _distance);
        }
      }
    });
  });
  return {
    x: snapXPoints,
    y: snapYPoints
  };
}

function gridSnapPoint(delta, startPoint, gridSpace, stretch, handle) {
  var snappedSide = {
    coordinate: NaN,
    start: false,
    center: false,
    end: false
  };
  var point1 = startPoint + delta;
  point1 = Math.round(point1 / gridSpace) * gridSpace;
  var delta1 = point1 - startPoint;
  var point2 = startPoint + stretch + delta;
  point2 = Math.round(point2 / gridSpace) * gridSpace;
  var delta2 = point2 - stretch - startPoint;
  var outputDelta = delta1;
  snappedSide.coordinate = point1;
  snappedSide.start = true;
  outputDelta = delta1;

  if (handle) {
    if (handle.indexOf('L') === -1 && handle.indexOf('T') === -1) {
      snappedSide.coordinate = point2;
      snappedSide.end = true;
      outputDelta = delta2;
    }
  } else {
    if (Math.abs(delta + startPoint - point1) > Math.abs(delta + startPoint + stretch - point2)) {
      snappedSide.coordinate = point2;
      snappedSide.end = true;
      outputDelta = delta2;
    }
  }

  return {
    value: snappedSide.coordinate,
    rootValue: snappedSide.coordinate,
    snappedSide: snappedSide,
    snapType: 'grid',
    delta: outputDelta
  };
}

function snapToGrid(config, context, startX, totalDeltaX, startY, totalDeltaY, stretchX, stretchY, handle) {
  if (!config.snap || !config.gridSnap) {
    return;
  }

  var gridOffset = context.canvas.executeFunction('getGridOffset');
  var x;
  var y;
  var snapBounds = context.canvas.executeFunction('getGridSize');

  if (!snapBounds) {
    snapBounds = {
      x: 20,
      y: 20
    };
  }

  if (!snapBounds) {
    return {
      x: {
        value: startX + totalDeltaX,
        rootValue: startX + totalDeltaX
      },
      y: {
        value: startY + totalDeltaY,
        rootValue: startY + totalDeltaY
      }
    };
  }

  var xSnapPoint = gridSnapPoint(totalDeltaX, startX - gridOffset.x, snapBounds.x, stretchX, handle);
  x = xSnapPoint;
  var ySnapPoints = gridSnapPoint(totalDeltaY, startY - gridOffset.y, snapBounds.y, stretchY, handle); // snappedSideY.coordinate = ySnapPoint;

  y = ySnapPoints;
  return {
    x: x,
    y: y
  };
}

function snapToPoints(context, snapPoints, startPoint, totalDelta, dims, absoluteDelta, startAbsolutePoint, parentAbsoluteRotation, boundingBoxWRTWorld, handle) {
  if (absoluteDelta === void 0) {
    absoluteDelta = [0, 0];
  }

  if (startAbsolutePoint === void 0) {
    startAbsolutePoint = [0, 0];
  }

  //
  var meta = {
    snappedSide: {
      x: undefined,
      y: undefined
    }
  };
  var x = totalDelta[0];
  var y = totalDelta[1];

  if (snapPoints) {
    var snappedData = snapPoint(context, snapPoints, startPoint, totalDelta, dims, absoluteDelta, startAbsolutePoint, parentAbsoluteRotation, boundingBoxWRTWorld, handle);
    x = snappedData.delta.x;
    y = snappedData.delta.y;
    meta.snappedSide.x = snappedData.meta.x;
    meta.snappedSide.y = snappedData.meta.y;
  }

  var delta = {
    x: x,
    y: y
  };
  return {
    x: x,
    y: y,
    delta: delta,
    meta: meta
  };
}
function snapPoint(context, snapPoints, startPoint, totalDelta, dims, absoluteDelta, startAbsolutePoint, parentAbsoluteRotation, boundingBoxWRTWorld, handle) {
  var stretchX = dims.width;
  var stretchY = dims.height;
  var rulerCoordinatesX = snapPoints.rulerSnapPoints.y;
  var rulerCoordinatesY = snapPoints.rulerSnapPoints.x;
  var documentCoordinatesX = snapPoints.parentSnapPoints.x;
  var documentCoordinatesY = snapPoints.parentSnapPoints.y;
  var layerCoordinatesX = snapPoints.siblingSnapPoints.x;
  var layerCoordinatesY = snapPoints.siblingSnapPoints.y; // let gutterCoordinates =
  //   axis === 'x'
  //     ? snapPoints.gutterSnapPoints.x
  //     : snapPoints.gutterSnapPoints.y;

  var snapBounds = context.canvas.executeFunction('getSnapBound') / context.canvas.getZoom();
  var coordinateValueX = startPoint[0] + totalDelta[0];
  var coordinateValueY = startPoint[1] + totalDelta[1];
  var parentSnappedDataX = getPointForParentSnap(documentCoordinatesX, coordinateValueX, stretchX, snapBounds);
  var parentSnappedDataY = getPointForParentSnap(documentCoordinatesY, coordinateValueY, stretchY, snapBounds);
  parentSnappedDataX.snapType = 'documentBounds';
  parentSnappedDataY.snapType = 'documentBounds';
  parentSnappedDataX.delta = parentSnappedDataX.value - startPoint[0];
  parentSnappedDataY.delta = parentSnappedDataY.value - startPoint[1];
  var siblingDataX = getPointForSiblingSnap(layerCoordinatesX, coordinateValueX, stretchX, snapBounds);
  siblingDataX.snapType = 'sibling';
  var siblingDataY = getPointForSiblingSnap(layerCoordinatesY, coordinateValueY, stretchY, snapBounds);
  siblingDataY.snapType = 'sibling';
  siblingDataX.delta = siblingDataX.value - startPoint[0];
  siblingDataY.delta = siblingDataY.value - startPoint[1];
  var rulersDataX = getPointForRulerLines(rulerCoordinatesX, startAbsolutePoint[0] + absoluteDelta[0], stretchX, snapBounds);
  var rulersDataY = getPointForRulerLines(rulerCoordinatesY, startAbsolutePoint[1] + absoluteDelta[1], stretchY, snapBounds);
  rulersDataX.snapType = 'ruler';
  rulersDataY.snapType = 'ruler';
  rulersDataX.delta = rulersDataX.value - startAbsolutePoint[0];
  rulersDataY.delta = rulersDataY.value - startAbsolutePoint[1];
  var rotateDelta = ModelUtils.rotatePoint([rulersDataX.delta, rulersDataY.delta], 360 - parentAbsoluteRotation, [0, 0]);
  rulersDataX.delta = rotateDelta[0];
  rulersDataY.delta = rotateDelta[1]; // grid snapping

  var gridDataX = {
    delta: 0,
    snappedSide: {
      coordinate: NaN,
      start: true,
      center: false,
      end: true
    }
  };
  var gridDataY = {
    delta: 0,
    snappedSide: {
      coordinate: NaN,
      start: true,
      center: false,
      end: true
    }
  }; // console.log(
  //   gridOffset.x,
  //   gridOffset.y,
  //   startAbsolutePoint[1],
  //   startAbsolutePoint[0],
  //   'grid snap points here'
  // );

  var gridSnapPoints = context.canvas.executeFunction('snapToGrid', boundingBoxWRTWorld.x, absoluteDelta[0], boundingBoxWRTWorld.y, absoluteDelta[1], stretchX, stretchY, handle);

  if (gridSnapPoints) {
    gridDataX = gridSnapPoints.x;
    gridDataY = gridSnapPoints.y;
    var rotateDeltaGrid = ModelUtils.rotatePoint([gridDataX.delta, gridDataY.delta], 360 - parentAbsoluteRotation, [0, 0]);
    gridDataX.delta = rotateDeltaGrid[0];
    gridDataY.delta = rotateDeltaGrid[1];
  } // console.log(gridSnapPoints, 'grid snap points');


  var minSnappedDataX = minBy([rulersDataX, gridDataX, siblingDataX, parentSnappedDataX], function (data) {
    var point = startPoint[0];

    if (data.snappedSide.end) {
      point = startPoint[0] + stretchX;
    }

    if (data.snappedSide.center) {
      point = startPoint[0] + stretchX / 2;
    } // console.log(
    //   point,
    //   data.delta,
    //   totalDelta[0],
    //   coordinateValueX,
    //   data.snapType,
    //   data.snappedSide.coordinate,
    //   Math.abs(data.snappedSide.coordinate - coordinateValueX),
    //   '&&&&&&&&'
    // );


    if (!isNaN(data.snappedSide.coordinate)) return Math.abs(data.delta - totalDelta[0]);else return Number.MAX_VALUE;
  }); // console.log(minSnappedDataX, '&&&&&&&& ******');

  var minSnappedDataY = minBy([rulersDataY, gridDataY, siblingDataY, parentSnappedDataY], function (data) {
    var point = startPoint[1];

    if (data.snappedSide.end) {
      point = startPoint[1] + stretchY;
    }

    if (data.snappedSide.center) {
      point = startPoint[1] + stretchY / 2;
    }

    if (!isNaN(data.snappedSide.coordinate)) return Math.abs(data.delta - totalDelta[1]);else return Number.MAX_VALUE;
  });
  return {
    value: minSnappedDataX.value,
    delta: {
      x: minSnappedDataX.delta,
      y: minSnappedDataY.delta
    },
    meta: {
      x: {
        snappedSide: minSnappedDataX.snappedSide,
        snapType: minSnappedDataX.snapType
      },
      y: {
        snappedSide: minSnappedDataY.snappedSide,
        snapType: minSnappedDataY.snapType
      }
    }
  };
}

function getPointForParentSnap(documentCoordinates, coordinateValue, stretch, snapBounds) {
  if (snapBounds === void 0) {
    snapBounds = 0;
  }

  // TODO: think of a better logic
  var distance = Number.MAX_VALUE; // let snappedSide;
  var snappedSide = {
    coordinate: NaN,
    start: false,
    center: false,
    end: false,
    snappedPoint: {
      value: NaN,
      rootValue: NaN
    }
  };
  var originalCoordinateValue = coordinateValue;

  for (var _iterator = _createForOfIteratorHelperLoose(documentCoordinates), _step; !(_step = _iterator()).done;) {
    var _coordinate = _step.value;
    var newData = calculateCoordinate(originalCoordinateValue, coordinateValue, _coordinate, snapBounds, stretch, distance, snappedSide);
    coordinateValue = newData.coordinateValue;
    distance = newData.distance;
    snappedSide = newData.snapped;
    _coordinate = _coordinate; // snappedSide.snappedPoint = newData.snappedPoint;
  }

  return {
    value: coordinateValue,
    snappedSide: snappedSide
  };
}

function getPointForSiblingSnap(layerCoordinates, coordinateValue, stretch, snapBounds, showLog) {
  if (snapBounds === void 0) {
    snapBounds = 0;
  }

  // TODO: think of a better logic
  var distance = Number.MAX_VALUE;
  var snappedSide = {
    coordinate: NaN,
    start: false,
    center: false,
    end: false,
    snappedPoint: {
      value: NaN,
      rootValue: NaN
    }
  };
  var originalCoordinateValue = coordinateValue;

  for (var _iterator2 = _createForOfIteratorHelperLoose(layerCoordinates), _step2; !(_step2 = _iterator2()).done;) {
    var coordinate = _step2.value;
    var newData = calculateCoordinate(originalCoordinateValue, coordinateValue, coordinate, snapBounds, stretch, distance, snappedSide);
    coordinateValue = newData.coordinateValue; // coordinateValueFinal = newData.coordinateValue;

    distance = newData.distance;
    snappedSide = newData.snapped; // snappedSide = newData.snapped;
  }

  return {
    value: coordinateValue,
    snappedSide: snappedSide
  };
}

function getPointForRulerLines(rulerCoordinates, coordinateValue, stretch, snapBounds) {
  if (snapBounds === void 0) {
    snapBounds = 0;
  }

  var snappedSide = {
    coordinate: NaN,
    start: false,
    center: false,
    end: false,
    snappedPoint: {
      value: NaN,
      rootValue: NaN
    }
  };
  var distance = Number.MAX_VALUE;
  var originalCoordinateValue = coordinateValue;

  for (var _iterator3 = _createForOfIteratorHelperLoose(rulerCoordinates), _step3; !(_step3 = _iterator3()).done;) {
    var coordinate = _step3.value;
    var newData = calculateCoordinate(originalCoordinateValue, coordinateValue, coordinate, snapBounds, stretch, distance, snappedSide); // if (newData) {
    // }

    snappedSide = newData.snapped;
    coordinateValue = newData.coordinateValue;
    distance = newData.distance;
  }

  return {
    value: coordinateValue,
    snappedSide: snappedSide
  };
}

function getDistance$1(value1, value2) {
  return Math.abs(value1 - value2);
}

function calculateCoordinate(originalCoordinateValue, coordinateValue, coordinate, snapMagnet, stretch, distance, snappedSide, showLog) {
  var snapTo = {
    start: true,
    center: true,
    end: true
  };
  var snapped = snappedSide;
  snapped.coordinateValue = coordinateValue;
  snapped.distance = distance;

  if (coordinate.snapTo) {
    snapTo = coordinate.snapTo;
  }

  if (Math.abs(originalCoordinateValue - coordinate.value) <= snapMagnet && snapTo.start && distance >= getDistance$1(originalCoordinateValue, coordinate.value)) {
    // coordinateValue = coordinate.value;
    // distance = getDistance(coordinateValue, coordinate.value);
    snapped.start = true;
    snapped.coordinate = coordinate.value;
    snapped.snappedPoint = {
      value: coordinate.value,
      rootValue: coordinate.rootValue
    };
    snapped.distance = getDistance$1(originalCoordinateValue, coordinate.value);
    snapped.coordinateValue = coordinate.value;
  }

  if (Math.abs(originalCoordinateValue + stretch / 2 - coordinate.value) <= snapMagnet && snapTo.center && distance >= getDistance$1(originalCoordinateValue + stretch / 2, coordinate.value)) {
    // coordinateValue = coordinate.value - stretch / 2;
    // distance = getDistance(coordinateValue + stretch / 2, coordinate.value);
    // let snapped = snappedSide;
    snapped.distance = getDistance$1(originalCoordinateValue + stretch / 2, coordinate.value);
    snapped.coordinateValue = coordinate.value - stretch / 2;
    snapped.center = true;
    snapped.coordinate = coordinate.value;
    snapped.snappedPoint = {
      value: coordinate.value,
      rootValue: coordinate.rootValue
    }; // snappedArray.push(snapped);
  }

  if (Math.abs(originalCoordinateValue + stretch - coordinate.value) <= snapMagnet && snapTo.end && distance >= getDistance$1(originalCoordinateValue + stretch, coordinate.value)) {
    // coordinateValue = coordinate.value - stretch;
    // distance = getDistance(coordinateValue + stretch, coordinate.value);
    // let snapped = snappedSide;
    snapped.distance = getDistance$1(originalCoordinateValue + stretch, coordinate.value);
    snapped.coordinateValue = coordinate.value - stretch;
    snapped.end = true;
    snapped.coordinate = coordinate.value;
    snapped.snappedPoint = {
      value: coordinate.value,
      rootValue: coordinate.rootValue
    }; // snappedArray.push(snapped);
  }

  return {
    coordinateValue: snapped.coordinateValue,
    distance: snapped.distance,
    snapped: snapped
  };
}

function filterSnapPointX(snapPoint, handle) {
  //
  snapPoint.snapTo.center = false;
  snapPoint.snapTo.start = true;
  snapPoint.snapTo.end = true;

  if (handle.indexOf('R') !== -1) {
    snapPoint.snapTo.start = false;
  }

  if (handle.indexOf('L') !== -1) {
    snapPoint.snapTo.end = false;
  }
}

function filterSnapPointY(snapPoint, handle) {
  snapPoint.snapTo.center = false;
  snapPoint.snapTo.start = true;
  snapPoint.snapTo.end = true;

  if (handle.indexOf('B') !== -1) {
    snapPoint.snapTo.start = false;
  }

  if (handle.indexOf('T') !== -1) {
    snapPoint.snapTo.end = false;
  }
}

function getSnapPoints(config, context, selectedLayers, parent, handle) {
  if (parent === void 0) {
    parent = undefined;
  }

  var snapPoints = {
    x: [],
    y: []
  };

  if (!parent || !config.snap) {
    return {
      parentSnapPoints: snapPoints,
      siblingSnapPoints: snapPoints,
      gutterSnapPoints: snapPoints,
      rulerSnapPoints: snapPoints,
      gridSnap: undefined
    };
  }

  var layers = [];

  if (parent) {
    layers = parent.children;
  } // TODO: Suraj review


  if (layers.length === 0 && !parent) {
    return {
      parentSnapPoints: snapPoints,
      siblingSnapPoints: snapPoints,
      gutterSnapPoints: snapPoints,
      rulerSnapPoints: snapPoints,
      gridSnap: config.gridSnap
    };
  }

  var layerParent = parent;

  if (!layerParent) {
    layerParent = layers[0].parent;
  } // document bound snap points


  var documentBound = layerParent;
  var parentSnapPoints = snapPoints;

  if (documentBound && config.parentSnap) {
    // @ts-ignore
    parentSnapPoints = documentBound.executeFunction('getParentSnapPoints', [documentBound]);
  }

  snapPoints.x = snapPoints.x.concat(parentSnapPoints.x);
  snapPoints.y = snapPoints.y.concat(parentSnapPoints.y); // layers snap points

  var siblingSnapPoints = {
    x: [],
    y: []
  };

  if (config.siblingSnap && layers[0]) {
    siblingSnapPoints = layers[0].executeFunction('getSiblingSnapPoints', selectedLayers, parent);
  }

  var gutterSnapPoints = {
    x: [],
    y: []
  };

  if (config.gutterSnap && parent && layers[0]) {
    // @ts-ignore
    gutterSnapPoints = layers[0].executeFunction('getGutterSnapPoints', selectedLayers);
  }

  var rulerSnapPoints = {
    x: [],
    y: []
  };

  if (config.rulerSnap) {
    rulerSnapPoints = context.canvas.executeFunction('RulerLines.getLineCoordinates');
    var boundingBox = context.canvas.getBoundingBox([parent], true);
    forEach(rulerSnapPoints.x, function (coordinate, index) {
      var point = coordinate - boundingBox.y;
      rulerSnapPoints.x[index] = {
        value: point,
        rootValue: coordinate
      };
    });
    forEach(rulerSnapPoints.y, function (coordinate, index) {
      var point = coordinate - boundingBox.x;
      rulerSnapPoints.y[index] = {
        value: point,
        rootValue: coordinate
      };
    });
  } // window['ModelUtils'] = ModelUtils;
  // filtered snap point based on handle


  if (handle) {
    parentSnapPoints.x.forEach(function (snapPoint) {
      filterSnapPointX(snapPoint, handle);
    });
    parentSnapPoints.y.forEach(function (snapPoint) {
      filterSnapPointY(snapPoint, handle);
    });
    siblingSnapPoints.x.forEach(function (snapPoint) {
      // console.log(snapPoint, 'snap pont');
      // snapPoint.snapTo.center = false;
      filterSnapPointX(snapPoint, handle);
    });
    siblingSnapPoints.y.forEach(function (snapPoint) {
      // snapPoint.snapTo.center = false;
      filterSnapPointY(snapPoint, handle);
    });
  } // console.log(paren)


  return {
    parentSnapPoints: parentSnapPoints,
    siblingSnapPoints: siblingSnapPoints,
    gutterSnapPoints: gutterSnapPoints,
    rulerSnapPoints: rulerSnapPoints,
    gridSnap: config.gridSnap
  };
}

var SnapPointsCalculator = /*#__PURE__*/function () {
  function SnapPointsCalculator() {
    var _this = this;

    this.name = 'SnapPointsCalculator';
    this.snapBound = 5;

    this.setSnapBound = function (context, bound) {
      _this.snapBound = bound;
    };

    this.getSnapBound = function (context) {
      return _this.snapBound;
    };

    this.getConfig = function () {
      return _this.config;
    };

    this.setConfig = function (context, config) {
      _this.config = _extends({}, _this.config, config);
    };
  }

  var _proto = SnapPointsCalculator.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
    this.config = {
      snap: false,
      parentSnap: false,
      siblingSnap: false,
      gutterSnap: false,
      gridSnap: false,
      rulerSnap: false
    };
  };

  _proto.activate = function activate() {
    var _this2 = this;

    this.canvas.addFunction('getSnapConfig', this.getConfig);
    this.canvas.addFunction('setSnapConfig', this.setConfig);
    this.canvas.addFunction('getSiblingSnapPoints', function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return (// @ts-ignore
        getAllSiblingLayerPoints.apply(void 0, [_this2.config].concat(args))
      );
    });
    this.canvas.addFunction('getParentSnapPoints', function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return (// @ts-ignore
        getParentSnapPoints.apply(void 0, [_this2.config].concat(args))
      );
    });
    this.canvas.addFunction('getGutterSnapPoints', function () {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return (// @ts-ignore
        getGutterSnapPoints.apply(void 0, [_this2.config].concat(args))
      );
    });
    this.canvas.addFunction('snapToGrid', function () {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return (// @ts-ignore
        snapToGrid.apply(void 0, [_this2.config].concat(args))
      );
    });
    this.canvas.addFunction('snapToPoints', snapToPoints);
    this.canvas.addFunction('getSnapPoints', function () {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      return (// @ts-ignore
        getSnapPoints.apply(void 0, [_this2.config].concat(args))
      );
    });
    this.canvas.addFunction('setSnapBound', this.setSnapBound);
    this.canvas.addFunction('getSnapBound', this.getSnapBound);
  };

  _proto.deactivate = function deactivate() {
    this.canvas.removeFunction('getSiblingSnapPoints');
    this.canvas.removeFunction('getParentSnapPoints');
    this.canvas.removeFunction('getGutterSnapPoints');
    this.canvas.removeFunction('snapToGrid');
    this.canvas.removeFunction('snapToPoints');
    this.canvas.removeFunction('getSnapPoints');
    this.canvas.removeFunction('setSnapBound');
    this.canvas.removeFunction('getSnapBound');
  };

  return SnapPointsCalculator;
}();

var ConstructionLinesPlugin = /*#__PURE__*/function () {
  function ConstructionLinesPlugin() {
    var _this = this;

    this.name = 'ConstructionLinesPlugin';

    this.updateLines = function () {
      var context = _this.canvasDOMElement.getContext('2d');

      var collisionScope = _this.canvas.collisionScope;

      if (context && collisionScope) {
        context.clearRect(0, 0, _this.canvasDOMElement.width, _this.canvasDOMElement.height);
        context.strokeStyle = '#f00';
        context.beginPath();
        collisionScope.drawBVH(context);
        context.stroke();
      }
    };

    this.showConstructionLines = function () {
      _this.constructionLinesWrapper.style.display = 'block';
    };

    this.setDimensions = function () {
      _this.canvasDOMElement.setAttribute('height', _this.canvas.getBoundingClientRect().height.toString() + 'px');

      _this.canvasDOMElement.setAttribute('width', _this.canvas.getBoundingClientRect().width.toString() + 'px');
    };

    this.hideConstructionLines = function () {
      _this.constructionLinesWrapper.style.display = 'none';
    };
  }

  var _proto = ConstructionLinesPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
    this.dispose = null;
  };

  _proto.activate = function activate() {
    this.canvas.addFunction('showConstructionLines', this.showConstructionLines.bind(this));
    this.canvas.addFunction('hideConstructionLines', this.hideConstructionLines.bind(this));
    this.canvas.addEventListener('setLayout', this.setDimensions.bind(this));
    this.constructionLinesWrapper = document.createElement('div');
    this.constructionLinesWrapper.className = 'construction-line-wrapper';
    this.dispose = this.canvas.addDomToWorld(this.constructionLinesWrapper);
    this.canvasDOMElement = document.createElement('canvas');
    this.setDimensions(); // this.canvasDOMElement.setAttribute(
    //   'height',
    //   this.canvas.getBoundingClientRect().height.toString() + 'px'
    // );
    // this.canvasDOMElement.setAttribute(
    //   'width',
    //   this.canvas.getBoundingClientRect().width.toString() + 'px'
    // );

    this.canvasDOMElement.style.pointerEvents = 'none';
    var context = this.canvasDOMElement.getContext('2d');
    this.constructionLinesWrapper.style.pointerEvents = 'none';
    this.constructionLinesWrapper.appendChild(this.canvasDOMElement);
    var collisionScope = this.canvas.collisionScope;
    this.attachListeners(this.canvas);

    if (context && collisionScope) {
      context.strokeStyle = '#f00';
      context.beginPath();
      collisionScope.drawBVH(context);
      context.stroke();
    }
  };

  _proto.attachListeners = function attachListeners(layer) {
    var _this2 = this;

    layer.on('*', this.updateLines);
    layer.on(['children'], function () {
      layer.children.forEach(function (child) {
        _this2.attachListeners(child);
      });
    });
    layer.children.forEach(function (child) {
      _this2.attachListeners(child);
    });
  };

  _proto.deactivate = function deactivate() {
    this.dispose();
    this.canvas.removeFunction('showConstructionLines');
    this.canvas.removeFunction('hideConstructionLines');
    this.canvas.removeEventListener('setLayout', this.setDimensions);
  };

  return ConstructionLinesPlugin;
}();

var ScrollMousePositionPlugin = /*#__PURE__*/function () {
  function ScrollMousePositionPlugin() {
    this.name = 'ScrollMousePositionPlugin';
  }

  var _proto = ScrollMousePositionPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
    this.dispose = null;
  };

  _proto.activate = function activate() {
    var _this = this;

    var wrapperLayer = document.createElement('div');
    this.dispose = this.canvas.addDomToViewport(wrapperLayer);
    var positionElement = document.createElement('div');
    wrapperLayer.appendChild(positionElement);
    positionElement.style.position = 'absolute';
    positionElement.style.top = '10px';
    positionElement.style.right = '10px';
    positionElement.style.height = '95px';
    positionElement.style.width = '245px';
    positionElement.style.pointerEvents = 'none';
    positionElement.style.backgroundColor = 'skyblue';
    positionElement.style.zIndex = '10';
    var mousePosWorldNode = document.createTextNode(" Mouse World: {x:0, y:0} ");
    positionElement.appendChild(mousePosWorldNode);
    positionElement.appendChild(document.createElement('br'));
    var mousePosViewportNode = document.createTextNode("Mouse Viewport: {x: 0, y:0} ");
    positionElement.appendChild(mousePosViewportNode);
    positionElement.appendChild(document.createElement('br'));
    var pagePosPageNode = document.createTextNode("Mouse Page: {x: 0, y:0} ");
    positionElement.appendChild(pagePosPageNode);
    positionElement.appendChild(document.createElement('br'));
    var scroll = this.canvas.getScroll();
    var scrollPosNode = document.createTextNode("Scroll: {x:" + scroll.x + ", y:" + scroll.y + "}");
    positionElement.appendChild(scrollPosNode);
    positionElement.appendChild(document.createElement('br'));
    var zoom = this.canvas.getZoom();
    var zoomNode = document.createTextNode("Zoom: " + Number(zoom.toFixed(2)));
    positionElement.appendChild(zoomNode);
    this.canvas.on('scroll', function () {
      scroll = _this.canvas.getScroll();
      scrollPosNode.nodeValue = "Scroll: {x:" + Number(scroll.x.toFixed(2)) + ", y:" + Number(scroll.y.toFixed(2)) + "}";
    });
    this.canvas.on('zoom', function (e) {
      zoom = _this.canvas.getZoom();
      zoomNode.nodeValue = "Zoom: " + Number(zoom.toFixed(2));
    });
    this.canvas.addEventListener('mousemove', function (e) {
      mousePosWorldNode.nodeValue = "Mouse W: {x:" + Number(e.worldX.toFixed(2)) + ", y:" + Number(e.worldY.toFixed(2)) + "}";
      mousePosViewportNode.nodeValue = "Mouse VP: {x:" + Number(e.viewportX.toFixed(2)) + ", y:" + Number(e.viewportY.toFixed(2)) + "}";
      pagePosPageNode.nodeValue = "Mouse P: {x:" + Number(e.pageX.toFixed(2)) + ", y:" + Number(e.pageY.toFixed(2)) + "}";
    });
  };

  _proto.deactivate = function deactivate() {
    this.dispose();
  };

  return ScrollMousePositionPlugin;
}();

function isContained(axis, box, helperBox) {
  if (axis === 'x') {
    var leftContained = box.x <= helperBox.x;
    var rightContained = round(box.x + box.width, 2) >= round(helperBox.x + helperBox.width, 2);

    if (leftContained && rightContained) {
      return true;
    }
  }

  if (axis === 'y') {
    var topContained = box.y <= helperBox.y;
    var bottomContained = round(box.y + box.height, 2) >= round(helperBox.y + helperBox.height, 2);

    if (topContained && bottomContained) {
      return true;
    }
  }

  return false;
}
function isAlignedonAxis(axis, box, helperBox) {
  if (axis === 'x') {
    if (helperBox.y > box.y + box.height || box.y > helperBox.y + helperBox.height) {
      return false;
    }

    return true;
  } else if (axis === 'y') {
    if (helperBox.x > box.x + box.width || box.x > helperBox.x + helperBox.width) {
      return false;
    }

    return true;
  }

  return false;
}
function getDirection(axis, box, helperBox) {
  if (axis === 'x') {
    if (helperBox.x > box.x) {
      return 'left';
    }

    return 'right';
  } else if (axis === 'y') {
    if (helperBox.y > box.y) {
      return 'top';
    }

    return 'bottom';
  }

  return 'No Axis';
}

var getLeftEnd = function getLeftEnd(xContained, yContained, box) {
  if (xContained && yContained) {
    return box.x;
  }

  return box.x + box.width;
};

var getLeftWidth = function getLeftWidth(xContained, yContained, box, helperBox) {
  if (xContained && yContained) {
    return helperBox.x - box.x;
  }

  return helperBox.x - box.x - box.width;
};

var getTop = function getTop(helperBox) {
  return helperBox.y + Math.floor(helperBox.height / 2);
};

var getRightEnd = function getRightEnd(helperBox) {
  return helperBox.x + helperBox.width;
};

var getRightWidth = function getRightWidth(xContained, yContained, box, helperBox) {
  if (xContained && yContained) {
    return box.x + box.width - (helperBox.x + helperBox.width);
  }

  return box.x - helperBox.x - helperBox.width;
};

var drawXLines = function drawXLines(props) {
  var box = props.box,
      helperBox = props.helperBox;
  var xContained = isContained('x', box, helperBox);
  var yContained = isContained('y', box, helperBox);
  var xAligned = isAlignedonAxis('x', box, helperBox);
  var leftAligned = false;
  var rightAligned = false;
  var direction = getDirection('x', box, helperBox);

  if (xAligned) {
    if (direction === 'left') {
      leftAligned = true;
    } else if (direction === 'right') {
      rightAligned = true;
    }
  }

  var leftEnd = getLeftEnd(xContained, yContained, props.box);
  var leftWidth = getLeftWidth(xContained, yContained, props.box, props.helperBox);
  var top = getTop(props.helperBox);
  var rightEnd = getRightEnd(props.helperBox);
  var rightWidth = getRightWidth(xContained, yContained, props.box, props.helperBox);
  var leftDistance = xContained && yContained ? helperBox.x - box.x : helperBox.x - box.x - box.width;
  var rightDistance = xContained && yContained ? box.x + box.width - (helperBox.x + helperBox.width) : box.x - helperBox.x - helperBox.width;
  var leftShow = (leftAligned || xContained && yContained) && leftDistance > 0;
  var rightShow = (rightAligned || xContained && yContained) && rightDistance > 0;
  var lines = [];

  if (leftShow) {
    leftDistance = Math.round(leftDistance);
    lines.push(props.canvas.executeFunction('drawLine', 'y', leftEnd, 'measurementXLine1-edge', top - 2.5, top + 3, false));
    lines.push(props.canvas.executeFunction('drawLine', 'x', top, 'measurementXLine1', leftEnd, leftEnd + leftWidth, false, leftDistance));
    lines.push(props.canvas.executeFunction('drawLine', 'y', leftEnd + leftWidth - 1, 'measurementXLine1-edge', top - 2.5, top + 3, false));
  }

  if (rightShow) {
    rightDistance = Math.round(rightDistance);
    lines.push(props.canvas.executeFunction('drawLine', 'y', rightEnd, 'measurementXLine1-edge', top - 2.5, top + 3, false));
    lines.push(props.canvas.executeFunction('drawLine', 'x', top, 'measurementXLine2', rightEnd, rightWidth + rightEnd, false, rightDistance));
    lines.push(props.canvas.executeFunction('drawLine', 'y', rightWidth + rightEnd - 1, 'measurementXLine1-edge', top - 2.5, top + 3, false));
  }

  return lines;
};

var getTopEnd = function getTopEnd(xContained, yContained, box) {
  if (xContained && yContained) {
    return box.y;
  }

  return box.y + box.height;
};

var getTopHeight = function getTopHeight(xContained, yContained, box, helperBox) {
  if (xContained && yContained) {
    return helperBox.y - box.y;
  }

  return helperBox.y - box.y - box.height;
};

var getLeft = function getLeft(helperBox) {
  return helperBox.x + Math.floor(helperBox.width / 2);
};

var getBottomEnd = function getBottomEnd(helperBox) {
  return helperBox.y + helperBox.height;
};

var getBottomHeight = function getBottomHeight(xContained, yContained, box, helperBox) {
  if (xContained && yContained) {
    return box.y + box.height - (helperBox.y + helperBox.height);
  }

  return box.y - helperBox.y - helperBox.height;
};

var drawYLines = function drawYLines(props) {
  var box = props.box,
      helperBox = props.helperBox;
  var xContained = isContained('x', box, helperBox);
  var yContained = isContained('y', box, helperBox);
  var yAligned = isAlignedonAxis('y', box, helperBox);
  var topAligned = false;
  var bottomAligned = false;
  var direction = getDirection('y', box, helperBox);

  if (yAligned) {
    if (direction === 'top') {
      topAligned = true;
    } else if (direction === 'bottom') {
      bottomAligned = true;
    }
  }

  var topEnd = getTopEnd(xContained, yContained, props.box);
  var topHeight = getTopHeight(xContained, yContained, props.box, props.helperBox);
  var left = getLeft(props.helperBox);
  var bottomEnd = getBottomEnd(props.helperBox);
  var bottomHeight = getBottomHeight(xContained, yContained, props.box, props.helperBox);
  var topDistance = xContained && yContained ? helperBox.y - box.y : helperBox.y - box.y - box.height;
  var topShow = (topAligned || xContained && yContained) && topDistance > 0;
  var bottomDistance = xContained && yContained ? box.y + box.height - (helperBox.y + helperBox.height) : box.y - helperBox.y - helperBox.height;
  var bottomShow = (bottomAligned || xContained && yContained) && bottomDistance > 0;
  var lines = [];

  if (topShow) {
    topDistance = Math.round(topDistance);
    lines.push(props.canvas.executeFunction('drawLine', 'x', topEnd, 'measurementXLine1-edge', left - 2.5, left + 3, false));
    lines.push(props.canvas.executeFunction('drawLine', 'y', left, 'measurementYLine1', topEnd, topEnd + topHeight, false, topDistance));
    lines.push(props.canvas.executeFunction('drawLine', 'x', topEnd + topHeight - 1, 'measurementXLine1-edge', left - 2.5, left + 3, false));
  }

  if (bottomShow) {
    bottomDistance = Math.round(bottomDistance);
    lines.push(props.canvas.executeFunction('drawLine', 'x', bottomEnd, 'measurementXLine1-edge', left - 2.5, left + 3, false));
    lines.push(props.canvas.executeFunction('drawLine', 'y', left, 'measurementYLine2', bottomEnd, bottomEnd + bottomHeight, false, bottomDistance));
    lines.push(props.canvas.executeFunction('drawLine', 'x', bottomEnd + bottomHeight - 1, 'measurementXLine1-edge', left - 2.5, left + 3, false));
  }

  return lines;
};

var MeasurementLinesPlugin = /*#__PURE__*/function () {
  function MeasurementLinesPlugin() {
    this.name = 'MeasurementLinesPlugin';
    this.namespace = 'MeasurementLines';
    this.show = false;
    this.lines = [];
    this.temporarilyHidden = false;
  }

  var _proto = MeasurementLinesPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
    this.dispose = null;
  };

  _proto.display = function display() {
    if (this.show) {
      var hoveredLayers = this.canvas.hoveredLayers.filter(function (layer) {
        return layer.type !== 'canvas';
      });
      var emptyBox = {
        x: 0,
        y: 0,
        height: 0,
        width: 0
      };
      var box = emptyBox;
      var helperBox = emptyBox;
      var hoveredDims;
      var parentHoveredLayer;

      if (hoveredLayers.length) {
        hoveredDims = this.canvas.getBoundingBox([hoveredLayers[0]]);
        this.currentHoveredLayer = hoveredLayers[0];
        parentHoveredLayer = get(hoveredLayers, '[0].parent');
      }

      if (this.canvas.selectedLayers.length && hoveredDims) {
        helperBox = this.canvas.getBoundingBox(this.canvas.selectedLayers);
        box = hoveredDims;
      } else if (parentHoveredLayer && parentHoveredLayer.type !== 'canvas' && hoveredDims) {
        helperBox = hoveredDims;
        box = this.canvas.getBoundingBox([parentHoveredLayer]);
      } else if (this.canvas.selectedLayers.length) {
        helperBox = this.canvas.getBoundingBox(this.canvas.selectedLayers);
        var parent = get(this.canvas, 'selectedLayers[0].parent');
        box = parent && parent.type !== 'canvas' ? this.canvas.getBoundingBox([parent]) : emptyBox;
      }

      var xLines = drawXLines({
        box: box,
        helperBox: helperBox,
        canvas: this.canvas
      });
      var yLines = drawYLines({
        box: box,
        helperBox: helperBox,
        canvas: this.canvas
      });

      if (this.lines && this.lines.length > 0) {
        this.lines.forEach(function (line) {
          line.parentNode.removeChild(line);
        });
        this.lines = [];
      }

      this.lines = [].concat(xLines, yLines);
    }
  };

  _proto.showLines = function showLines() {
    this.show = true;
    this.temporarilyHidden = false;
    this.display();
  };

  _proto.hideLines = function hideLines() {
    this.show = false;

    if (this.lines && this.lines.length > 0) {
      this.lines.forEach(function (line) {
        line.parentNode.removeChild(line);
      });
      this.lines = [];
    }

    this.currentHoveredLayer = undefined;
  };

  _proto.activate = function activate() {
    var _this = this;

    this.canvas.addFunction(this.namespace + ".show", this.showLines.bind(this));
    this.canvas.addFunction(this.namespace + ".hide", this.hideLines.bind(this));
    this.canvas.addEventListener('keyUp', function (data) {
      var event = data.originalEvent ? data.originalEvent : data;

      if (event.keyCode === 18) {
        _this.temporarilyHidden = false;

        _this.hideLines();
      }
    });
    this.canvas.addEventListener('blur', function (data) {
      _this.hideLines();
    });
    this.canvas.addEventListener('keyDown', function (data) {
      var event = data.originalEvent ? data.originalEvent : data;

      if (event.keyCode === 18) {
        _this.showLines();
      }
    });
    this.canvas.on('mouseEventsBlocked', function () {
      if (_this.canvas.mouseEventsBlocked && _this.show) {
        _this.temporarilyHidden = true;

        _this.hideLines();
      } else if (_this.temporarilyHidden) {
        _this.temporarilyHidden = false;

        _this.showLines();
      }
    });
    this.canvas.on('hoveredLayers', function () {
      if (_this.show && _this.canvas.hoveredLayers.length > 0 && _this.canvas.hoveredLayers[0].type !== 'canvas' && _this.canvas.hoveredLayers[0] !== _this.currentHoveredLayer) {
        _this.display();
      }
    });
  };

  _proto.deactivate = function deactivate() {
    this.canvas.removeFunction(this.namespace + ".show");
    this.canvas.removeFunction(this.namespace + ".hide");
    this.dispose();
  };

  return MeasurementLinesPlugin;
}();

var MouseRectEvent = /*#__PURE__*/function (_Event) {
  _inheritsLoose(MouseRectEvent, _Event);

  function MouseRectEvent(name, target, payload, currentTarget) {
    var _this;

    _this = _Event.call(this, name, target, currentTarget) || this;
    _this.payload = payload;
    return _this;
  }

  return MouseRectEvent;
}(Event);

var MouseRectPlugin = /*#__PURE__*/function () {
  function MouseRectPlugin() {
    var _this = this;

    this.name = 'MouseRectPlugin';
    this.namespace = 'MouseRect';
    this.dragStarted = false;
    this.dragStart = {
      x: 0,
      y: 0
    };
    this.dims = {
      x: 0,
      y: 0,
      height: 0,
      width: 0
    };

    this.getLayers = function () {
      var hitRectResult = _this.canvas.getHitRectResult(_this.dims.x, _this.dims.y, _this.dims.width, _this.dims.height);

      return _this.canvas.executeMiddleware('MouseRect.getHitRectResult', hitRectResult, function (hitRectResult) {
        return hitRectResult;
      });
    };
  }

  var _proto = MouseRectPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
    this.dispose = null;
  };

  _proto.activate = function activate() {
    var _this2 = this;

    var zoom = this.canvas.getZoom();
    this.wrapperLayer = document.createElement('div');
    this.dispose = this.canvas.addDomToWorld(this.wrapperLayer, true, 105);
    this.wrapperLayer.style.position = 'absolute';
    this.wrapperLayer.style.border = 1 / this.canvas.getZoom() + "px solid #25B9D1";
    this.wrapperLayer.style.top = '0px';
    this.wrapperLayer.style.left = '0px';
    this.wrapperLayer.style.height = '0px';
    this.wrapperLayer.style.width = '0px';
    this.wrapperLayer.style.display = 'none';
    this.wrapperLayer.style.backgroundColor = 'rgba(121,121,121,0.09)';
    this.wrapperLayer.style.pointerEvents = 'none';
    this.canvas.addEventListener('dragStart', function (event) {
      return _this2.canvas.executeMiddleware('MouseRect.dragStart', event, function (event) {
        _this2.dragStarted = true;
        _this2.dragStart = {
          x: event.worldX,
          y: event.worldY
        };
        _this2.wrapperLayer.style.display = '';
        _this2.wrapperLayer.style.left = _this2.dragStart.x + 'px';
        _this2.wrapperLayer.style.top = _this2.dragStart.y + 'px';
      });
    });
    this.canvas.addEventListener('drag', function (event) {
      if (_this2.dragStarted) {
        _this2.dims.x = event.worldX < _this2.dragStart.x ? event.worldX : _this2.dragStart.x;
        _this2.dims.y = event.worldY < _this2.dragStart.y ? event.worldY : _this2.dragStart.y;
        _this2.dims.height = Math.abs(event.worldY - _this2.dragStart.y);
        _this2.dims.width = Math.abs(event.worldX - _this2.dragStart.x);
        _this2.wrapperLayer.style.left = _this2.dims.x + 'px';
        _this2.wrapperLayer.style.top = _this2.dims.y + 'px';
        _this2.wrapperLayer.style.height = _this2.dims.height + 'px';
        _this2.wrapperLayer.style.width = _this2.dims.width + 'px';
        var drawEvent = new MouseRectEvent(_this2.namespace + ".draw", _this2.canvas, _this2.getLayers(), _this2.canvas);

        _this2.canvas.dispatchEvent(_this2.namespace + ".draw", drawEvent);
      }
    });
    this.canvas.addEventListener('dragEnd', function (event) {
      if (_this2.dragStarted) {
        _this2.wrapperLayer.style.top = '0px';
        _this2.wrapperLayer.style.left = '0px';
        _this2.wrapperLayer.style.height = '0px';
        _this2.wrapperLayer.style.width = '0px';
        _this2.wrapperLayer.style.display = 'none';
        var drawEndEvent = new MouseRectEvent(_this2.namespace + ".drawEnd", _this2.canvas, _this2.getLayers(), _this2.canvas);

        _this2.canvas.dispatchEvent(_this2.namespace + ".drawEnd", drawEndEvent);

        _this2.dragStarted = false;
      }
    });
    this.canvas.on('zoom', function (e) {
      var zoom = _this2.canvas.getZoom();

      _this2.wrapperLayer.style.border = 1 / zoom + "px solid #25B9D1";
    });
  };

  _proto.deactivate = function deactivate() {
    this.dispose();
  };

  return MouseRectPlugin;
}();

var TextEditor = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(TextEditor, _React$Component);

  function TextEditor(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.isBlurred = false;
    _this.text = '';
    _this.dims = _this.props.layer.getBoundingClientRect();
    _this.isText = _this.props.layer.type === 'text';
    _this.isAuto = _this.props.layer && _this.props.layer.layout && isNil(_this.props.layer.layout.get('width'));

    _this.onBlur = function () {
      _this.isBlurred = true;
      var event = new TextEditorEvent('onEditorBlur', _this.props.layer, _this.state.editorState.getCurrentContent().getPlainText(), _this.isBlurred);

      _this.props.onEvent(event);
    };

    _this.onFocus = function () {
      _this.isBlurred = false;
      var event = new TextEditorEvent('onEditorFocus', _this.props.layer, _this.state.editorState.getCurrentContent().getPlainText());

      _this.props.onEvent(event);
    };

    _this.handleNumpadEnter = function (e) {
      if (_this.isNumpadEnter(e)) {
        _this.onBlur();
      }
    };

    _this.removePositionalAttribute = function (style) {
      var newStyle = _extends({}, style);

      delete newStyle['left'];
      delete newStyle['top'];
      delete newStyle['width'];
      delete newStyle['height'];
      delete newStyle['flex'];
      delete newStyle['margin'];
      delete newStyle['marginTop'];
      delete newStyle['marginRight'];
      delete newStyle['marginBottom'];
      delete newStyle['marginLeft'];

      if (!newStyle['fontFamily'] || newStyle['fontFamily'] === 'System') {
        newStyle['fontFamily'] = 'system-ui';
      }

      return newStyle;
    };

    _this.onChange = function (editorState) {
      if (_this.isBlurred) {
        return;
      }

      if (editorState.getCurrentContent().getPlainText() !== _this.text) {
        var event = new TextEditorEvent('onEditorChange', _this.props.layer, _this.state.editorState.getCurrentContent().getPlainText(), _this.isBlurred);

        _this.props.onEvent(event);
      }

      _this.setState({
        editorState: editorState
      });
    };

    _this.myBlockStyleFn = function (contentBlock) {
      var type = contentBlock.getType();

      if (type === 'unstyled') {
        return 'defaultTextStyle';
      }

      return '';
    };

    _this.getStringStyle = function (propertyName) {
      var property = _this.props.layer.layout.isValidKey(propertyName) ? _this.props.layer.layout.get(propertyName) : _this.props.layer.style.get(propertyName);
      return typeof property === 'number' ? property.toString() + 'px' : property;
    };

    _this.handleTab = function (event) {
      event.preventDefault();

      if (_this.isBlurred) {
        return;
      }

      var newContentState = Modifier.replaceText(_this.state.editorState.getCurrentContent(), _this.state.editorState.getSelection(), '\t');
      var editorState = EditorState.push(_this.state.editorState, newContentState, 'insert-characters');

      if (editorState.getCurrentContent().getPlainText() !== _this.text) {
        var _event = new TextEditorEvent('onEditorChange', _this.props.layer, _this.state.editorState.getCurrentContent().getPlainText(), _this.isBlurred);

        _this.props.onEvent(_event);
      }

      _this.setState({
        editorState: editorState
      });
    };

    _this.handleKeyBinding = function (event) {
      if (event.keyCode === 27) {
        _this.onBlur();
      }

      return getDefaultKeyBinding(event);
    };

    _this.text = _this.isText ? _this.props.layer.innerText : _this.props.layer.props ? _this.props.layer.props.get('placeholder') : ' ';
    _this.state = {
      editorState: EditorState.moveFocusToEnd(EditorState.createWithContent(ContentState.createFromText(_this.text || '')))
    };
    return _this;
  }

  var _proto = TextEditor.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.onFocus();
    document.addEventListener('keydown', this.handleNumpadEnter);
    document.execCommand('selectAll', false, undefined);
  };

  _proto.isNumpadEnter = function isNumpadEnter(e) {
    return e.key === 'Enter' && e.location === 3 && e.which === 13;
  };

  _proto.render = function render() {
    var _this2 = this;

    var style = this.removePositionalAttribute(_extends({}, this.props.layer.style.getAll(), this.props.layer.layout.getAll()));
    return createElement("div", {
      className: "editorWrapper",
      style: _extends({}, style, {
        display: '',
        visibility: 'visible',
        position: 'absolute',
        transform: this.props.layer.rotation ? "rotate(" + this.props.layer.rotation + "deg)" : undefined,
        top: this.dims.rootY + (!this.isText ? this.dims.height / 2 - 7.6 // No clue how, but it works
        : 0),
        left: this.dims.rootX,
        height: this.dims.height,
        width: this.isAuto ? undefined : this.dims.width,
        caretColor: this.isText ? style.color || 'black' : 'grey',
        color: this.isText ? style.color || 'black' : '#757575',
        fontSize: style.fontSize ? parseInt(style.fontSize, 10) : 14,
        lineHeight: this.getStringStyle('lineHeight') || 'normal',
        letterSpacing: this.getStringStyle('letterSpacing'),
        WebkitFontSmoothing: 'antialiased'
      })
    }, createElement(Editor, {
      ref: function ref(c) {
        _this2.editorRef = c;
      },
      editorState: this.state.editorState,
      onChange: this.onChange,
      keyBindingFn: this.handleKeyBinding,
      blockStyleFn: this.myBlockStyleFn,
      handleReturn: function handleReturn(e, editorState) {
        return _this2.isNumpadEnter(e) ? 'handled' : 'not-handled';
      },
      onBlur: this.onBlur,
      onFocus: this.onFocus,
      onTab: this.handleTab
    }));
  };

  return TextEditor;
}(Component);

var TextEditorPlugin = /*#__PURE__*/function () {
  function TextEditorPlugin() {
    this.name = 'TextEditorPlugin';
  }

  var _proto = TextEditorPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
    this.dispose = null;
  };

  _proto.mountTextEditor = function mountTextEditor(context, layer) {
    var _this = this;

    if (layer && (layer.type == 'text' || layer.type == 'textInput')) {
      // layer.setStyle('display', 'none');
      layer.setStyle('visibility', 'hidden');
      var dims = this.canvas.getBoundingClientRect();
      this.wrapperLayer.style.display = '';
      this.wrapperLayer.style.top = dims.rootY + 'px';
      this.wrapperLayer.style.left = dims.rootX + 'px';
      this.wrapperLayer.style.height = dims.height + 'px';
      this.wrapperLayer.style.width = dims.width + 'px';
      ReactDOM__default.render(createElement(TextEditor, {
        layer: layer,
        onEvent: function onEvent(event) {
          if (event.name === 'onEditorChange' && event.target) {
            event.target.dispatchEvent('setText', event);
          } else if (event.name === 'onEditorBlur' && event.target) {
            _this.wrapperLayer.style.display = 'none'; // event.target.setStyle('display', '');

            event.target.removeStyle('visibility');
            event.target.dispatchEvent('setText', event);
          }
        }
      }), this.wrapperLayer);
    }
  };

  _proto.unmountTextEditor = function unmountTextEditor(context) {
    ReactDOM__default.unmountComponentAtNode(this.wrapperLayer);
  };

  _proto.activate = function activate() {
    this.wrapperLayer = document.createElement('div');
    this.dispose = this.canvas.addDomToWorld(this.wrapperLayer);
    this.wrapperLayer.style.position = 'absolute';
    this.wrapperLayer.style.top = '0';
    this.wrapperLayer.style.left = '0';
    this.wrapperLayer.style.height = '0';
    this.wrapperLayer.style.width = '0';
    this.wrapperLayer.style.display = 'none';
    this.canvas.addFunction('TextEditorPlugin.mountEditor', this.mountTextEditor.bind(this));
    this.canvas.addFunction('TextEditorPlugin.unmountEditor', this.unmountTextEditor.bind(this));
  };

  _proto.deactivate = function deactivate() {
    this.canvas.removeFunction('TextEditorPlugin.mountEditor');
    this.canvas.removeFunction('TextEditorPlugin.unmountEditor');
    this.dispose();
  };

  return TextEditorPlugin;
}();

var PathEditor = /*#__PURE__*/function (_React$PureComponent) {
  _inheritsLoose(PathEditor, _React$PureComponent);

  function PathEditor() {
    var _this;

    _this = _React$PureComponent.apply(this, arguments) || this;
    _this.paper = paper;
    _this.xFactor = 1;
    _this.yFactor = 1;
    _this.isFirstClick = true;

    _this.onUpdate = function (keys) {
      _this.forceUpdate();
    };

    _this.getRotation = function () {
      // TODO: handle rotation here
      // const rotation = get(
      //   this.props.layer,
      //   'domainCompiledRefs[0].renderCompiledRef.rotation'
      // );
      return 0;
    };

    _this.finishEditing = function () {
      if (_this.segment) {
        _this.segment.remove();

        _this.segment = null;
      }
    };

    _this.closePath = function () {
      _this.finishEditing();

      if (_this.path) {
        _this.path.closePath();
      }
    };

    _this.deleteSelectedPoint = function () {
      if (_this.segment) {
        _this.segment.remove();

        _this.ready();
      }
    };

    _this.straightenSelectedPoint = function () {
      if (_this.segment) {
        _this.segment.clearHandles();

        _this.ready();
      }
    };

    _this.disconnectSelectedPoint = function () {
      if (_this.segment) {
        if (_this.segment.handleIn.isZero()) {
          _this.segment.smooth();
        }

        if (_this.segment.handleOut.isZero()) {
          _this.segment.smooth();
        }

        _this.ready();
      }
    };

    _this.emitUpdatedJSON = function () {
      if (_this.path) {
        if (_this.props.newPath) {
          var tempPath = _this.path.clone({
            insert: false,
            deep: true
          });

          tempPath.translate(new paper.Point(-_this.path.bounds.x, -_this.path.bounds.y));
          var convertedJSON = convertPaperPointToBxObj(tempPath);
          var emitEvent = new PathEvent('pathEditorOnChange', _this.props.layer, {
            pathProps: convertedJSON,
            bounds: _this.path.bounds
          });

          _this.props.onEvent(emitEvent);
        } else {
          var _tempPath = _this.path.clone({
            insert: false,
            deep: true
          });

          _tempPath.translate(new paper.Point(-_this.props.dimensions.x, -_this.props.dimensions.y));

          var tempPath2 = _this.path.clone({
            insert: false,
            deep: true
          });

          var rotation = _this.getRotation();

          if (rotation) {
            _tempPath.rotate(-rotation);

            tempPath2.rotate(-rotation);
          }

          _tempPath.bounds = _this.oldBounds;

          var _convertedJSON = convertPaperPointToBxObj(_tempPath);

          var _emitEvent = new PathEvent('pathEditorOnChange', _this.props.layer, {
            pathProps: _convertedJSON,
            bounds: tempPath2.bounds
          });

          _this.props.onEvent(_emitEvent);
        }
      }
    };

    _this.onMouseUp = function (event) {
      var point = event.point;
      var canvasEvent = new DesignerMouseEvent('PaperEvent', _this.props.canvas, event.event);
      point.x = canvasEvent.worldX;
      point.y = canvasEvent.worldY;

      if (_this.props.newPath && _this.path) {
        if (_this.segment) {
          _this.segment.selected = false;
        }

        var hitResult = _this.paper.project.hitTest(point, {
          segments: true,
          tolerance: 5
        });

        if (hitResult && hitResult.segment && hitResult.segment.index === 0 && hitResult.segment.next || get(event, 'event.detail') === 2) {
          _this.closePath();

          _this.emitUpdatedJSON();
        } else {
          _this.segment = _this.path.add(point);
          _this.segment.selected = true;
        }
      }

      _this.handle = null;
    };

    _this.onMouseDrag = function (event) {
      var point = event.point,
          downPoint = event.downPoint;

      if (downPoint) {
        var canvasEvent = new DesignerMouseEvent('PaperEvent', _this.props.canvas, event.event);
        point.x = canvasEvent.worldX;
        point.y = canvasEvent.worldY;

        if (_this.props.newPath && _this.segment) {
          _this.segment.handleIn = downPoint.subtract(point);
          _this.segment.handleOut = point.subtract(downPoint);
        } else {
          if (_this.segment) {
            switch (_this.handle) {
              case 'segment':
                _this.segment.point = point;

                _this.emitUpdatedJSON();

                break;

              case 'handle-in':
                _this.segment.handleIn = point.subtract(_this.segment.point);

                _this.emitUpdatedJSON();

                break;

              case 'handle-out':
                _this.segment.handleOut = point.subtract(_this.segment.point);

                _this.emitUpdatedJSON();

                break;
            }
          }
        }
      }
    };

    _this.pathEditorOnEnd = function (isLastUpdate) {
      if (isLastUpdate === void 0) {
        isLastUpdate = false;
      }

      if (!isLastUpdate) {
        _this.emitUpdatedJSON();
      }

      var emitEvent = new PathEvent('pathEditorOnEnd', _this.props.layer);

      _this.props.onEvent(emitEvent);
    };

    _this.onMouseDown = function (event) {
      if (_this.isFirstClick) {
        var emitEvent = new DesignerMouseEvent('pathEditor.selectParent', _this.props.canvas, event.event);

        _this.props.onEvent(emitEvent);

        _this.isFirstClick = false;
      }

      if (_this.path) {
        var downPoint = event.downPoint;
        var canvasEvent = new DesignerMouseEvent('PaperEvent', _this.props.canvas, event.event);
        downPoint.x = canvasEvent.worldX;
        downPoint.y = canvasEvent.worldY;

        if (!_this.props.newPath) {
          var hitResult = _this.paper.project.hitTest(downPoint, {
            stroke: true,
            segments: true,
            handles: true,
            tolerance: 5
          });

          if (_this.segment) {
            _this.segment.selected = false;
          }

          if (hitResult) {
            _this.handle = hitResult.type;

            switch (hitResult.type) {
              case 'stroke':
                if (hitResult.location) {
                  var location = hitResult.location;
                  var newCurve = location.curve.divideAt(location);

                  if (newCurve) {
                    _this.segment = newCurve.segment1;
                    _this.segment.selected = true;
                    _this.handle = 'segment';
                  }
                }

                break;

              case 'segment':
              case 'handle-in':
              case 'handle-out':
                _this.segment = hitResult.segment;
                _this.segment.selected = true;
                break;
            }

            _this.ready();
          } else {
            if (!_this.path.contains(downPoint)) {
              _this.pathEditorOnEnd();
            }
          }
        }
      }
    };

    _this.onMouseMove = function (event) {
      var newPath = _this.props.newPath;
      var point = event.point;
      var canvasEvent = new DesignerMouseEvent('PaperEvent', _this.props.canvas, event.event);
      point.x = canvasEvent.worldX;
      point.y = canvasEvent.worldY;

      if (newPath && _this.segment) {
        _this.segment.point.set(point);
      }
    };

    return _this;
  }

  var _proto = PathEditor.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var canvas = document.getElementById('path-editor-canvas');

    if (!canvas) {
      return;
    }

    this.props.canvas.on('zoom', this.onUpdate);
    this.paper.setup(canvas);
    this.init();
    var tool = new paper.Tool();
    tool.onMouseDrag = this.onMouseDrag;
    tool.onMouseDown = this.onMouseDown;
    tool.onMouseUp = this.onMouseUp;
    tool.onMouseMove = this.onMouseMove;
    this.tool = tool;
    this.paper.settings.handleSize = 7 / this.props.canvas.getZoom();
    this.ready();
  };

  _proto.ready = function ready() {
    var pointMode = '';

    if (this.segment) {
      if (this.segment.handleIn.isZero() || this.segment.handleOut.isZero()) {
        pointMode = 'straight';
      } else {
        pointMode = 'disconnected';
      }
    }

    var event = new PathEvent('pathEditorOnReady', this.props.layer, {
      actions: {
        deleteSelectedPoint: this.deleteSelectedPoint,
        straightenSelectedPoint: this.straightenSelectedPoint,
        disconnectSelectedPoint: this.disconnectSelectedPoint,
        finishEditing: this.finishEditing,
        closePath: this.closePath
      },
      pointMode: pointMode
    });
    this.props.onEvent(event);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    this.paper.settings.handleSize = 7 / this.props.canvas.getZoom();
    this.init();
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.tool) {
      this.tool.remove();
    }

    this.pathEditorOnEnd(true);
    this.paper.project.clear();
    this.paper.project.remove();
  };

  _proto.init = function init() {
    var _this$props = this.props,
        layer = _this$props.layer,
        dimensions = _this$props.dimensions,
        newPath = _this$props.newPath;
    var path;

    if (newPath) {
      path = new paper.Path();
      this.segment = path.add(new paper.Point(0, 0));
      path.selectedColor = '#A3A3A3';
      path.strokeColor = '#A3A3A3';
      path.strokeWidth = 1 / this.props.canvas.getZoom();
      this.paper.project.clear();
      var paperLayer = new paper.Layer([path]);
      this.paper.project.addLayer(paperLayer);
    } else {
      if (this.path) {
        this.path.remove();
      }

      this.isFirstClick = false;
      var pathProps = layer.props.getAll();
      var points = pathProps.points;
      var isClosed = pathProps.isClosed;
      var pathJSON = getPaperPathFromPoints(points, isClosed);
      path = pathJSON;
      this.xFactor = dimensions.width / path.bounds.width;
      this.yFactor = dimensions.height / path.bounds.height;
      this.oldBounds = path.bounds;
      path.applyMatrix = true;
      path.bounds.x = 0;
      path.bounds.y = 0;
      path.translate(new paper.Point(dimensions.rootX, dimensions.rootY));
      path.scale(this.xFactor, this.yFactor, path.bounds.topLeft);
      var rotation = this.getRotation();

      if (rotation) {
        path.rotate(rotation);
      }

      path.selectedColor = '#A3A3A3';
      path.strokeColor = '#A3A3A3';
      path.fillColor = pathProps.fill;
      this.paper.project.clear();

      var _paperLayer = new paper.Layer([path]);

      this.paper.project.addLayer(_paperLayer);
    }

    path.selected = true; //@ts-ignore

    this.paper.view.draw();
    this.paper.view.update();
    this.path = path;
  };

  _proto.render = function render() {
    return createElement("canvas", {
      width: this.props.bounds.width,
      height: this.props.bounds.height,
      style: {
        cursor: 'crosshair',
        position: 'absolute',
        pointerEvents: 'auto'
      },
      id: "path-editor-canvas"
    });
  };

  return PathEditor;
}(PureComponent);

var PathEditorPlugin = /*#__PURE__*/function () {
  function PathEditorPlugin() {
    var _this = this;

    this.name = 'PathEditorPlugin';
    this.nameSpace = 'PathEditor';
    this.selectedTool = 'pen';

    this.handlePathEditorEvents = function (event) {
      var payload = event.payload,
          target = event.target,
          name = event.name;

      switch (name) {
        case 'pathEditorOnReady':
          var _payload$actions = payload.actions,
              deleteSelectedPoint = _payload$actions.deleteSelectedPoint,
              disconnectSelectedPoint = _payload$actions.disconnectSelectedPoint,
              straightenSelectedPoint = _payload$actions.straightenSelectedPoint,
              finishEditing = _payload$actions.finishEditing,
              closePath = _payload$actions.closePath;

          _this.canvas.addFunction(_this.nameSpace + ".deleteSelectedPoint", deleteSelectedPoint);

          _this.canvas.addFunction(_this.nameSpace + ".disconnectSelectedPoint", disconnectSelectedPoint);

          _this.canvas.addFunction(_this.nameSpace + ".straightenSelectedPoint", straightenSelectedPoint);

          _this.canvas.addFunction(_this.nameSpace + ".finishEditing", finishEditing);

          _this.canvas.addFunction(_this.nameSpace + ".closePath", closePath);

          break;

        case 'pathEditorOnChange':
          var pathProps = payload.pathProps,
              bounds = payload.bounds;
          var viewBox = "0 0 " + bounds.width + " " + bounds.height;
          var style = {
            left: bounds.x,
            top: bounds.y,
            width: bounds.width,
            height: bounds.height,
            position: 'absolute'
          };

          if (_this.selectedTool === 'path' && target) {
            target.dispatchEvent(_this.nameSpace + ".onEdit", new PathEvent(_this.nameSpace + ".onEdit", target, {
              viewBox: viewBox,
              points: pathProps.points,
              style: style,
              isClosed: pathProps.closed
            }));
          } else if (_this.selectedTool === 'pen') {
            _this.canvas.dispatchEvent(_this.nameSpace + ".addNew", new PathEvent(_this.nameSpace + ".addNew", _this.canvas, {
              viewBox: viewBox,
              points: pathProps.points,
              style: style,
              isClosed: pathProps.closed
            }));

            _this.hide();
          }

          break;

        case 'pathEditorOnEnd':
          _this.hide();

          target.setStyle('display', '');

          _this.canvas.dispatchEvent(_this.nameSpace + ".isClosed", new PathEvent(_this.nameSpace + ".isClosed", _this.canvas));

          break;

        case 'pathEditor.selectParent':
          _this.canvas.dispatchEvent(_this.nameSpace + ".selectParent", event);

          break;
      }
    };

    this.hide = function () {
      ReactDOM__default.unmountComponentAtNode(_this.wrapperLayer);
      _this.wrapperLayer.style.display = 'none';

      _this.canvas.removeFunction(_this.nameSpace + ".deleteSelectedPoint");

      _this.canvas.removeFunction(_this.nameSpace + ".disconnectSelectedPoint");

      _this.canvas.removeFunction(_this.nameSpace + ".straightenSelectedPoint");

      _this.canvas.removeFunction(_this.nameSpace + ".finishEditing");

      _this.canvas.removeFunction(_this.nameSpace + ".closePath");
    };

    this.getScrollShift = function () {
      var canvasScroll = _this.canvas.getScroll();

      var zoom = _this.canvas.getZoom();

      var viewPortLeftPos = canvasScroll.x * (_this.canvas.layout.get('width') * zoom - _this.canvas.getViewport().width);

      var viewPortTopPos = canvasScroll.y * (_this.canvas.layout.get('height') * zoom - _this.canvas.getViewport().height);

      return {
        x: viewPortLeftPos,
        y: viewPortTopPos
      };
    };

    this.handleEvent = function (data) {
      _this.selectedTool = data.payload.selectedTool;
      var dims;

      var viewPort = _this.canvas.getViewport();

      var _this$getScrollShift = _this.getScrollShift(),
          x = _this$getScrollShift.x,
          y = _this$getScrollShift.y;

      var zoom = _this.canvas.getZoom(); // let bounds = {
      //   x: x / zoom,
      //   y: y / zoom,
      //   rootX: x / zoom,
      //   rootY: y / zoom,
      //   height: viewPort.height / zoom,
      //   width: viewPort.width / zoom,
      // };


      var bounds = _this.canvas.getBoundingClientRect();

      if (_this.selectedTool === 'path') {
        data.target.setStyle('display', 'none');
        dims = data.target.getBoundingClientRect();
      } else {
        dims = bounds;
      }

      _this.wrapperLayer.style.display = ''; // this.wrapperLayer.style.top = dims.rootY + 'px';
      // this.wrapperLayer.style.left = dims.rootX + 'px';

      _this.wrapperLayer.style.height = dims.height + 'px';
      _this.wrapperLayer.style.width = dims.width + 'px'; // this.wrapperLayer.style.border = '2px solid green';

      ReactDOM__default.render(createElement(PathEditor, {
        onEvent: _this.handlePathEditorEvents,
        layer: _this.selectedTool === 'pen' ? _this.canvas : data.target,
        newPath: _this.selectedTool === 'pen',
        bounds: {
          left: bounds.x,
          top: bounds.y,
          width: bounds.width / _this.canvas.getZoom(),
          height: bounds.height / _this.canvas.getZoom()
        },
        canvas: _this.canvas,
        dimensions: dims
      }), _this.wrapperLayer);
    };
  }

  var _proto = PathEditorPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
    this.dispose = null;
  };

  _proto.activate = function activate() {
    var _this2 = this;

    this.wrapperLayer = document.createElement('div');
    this.dispose = this.canvas.addDomToWorld(this.wrapperLayer);
    this.wrapperLayer.style.position = 'absolute';
    this.wrapperLayer.style.top = '0';
    this.wrapperLayer.style.left = '0';
    this.wrapperLayer.style.height = '0';
    this.wrapperLayer.style.width = '0';
    this.wrapperLayer.style.display = 'none';
    this.canvas.addFunction(this.nameSpace + ".open", function (context, data) {
      _this2.handleEvent(data);
    });
    this.canvas.addFunction(this.nameSpace + ".mount", this.mountEditor.bind(this));
    this.canvas.addFunction(this.nameSpace + ".unmount", this.hide.bind(this));
  };

  _proto.mountEditor = function mountEditor(context, targetLayer) {
    this.handleEvent(new PathEvent('PathEditor.open', targetLayer, {
      selectedTool: 'path'
    }));
    this.canvas.dispatchEvent(this.nameSpace + ".isOpened", new PathEvent(this.nameSpace + ".isOpened", this.canvas));
  };

  _proto.deactivate = function deactivate() {
    this.canvas.removeFunction(this.nameSpace + ".open");
    this.canvas.removeFunction(this.nameSpace + ".mount");
    this.canvas.removeFunction(this.nameSpace + ".unmount");
    this.dispose();
  };

  return PathEditorPlugin;
}();

var getLineSegmentObject = function getLineSegmentObject(gradient) {
  var stops = [];
  gradient.stops.map(function (stop) {
    stops.push({
      position: stop.offset,
      color: stop.stopColor
    });
  });
  return {
    from: [gradient.from.x, gradient.from.y],
    to: [gradient.to.x, gradient.to.y],
    stops: stops,
    activeIndex: gradient.activeIndex,
    gradientType: gradient.gradientType
  };
};
var getGradientFromLineSegmentObject = function getGradientFromLineSegmentObject(gradient) {
  var stops = [];
  gradient.stops.map(function (stop) {
    stops.push({
      offset: stop.position,
      stopColor: stop.color
    });
  });
  return {
    from: {
      x: gradient.from[0],
      y: gradient.from[1]
    },
    to: {
      x: gradient.to[0],
      y: gradient.to[1]
    },
    stops: stops,
    activeIndex: gradient.activeIndex,
    gradientType: gradient.gradientType
  };
};

var GradientEditorRenderer = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(GradientEditorRenderer, _React$Component);

  function GradientEditorRenderer(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;

    _this.handleMove = function (type, handle) {
      if (type === 'from') {
        _this.props.onChange(_extends({}, _this.state, {
          from: handle
        }), 'Skip');

        _this.setState({
          from: handle
        });
      } else if (type === 'to') {
        _this.props.onChange(_extends({}, _this.state, {
          to: handle
        }), 'Skip');

        _this.setState({
          to: handle
        });
      } else {
        _this.props.onChange(_extends({}, _this.state, {
          stops: handle
        }), 'Skip');

        _this.setState({
          stops: handle
        });
      }

      return null;
    };

    _this.removeHandle = function () {
      if (_this.state.activeIndex) {
        var stops = _this.state.stops;

        if (!(_this.state.activeIndex === 0 || _this.state.activeIndex === stops.length - 1)) {
          stops.splice(_this.state.activeIndex, 1);
        }

        _this.setState({
          stops: stops
        });

        _this.props.onChange(_extends({}, _this.state), '');
      }
    };

    _this.changeIndex = function (activeIndex) {
      _this.setState({
        activeIndex: activeIndex
      });

      _this.props.onChange(_extends({}, _this.state, {
        activeIndex: activeIndex
      }), 'Skip');
    };

    _this.handleDragStart = function () {
      _this.props.onChange(_extends({}, _this.state), 'Forget');
    };

    _this.handleDragEnd = function () {
      _this.props.onChange(_extends({}, _this.state), '');
    };

    _this.state = _extends({
      activeIndex: props.gradient.activeIndex
    }, getLineSegmentObject(props.gradient));
    return _this;
  }

  var _proto = GradientEditorRenderer.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;

    var canvas = this.props.canvas;
    canvas.addFunction('GradientEditor.changeStopColor', function (context, payload) {
      var newStops = _this2.state.stops;
      newStops[_this2.state.activeIndex].color = payload.color;

      _this2.setState({
        stops: newStops
      });

      _this2.props.onChange(_extends({}, _this2.state), 'Skip');
    });
    canvas.addFunction('GradientEditor.change', function (context, gradient) {
      if (gradient) {
        var lineSegmentObj = getLineSegmentObject(gradient);

        _this2.setState(_extends({}, lineSegmentObj));
      }
    });
  };

  _proto.render = function render() {
    var props = this.props,
        state = this.state;
    var dims = props.dims,
        zoom = props.zoom,
        scroll = props.scroll;
    return createElement(LineSegmentSliderInput //@ts-ignore
    , {
      //@ts-ignore
      x: dims.rootX,
      y: dims.rootY,
      width: dims.width,
      height: dims.height,
      from: state.from,
      to: state.to,
      stops: state.stops,
      index: state.activeIndex,
      zoom: zoom,
      rotation: dims.rotation,
      scroll: scroll,
      changeIndex: this.changeIndex,
      handleMove: this.handleMove,
      removeHandle: this.removeHandle,
      onClickOutside: this.props.onClickOutside,
      onWrapperMouseDown: this.props.onWrapperMouseDown,
      onWrapperContexMenu: this.props.onWrapperContexMenu,
      onWrapperDoubleClick: this.props.onWrapperDoubleClick,
      onWrapperMouseOut: this.props.onWrapperMouseOut,
      onWrapperDrop: this.props.onWrapperDrop,
      onDragOver: this.props.onDragOver,
      onWrapperMouseMove: this.props.onWrapperMouseMove,
      onWrapperMouseUp: this.props.onWrapperMouseUp,
      onDragStart: this.handleDragStart,
      onDragEnd: this.handleDragEnd
    });
  };

  return GradientEditorRenderer;
}(Component);

var CommandEvent = /*#__PURE__*/function (_Event) {
  _inheritsLoose(CommandEvent, _Event);

  function CommandEvent(name, target, commandParams, currentTarget, type) {
    var _this;

    _this = _Event.call(this, name, target, currentTarget) || this;
    _this.commandParams = commandParams;
    _this.type = type || '';
    return _this;
  }

  return CommandEvent;
}(Event);

var GradientEditorPlugin = /*#__PURE__*/function () {
  function GradientEditorPlugin() {
    var _this = this;

    this.name = 'GradientEditorPlugin';
    this.nameSpace = 'GradientEditor';
    this.isOpened = false;

    this.getScrollShift = function () {
      var canvasScroll = _this.canvas.getScroll();

      var zoom = _this.canvas.getZoom();

      var viewPortLeftPos = canvasScroll.x * (_this.canvas.layout.get('width') * zoom - _this.canvas.getViewport().width);

      var viewPortTopPos = canvasScroll.y * (_this.canvas.layout.get('height') * zoom - _this.canvas.getViewport().height);

      return {
        x: viewPortLeftPos,
        y: viewPortTopPos
      };
    };

    this.render = function (layer) {
      _this.gradient = layer.style.get('gradient');

      if (!_this.gradient) {
        _this.gradient = new Gradient('LinearGradient', {
          x: 0.1,
          y: 0.1
        }, {
          x: 0.9,
          y: 0.9
        }, [{
          stopColor: '#E70B0B',
          offset: 0
        }, {
          stopColor: '#EEEEEE',
          offset: 1
        }], 1);

        _this.canvas.dispatchEvent('setStyleAttribute', new CommandEvent('setStyleAttribute', _this.canvas, {
          layer: layer,
          key: 'gradient',
          value: _this.gradient.toJS(),
          stylePropName: 'style'
        }));
      }

      var dims = layer.getBoundingClientRect();

      if (!_this.wrapperLayer) {
        return;
      }

      _this.isOpened = true;
      _this.wrapperLayer.style.display = '';

      var scroll = _this.getScrollShift();

      if (_this.initialShift) {
        scroll = {
          x: scroll.x - _this.initialShift.x,
          y: scroll.y - _this.initialShift.y
        };
      }

      ReactDOM__default.render(createElement(GradientEditorRenderer, {
        layer: layer,
        dims: dims,
        zoom: _this.canvas.getZoom(),
        scroll: scroll,
        canvas: _this.canvas,
        gradient: _this.gradient,
        onChange: function onChange(gradient, type) {
          var gradientProps = getGradientFromLineSegmentObject(gradient);
          _this.gradient = new Gradient(gradient ? gradient.gradientType : 'LinearGradient', gradientProps.from, gradientProps.to, gradientProps.stops, gradientProps.activeIndex);

          _this.canvas.dispatchEvent('setStyleAttribute', new CommandEvent('setStyleAttribute', _this.canvas, {
            layer: layer,
            key: 'gradient',
            value: _this.gradient.toJS(),
            stylePropName: 'style'
          }, undefined, type));
        },
        onClickOutside: function onClickOutside(e) {
          _this.closeEditor();

          _this.canvas.dispatchEventOnHitLayer(e.type, new DesignerMouseEvent(e.type, _this.canvas, e, _this.canvas));
        },
        onWrapperMouseDown: function onWrapperMouseDown(e) {
          _this.canvas.dispatchEventOnHitLayer(e.type, new DesignerMouseEvent(e.type, _this.canvas, e, _this.canvas));
        },
        onWrapperContexMenu: function onWrapperContexMenu(e) {
          _this.canvas.dispatchEventOnHitLayer(e.type, new DesignerMouseEvent(e.type, _this.canvas, e, _this.canvas));
        },
        onWrapperDoubleClick: function onWrapperDoubleClick(e) {
          _this.canvas.dispatchEventOnHitLayer(e.type, new DesignerMouseEvent(e.type, _this.canvas, e, _this.canvas));
        },
        onWrapperMouseOut: function onWrapperMouseOut(e) {
          _this.canvas.dispatchEventOnHitLayer(e.type, new DesignerMouseEvent(e.type, _this.canvas, e, _this.canvas));
        },
        onWrapperDrop: function onWrapperDrop(e) {
          _this.canvas.dispatchEventOnHitLayer(e.type, new DesignerMouseEvent(e.type, _this.canvas, e, _this.canvas));
        },
        onDragOver: function onDragOver(e) {
          _this.canvas.dispatchEventOnHitLayer(e.type, new DesignerMouseEvent(e.type, _this.canvas, e, _this.canvas));
        },
        onWrapperMouseMove: function onWrapperMouseMove(e) {
          _this.canvas.dispatchEventOnHitLayer(e.type, new DesignerMouseEvent(e.type, _this.canvas, e, _this.canvas));
        },
        onWrapperMouseUp: function onWrapperMouseUp(e) {
          _this.canvas.dispatchEventOnHitLayer(e.type, new DesignerMouseEvent(e.type, _this.canvas, e, _this.canvas));
        }
      }), _this.wrapperLayer);
    };

    this.rerender = function () {
      var layer = _this.canvas.selectedLayers[0];

      if (layer && _this.isOpened) {
        _this.render(layer);
      }
    };

    this.closeEditor = function () {
      if (_this.isOpened) {
        ReactDOM__default.unmountComponentAtNode(_this.wrapperLayer);
        _this.isOpened = false;
        _this.wrapperLayer.style.display = 'none';

        _this.canvas.off('zoom', _this.rerender);

        _this.canvas.off('scroll', _this.rerender);

        _this.canvas.removeFunction(_this.nameSpace + ".change");

        _this.canvas.removeFunction(_this.nameSpace + ".changeStopColor");
      }
    };
  }

  var _proto = GradientEditorPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
  };

  _proto.activate = function activate() {
    var _this2 = this;

    this.wrapperLayer = document.createElement('div');
    this.dispose = this.canvas.addDomToWorld(this.wrapperLayer);
    this.wrapperLayer.style.position = 'absolute';
    this.wrapperLayer.style.top = '0';
    this.wrapperLayer.style.left = '0';
    this.wrapperLayer.style.right = '0';
    this.wrapperLayer.style.bottom = '0';
    this.wrapperLayer.style.display = 'none';
    this.wrapperLayer.style.zIndex = 101;
    this.canvas.addEventListener(this.nameSpace + ".open", function (data) {
      if (!_this2.isOpened) {
        var layer = _this2.canvas.selectedLayers[0];
        _this2.initialShift = _this2.getScrollShift();

        if (layer) {
          _this2.render(layer);
        }

        _this2.canvas.on('zoom', _this2.rerender);

        _this2.canvas.on('scroll', _this2.rerender);
      }
    });
    this.canvas.addFunction(this.nameSpace + ".isOpen", function (context) {
      return _this2.isOpened;
    });
    this.canvas.addEventListener(this.nameSpace + ".close", this.closeEditor);
  };

  _proto.deactivate = function deactivate() {
    this.canvas.removeFunction(this.nameSpace + ".isOpen");
    this.canvas.removeEventListener(this.nameSpace + ".close", this.closeEditor);
    this.dispose();
  };

  return GradientEditorPlugin;
}();

var NativeHtmlDrag = /*#__PURE__*/function () {
  function NativeHtmlDrag() {
    var _this = this;

    this.name = 'NativeHtmlDrag';
    this.namespace = 'NativeHtmlDrag';
    this.mouseDown = false;
    this.dragStarted = false;

    this.onMouseMove = function (dragDom, e) {
      if (_this.mouseDown && !_this.dragStarted) {
        _this.dragStarted = true;
        var event = new MouseEvent('htmlDragStart', e);
        dragDom.dispatchEvent(event);
      } else if (_this.dragStarted) {
        var event = new MouseEvent('htmlDrag', e);
        dragDom.dispatchEvent(event);
      }
    };

    this.disableSelect = function (event) {
      event.preventDefault();
    };

    this.onMouseUp = function (dragDom, e) {
      e.preventDefault();

      if (_this.dragStarted) {
        var event = new MouseEvent('htmlDragEnd', e);
        dragDom.dispatchEvent(event);
      }

      _this.mouseDown = false;
      _this.dragStarted = false;
      dragDom.ownerDocument.removeEventListener('mousemove', _this.boundMouseMove);
      dragDom.ownerDocument.removeEventListener('mouseup', _this.boundMouseUp);
      dragDom.ownerDocument.removeEventListener('contextmenu', _this.boundMouseUp);
      window.removeEventListener('selectstart', _this.disableSelect);
    };
  }

  var _proto = NativeHtmlDrag.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
  };

  _proto.handleHtmlDrag = function handleHtmlDrag(context, dragDom) {
    var _this2 = this;

    this.dragDom = dragDom;
    dragDom.addEventListener('mousedown', function (event) {
      window.addEventListener('selectstart', _this2.disableSelect); // event.preventDefault();

      if (event.button !== 2 && event.which !== 3) {
        // Ignore right click mousedown
        _this2.mouseDown = true;
        _this2.dragStarted = false;

        if (dragDom && dragDom.ownerDocument) {
          _this2.boundMouseMove = _this2.onMouseMove.bind(_this2, dragDom);
          _this2.boundMouseUp = _this2.onMouseUp.bind(_this2, dragDom);
          dragDom.ownerDocument.addEventListener('mousemove', _this2.boundMouseMove);
          dragDom.ownerDocument.addEventListener('mouseup', _this2.boundMouseUp);
          dragDom.ownerDocument.addEventListener('contextmenu', _this2.boundMouseUp);
        }
      }
    }); // dragDom.addEventListener('mousemove', (e: any) => {
    //   if (this.mouseDown && !this.dragStarted) {
    //     this.dragStarted = true;
    //     var event = new MouseEvent('htmlDragStart', e);
    //     dragDom.dispatchEvent(event);
    //   } else if (this.dragStarted) {
    //     var event = new MouseEvent('htmlDrag', e);
    //     dragDom.dispatchEvent(event);
    //   }
    // });
    // dragDom.addEventListener('mouseup', (e: any) => {
    //   e.preventDefault();
    //   if (this.dragStarted) {
    //     var event = new MouseEvent('htmlDragEnd', e);
    //     dragDom.dispatchEvent(event);
    //   }
    //   this.mouseDown = false;
    //   this.dragStarted = false;
    // });
  };

  _proto.activate = function activate() {
    this.canvas.addFunction("handleHtmlDrag", this.handleHtmlDrag.bind(this));
  };

  _proto.deactivate = function deactivate() {
    //
    this.canvas.removeFunction("handleHtmlDrag");
  };

  return NativeHtmlDrag;
}();

var StageDesignerDeviceData = /*#__PURE__*/function () {
  function StageDesignerDeviceData() {
    var _this = this;

    this.name = 'StageDesignerDeviceData';
    this.dataMap = new Map();

    this.getDeviceData = function (context) {
      var layer = context.layer;
      return _this.getDeviceDataOnLayer(layer);
    };

    this.getDeviceDataOnLayer = function (layer) {
      var deviceData = layer.executeFunction('getData', 'deviceData');

      if (deviceData) {
        return deviceData;
      } else if (layer.parent) {
        return _this.getDeviceDataOnLayer(layer.parent);
      }

      return null;
    };
  }

  var _proto = StageDesignerDeviceData.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
  };

  _proto.activate = function activate() {
    this.canvas.addFunction('getDeviceData', this.getDeviceData);
  };

  _proto.deactivate = function deactivate() {
    this.canvas.removeFunction('getDeviceData');
  };

  return StageDesignerDeviceData;
}();

var PathEvent = /*#__PURE__*/function (_Event) {
  _inheritsLoose(PathEvent, _Event);

  function PathEvent(name, target, payload, currentTarget) {
    var _this;

    _this = _Event.call(this, name, target, currentTarget) || this;
    _this.payload = payload;
    return _this;
  }

  return PathEvent;
}(Event);

var ArtboardEvent = /*#__PURE__*/function (_Event) {
  _inheritsLoose(ArtboardEvent, _Event);

  function ArtboardEvent(name, target, artboard, currentTarget) {
    var _this;

    _this = _Event.call(this, name, target, currentTarget) || this;
    _this.artboard = artboard;
    return _this;
  }

  return ArtboardEvent;
}(Event);

var TextEditorEvent = /*#__PURE__*/function (_Event) {
  _inheritsLoose(TextEditorEvent, _Event);

  function TextEditorEvent(name, target, payload, isFinal, currentTarget) {
    var _this;

    _this = _Event.call(this, name, target, currentTarget) || this;
    _this.payload = payload;
    _this.isFinal = isFinal || false;
    return _this;
  }

  return TextEditorEvent;
}(Event);

var LayerDragEvent = /*#__PURE__*/function (_DesignerMouseEvent) {
  _inheritsLoose(LayerDragEvent, _DesignerMouseEvent);

  function LayerDragEvent(name, target, originalEvent, payload, currentTarget) {
    var _this;

    _this = _DesignerMouseEvent.call(this, name, target, originalEvent, currentTarget) || this;
    var dims = target.getBoundingClientRect();
    var newDims = target.convertLayerDimensions({
      x: payload.layerWorldX,
      y: payload.layerWorldY,
      width: dims.width,
      height: dims.height,
      rotation: dims.rotation
    });
    _this.layout = newDims;
    _this.meta = payload.meta;
    _this.snapPoints = payload.snapPoints;
    return _this;
  }

  return LayerDragEvent;
}(DesignerMouseEvent);

var LayerDrag = /*#__PURE__*/function () {
  function LayerDrag() {
    this.name = 'LayerDrag';
    this.nameSpace = 'LayerDrag';
    this.dragStarted = false;
    this.startX = 0;
    this.startY = 0;
    this.startLayoutX = 0;
    this.startLayoutY = 0;
    this.startAbsoluteX = 0;
    this.startAbsoluteY = 0;
    this.totalDx = 0;
    this.totalDy = 0;
    this.isAltPressed = false;
    this.isShiftPressed = false;
    this.shiftDirection = '';
  }

  var _proto = LayerDrag.prototype;

  _proto.applyDimensions = function applyDimensions(eventType, showLog) {

    var data = this.dragEventData; // if (showLog)
    // console.log(this.totalDx, this.totalDy, 'database me chal raha hai');

    var worldDx = isNaN(data.worldDx) ? 0 : data.worldDx;
    var worldDy = isNaN(data.worldDy) ? 0 : data.worldDy; // this.totalDx += worldDx;
    // this.totalDy += worldDy;
    // const deltaX  = worldDx;
    // const deltaY += worldDy;

    this.totalDx += worldDx;
    this.totalDy += worldDy;
    var currentDeltaX = this.totalDx;
    var currentDeltaY = this.totalDy;

    if (!this.targetLayer.parent) {
      return;
    }

    var parentAbsoluteRotation = this.targetLayer ? this.targetLayer.parent.getAbsoluteRotation() : 0;
    var rotateDelta = ModelUtils.rotatePoint([currentDeltaX, currentDeltaY], 360 - parentAbsoluteRotation, [0, 0]);
    var snappedData = this.canvas.executeFunction('snapToPoints', this.snapPoints, [this.startX, this.startY], [rotateDelta[0], rotateDelta[1]], _extends({}, this.boundingBox), [currentDeltaX, currentDeltaY], [this.startAbsoluteX, this.startAbsoluteY], parentAbsoluteRotation, this.boundingBoxWRTWorld);
    this.boundingBox = _extends({}, this.boundingBox, {
      x: this.boundingBox.x + snappedData.delta.x,
      y: snappedData.y + snappedData.delta.y
    });
    var delta = snappedData.delta;

    if (!this.isShiftPressed) {
      this.shiftDirection = '';
    }

    var payload = {
      layerWorldX: this.startLayoutX + delta.x,
      layerWorldY: this.startLayoutY + delta.y,
      meta: snappedData.meta
    };

    if (this.isShiftPressed) {
      if (!this.shiftDirection) {
        if (Math.abs(data.worldDx) !== Math.abs(data.worldDy)) {
          if (Math.abs(data.worldDx) > Math.abs(data.worldDy)) {
            this.shiftDirection = 'horizontal';
          } else {
            this.shiftDirection = 'vertical';
          }
        }
      }

      if (this.shiftDirection) {
        if (this.shiftDirection === 'horizontal') {
          payload.layerWorldY = this.targetLayer.getBoundingClientRect().y;
        } else {
          payload.layerWorldX = this.targetLayer.getBoundingClientRect().x;
        }
      }
    } // this.oldDelta = {
    //   x: delta.x,
    //   y: delta.y,
    // };


    var layerDragEvent = new LayerDragEvent(eventType, this.targetLayer, data.originalEvent, payload);
    this.targetLayer.dispatchEvent(eventType, layerDragEvent, data); // this.setNewLayout(
    //   this.selectedLayers,
    //   this.boundingBox,
    //   data.session,
    //   data.targetHandle,
    //   eventType,
    //   data,
    //   delta
    //   // { x: rotateDelta[0], y: rotateDelta[1] }
    // );
  };

  _proto.init = function init(canvas) {
    this.canvas = canvas;
    this.dispose = null;
  };

  _proto.activate = function activate() {
    var _this = this;
    this.canvas.addFunction(this.nameSpace + ".isDragging", function () {
      return _this.dragStarted;
    });
    this.canvas.addEventListener('dragStart', function (event) {
      return _this.canvas.executeMiddleware('LayerDrag.dragStart', event, function (event) {
        try {
          _this.dragStarted = true;
          _this.targetLayer = event.target;

          if (_this.targetLayer) {
            //
            _this.targetLayer.setDragging(true);

            _this.boundingBox = _this.canvas.getContainerBoundingBoxWRTParent([_this.targetLayer]);
            _this.boundingBoxWRTWorld = _this.canvas.getContainerBoundingBox([_this.targetLayer]);
            var parentLayer = _this.targetLayer.parent;

            if (!parentLayer) {
              return Promise.resolve();
            }

            _this.startX = _this.boundingBox.x;
            _this.startY = _this.boundingBox.y;
            _this.startAbsoluteX = _this.boundingBoxWRTWorld.x - _this.canvas.getContainerBoundingBox([parentLayer]).x;
            _this.startAbsoluteY = _this.boundingBoxWRTWorld.y - _this.canvas.getContainerBoundingBox([parentLayer]).y;
            _this.snapPoints = _this.canvas.executeFunction('getSnapPoints', [_this.targetLayer], parentLayer); //

            var layoutData = _this.targetLayer.getBoundingClientRect();

            _this.startLayoutX = layoutData.x;
            _this.startLayoutY = layoutData.y;
            var payload = {
              layerWorldX: layoutData.x,
              layerWorldY: layoutData.y,
              snapPoints: _this.snapPoints
            };
            var layerDragEvent = new LayerDragEvent('layerDragStart', _this.targetLayer, event.originalEvent, payload); // TODO: data to be removed later

            _this.targetLayer.dispatchEvent('layerDragStart', layerDragEvent, event);
          }

          return Promise.resolve();
        } catch (e) {
          return Promise.reject(e);
        }
      });
    });
    this.canvas.addEventListener('drag', function (data) {
      return _this.canvas.executeMiddleware('LayerDrag.drag', data, function (data) {
        if (_this.dragStarted) {
          if (!_this.targetLayer) {
            return;
          }

          _this.dragEventData = data;

          _this.applyDimensions('layerDrag'); // let layoutData = this.targetLayer
          //   ? this.canvas.getBoundingBoxWRTParent([this.targetLayer], true)
          //   : null;
          // // let dims = this.canvas.getBoundingBoxWRTParent([data.target], true); //.getBoundingClientRect();
          // totalDx += data.worldDx;
          // totalDy += data.worldDy;
          // let left = startX + totalDx;
          // let top = startY + totalDy;
          // const absoluteRotation = this.targetLayer.parent.getAbsoluteRotation();
          // let rotateDelta = ModelUtils.rotatePoint(
          //   [totalDx, totalDy],
          //   360 - absoluteRotation,
          //   [0, 0]
          // );
          // const newDx = rotateDelta[0];
          // const newDy = rotateDelta[1];
          // let newSnapPoints = this.getSnapPointCoordinates(
          //   snapPoints,
          //   top,
          //   left,
          //   startX,
          //   startY,
          //   newDx,
          //   newDy,
          //   layoutData
          // );
          // left = newSnapPoints.left;
          // top = newSnapPoints.top;
          // let payload = { layerWorldX: left, layerWorldY: top };
          // let layerDragEvent = new LayerDragEvent(
          //   'layerDrag',
          //   this.targetLayer,
          //   data.originalEvent,
          //   payload
          // );
          // this.targetLayer.dispatchEvent('layerDrag', layerDragEvent, data);

        }
      });
    });
    this.canvas.addEventListener('dragEnd', function (data) {
      return _this.canvas.executeMiddleware('LayerDrag.dragEnd', data, function (data) {
        if (_this.dragStarted) {
          if (!_this.targetLayer) {
            return;
          }

          _this.targetLayer.setDragging(false);

          _this.dragEventData = data;

          _this.applyDimensions('layerDragEnd');

          _this.shiftDirection = '';
          _this.totalDx = 0;
          _this.totalDy = 0;
          _this.startX = 0;
          _this.startY = 0;
          _this.startAbsoluteX = 0;
          _this.startAbsoluteY = 0;
          _this.dragStarted = false;
          _this.dragEventData = undefined;
        }
      });
    });
    this.canvas.addEventListener('blur', function () {
      if (_this.isAltPressed) _this.isAltPressed = false;
      if (_this.isShiftPressed) _this.isShiftPressed = false;
    });
    this.canvas.addEventListener('keyUp', function (data) {
      var event = data.originalEvent ? data.originalEvent : data;

      if (event.keyCode === 16) {
        _this.isShiftPressed = false;
      }

      if (event.keyCode === 18) {
        _this.isAltPressed = false;
      }

      if (_this.dragEventData) {
        _this.applyDimensions('layerDrag', true);
      }
    });
    this.canvas.addEventListener('keyDown', function (data) {
      var event = data.originalEvent ? data.originalEvent : data;

      if (event.keyCode === 16) {
        _this.isShiftPressed = true;
      }

      if (event.keyCode === 18) {
        _this.isAltPressed = true;
      }

      if (_this.dragEventData) {
        _this.applyDimensions('layerDrag');
      }
    });
  };

  _proto.deactivate = function deactivate() {
    this.dispose();
  };

  return LayerDrag;
}();

var GridRenderer = /*#__PURE__*/function () {
  function GridRenderer() {
    var _this = this;

    this.name = 'GridRenderer';
    this.gridLayers = new Map();
    this.gridLayersRef = new Map();
    this.gridOffset = {
      x: 0,
      y: 0
    };

    this.refreshGrid = function (layer) {
      var gridData = _this.gridLayers.get(layer);

      if (layer.type !== 'canvas') {
        if (gridData) {
          _this.createGrid(layer, gridData.dimensions);
        } else {
          _this.createGrid(layer, {
            x: 0,
            y: 0
          });
        }
      }
    };

    this.getGridSize = function (context) {
      var layer = context.layer;

      var data = _this.gridLayers.get(layer);

      if (data) {
        return data.dimensions;
      }

      return null;
    };

    this.setGridSize = function (context, gridSize) {
      var layer = context.layer;

      if (_this.gridLayers.has(layer)) {
        _this.gridLayers["delete"](layer);
      }

      _this.gridLayers.set(layer, {
        dimensions: gridSize
      });
    };

    this.hideGrid = function (context) {
      var layer = context.layer;

      if (_this.gridLayers.has(layer)) {
        _this.gridLayers["delete"](layer);

        if (_this.gridLayersRef.get(layer)) {
          var gridElementMap = _this.gridLayersRef.get(layer);

          if (gridElementMap) {
            var wrapperElement = gridElementMap.get('wrapper');

            _this.gridWrapper.removeChild(wrapperElement);
          }

          _this.gridLayersRef["delete"](layer);
        }
      }

      _this.gridLayers.forEach(function (gridData, layer) {
        _this.refreshGrid(layer);
      });
    };

    this.showGrid = function (context, dims) {
      _this.setGridSize(context, dims);

      _this.gridLayers.forEach(function (gridData, layer) {
        _this.refreshGrid(layer);
      });
    };

    this.setGridOffset = function (context, offset) {
      _this.gridOffset = offset;
    };

    this.getGridOffset = function (context, dims) {
      return _this.gridOffset;
    };

    this.adjustStroke = function () {
      _this.gridLayers.forEach(function (gridData, layer) {
        var gridElementMap = _this.gridLayersRef.get(layer);

        if (gridElementMap) {
          var pathElement = gridElementMap.get('path');

          if (pathElement) {
            pathElement.setAttributeNS(null, 'stroke-width', 1 / _this.canvas.getZoom() + "px");
          }
        }
      });
    };

    this.createGrid = function (layer, gridDims) {
      var dims = layer.getBoundingClientRect();

      var gridElementMap = _this.gridLayersRef.get(layer);

      if (gridElementMap) {
        var wrapperElement = gridElementMap.get('wrapper');

        if (!wrapperElement) {
          wrapperElement = document.createElement('div');
          wrapperElement.style.pointerEvents = 'none';
          wrapperElement.style.position = 'absolute';

          _this.gridWrapper.appendChild(wrapperElement);

          gridElementMap.set('wrapper', wrapperElement);
        }

        wrapperElement.style.left = dims.rootX + 'px';
        wrapperElement.style.top = dims.rootY + 'px';
        wrapperElement.style.height = dims.height + 'px';
        wrapperElement.style.width = dims.width + 'px';
        var svgns = 'http://www.w3.org/2000/svg';
        var svgElement = gridElementMap.get('svg');

        if (!svgElement) {
          svgElement = document.createElementNS(svgns, 'svg');
          svgElement.setAttributeNS(null, 'height', '100%');
          svgElement.setAttributeNS(null, 'width', '100%');
          wrapperElement.appendChild(svgElement);
          gridElementMap.set('svg', svgElement);
        }

        var defsElement = gridElementMap.get('defs');

        if (!defsElement) {
          defsElement = document.createElementNS(svgns, 'defs');
          svgElement.appendChild(defsElement);
          gridElementMap.set('defs', defsElement);
        }

        var patternElement = gridElementMap.get('pattern');

        if (!patternElement) {
          patternElement = document.createElementNS(svgns, 'pattern');
          defsElement.appendChild(patternElement);
          patternElement.setAttributeNS(null, 'id', 'grid-pattern');
          patternElement.setAttributeNS(null, 'patternUnits', 'userSpaceOnUse');
          gridElementMap.set('pattern', patternElement);
        }

        patternElement.setAttributeNS(null, 'width', gridDims.x + 'px');
        patternElement.setAttributeNS(null, 'height', gridDims.y + 'px');
        var pathElement = gridElementMap.get('path');

        if (!pathElement) {
          pathElement = document.createElementNS(svgns, 'path');
          patternElement.appendChild(pathElement);
          pathElement.setAttributeNS(null, 'fill', 'none');
          pathElement.setAttributeNS(null, 'stroke', '#DBDBDB');
          gridElementMap.set('path', pathElement);
        }

        pathElement.setAttributeNS(null, 'd', "M " + gridDims.x + " 0 L 0 0 0 " + gridDims.y);
        pathElement.setAttributeNS(null, 'stroke-width', 1 / _this.canvas.getZoom() + "px");
        var rectElement = gridElementMap.get('rect');

        if (!rectElement) {
          rectElement = document.createElementNS(svgns, 'rect');
          svgElement.appendChild(rectElement);
          rectElement.setAttributeNS(null, 'height', '100%');
          rectElement.setAttributeNS(null, 'width', '100%');
          rectElement.setAttributeNS(null, 'fill', "url(#grid-pattern)");
          gridElementMap.set('rect', rectElement);
        }
      } else {
        _this.gridLayersRef.set(layer, new Map());

        _this.createGrid(layer, gridDims);
      }
    };
  }

  var _proto = GridRenderer.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
  };

  _proto.activate = function activate() {
    var _this2 = this;

    var canvasDims = this.canvas.getBoundingClientRect();
    this.gridWrapper = document.createElement('div');
    this.dispose = this.canvas.addDomToWorld(this.gridWrapper, true);
    this.gridWrapper.style.pointerEvents = 'none';
    this.gridWrapper.style.position = 'absolute';
    this.gridWrapper.style.height = canvasDims.height + 'px';
    this.gridWrapper.style.width = canvasDims.width + 'px';
    this.canvas.addFunction('showGrid', this.showGrid);
    this.canvas.addFunction('hideGrid', this.hideGrid);
    this.canvas.addFunction('getGridSize', this.getGridSize);
    this.canvas.addFunction('setGridSize', this.setGridSize);
    this.canvas.addFunction('setGridOffset', this.setGridOffset);
    this.canvas.addFunction('getGridOffset', this.getGridOffset);
    this.canvas.addEventListener('setLayout', function (data) {
      if (data.target.type === 'canvas') {
        var newDims = data.target.getBoundingClientRect();
        _this2.gridWrapper.style.height = newDims.height;
        _this2.gridWrapper.style.width = newDims.width;

        _this2.gridLayers.forEach(function (gridData, layer) {
          _this2.refreshGrid(layer);
        });
      }

      if (_this2.gridLayers.has(data.target)) {
        var gridData = _this2.gridLayers.get(data.target);

        if (gridData) {
          var dims = gridData.dimensions;
          data.target.executeFunction('showGrid', dims);
        }
      }
    });
    this.canvas.on('zoom', function () {
      _this2.adjustStroke();
    });
  };

  _proto.deactivate = function deactivate() {
    this.canvas.removeFunction('showGrid');
    this.canvas.removeFunction('hideGrid');
    this.canvas.removeFunction('getGridSize');
    this.canvas.removeFunction('setGridSize');
    this.canvas.removeFunction('setGridOffset');
    this.canvas.removeFunction('getGridOffset');
    this.dispose();
  };

  return GridRenderer;
}();

var SelectLayers = /*#__PURE__*/function (_Event) {
  _inheritsLoose(SelectLayers, _Event);

  function SelectLayers(name, target, layers, currentTarget) {
    var _this;

    _this = _Event.call(this, name, target, currentTarget) || this;
    _this.layers = layers;
    return _this;
  }

  return SelectLayers;
}(Event);

var ResetResizerEvent = /*#__PURE__*/function (_Event) {
  _inheritsLoose(ResetResizerEvent, _Event);

  function ResetResizerEvent(name, target, event, currentTarget) {
    var _this;

    _this = _Event.call(this, name, target, currentTarget) || this;
    _this.originalEvent = event;
    return _this;
  }

  return ResetResizerEvent;
}(Event);

var StageDesigner = /*#__PURE__*/function () {
  function StageDesigner() {
    var _this = this;

    this.name = 'StageDesigner';
    this.artboards = new Map();
    this.topLayerSelectionMode = false;
    this.previousMovedLayers = [];

    this.getNewRootLayer = function (targetDims, currentArtboard) {
      var rootX = targetDims.rootX,
          rootY = targetDims.rootY,
          width = targetDims.width,
          height = targetDims.height;

      var layersHit = _this.canvas.getHitRectResult(rootX, rootY, width, height);

      var currentRootLayer = currentArtboard.children[0];
      var newRootLayersHit = filter(layersHit, function (layer) {
        if (layer !== currentRootLayer && layer.parent && layer.parent.parent && layer.parent.parent.type === 'canvas') {
          return true;
        }

        return false;
      });
      var newRootLayer;
      newRootLayersHit.forEach(function (layer) {
        var dims = layer.getBoundingClientRect();
        var x_overlap = Math.max(0, Math.min(dims.rootX + dims.width, targetDims.rootX + targetDims.width) - Math.max(dims.rootX, targetDims.rootX));
        var y_overlap = Math.max(0, Math.min(dims.rootY + dims.height, targetDims.rootY + targetDims.height) - Math.max(dims.rootY, targetDims.rootY));
        var overlapArea = x_overlap * y_overlap;
        newRootLayer = overlapArea > targetDims.width * targetDims.height / 2 ? layer : undefined;
      });
      return newRootLayer;
    };

    this.handleMoveLayerArtboard = function (event) {
      if (indexOf(_this.previousMovedLayers, event.target) !== -1) {
        return;
      }

      _this.canvas.executeFunction('Hover.hideAllHoverBoxes');

      var layerDims = event.target.getBoundingClientRect();
      var currentArtboard = event.target.executeFunction('getArtboard');
      var currentSelectedLayers = filter(_this.canvas.selectedLayers, function (layer) {
        if (layer.parent && layer.parent.type === 'canvas') {
          return false;
        }

        return true;
      });
      var hitRectParams = {};

      if (currentSelectedLayers.length > 1) {
        var boundingBox = _this.canvas.getBoundingBox(currentSelectedLayers);

        hitRectParams = {
          rootX: boundingBox.x,
          rootY: boundingBox.y,
          width: boundingBox.width,
          height: boundingBox.height
        };
      } else {
        hitRectParams = {
          rootX: layerDims.rootX,
          rootY: layerDims.rootY,
          width: layerDims.width,
          height: layerDims.height
        };
      }

      var newRootLayer = _this.getNewRootLayer(hitRectParams, currentArtboard);

      if (newRootLayer) {
        if (currentSelectedLayers.length > 0 && currentSelectedLayers.includes(event.target)) {
          var newToSelectLayers = [];
          currentSelectedLayers.forEach(function (layer) {
            _this.previousMovedLayers.push(layer);

            var newLayer = _this.moveLayer(layer, newRootLayer);

            if (newLayer) {
              newToSelectLayers.push(newLayer);
            }
          });

          _this.canvas.selectLayers(newToSelectLayers);

          _this.canvas.dispatchEvent('resetResizer', new ResetResizerEvent('resetResizer', _this.canvas, event.originalEvent));
        } else {
          // Synthetic Mouse Up event
          var mouseUpEvent = new DesignerMouseEvent('mouseup', _this.canvas, event.originalEvent, _this.canvas);

          _this.canvas.dispatchEventOnHitLayer('mouseup', mouseUpEvent);

          _this.moveLayer(event.target, newRootLayer); // Synthetic mouseDown event for LayerDrag


          var mouseDownEvent = new DesignerMouseEvent('mousedown', _this.canvas, event.originalEvent, _this.canvas);

          _this.canvas.dispatchEventOnHitLayer('mousedown', mouseDownEvent);
        }
      }

      _this.canvas.executeFunction('Hover.showAllHoverBoxes');
    };

    this.moveLayer = function (layer, newRootLayer) {
      var _layer$parent;

      var fromIndex = indexOf((_layer$parent = layer.parent) == null ? void 0 : _layer$parent.children, layer);
      var toIndex = newRootLayer.children.length;

      _this.canvas.dispatchEvent('moveLayer', new CommandEvent('moveLayer', _this.canvas, {
        fromParent: layer.parent,
        toParent: newRootLayer,
        fromIndex: fromIndex,
        toIndex: toIndex
      }));

      var newLayer = newRootLayer.children[toIndex];
      var dims = layer.getBoundingClientRect();
      var newRootLayerDims = newRootLayer.getBoundingClientRect();

      var newLayerDims = _extends({}, layer.getBoundingClientRect(), {
        x: dims.rootX - newRootLayerDims.rootX,
        y: dims.rootY - newRootLayerDims.rootY
      });

      if (newLayer) {
        forEach(newLayer.convertLayerDimensions(newLayerDims), function (value, key) {
          _this.canvas.dispatchEvent('setStyleAttribute', new CommandEvent('setStyleAttribute', _this.canvas, {
            layer: newLayer,
            key: key,
            value: value,
            stylePropName: 'style'
          }));
        });
      }

      return newLayer;
    };

    this.getNewArtboardPosition = function () {
      var left = Number.MIN_VALUE;
      var artLeft = Number.MIN_VALUE;
      var artTop = Number.MIN_VALUE;
      var top = Number.MIN_VALUE;
      var zoom = 1; // TODO: get actual zoom later

      if (_this.artboards.size === 0) {
        return {
          left: 300,
          top: 50,
          artTop: 50,
          artLeft: 300
        };
      }

      _this.artboards.forEach(function (artboard) {
        var artboardClientRect = artboard.getBoundingClientRect();
        var artMaxX = artboardClientRect.x + artboardClientRect.width;
        var artMidY = artboardClientRect.y + artboardClientRect.height / 2;

        if (left < artMaxX) {
          left = artMaxX;
          top = artMidY;
          artTop = artboardClientRect.y;
        }
      });

      artLeft = left + 50;
      left = left * zoom + 50;
      top = top * zoom - 40;
      return {
        left: left,
        top: top,
        artTop: artTop,
        artLeft: artLeft
      };
    };
  }

  var _proto = StageDesigner.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
  };

  _proto.activate = function activate() {
    var _this2 = this;

    this.canvas.addFunction('addArtboard', this.addArtboard.bind(this));
    this.canvas.addFunction('removeArtboard', this.removeArtboard.bind(this));
    this.canvas.addFunction('selectArtboard', this.selectArtboard.bind(this));
    this.canvas.addFunction('getSelectedArtboard', this.getSelectedArtboard.bind(this));
    this.canvas.addFunction('getArtboard', this.getArtboard.bind(this));
    this.canvas.addFunction('focusArtboard', this.focusArtboard.bind(this));
    this.canvas.addFunction('getAllArtboards', this.getAllArtboards.bind(this));
    this.canvas.addFunction('getArtboardById', this.getArtboardById.bind(this));
    this.canvas.addFunction('getSelectedArtboardId', this.getSelectedArtboardId.bind(this));
    this.canvas.addFunction('getNewArtboardPosition', this.getNewArtboardPosition.bind(this));
    this.canvas.addFunction('getHitArtboard', this.getHitArtboard.bind(this));
    this.canvas.on('selectedLayers', function () {
      if (_this2.canvas.selectedLayers[0] && _this2.canvas.selectedLayers[0].parent && _this2.canvas.selectedLayers[0].parent.parent && _this2.canvas.selectedLayers[0].parent.parent.type === 'canvas' && _this2.canvas.selectedLayers[0].type !== 'scrollView') {
        // TODO: heavy jugaad
        // if root layer is selected, select artboard instead
        stopRerender();
        var artboardLayer = _this2.canvas.selectedLayers[0].parent;

        _this2.canvas.selectLayers(artboardLayer);

        if (artboardLayer.children[0].children.length === 0) {
          artboardLayer.executeFunction('LayerResizer.showLayer');
        } else {
          artboardLayer.executeFunction('LayerResizer.hideLayer');
        }

        startRerender();
      }
    }); // Filter layers in hitRect other that direct children of root layer in selected artboard

    this.canvas.addMiddleware('MouseRect.getHitRectResult', function (next, hitRectResult) {
      var selectedArtboard = _this2.canvas.executeFunction('getSelectedArtboard'); // console.log(hitRectResult, 'Layer.getHitRectResult original *(*(*(');


      if (selectedArtboard) {
        var selectedArtboardLayers = [];
        var lowestIndexArtboardLayers = [];
        var allArtboards = Array.from(_this2.artboards.values());
        var lowestIndex = allArtboards.length - 1;
        var ignoredHitRectLayers = [];
        hitRectResult.forEach(function (layer) {
          if (layer.parent && layer.parent.style.get('pointerEvents') === 'none') {
            ignoredHitRectLayers.push(layer.parent);
          }
        });
        var hitRectResultWithIgnored = union(hitRectResult, ignoredHitRectLayers);
        hitRectResultWithIgnored.forEach(function (layer) {
          if (layer.type === 'canvas') return;
          var currentLayerArtboard = layer.executeFunction('getArtboard');

          if (!currentLayerArtboard) {
            return;
          }

          var modLayers; // Layers to consider for comparing. Should be a direct child of root layer
          // or should be a child of ignored layer which is a direct child of root layer

          if (currentLayerArtboard.children[0] && currentLayerArtboard.children[0].children.includes(layer)) {
            if (layer.style.get('pointerEvents') !== 'none') {
              modLayers = [layer];
            } else {
              // if ignored layer, then consider its children and add to modLayers
              modLayers = intersection(hitRectResult, layer.children);
            }
          }

          if (modLayers) {
            if ( // Layer belongs to selectedArtboard
            currentLayerArtboard === selectedArtboard) {
              selectedArtboardLayers = union(selectedArtboardLayers, modLayers);
            } // Check if layer belongs to lowestIndexArtboard
            else {
                var index = indexOf(allArtboards, currentLayerArtboard);

                if (index < lowestIndex) {
                  // If index is lesser than previous, createNewArray and change index
                  lowestIndexArtboardLayers = [];
                  lowestIndexArtboardLayers = union(lowestIndexArtboardLayers, modLayers);
                  lowestIndex = index;
                } else if (index === lowestIndex) {
                  lowestIndexArtboardLayers = union(lowestIndexArtboardLayers, modLayers);
                }
              }
          }
        });

        if (selectedArtboardLayers.length) {
          return next(selectedArtboardLayers);
        } else {
          return next(lowestIndexArtboardLayers);
        }
      } else {
        return next(hitRectResult);
      }
    }); // Modify event.target in Canvas.dispatchEventOnHitLayer according to selected layer,

    this.canvas.addMiddleware('Canvas.dispatchEventOnHitLayer', function (next, event) {
      if (event.name === 'click') {
        _this2.modifyEventForSelectableLayers(event);

        return next(event);
      } else if (event.name === 'mousemove') {
        _this2.modifyEventForSelectableLayers(event);

        return next(event);
      }

      return next(event);
    });
    this.canvas.addMiddleware('LayerDrag.dragStart', function (next, event) {
      var target = event.target;

      if (target.type === 'canvas' || // (target.parent && target.parent.type === 'canvas') ||
      target.parent.parent && target.parent.parent.type === 'canvas' || _this2.canvas.moveWithGrabHandle) {
        return;
      } // const allRootLayers: Array<Layer> = [];
      //   const artboardArray = Array.from(this.artboards.values());
      //   artboardArray.forEach((artboard: Layer) => {
      //     const rootLayer = artboard.children[0];
      //     if (rootLayer) {
      //       allRootLayers.push(rootLayer);
      //     }
      //   });
      //   if (allRootLayers.includes(hitLayer)) {
      //     next(event);
      //   }


      _this2.modifyEventForSelectableLayers(event, true);

      return next(event);
    }); // this.canvas.on('selectedLayers', () => {
    //   if (this.canvas.selectedLayers[0]) {
    //     const artboard = this.canvas.selectedLayers[0].executeFunction(
    //       'getArtboard'
    //     );
    //     if (this.selectedArtboard !== artboard) {
    //       this.canvas.dispatchEvent(
    //         'selectArtboard',
    //         new Event('selectArtboard', artboard)
    //       );
    //       this.selectArtboard(
    //         { canvas: this.canvas, layer: this.canvas },
    //         artboard
    //       );
    //     }
    //   }
    // });

    this.canvas.addEventListener('dblclick', function (e) {
      var parentLayer = e.target.parent;
      var hitLayers = e.target.getHitResult(e.worldX, e.worldY);
      var currentLayer = e.target;

      while (currentLayer && currentLayer.type !== 'canvas' && !_this2.canvas.selectedLayers.includes(currentLayer)) {
        if (_this2.canvas.selectedLayers.includes(currentLayer.parent)) {
          var filteredLayer = filterIgnoredLayers(currentLayer, hitLayers);

          if (filteredLayer) {
            _this2.canvas.dispatchEvent('selectLayers', new SelectLayers('selectLayers', _this2.canvas, [filteredLayer]));
          }

          break;
        }

        currentLayer = currentLayer.parent;
      }
    });
    this.canvas.addMiddleware('MouseRect.dragStart', function (next, event) {
      if (_this2.canvas.moveWithGrabHandle) {
        return;
      }

      var hitLayer = _this2.canvas.getHitLayer(event.worldX, event.worldY);

      if (hitLayer && (hitLayer.locked || hitLayer.type === 'canvas' && event.target && event.target.type === 'canvas')) {
        next(event);
      } else {
        var allRootLayers = [];
        var artboardArray = Array.from(_this2.artboards.values());
        artboardArray.forEach(function (artboard) {
          var rootLayer = artboard.children[0];

          if (rootLayer) {
            allRootLayers.push(rootLayer);
          }
        });

        if (allRootLayers.includes(hitLayer)) {
          next(event);
        }
      }
    });
    this.canvas.addMiddleware('LayerResizer.dragStart', function (next, event) {
      if (_this2.canvas.moveWithGrabHandle) {
        return;
      } else {
        next(event);
      }
    });
    this.canvas.addMiddleware('LayerResizer.drag', function (next, event) {
      if (_this2.canvas.moveWithGrabHandle) {
        return;
      } else {
        next(event);
      }
    });
    this.canvas.addMiddleware('LayerResizer.dragEnd', function (next, event) {
      if (_this2.canvas.moveWithGrabHandle) {
        return;
      } else {
        next(event);
      }
    }); // this.canvas.addEventListener('layerDrag', this.handleMoveLayerArtboard);
    // this.canvas.addEventListener(
    //   'LayerResizer.drag',
    //   this.handleMoveLayerArtboard
    // );

    this.canvas.addEventListener('keyUp', function (data) {
      var event = data.originalEvent ? data.originalEvent : data;

      if (event.keyCode === 91) {
        _this2.setTopLayerSelectionMode(false);
      }
    });
    this.canvas.addEventListener('keyDown', function (data) {
      var event = data.originalEvent ? data.originalEvent : data;

      if (event.keyCode === 91) {
        _this2.setTopLayerSelectionMode(true);
      }
    });
    this.canvas.addMiddleware("LayerResizer.getHandles", function (next, layers) {
      var _layers$, _layers$$parent;

      if ((layers == null ? void 0 : (_layers$ = layers[0]) == null ? void 0 : (_layers$$parent = _layers$.parent) == null ? void 0 : _layers$$parent.type) === 'canvas') {
        // if layer is an artboard
        var handles = next(layers);
        var handlesWithoutRotation = filter(handles, function (h) {
          return h !== 'ROTATE';
        });
        return handlesWithoutRotation;
      } else {
        return next(layers);
      }
    }); // this.canvas.addEventListener('drag', (e: DesignerMouseEvent) => {
    //   this.setScroll(
    //     { canvas: this.canvas, layer: this.canvas },
    //     {
    //       x:
    //         (this.canvas.layout.get('width') - e.worldX) /
    //         this.canvas.layout.get('width'),
    //       y:
    //         (this.canvas.layout.get('height') - e.worldY) /
    //         this.canvas.layout.get('height'),
    //     }
    //   );
    // });

    this.canvas.addEventListener('keyDown', function (event) {
      event = event.originalEvent ? event.originalEvent : event;

      if (event.keyCode === 32) {
        _this2.canvas.enableMoveWithGrabHandle();
      }
    });
    this.canvas.addEventListener('keyUp', function (event) {
      event = event.originalEvent ? event.originalEvent : event;

      if (event.keyCode === 32) {
        _this2.canvas.disableMoveWithGrabHandle();
      }
    });
  };

  _proto.addArtboard = function addArtboard(context, filePath) {
    var _this3 = this;

    var position = this.getNewArtboardPosition();
    var artboard = this.canvas.createLayer();
    this.canvas.addChild(artboard);
    artboard.setLayout({
      top: position.artTop,
      left: position.artLeft,
      height: 600,
      width: 300,
      position: 'absolute'
    });
    artboard.setStyle('backgroundColor', 'white');
    artboard.setProp('id', generateRandomString(20));
    this.artboards.set(filePath, artboard);
    artboard.on('layout', function () {
      _this3.canvas.dispatchEvent('artboardLayoutChanges', new Event('artboardLayoutChanges', _this3.canvas, _this3.canvas));
    });
    artboard.on('updateDom', function () {
      _this3.canvas.dispatchEvent('artboardLayoutChanges', new Event('artboardLayoutChanges', _this3.canvas, _this3.canvas));
    });
    this.canvas.dispatchEvent('artboardLayoutChanges', new Event('artboardLayoutChanges', this.canvas, this.canvas));
    return artboard;
  };

  _proto.removeArtboard = function removeArtboard(context, filePath) {
    var artboard = this.artboards.get(filePath);

    if (artboard) {
      this.artboards["delete"](filePath);
      this.canvas.removeChild(artboard);
    }

    this.canvas.dispatchEvent('artboardLayoutChanges', new Event('artboardLayoutChanges', this.canvas, this.canvas));
  };

  _proto.selectArtboard = function selectArtboard(context, artboard) {
    this.selectedArtboard = artboard;

    if (this.selectedArtboard) {
      var artboardDims = this.selectedArtboard.getBoundingClientRect(); // set grid configuration

      this.canvas.executeFunction('setGridOffset', {
        x: artboardDims.rootX,
        y: artboardDims.rootY
      });
      this.canvas.executeFunction('setGridSize', this.selectedArtboard.executeFunction('getGridSize'));
    }

    this.canvas.dispatchEvent('artboardSelected', new ArtboardEvent('artboardSelected', this.canvas, artboard, this.canvas));
  };

  _proto.focusArtboard = function focusArtboard(context) {
    var canvasDims = this.canvas.getBoundingClientRect();
    var artboardDims = context.layer.getBoundingClientRect();
    var scrollDims = {
      x: (artboardDims.x + artboardDims.width / 2) / canvasDims.width,
      y: (artboardDims.y + artboardDims.height / 2) / canvasDims.height
    };
    this.canvas.executeFunction('setScroll', scrollDims);
  };

  _proto.getHitArtboard = function getHitArtboard(context, x, y) {
    var hitLayers = this.canvas.getHitResult(x, y);
    var artboardArray = Array.from(this.artboards.values());
    var artboards = [];
    forEach(hitLayers.reverse(), function (layer) {
      if (artboardArray.includes(layer)) {
        artboards.push(layer);
      }
    });

    if (isEmpty(artboards)) {
      return null;
    }

    return artboards[artboards.length - 1];
  };

  _proto.getSelectedArtboard = function getSelectedArtboard(context, filePath) {
    return this.selectedArtboard;
  };

  _proto.getSelectedArtboardId = function getSelectedArtboardId(context) {
    return this.selectedArtboard ? this.selectedArtboard.props.get('id') : undefined;
  };

  _proto.getAllArtboards = function getAllArtboards(context) {
    return this.artboards;
  };

  _proto.getArtboardById = function getArtboardById(context, path) {
    return this.artboards.get(path);
  };

  _proto.getArtboard = function getArtboard(context) {
    var layer = context.layer;

    if (layer.type !== 'canvas') {
      var artboardArray = Array.from(this.artboards.values());

      while (!artboardArray.includes(layer) && layer.parent) {
        layer = layer.parent;
      }

      if (artboardArray.includes(layer)) {
        return layer;
      } else {
        return null;
      }
    } else {
      throw new Error('getArtboard should be called on layer only');
    }
  };

  _proto.modifyEventForSelectableLayers = function modifyEventForSelectableLayers(event, forLayerDrag) {
    var _this4 = this;

    if (forLayerDrag === void 0) {
      forLayerDrag = false;
    }

    // Traverse up the chain to all the parents and modify e.target as soon as you find a layer that matches one of the following conditions
    // - It is a sibling of selected layers,
    // - It is one of the direct ancestors of the selected layer upto the root layer, siblings of those parents, or a direct children of root layer of any artboard
    // console.log(
    //   event.target,
    //   'Canvas.dispatchEventOnHitLayer click original *(*(*('
    // );
    if (event.target && event.target.type === 'canvas') {
      // event.target = null;
      return;
    }

    var hitLayers = event.target.getHitResult(event.worldX, event.worldY);
    var selectedArtboard = this.canvas.executeFunction('getSelectedArtboard');
    var currentRootLayer;

    if (selectedArtboard) {
      currentRootLayer = selectedArtboard.children[0];
    }

    var allRootLayerChildren = [];
    var allRootLayers = [];
    var artboardArray = Array.from(this.artboards.values());
    artboardArray.forEach(function (artboard) {
      var rootLayer = artboard.children[0];

      if (rootLayer) {
        allRootLayerChildren = allRootLayerChildren.concat(rootLayer.children); // allRootLayerChildren.push(rootLayer);

        allRootLayers.push(rootLayer);
      }
    }); // Because artboard should be draggable (when dragging its label) but not clickable or hoverable

    if (artboardArray.includes(event.target) && forLayerDrag) {
      return;
    }

    var currentLayer = event.target;

    var _loop = function _loop() {
      if (_this4.topLayerSelectionMode) {
        // Don't modify target, select top layer
        return "break";
      } // If currentLayer is a sibling of selected Layer


      if (_this4.canvas.selectedLayers.length > 0 && _this4.canvas.selectedLayers[0].parent && _this4.canvas.selectedLayers[0].parent.children.includes(currentLayer)) {
        var filteredLayer = filterIgnoredLayers(currentLayer, hitLayers);

        if (filteredLayer) {
          event.target = filteredLayer;
        } // console.log(currentLayer, 'is being hovered *(*(*(*');


        return "break";
      }

      if (allRootLayerChildren.includes(currentLayer)) {
        var _filteredLayer = filterIgnoredLayers(currentLayer, hitLayers);

        if (_filteredLayer) {
          event.target = _filteredLayer;
        }

        return "break";
      }

      if (allRootLayers.includes(currentLayer)) {
        var _filteredLayer2 = filterIgnoredLayers(currentLayer, hitLayers);

        if (_filteredLayer2) {
          event.target = _filteredLayer2;
        }

        return "break";
      }

      var ancestorsList = [];
      var parent = _this4.canvas.selectedLayers[0];

      while (currentRootLayer && parent && !currentRootLayer.children.includes(parent) && parent.parent) {
        parent = parent.parent;
        ancestorsList.push(parent);
      }

      var ancestorSiblingsList = [];
      ancestorsList.forEach(function (ancestor) {
        if (ancestor.parent) {
          ancestorSiblingsList = ancestorSiblingsList.concat(ancestor.parent.children);
        }
      });

      if (union(ancestorsList, ancestorSiblingsList).includes(currentLayer)) {
        var _filteredLayer3 = filterIgnoredLayers(currentLayer, hitLayers);

        if (_filteredLayer3) {
          event.target = _filteredLayer3;
        }

        return "break";
      }

      currentLayer = currentLayer.parent; // while (currentLayer && !hitLayers.includes(currentLayer?.parent)) {
      //   currentLayer = currentLayer.parent;
      // }

      event.target = null;
    };

    while (currentLayer && currentLayer.type !== 'canvas' // !this.canvas.selectedLayers.includes(currentLayer)
    ) {
      var _ret = _loop();

      if (_ret === "break") break;
    }
  };

  _proto.setTopLayerSelectionMode = function setTopLayerSelectionMode(value) {
    this.topLayerSelectionMode = value;
  };

  _proto.deactivate = function deactivate() {
    this.canvas.removeFunction('addArtboard');
    this.canvas.removeFunction('removeArtboard');
    this.canvas.removeFunction('getArtboardById');
    this.canvas.removeFunction('getNewArtboardPosition');
    this.canvas.removeFunction('getSelectedArtboardId');
  };

  return StageDesigner;
}();

function filterIgnoredLayers(currentLayer, hitLayers) {
  if (hitLayers.includes(currentLayer)) {
    return currentLayer;
  } else if (currentLayer.style.get('pointerEvents') === 'none') {
    var topChildInHitLayers = findLast(currentLayer.children, function (child) {
      if (hitLayers.includes(child)) {
        return true;
      }

      return false;
    });

    if (topChildInHitLayers) {
      return topChildInHitLayers;
    }
  }

  return;
}

var LayerMouseCursorPlugin = /*#__PURE__*/function () {
  function LayerMouseCursorPlugin() {
    this.name = 'LayerMouseCursorPlugin';
  }

  var _proto = LayerMouseCursorPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
    this.dispose = null;
  };

  _proto.activate = function activate() {
    var _this = this;

    this.canvas.addFunction('setMouseCursor', function (context, cursor) {
      context.layer.addEventListener('mouseEnter', function (data) {
        _this.canvas.setMouseCursor(cursor);
      });
      context.layer.addEventListener('mouseLeave', function (data) {
        _this.canvas.setMouseCursor('default');
      });
    });
  };

  _proto.deactivate = function deactivate() {
    this.canvas.removeFunction('setMouseCursor');
    this.dispose();
  };

  return LayerMouseCursorPlugin;
}();

var DataStore = /*#__PURE__*/function () {
  function DataStore() {
    this.name = 'DataStore';
    this.dataMap = new Map();
  }

  var _proto = DataStore.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
  };

  _proto.activate = function activate() {
    this.canvas.addFunction('setData', this.setData.bind(this));
    this.canvas.addFunction('getData', this.getData.bind(this));
    this.canvas.addFunction('removeData', this.removeData.bind(this));
  };

  _proto.setData = function setData(context, key, value) {
    //
    var layer = context.layer;
    var layerData = this.dataMap.get(layer);

    if (layerData) {
      var _extends2;

      layerData = _extends({}, layerData, (_extends2 = {}, _extends2[key] = value, _extends2));
    } else {
      var _layerData;

      layerData = (_layerData = {}, _layerData[key] = value, _layerData);
    } // console.log(layerData, layer, 'layer data here');


    this.dataMap.set(layer, layerData);
  };

  _proto.getData = function getData(context, key) {
    var layer = context.layer;
    var layerData = this.dataMap.get(layer);

    if (layerData) {
      if (key) {
        return layerData[key];
      } else {
        return layerData;
      }
    }
  };

  _proto.removeData = function removeData(context, key) {
    var layer = context.layer;
    var layerData = this.dataMap.get(layer);

    if (key) {
      delete layerData[key];
    } else {
      this.dataMap["delete"](layer);
    }
  };

  _proto.deactivate = function deactivate() {
    this.canvas.removeFunction('setData');
    this.canvas.removeFunction('getData');
    this.canvas.removeFunction('removeData');
  };

  return DataStore;
}();

var TooltipPlugin = /*#__PURE__*/function () {
  function TooltipPlugin() {
    this.name = 'Tooltip';
  }

  var _proto = TooltipPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
    this.dispose = null;
  };

  _proto.activate = function activate() {
    var containerDiv = document.createElement('div');
    containerDiv.style.position = 'absolute';
    this.dispose = this.canvas.addDomToViewport(containerDiv);
    containerDiv.style.pointerEvents = 'none';
    containerDiv.style.padding = '.25em .4em';
    containerDiv.style.fontWeight = '700px';
    containerDiv.style.textAlign = 'center';
    containerDiv.style.flexDirection = 'row';
    containerDiv.style.alignItems = 'center';
    containerDiv.style.justifyContent = 'center';
    containerDiv.style.display = 'none';
    containerDiv.style.whiteSpace = 'nowrap';
    containerDiv.style.verticalAlign = 'middle';
    containerDiv.style.borderRadius = '2px';
    containerDiv.style.position = 'absolute';
    containerDiv.style.color = 'white';
    containerDiv.style.fontSize = '10px';
    containerDiv.style.background = '#1FB2CC';
    containerDiv.style.fontFamily = 'Roboto, -apple-system, BlinkMacSystemFont, sans-serif';
    this.canvas.addFunction(this.name + ".show", function (context, coords, text) {
      containerDiv.style.left = coords.x + "px";
      containerDiv.style.top = coords.y + "px";
      containerDiv.style.display = 'flex';

      if (containerDiv.childNodes.length) {
        containerDiv.childNodes[0].nodeValue = text;
      } else {
        containerDiv.appendChild(document.createTextNode(text));
      }
    });
    this.canvas.addFunction(this.name + ".hide", function (context) {
      containerDiv.style.display = 'none';
    });
    this.canvas.addFunction(this.name + ".setPosition", function (context, coords) {
      containerDiv.style.left = coords.x + "px";
      containerDiv.style.top = coords.y + "px";
    });
    this.canvas.addFunction(this.name + ".setText", function (context, text) {
      if (containerDiv.childNodes.length) {
        containerDiv.childNodes[0].nodeValue = text;
      } else {
        containerDiv.appendChild(document.createTextNode(text));
      }
    });
  };

  _proto.deactivate = function deactivate() {
    this.canvas.removeFunction(this.name + ".show");
    this.canvas.removeFunction(this.name + ".hide");
    this.canvas.removeFunction(this.name + ".setPosition");
    this.canvas.removeFunction(this.name + ".setText");
    this.dispose();
  };

  return TooltipPlugin;
}();

var OpacityShortcutPlugin = /*#__PURE__*/function () {
  function OpacityShortcutPlugin() {
    var _this = this;

    this.name = 'OpacityShortcut';
    this.opacity = 100;

    this.handleKeyPress = function (event) {
      var originalEvent = event.originalEvent;
      var keycode = originalEvent.keyCode || originalEvent.which;
      var newOpacity = _this.opacity;
      var isModifierKeyPressed = originalEvent.altKey || originalEvent.ctrlKey || originalEvent.metaKey || originalEvent.shiftKey;

      if (!isModifierKeyPressed && _this.canvas.selectedLayers.length > 0 && keycode >= 48 && keycode <= 57) {
        if (_this.previousEvent && originalEvent.timeStamp - _this.previousEvent.timeStamp < 1000) {
          newOpacity = _this.opacity * 10 + parseInt(originalEvent.key);

          if (newOpacity > 100) {
            var opacityInString = newOpacity.toString();
            newOpacity = parseInt(opacityInString.slice(opacityInString.length - 2, opacityInString.length));
          }

          _this.opacity = newOpacity;
        } else {
          newOpacity = parseInt(originalEvent.key) * 10;
          _this.opacity = parseInt(originalEvent.key);
        }

        _this.previousEvent = originalEvent;

        _this.canvas.selectedLayers.map(function (selectedLayer) {
          var commandParams = {
            layer: selectedLayer,
            key: 'opacity',
            value: newOpacity / 100,
            stylePropName: 'style'
          };

          _this.canvas.dispatchEvent('setStyleAttribute', new CommandEvent('setStyleAttribute', _this.canvas, commandParams));
        });
      }
    };
  }

  var _proto = OpacityShortcutPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
    this.dispose = null;
  };

  _proto.activate = function activate() {
    this.canvas.addEventListener('keyDown', this.handleKeyPress);
  };

  _proto.deactivate = function deactivate() {
    this.dispose();
  };

  return OpacityShortcutPlugin;
}();

var FontResizerEvent = /*#__PURE__*/function (_Event) {
  _inheritsLoose(FontResizerEvent, _Event);

  function FontResizerEvent(name, target, payload, currentTarget) {
    var _this;

    _this = _Event.call(this, name, target, currentTarget) || this;
    var x = payload.x,
        y = payload.y,
        fontSize = payload.fontSize;
    if (fontSize) _this.fontSize = fontSize;
    if (y) _this.y = y;
    if (x) _this.x = x;
    return _this;
  }

  return FontResizerEvent;
}(Event);

var FontResizerPlugin = /*#__PURE__*/function () {
  function FontResizerPlugin() {
    var _this = this;

    this.name = 'FontResizerPlugin';
    this.namespace = 'FontResizer';
    this.disabled = false;

    this.getHandles = function (next, layers) {
      if (layers.length === 1 && layers[0].type === 'text' && !layers[0].layout.get('height') && !layers[0].layout.get('width')) {
        var _textLayer$parent;

        var textLayer = layers[0];
        var parentDims = (_textLayer$parent = textLayer.parent) == null ? void 0 : _textLayer$parent.getBoundingClientRect();
        var textLayerDims = textLayer.getBoundingClientRect();
        var newHandle = '';

        if (parentDims) {
          var parentCenterY = parentDims.rootY + parentDims.height / 2;
          var parentCenterX = parentDims.rootX + parentDims.width / 2;
          var textLayerCenterY = textLayerDims.rootY + textLayerDims.height / 2;
          var textLayerCenterX = textLayerDims.rootX + textLayerDims.width / 2;

          if (textLayerCenterY < parentCenterY) {
            newHandle = 'B';
          } else if (textLayerCenterY > parentCenterY) {
            newHandle += 'T';
          } else {
            newHandle += '';
          }

          if (textLayerCenterX < parentCenterX) {
            newHandle += 'R';
          } else if (textLayerCenterX > parentCenterX) {
            newHandle += 'L';
          } else {
            newHandle += '';
          }

          if (textLayer.parent && _this.isInsideCenterBox(textLayerDims, parentDims)) {
            newHandle = 'B';
          }

          return [newHandle, 'ROTATE'];
        }
      } else {
        return next(layers);
      }
    };

    this.handleDragStart = function (next, data) {
      var event = data.data;
      var selectedLayer = data.selectedLayer;

      if (event.targetHandle && event.targetHandle.includes('ROTATE') || _this.disabled) {
        return next(data);
      }

      if (selectedLayer && selectedLayer.type === 'text' && !selectedLayer.layout.get('height') && !selectedLayer.layout.get('width')) {
        _this.canvas.executeFunction('Tooltip.hide');

        selectedLayer.executeFunction('setData', 'fontSize', selectedLayer.layout.get('fontSize') || 14);
        selectedLayer.executeFunction('setData', 'initialDimensions', selectedLayer.getBoundingClientRect());

        _this.canvas.executeFunction('LayerResizer.stopHandleRerender');

        _this.canvas.dispatchEvent(_this.namespace + ".dragStart", new FontResizerEvent(_this.namespace + ".dragStart", selectedLayer, {}));
      } else {
        return next(data);
      }
    };

    this.handleDrag = function (next, data) {
      var event = data.data;
      var selectedLayer = data.selectedLayer;

      if (event.targetHandle && event.targetHandle.includes('ROTATE') || _this.disabled) {
        return next(data);
      }

      if (selectedLayer && selectedLayer.type === 'text' && !selectedLayer.layout.get('height') && !selectedLayer.layout.get('width')) {
        var session = event.session,
            targetHandle = event.targetHandle;
        var deltaInput = {
          x: session.current.x - session.start.x,
          y: session.current.y - session.start.y
        };
        var currentFontSize = selectedLayer.executeFunction('getData', 'fontSize');
        var initialDims = selectedLayer.executeFunction('getData', 'initialDimensions');
        var ratioX = deltaInput.x / initialDims.width;
        var ratioY = deltaInput.y / initialDims.height;
        var newFontSize = currentFontSize;
        var newLeft = initialDims.x;
        var newTop = initialDims.y;

        if (targetHandle === 'B') {
          newFontSize += currentFontSize * ratioY;
        } else if (targetHandle === 'T') {
          newFontSize += -currentFontSize * ratioY;
        } else {
          if (targetHandle.indexOf('L') === -1) {
            newFontSize += currentFontSize * ratioX;
          } else {
            newFontSize += -currentFontSize * ratioX;
          }
        }

        if (newFontSize <= 0) {
          newFontSize *= -1;
        }

        _this.canvas.dispatchEvent(_this.namespace + ".setFontSize", new FontResizerEvent(_this.namespace + ".setFontSize", selectedLayer, {
          fontSize: Math.round(newFontSize)
        }));

        var currentDims = selectedLayer.getBoundingClientRect();
        var widthChanged = currentDims.width - initialDims.width;
        var heightChanged = currentDims.height - initialDims.height;

        if (targetHandle === 'L' || targetHandle === 'R') {
          newTop = newTop - heightChanged / 2;
        } else if (!(targetHandle.indexOf('B') !== -1)) {
          newTop = newTop - heightChanged;
        }

        if (!(targetHandle.indexOf('L') === -1)) {
          newLeft = newLeft - widthChanged;
        } else if (targetHandle === 'T' || targetHandle === 'B') {
          newLeft = newLeft - widthChanged / 2;
        }

        var positionChanged = initialDims.y !== newTop || initialDims.x !== newLeft;

        if (positionChanged) {
          _this.canvas.dispatchEvent(_this.namespace + ".setPosition", new FontResizerEvent(_this.namespace + ".setPosition", selectedLayer, {
            y: newTop,
            x: newLeft
          }));
        }

        _this.canvas.executeFunction('Tooltip.show', {
          x: event.viewportX + 20,
          y: event.viewportY + 20
        }, "" + Math.round(newFontSize));
      } else {
        return next(data);
      }
    };

    this.handleDragEnd = function (next, data) {
      var event = data.data;
      var selectedLayer = data.selectedLayer;

      if (event.targetHandle && event.targetHandle.includes('ROTATE') || _this.disabled) {
        return next(data);
      }

      if (selectedLayer && selectedLayer.type === 'text' && !selectedLayer.layout.get('height') && !selectedLayer.layout.get('width')) {
        _this.canvas.executeFunction('Tooltip.hide');

        selectedLayer.executeFunction('setData', 'fontSize', selectedLayer.layout.get('fontSize') || 14);
        selectedLayer.executeFunction('setData', 'initialDimensions', selectedLayer.getBoundingClientRect());

        _this.canvas.executeFunction('LayerResizer.startHandleRerender');

        _this.canvas.dispatchEvent(_this.namespace + ".dragEnd", new FontResizerEvent(_this.namespace + ".dragEnd", selectedLayer, {}));
      } else {
        return next(data);
      }
    };
  }

  var _proto = FontResizerPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
  };

  _proto.activate = function activate() {
    this.canvas.addMiddleware("LayerResizer.handleDragStart", this.handleDragStart);
    this.canvas.addMiddleware("LayerResizer.handleDrag", this.handleDrag);
    this.canvas.addMiddleware("LayerResizer.handleDragEnd", this.handleDragEnd);
    this.canvas.addMiddleware("LayerResizer.getHandles", this.getHandles);
    this.canvas.addFunction(this.namespace + ".disable", this.disableDrag.bind(this));
  };

  _proto.disableDrag = function disableDrag() {
    this.disabled = true;
  };

  _proto.isInsideCenterBox = function isInsideCenterBox(layerDims, parentDims) {
    var parentBoundaries = {
      left: parentDims.rootX + parentDims.width / 5,
      right: parentDims.rootX + parentDims.width * 4 / 5,
      top: parentDims.rootY + parentDims.height / 10,
      bottom: parentDims.rootY + parentDims.height * 9 / 10
    };
    var layerCenterY = layerDims.rootY + layerDims.height / 2;
    var layerCenterX = layerDims.rootX + layerDims.width / 2;
    return layerCenterX > parentBoundaries.left && layerCenterX < parentBoundaries.right && layerCenterY > parentBoundaries.top && layerCenterY < parentBoundaries.bottom;
  };

  _proto.deactivate = function deactivate() {};

  return FontResizerPlugin;
}();

var transitionStyle = /*#__PURE__*/document.createElement('style');
transitionStyle.innerHTML = "\n #transition {\n   transition: top 0.2s ease-in 0s, left 0.2s ease-in 0s, right 0.2s ease-in 0s,\n     bottom 0.2s ease-in 0s;\n }";

var FlexDragPlugin = /*#__PURE__*/function () {
  function FlexDragPlugin() {
    var _this = this;

    this.name = 'FlexDragPlugin';
    this.namespace = 'FlexDrag';
    this.disabled = false;
    this.layerOpacities = new Map();
    this.previousTriggerPoint = null;
    this.nextTriggerPoint = null;
    this.target = [];
    this.flexLayers = [];
    this.totalDx = 0;
    this.totalDy = 0;
    this.initialSnapshotData = new Map();
    this.beforeDragSnapshotData = new Map();
    this.currentSnapshotData = new Map();
    this.isFlex = false;
    this.layersHeightWidth = new Map();

    this.saveLayersHeightWidth = function (layer) {
      if (!_this.layersHeightWidth.get(layer)) {
        _this.layersHeightWidth.set(layer, {
          height: layer.layout.get('height'),
          width: layer.layout.get('width')
        });
      }
    };

    this.clearFlexLayersHeightWidth = function () {
      _this.layersHeightWidth.clear();
    };

    this.saveSiblingOpacity = function (parentLayer) {
      forEach(parentLayer.children, function (layer) {
        if (layer.isFlexChild()) {
          var opacity = !isNil(layer.style.get('opacity')) ? layer.style.get('opacity') : 1;

          _this.layerOpacities.set(layer, opacity);

          layer.setStyle('opacity', 0.3);
        }
      });
    };

    this.revertSiblingOpacity = function () {
      _this.layerOpacities.forEach(function (opacity, layer) {
        layer.setStyle('opacity', _this.layerOpacities.get(layer));
      });

      _this.layerOpacities.clear();
    };

    this.layerResizerDrag = function (next, event) {
      if (_this.disabled) return;

      if (event.selectedLayers.length === 0) {
        return;
      }

      if (!_this.isFlex) {
        return next(event);
      }
    };

    this.layerResizerDragEnd = function (next, event) {
      if (_this.disabled) return;

      if (event.selectedLayers.length === 0) {
        return;
      }

      _this.revertParentDims();

      _this.canvas.dispatchEvent(_this.namespace + ".dragEnd", new Event(_this.namespace + ".dragEnd", _this.canvas));

      if (!_this.isFlex) {
        return next(event);
      }
    };

    this.revertParentDims = function () {
      if (_this.initialParentData) {
        var layer = _this.initialParentData.layer;
        var dims = _this.initialParentData.dims;

        if (layer.isAutoHeight() || layer.isAutoWidth()) {
          layer.removeLayout(['position', 'top', 'left', 'right', 'bottom']);

          if (!dims.hasOwnProperty('height')) {
            layer.removeLayout('height');
          }

          if (!dims.hasOwnProperty('width')) {
            layer.removeLayout('width');
          }

          layer.setLayout(dims);
          _this.initialParentData = undefined;
        }
      }
    };

    this.changeParentDims = function (layer) {
      if (!_this.initialParentData && (layer.isAutoHeight() || layer.isAutoWidth())) {
        _this.initialParentData = {
          layer: layer,
          dims: layer.layout.getAll()
        };

        var dims = _this.getMarginAdjustedBounds(layer);

        layer.setLayout({
          position: 'absolute',
          left: dims.x,
          top: dims.y,
          width: dims.width,
          height: dims.height
        });
      }
    };
    /*
      ---> This is used to differentiate between both in the code wherever required:
      - Event from layerResizer is of type {data:Event,selectedLayers:current selected layers}
      - Event from layer drag is directly Event
      ---> On each drag start a ghost layer is created and everything else is handeled on that
           ghost layer only.
    */


    this.setFlexLayers = function () {
      var parent;

      if (_this.target instanceof Layer) {
        parent = _this.target.parent;
      } else {
        parent = _this.target[0].parent;
      }

      if (parent) {
        _this.flexLayers = [];
        forEach(parent.children, function (layer) {
          document.body.appendChild(transitionStyle);

          if (layer.isFlexChild()) {
            layer.setProp('id', 'transition');

            _this.saveLayersHeightWidth(layer);

            _this.flexLayers.push(layer);
          } else {
            _this.flexLayers.push(undefined);
          }
        });
      }
    };

    this.createGhostLayer = function (layout, parent) {
      var dims = {
        width: layout.width,
        height: layout.height,
        left: layout.x,
        top: layout.y,
        position: 'absolute'
      };

      if (_this.target instanceof Layer) {
        _this.ghostLayer = _this.canvas.createLayer();
        parent.addChild(_this.ghostLayer);

        _this.ghostLayer.setLayout(dims);

        _this.ghostLayer.executeFunction('Hover.hideLayer');

        _this.target.setStyle('opacity', _this.layerOpacities.get(_this.target));

        var layerStyles = _extends({}, _this.target.style.getAll());

        _this.ghostLayer.setStyle(_extends({}, layerStyles, {
          opacity: 0
        }));
      } else {
        var wrapperLayer = _this.canvas.createLayer();

        parent.addChild(wrapperLayer);
        wrapperLayer.setLayout(dims);
        wrapperLayer.executeFunction('Hover.hideLayer');

        _this.target.forEach(function (layer) {
          var copyLayer = _this.canvas.createLayer();

          wrapperLayer.addChild(copyLayer);

          var layerDims = _this.getMarginAdjustedBounds(layer);

          var layerStyles = _extends({}, layer.style.getAll());

          layer.setStyle('opacity', _this.layerOpacities.get(layer));

          var wrapperLayerDims = _this.getMarginAdjustedBounds(wrapperLayer);

          copyLayer.setLayout({
            left: layerDims.x - wrapperLayerDims.x,
            top: layerDims.y - wrapperLayerDims.y,
            width: layerDims.width,
            height: layerDims.height,
            position: 'absolute'
          });
          copyLayer.setStyle(_extends({}, layerStyles, {
            opacity: 0
          }));
        });

        _this.ghostLayer = wrapperLayer;
      }
    };

    this.startGhostDragging = function (event) {
      document.addEventListener('mousemove', _this.ghostMove);
      document.addEventListener('mouseup', _this.ghostMouseUp);
      document.addEventListener('contextmenu', _this.ghostMouseUp);

      _this.canvas.setDragging(true);

      var mouseDownEvent = new DesignerMouseEvent('mousedown', _this.canvas, event.originalEvent, _this.canvas);

      _this.canvas.dispatchEventOnHitLayer('mousedown', mouseDownEvent);
    };

    this.ghostMove = function (e) {
      _this.canvas.handleNativeEvent(e);
    };

    this.ghostMouseUp = function (e) {
      document.removeEventListener('mousemove', _this.ghostMove);
      document.removeEventListener('mouseup', _this.ghostMouseUp);
      document.removeEventListener('contextmenu', _this.ghostMouseUp);

      _this.canvas.handleNativeEvent(e);

      _this.canvas.setDragging(false);
    };

    this.getMarginAdjustedBounds = function (layer) {
      var initialBounds = layer.getBoundingClientRect();
      return _extends({}, initialBounds, {
        x: initialBounds.x - layer.getMarginLeft(),
        y: initialBounds.y - layer.getMarginTop()
      });
    };

    this.endFlexLayerDragging = function (event) {
      var mouseUpEvent = new DesignerMouseEvent('mouseup', _this.canvas, event.originalEvent, _this.canvas);

      _this.canvas.dispatchEventOnHitLayer('mouseup', mouseUpEvent);
    };

    this.recordCurrentSnapshot = function (parent) {
      _this.currentSnapshotData.clear();

      parent.children.forEach(function (child, index) {
        if (child !== _this.ghostLayer) _this.currentSnapshotData.set(child, {
          index: index,
          dims: cloneDeep(_this.getMarginAdjustedBounds(child))
        });
      });
    };

    this.changeToAbsolute = function (parent) {
      parent.children.forEach(function (sibling) {
        if (sibling !== _this.ghostLayer) {
          var siblingDims = _this.getMarginAdjustedBounds(sibling);

          sibling.setLayout({
            position: 'absolute',
            left: siblingDims.x,
            top: siblingDims.y,
            width: siblingDims.width,
            height: siblingDims.height
          });
        }
      });
    };

    this.revertBackToSnapshot = function (parent, snapshotData) {
      snapshotData.forEach(function (value, layer) {
        if (layer.getIndexInParent() !== value.index) layer.move(parent, value.index);

        if (_this.flexLayers.includes(layer)) {
          layer.removeLayout(['position', 'top', 'left', 'right', 'bottom']);
        }

        var originalHW = _this.layersHeightWidth.get(layer);

        if (_this.flexLayers.includes(layer) && originalHW) {
          if (!originalHW.height && !isNil(layer.layout.get('height'))) layer.removeLayout('height');
          if (!originalHW.width && !isNil(layer.layout.get('width'))) layer.removeLayout('width');
        }
      });
    };

    this.findAbsolutePreviousLayer = function (index) {
      var previousLayer = undefined;
      var prevLayerIndex = index - 1;

      while (isNil(previousLayer) && prevLayerIndex >= 0) {
        if (_this.flexLayers[prevLayerIndex]) {
          previousLayer = _this.flexLayers[prevLayerIndex];
        }

        prevLayerIndex--;
      }

      return previousLayer;
    };

    this.findPreviousLayer = function (index) {
      if (_this.flexDirection && _this.flexDirection.includes('reverse')) {
        return _this.findAbsoluteNextLayer(index);
      }

      return _this.findAbsolutePreviousLayer(index);
    };

    this.findAbsoluteNextLayer = function (index) {
      var nextLayer = undefined;
      var nextLayerIndex = index + 1;

      while (isNil(nextLayer) && nextLayerIndex < _this.flexLayers.length) {
        if (_this.flexLayers[nextLayerIndex]) {
          nextLayer = _this.flexLayers[nextLayerIndex];
        }

        nextLayerIndex++;
      }

      return nextLayer;
    };

    this.findNextLayer = function (index) {
      if (_this.flexDirection && _this.flexDirection.includes('reverse')) {
        return _this.findAbsolutePreviousLayer(index);
      }

      return _this.findAbsoluteNextLayer(index);
    };

    this.setTriggerPoints = function () {
      _this.previousTriggerPoint = null;
      _this.nextTriggerPoint = null;

      if (_this.target instanceof Layer) {
        var targetIndexInParent = indexOf(_this.flexLayers, _this.target);

        if (targetIndexInParent !== -1) {
          var previousLayer = _this.findPreviousLayer(targetIndexInParent);

          var nextLayer = _this.findNextLayer(targetIndexInParent);

          var currentTargetDims = _this.getMarginAdjustedBounds(_this.target);

          if (previousLayer) {
            var previousLayerDims = _this.getMarginAdjustedBounds(previousLayer);

            _this.previousTriggerPoint = _this.calculateTriggerPoint(previousLayerDims, currentTargetDims);
          }

          if (nextLayer) {
            var nextLayerDims = _this.getMarginAdjustedBounds(nextLayer);

            _this.nextTriggerPoint = _this.calculateTriggerPoint(currentTargetDims, nextLayerDims);
          }
        }
      } else {
        var sortedSelectedLayers = sortBy(_this.target, function (layer) {
          return layer.getIndexInParent();
        });
        var firstSelectedLayerIndex = indexOf(_this.flexLayers, sortedSelectedLayers[0]);
        var lastSelectedLayerIndex = indexOf(_this.flexLayers, sortedSelectedLayers[sortedSelectedLayers.length - 1]);

        if (firstSelectedLayerIndex !== -1 && lastSelectedLayerIndex !== -1) {
          var _previousLayer = _this.findPreviousLayer(firstSelectedLayerIndex);

          var _nextLayer = _this.findNextLayer(lastSelectedLayerIndex);

          var boundingBoxDims = _this.canvas.getBoundingBox(sortedSelectedLayers);

          var parentDims = sortedSelectedLayers.length && sortedSelectedLayers[0].parent ? _this.getMarginAdjustedBounds(sortedSelectedLayers[0].parent) : undefined;

          if (parentDims) {
            var boundingBoxDimsWRTParent = _extends({}, boundingBoxDims, {
              x: boundingBoxDims.x - parentDims.rootX,
              y: boundingBoxDims.y - parentDims.rootY
            });

            if (_previousLayer) {
              var _previousLayerDims = _this.getMarginAdjustedBounds(_previousLayer);

              _this.previousTriggerPoint = _this.calculateTriggerPoint(_previousLayerDims, boundingBoxDimsWRTParent);
            }

            if (_nextLayer) {
              var _nextLayerDims = _this.getMarginAdjustedBounds(_nextLayer);

              _this.nextTriggerPoint = _this.calculateTriggerPoint(boundingBoxDimsWRTParent, _nextLayerDims);
            }
          }
        }
      }
    };

    this.calculateTriggerPoint = function (previousLayerDims, nextLayerDims) {
      if (_this.flexDirection === 'row' || _this.flexDirection === 'row-reverse') {
        return (previousLayerDims.x + nextLayerDims.x + nextLayerDims.width) / 2;
      } else {
        return (nextLayerDims.y + nextLayerDims.height + previousLayerDims.y) / 2;
      }
    };

    this.handleSwapWRTNewPosition = function (oldCenter, newCenter) {
      var crossedPreviousTriggerPoint = _this.previousTriggerPoint && oldCenter > _this.previousTriggerPoint && newCenter < _this.previousTriggerPoint;
      var crossedNextTriggerPoint = _this.nextTriggerPoint && oldCenter < _this.nextTriggerPoint && newCenter > _this.nextTriggerPoint;
      var targetLayerIndex;
      var newIndex;
      var toMoveLayer;

      if (_this.target instanceof Layer) {
        targetLayerIndex = indexOf(_this.flexLayers, _this.target);
        newIndex = targetLayerIndex;
        toMoveLayer = crossedPreviousTriggerPoint ? _this.findPreviousLayer(targetLayerIndex) : crossedNextTriggerPoint ? _this.findNextLayer(targetLayerIndex) : null;
        if (toMoveLayer) _this.newTargetIndex = indexOf(_this.flexLayers, toMoveLayer);
      } else {
        var sortedSelectedLayers = sortBy(_this.target, function (layer) {
          return layer.getIndexInParent();
        });
        var firstSelectedLayerIndex = indexOf(_this.flexLayers, sortedSelectedLayers[0]);
        var lastSelectedLayerIndex = indexOf(_this.flexLayers, sortedSelectedLayers[sortedSelectedLayers.length - 1]);

        if (crossedPreviousTriggerPoint) {
          newIndex = lastSelectedLayerIndex;
          toMoveLayer = _this.findPreviousLayer(firstSelectedLayerIndex);
          if (toMoveLayer) _this.newTargetIndex = indexOf(_this.flexLayers, toMoveLayer);
        } else if (crossedNextTriggerPoint) {
          newIndex = firstSelectedLayerIndex;
          toMoveLayer = _this.findNextLayer(lastSelectedLayerIndex);
          if (toMoveLayer) _this.newTargetIndex = indexOf(_this.flexLayers, toMoveLayer);
        }
      }

      if (!isNil(newIndex) && newIndex >= 0 && toMoveLayer) {
        _this.internalMove(toMoveLayer, newIndex);
      }
    };

    this.internalMove = function (targetLayer, newIndex) {
      var parent = targetLayer.parent;

      if (parent) {
        _this.revertBackToSnapshot(parent, _this.currentSnapshotData);

        targetLayer.move(parent, newIndex);
        var newPositionData = new Map();
        parent.children.forEach(function (child) {
          if (child !== _this.ghostLayer) {
            newPositionData.set(child, _this.getMarginAdjustedBounds(child));
          }
        });

        _this.recordCurrentSnapshot(parent);

        _this.setFlexLayers();

        _this.setTriggerPoints();

        _this.revertBackToSnapshot(parent, _this.beforeDragSnapshotData);

        _this.changeToAbsolute(parent);

        parent.children.forEach(function (child) {
          var newChildLayout = newPositionData.get(child);

          if (child !== _this.ghostLayer && newChildLayout) {
            child.setLayout({
              left: newChildLayout.x,
              top: newChildLayout.y
            });
          }
        });
      }
    };

    this.layerDragStart = function (next, event) {
      if (_this.disabled) return;
      _this.totalDx = 0;
      _this.totalDy = 0;

      _this.canvas.dispatchEvent(_this.namespace + ".dragStart", new Event(_this.namespace + ".dragStart", _this.canvas));

      if (event.selectedLayers) {
        var isFlex = event.selectedLayers.every(function (layer) {
          return layer.isFlexChild();
        });
        _this.isFlex = isFlex;

        if (!isFlex) {
          return next(event);
        }

        _this.target = event.selectedLayers;
        var parent = get(event.selectedLayers, '[0].parent');

        var boundingBoxDims = _this.canvas.getBoundingBox(event.selectedLayers);

        if (parent) {
          var parentDims = _this.getMarginAdjustedBounds(parent);

          _this.saveSiblingOpacity(parent);

          var boundingBoxDimsWRTParent = _extends({}, boundingBoxDims, {
            x: boundingBoxDims.x - parentDims.rootX,
            y: boundingBoxDims.y - parentDims.rootY
          });

          _this.targetInitialDims = boundingBoxDimsWRTParent;
          _this.flexDirection = parent.layout.get('flexDirection');

          _this.setFlexLayers();

          _this.recordCurrentSnapshot(parent);

          _this.initialSnapshotData = new Map(_this.currentSnapshotData);
          _this.beforeDragSnapshotData = new Map(_this.currentSnapshotData);

          _this.endFlexLayerDragging(event.data);

          _this.createGhostLayer(_this.targetInitialDims, parent);

          _this.startGhostDragging(event.data);

          _this.changeParentDims(parent);

          _this.changeToAbsolute(parent);

          _this.setTriggerPoints();
        }
      } else {
        if (!event || !(event && event.target)) {
          return next(event);
        }

        var _isFlex = event.target ? event.target.isFlexChild() : false;

        _this.isFlex = _isFlex;

        if (event.target === _this.ghostLayer) {
          _this.targetGhostLayer = event.target;
        }

        if (!_isFlex) {
          return next(event);
        }

        _this.target = event.target;
        _this.targetInitialDims = _this.getMarginAdjustedBounds(event.target);
        var _parent = event.target.parent;

        if (_parent) {
          _this.saveSiblingOpacity(_parent);

          _this.flexDirection = _parent.layout.get('flexDirection');

          _this.setFlexLayers();

          _this.recordCurrentSnapshot(_parent);

          _this.initialSnapshotData = new Map(_this.currentSnapshotData);
          _this.beforeDragSnapshotData = new Map(_this.currentSnapshotData);

          _this.endFlexLayerDragging(event);

          _this.createGhostLayer(_this.targetInitialDims, _parent);

          _this.startGhostDragging(event);

          _this.changeParentDims(_parent);

          _this.changeToAbsolute(_parent);

          _this.setTriggerPoints();
        }
      }
    };

    this.layerDrag = function (next, event) {
      if (_this.disabled) return; // if (!this.isFlex) {
      //   return next(event);
      // }

      _this.canvas.dispatchEvent(_this.namespace + ".drag", new Event(_this.namespace + ".drag", _this.canvas));

      if (_this.targetGhostLayer) {
        _this.canvas.selectLayers([]);

        _this.totalDx += event.worldDx;
        _this.totalDy += event.worldDy;
        var targetNewDims;

        if (_this.target instanceof Layer) {
          targetNewDims = _this.getMarginAdjustedBounds(_this.target);
        } else {
          var boundingBoxDims = _this.canvas.getBoundingBox(_this.target);

          var parentDims = _this.target[0].parent ? _this.getMarginAdjustedBounds(_this.target[0].parent) : undefined;

          if (parentDims) {
            targetNewDims = _extends({}, boundingBoxDims, {
              x: boundingBoxDims.x - parentDims.rootX,
              y: boundingBoxDims.y - parentDims.rootY
            });
          } else {
            targetNewDims = boundingBoxDims;
          }
        }

        var newLeft = _this.targetInitialDims.x + _this.totalDx;
        var newTop = _this.targetInitialDims.y + _this.totalDy;

        _this.ghostLayer.setLayout({
          left: newLeft,
          top: newTop
        });

        var oldCenterTargetLayer = null;
        var newCenterTargetLayer = null;

        if (_this.flexDirection === 'row' || _this.flexDirection === 'row-reverse') {
          oldCenterTargetLayer = targetNewDims.x + targetNewDims.width / 2;
          newCenterTargetLayer = newLeft + _this.targetInitialDims.width / 2;
        } else {
          oldCenterTargetLayer = targetNewDims.y + targetNewDims.height / 2;
          newCenterTargetLayer = newTop + _this.targetInitialDims.height / 2;
        }

        _this.handleSwapWRTNewPosition(oldCenterTargetLayer, newCenterTargetLayer);
      } else {
        next(event);
      }
    };

    this.layerDragEnd = function (next, event) {
      if (_this.disabled) return;

      if (_this.targetGhostLayer) {
        _this.isFlex = false;
        var parent = _this.targetGhostLayer.parent;

        _this.revertSiblingOpacity();

        if (parent) {
          while (_this.ghostLayer.children.length !== 0) {
            _this.ghostLayer.removeChild(_this.ghostLayer.children[0]);
          }

          parent.removeChild(_this.ghostLayer);
          delete _this.ghostLayer;

          _this.revertBackToSnapshot(parent, _this.beforeDragSnapshotData);
        }

        document.body.removeChild(transitionStyle);
        delete _this.targetGhostLayer;

        if (_this.target instanceof Layer) {
          var _this$target$parent;

          if (!isNil(_this.newTargetIndex) && _this.target.getIndexInParent() !== _this.newTargetIndex) {
            _this.canvas.dispatchEvent('moveLayer', new CommandEvent('moveLayer', _this.canvas, {
              fromParent: _this.target.parent,
              toParent: _this.target.parent,
              fromIndex: _this.target.getIndexInParent(),
              toIndex: _this.newTargetIndex
            }));
          }

          (_this$target$parent = _this.target.parent) == null ? void 0 : _this$target$parent.children.forEach(function (sibling) {
            sibling.setProp('id', undefined);
          });
        } else {
          var _this$target$0$parent;

          var sortedSelectedLayers = sortBy(_this.target, function (layer) {
            return layer.getIndexInParent();
          });

          if (!isNil(_this.newTargetIndex) && sortedSelectedLayers[0].getIndexInParent() > _this.newTargetIndex) {
            sortedSelectedLayers = sortedSelectedLayers.reverse();
          }

          var newToSelectLayers = [];

          if (!isNil(_this.newTargetIndex) && sortedSelectedLayers[0].getIndexInParent() !== _this.newTargetIndex) {
            sortedSelectedLayers.forEach(function (layer) {
              var parent = layer.parent;

              _this.canvas.dispatchEvent('moveLayer', new CommandEvent('moveLayer', _this.canvas, {
                fromParent: parent,
                toParent: parent,
                fromIndex: layer.getIndexInParent(),
                toIndex: _this.newTargetIndex
              }));

              if (parent && !isNil(_this.newTargetIndex)) newToSelectLayers.push(parent.children[_this.newTargetIndex]);
            });
          }

          if (newToSelectLayers.length) _this.canvas.selectLayers(newToSelectLayers);else _this.canvas.selectLayers(_this.target);
          (_this$target$0$parent = _this.target[0].parent) == null ? void 0 : _this$target$0$parent.children.forEach(function (sibling) {
            sibling.setProp('id', undefined);
          });
        }

        _this.clearFlexLayersHeightWidth();

        _this.revertParentDims();

        delete _this.newTargetIndex;

        _this.canvas.dispatchEvent(_this.namespace + ".dragEnd", new Event(_this.namespace + ".dragEnd", _this.canvas));
      } else {
        return next(event);
      }
    };
  }

  var _proto = FlexDragPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
  };

  _proto.activate = function activate() {
    var _this2 = this;

    this.canvas.addMiddleware("LayerDrag.dragStart", this.layerDragStart);
    this.canvas.addMiddleware("LayerDrag.drag", this.layerDrag);
    this.canvas.addMiddleware("LayerDrag.dragEnd", this.layerDragEnd);
    this.canvas.addMiddleware("LayerResizer.dragStart", this.layerDragStart);
    this.canvas.addMiddleware("LayerResizer.drag", this.layerResizerDrag);
    this.canvas.addMiddleware("LayerResizer.dragEnd", this.layerResizerDragEnd);
    this.canvas.addFunction(this.namespace + ".disable", function () {
      _this2.disabled = true;
    });
  };

  _proto.deactivate = function deactivate() {};

  return FlexDragPlugin;
}();

var Ruler = /*#__PURE__*/function (_React$PureComponent) {
  _inheritsLoose(Ruler, _React$PureComponent);

  function Ruler() {
    var _this;

    _this = _React$PureComponent.apply(this, arguments) || this;

    _this.handleResize = function (render) {
      var height = _this.props.height;
      var width = _this.props.width;
      _this.domWidth = width;
      _this.domHeight = height;
      _this.width = width * _this.props.ratio;
      _this.height = height * _this.props.ratio;
      _this.ruler.width = _this.width;
      _this.ruler.height = _this.height;

      var ctx = _this.ruler.getContext('2d');

      ctx.font = 12 * _this.props.ratio + "px Roboto, -apple-system, \".SFNSText-Regular\",\n      \"SF UI Text\", \"Helvetica Neue\", Arial, \"PingFang SC\",\n      \"Hiragino Sans GB\", \"Microsoft YaHei\", \"WenQuanYi Zen Hei\", sans-serif";
      ctx.lineWidth = _this.props.ratio;
      ctx.strokeStyle = '#6F727D';
      ctx.textBaseline = 'middle';
      _this.ctx = ctx;
      var start = _this.props.start;

      if (render) {
        _this.drawRuler(start, ctx);
      }
    };

    return _this;
  }

  var _proto = Ruler.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.handleResize(true);
    window.addEventListener('resize', this.handleResize);
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    this.handleResize(true);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    window.removeEventListener('resize', this.handleResize);
  };

  _proto.drawRuler = function drawRuler(start, select) {// console.log('*** drawRuler');
  };

  _proto.render = function render() {
    var _this2 = this;

    return createElement("canvas", {
      style: {
        pointerEvents: 'none'
      },
      className: "ruler",
      ref: function ref(_ref) {
        return _this2.ruler = _ref;
      }
    });
  };

  return Ruler;
}(PureComponent);

var HorizontalRuler = /*#__PURE__*/function (_Ruler) {
  _inheritsLoose(HorizontalRuler, _Ruler);

  function HorizontalRuler() {
    return _Ruler.apply(this, arguments) || this;
  }

  var _proto = HorizontalRuler.prototype;

  _proto.drawRuler = function drawRuler(start, ctx) {
    var _this$props = this.props,
        fontColor = _this$props.fontColor,
        bgColor = _this$props.bgColor,
        fontScale = _this$props.fontScale,
        width = _this$props.width,
        height = _this$props.height,
        ratio = _this$props.ratio,
        perWidth = _this$props.perWidth,
        scale = _this$props.scale,
        zoom = _this$props.zoom;
    ctx.fillStyle = bgColor;
    ctx.fillRect(0, 0, width, height);
    ctx.translate(-start * ratio, 0);
    ctx.beginPath();
    ctx.fillStyle = fontColor;
    var startX = start - start % perWidth;

    for (var i = startX; i < startX + width / ratio; i += perWidth) {
      var tempX = ((i >> 0) + 0.5) * ratio;
      ctx.lineWidth = 0.5;
      ctx.moveTo(tempX, height);
      var text = i / zoom;
      text = Math.round(text / scale) * scale;

      if (text % (scale * 10) === 0) {
        ctx.save();
        ctx.translate((i + 2) * ratio, 0);
        ctx.scale(fontScale, fontScale);
        ctx.fillText(text, 2 * ratio, height / 2);
        ctx.restore();
        ctx.lineTo(tempX, 0);
      } else if (text % (scale * 5) === 0) {
        ctx.lineTo(tempX, height / 2);
      } else {
        ctx.lineTo(tempX, height * 2 / 3);
      }

      ctx.stroke();
    }

    ctx.closePath();
    ctx.translate(start * ratio, 0);
  };

  return HorizontalRuler;
}(Ruler);

var VerticalRuler = /*#__PURE__*/function (_Ruler) {
  _inheritsLoose(VerticalRuler, _Ruler);

  function VerticalRuler(props) {
    var _this;

    _this = _Ruler.call(this, props) || this;
    _this.vertical = true;
    return _this;
  }

  var _proto = VerticalRuler.prototype;

  _proto.drawRuler = function drawRuler(start, ctx) {
    var _this$props = this.props,
        fontColor = _this$props.fontColor,
        bgColor = _this$props.bgColor,
        fontScale = _this$props.fontScale,
        width = _this$props.width,
        height = _this$props.height,
        ratio = _this$props.ratio,
        perWidth = _this$props.perWidth,
        scale = _this$props.scale,
        zoom = _this$props.zoom;
    ctx.fillStyle = bgColor;
    ctx.fillRect(0, 0, width, height);
    ctx.translate(0, -start * ratio);
    ctx.beginPath();
    ctx.fillStyle = fontColor;
    var perHeight = perWidth;
    var startY = start - start % perHeight;

    for (var i = startY; i < startY + height / ratio; i += perHeight) {
      var tempY = ((i >> 0) + 0.5) * ratio;
      var text = i / zoom;
      text = Math.round(text / scale) * scale;
      ctx.moveTo(width, tempY);

      if (text % (scale * 10) === 0) {
        ctx.save();
        ctx.translate(width, (i - 2) * ratio);
        ctx.rotate(-Math.PI / 2);
        ctx.scale(fontScale, fontScale);
        ctx.fillText(text, 2 * ratio, -width / 3 * 2);
        ctx.restore();
        ctx.lineTo(0, tempY);
      } else if (text % (scale * 5) === 0) {
        ctx.lineTo(width / 2, tempY);
      } else {
        ctx.lineTo(width * 2 / 3, tempY);
      }

      ctx.stroke();
    }

    ctx.closePath();
    ctx.translate(0, start * ratio);
  };

  return VerticalRuler;
}(Ruler);

var RulerScaleWrapper = /*#__PURE__*/function (_React$PureComponent) {
  _inheritsLoose(RulerScaleWrapper, _React$PureComponent);

  function RulerScaleWrapper() {
    return _React$PureComponent.apply(this, arguments) || this;
  }

  var _proto = RulerScaleWrapper.prototype;

  // TODO: move it to somewhere else
  _proto.getPixelRatio = function getPixelRatio() {
    var context = document.createElement('canvas').getContext('2d');
    var backingStore = 1;

    if (context) {
      backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
    }

    return (window.devicePixelRatio || 1) / backingStore;
  };

  _proto.render = function render() {
    var _this$props = this.props,
        horLineArr = _this$props.horLineArr,
        verLineArr = _this$props.verLineArr,
        shadow = _this$props.shadow;
    var canvas = this.props.canvas;
    var x = shadow.x,
        y = shadow.y,
        width = shadow.width,
        height = shadow.height;
    var props = {
      perWidth: this.props.perWidth,
      scale: this.props.scale,
      zoom: this.props.zoom,
      fontScale: 0.83,
      ratio: 1,
      bgColor: this.props.bgColor,
      fgColor: this.props.fgColor,
      fontColor: this.props.fontColor,
      shadowColor: this.props.shadowColor
    };
    return createElement("div", null, createElement("div", {
      className: "hor-ruler",
      onContextMenu: this.props.onContextMenu,
      style: {
        cursor: 'row-resize',
        pointerEvents: 'auto'
      },
      draggable: true,
      onDragStart: this.props.onDragStartHorizontal,
      onDrag: this.props.onDragHorizontal,
      onDragEnd: this.props.onDragEndHorizontal
    }, createElement(HorizontalRuler, Object.assign({
      start: -this.props.initialPoint.x,
      lines: horLineArr,
      select: {
        x: x,
        width: width
      },
      height: 20,
      width: canvas.getViewport().width
    }, props))), createElement("div", {
      className: "ver-ruler",
      style: {
        position: 'absolute',
        marginTop: -24,
        cursor: 'col-resize',
        pointerEvents: 'auto'
      },
      draggable: true,
      onDragStart: this.props.onDragStartVertical,
      onDrag: this.props.onDragVertical,
      onDragEnd: this.props.onDragEndVertical,
      onContextMenu: this.props.onContextMenu
    }, createElement(VerticalRuler, Object.assign({
      start: -this.props.initialPoint.y,
      lines: verLineArr,
      select: {
        y: y,
        height: height
      },
      height: canvas.getViewport().height,
      width: 20
    }, props))));
  };

  return RulerScaleWrapper;
}(PureComponent);

var RulerScalePlugin = /*#__PURE__*/function () {
  function RulerScalePlugin() {
    var _this = this;

    this.name = 'RulerScalePlugin';
    this.initialPoint = {
      x: 0,
      y: 0
    };

    this.onDragStartHorizontal = function (e) {
      _this.handleGhostImage(e);

      var dims = {
        x: 0,
        y: 19,
        height: 1,
        width: 1000,
        rotation: 0
      };

      _this.canvas.executeFunction('HtmlDragToWorld.dragStart', e, dims);

      _this.selectedLineIndex = _this.canvas.executeFunction('RulerLines.addLine', 'x', 19);
    };

    this.onDragEndHorizontal = function (e) {
      _this.disposeGhostImage();

      e.preventDefault();

      var dragVal = _this.canvas.executeFunction('HtmlDragToWorld.dragEnd', e);

      _this.canvas.executeFunction('RulerLines.setPosition', dragVal.session.current.y, _this.selectedLineIndex);

      _this.selectedLineIndex = undefined;
    };

    this.onDragHorizontal = function (e) {
      if (e.pageX && e.pageY) {
        var dragVal = _this.canvas.executeFunction('HtmlDragToWorld.drag', e);

        if (dragVal.session.current.deltaX !== 0 || dragVal.session.current.deltaY !== 0) {
          if (dragVal.session.current.y > 18) {
            _this.canvas.executeFunction('RulerLines.setPosition', dragVal.session.current.y, _this.selectedLineIndex);
          }
        }
      }
    };

    this.onDragStartVertical = function (e) {
      _this.handleGhostImage(e);

      var dims = {
        x: 19,
        y: 0,
        height: 1000,
        width: 1,
        rotation: 0
      };

      _this.canvas.executeFunction('HtmlDragToWorld.dragStart', e, dims);

      _this.selectedLineIndex = _this.canvas.executeFunction('RulerLines.addLine', 'y', 19);
    };

    this.onDragEndVertical = function (e) {
      _this.disposeGhostImage();

      e.preventDefault();

      var dragVal = _this.canvas.executeFunction('HtmlDragToWorld.dragEnd', e);

      _this.canvas.executeFunction('RulerLines.setPosition', dragVal.session.current.x, _this.selectedLineIndex);

      _this.selectedLineIndex = undefined;
    };

    this.onDragVertical = function (e) {
      if (e.pageX && e.pageY) {
        var dragVal = _this.canvas.executeFunction('HtmlDragToWorld.drag', e);

        if (dragVal.session.current.deltaX !== 0 || dragVal.session.current.deltaY !== 0) {
          if (dragVal.session.current.x > 18) {
            _this.canvas.executeFunction('RulerLines.setPosition', dragVal.session.current.x, _this.selectedLineIndex);
          }
        }
      }
    };
  }

  var _proto = RulerScalePlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
    this.dispose = null;
    this.show = true;
  };

  _proto.showRulers = function showRulers() {
    this.show = true;
    this.renderScale();
    this.wrapperLayer.style.display = '';
  };

  _proto.hideRulers = function hideRulers() {
    this.show = false;
    this.wrapperLayer.style.display = 'none';
    ReactDOM__default.unmountComponentAtNode(this.wrapperLayer);
  };

  _proto.setInitialPoint = function setInitialPoint(context, point) {
    this.initialPoint = point;

    if (this.show) {
      this.renderScale();
    }
  };

  _proto.handleGhostImage = function handleGhostImage(e) {
    var crt = e.target.cloneNode(true);
    crt.style.backgroundColor = 'red';
    crt.style.opacity = 0;
    crt.style.pointerEvents = 'none';
    document.body.appendChild(crt);
    this.ghostImageDOM = crt;
    e.dataTransfer.setDragImage(crt, 0, 0);
  };

  _proto.disposeGhostImage = function disposeGhostImage() {
    if (this.ghostImageDOM) this.ghostImageDOM.remove();
  };

  _proto.calculateScaleFromZoom = function calculateScaleFromZoom(zoom) {
    var scale = 1;

    if (zoom <= 0.01) {
      scale = 1000;
    } else if (zoom <= 0.03) {
      scale = 500;
    } else if (zoom <= 0.06) {
      scale = 200;
    } else if (zoom <= 0.12) {
      scale = 100;
    } else if (zoom <= 0.25) {
      scale = 50;
    } else if (zoom > 0.25 && zoom <= 0.5) {
      scale = 20;
    } else if (zoom > 0.5 && zoom <= 1) {
      scale = 10;
    } else if (zoom > 1 && zoom <= 2) {
      scale = 5;
    } else if (zoom > 2 && zoom <= 4) {
      scale = 2;
    }

    return scale;
  };

  _proto.renderScale = function renderScale() {
    var zoom = this.canvas.getZoom();
    var scale = this.calculateScaleFromZoom(zoom);
    var perWidth = scale * zoom;
    ReactDOM__default.render(createElement(RulerScaleWrapper, {
      canvas: this.canvas,
      initialPoint: this.initialPoint,
      thick: 0.5,
      perWidth: perWidth,
      zoom: zoom,
      scale: scale,
      horLineArr: [1, 1],
      verLineArr: [1, 1],
      bgColor: '#252a31',
      fgColor: '#6F727D',
      fontColor: '#6F727D',
      lineColor: '#FF0000',
      shadowColor: '#6F727D',
      horLineValue: [100, 200],
      verLineValue: [100, 200],
      shadow: {
        x: 200,
        y: 100,
        width: 100,
        height: 400
      },
      onDragStartHorizontal: this.onDragStartHorizontal,
      onDragEndHorizontal: this.onDragEndHorizontal,
      onDragHorizontal: this.onDragHorizontal,
      onDragStartVertical: this.onDragStartVertical,
      onDragEndVertical: this.onDragEndVertical,
      onDragVertical: this.onDragVertical
    }), this.wrapperLayer);
  };

  _proto.activate = function activate() {
    var _this2 = this;

    if (this.show) {
      this.wrapperLayer = document.createElement('div');
      this.dispose = this.canvas.addDomToViewport(this.wrapperLayer);
      this.wrapperLayer.style.position = 'absolute';
      this.wrapperLayer.style.top = '0px';
      this.wrapperLayer.style.left = '0px';
      this.wrapperLayer.style.bottom = '0px';
      this.wrapperLayer.style.right = '0px';
      this.wrapperLayer.style.display = this.show ? '' : 'none';
      this.wrapperLayer.id = 'ruler-wrapper';
      this.wrapperLayer.style.zIndex = '1';
      this.wrapperLayer.style.pointerEvents = 'none';

      if (this.show) {
        this.renderScale();
      }

      this.canvas.on('zoom', function () {
        if (_this2.show) {
          _this2.renderScale();
        }
      });
    }

    this.canvas.addFunction('RulerScale.setInitialPoint', this.setInitialPoint.bind(this));
    this.canvas.addFunction('RulerScale.show', this.showRulers.bind(this));
    this.canvas.addFunction('RulerScale.hide', this.hideRulers.bind(this));
  };

  _proto.deactivate = function deactivate() {
    this.dispose();
    this.canvas.removeFunction('RulerScale.setInitialPoint');
    this.canvas.removeFunction('RulerScale.show');
    this.canvas.removeFunction('RulerScale.hide');
  };

  return RulerScalePlugin;
}();

var RulerLinesAddEvent = /*#__PURE__*/function (_Event) {
  _inheritsLoose(RulerLinesAddEvent, _Event);

  function RulerLinesAddEvent(name, target, axis, axisCoordinate, currentTarget) {
    var _this;

    _this = _Event.call(this, name, target, currentTarget) || this;
    _this.axisCoordinate = axisCoordinate;
    _this.axis = axis;
    return _this;
  }

  return RulerLinesAddEvent;
}(Event);

var RulerLinesSetPositionEvent = /*#__PURE__*/function (_Event) {
  _inheritsLoose(RulerLinesSetPositionEvent, _Event);

  function RulerLinesSetPositionEvent(name, target, axis, axisCoordinate, index, currentTarget) {
    var _this;

    _this = _Event.call(this, name, target, currentTarget) || this;
    _this.axisCoordinate = axisCoordinate;
    _this.axis = axis;
    _this.index = index;
    return _this;
  }

  return RulerLinesSetPositionEvent;
}(Event);

var RulerLinesRemoveEvent = /*#__PURE__*/function (_Event) {
  _inheritsLoose(RulerLinesRemoveEvent, _Event);

  function RulerLinesRemoveEvent(name, target, index, currentTarget) {
    var _this;

    _this = _Event.call(this, name, target, currentTarget) || this;
    _this.index = index;
    return _this;
  }

  return RulerLinesRemoveEvent;
}(Event);

var RulerLinesPlugin = /*#__PURE__*/function () {
  function RulerLinesPlugin() {
    var _this = this;

    this.name = 'RulerLinesPlugin';
    this.lines = [];

    this.addLine = function (context, axis, axisCoordinate, noEmit) {
      if (noEmit === void 0) {
        noEmit = false;
      }

      var lineWrapper = _this.canvas.executeFunction('drawLine', axis, axisCoordinate, 'rulerHorizontalLine', 0, null, true);

      _this.lines.push({
        axis: axis,
        axisCoordinate: axisCoordinate,
        dom: lineWrapper
      });

      if (!noEmit) _this.canvas.dispatchEvent('RulerLines.add', new RulerLinesAddEvent('RulerLines.add', lineWrapper, axis, axisCoordinate));

      _this.canvas.addEventListener('LineDrawer.dragStart', function (data) {
        var deltaInput = {
          x: data.session.current.x,
          y: data.session.current.y
        };
        var target = data.originalEvent.originalEvent.target;
        var index = findIndex(_this.lines, function (o) {
          return o.dom == target;
        });

        _this.setPosition({
          layer: target,
          canvas: _this.canvas
        }, data.axis == 'y' ? deltaInput.x : deltaInput.y, index);
      });

      _this.canvas.addEventListener('LineDrawer.onDrag', function (data) {
        var deltaInput = {
          x: data.session.current.x,
          y: data.session.current.y
        };
        var target = data.originalEvent.originalEvent.target;
        var index = findIndex(_this.lines, function (o) {
          return o.dom == target;
        });

        _this.setPosition({
          layer: target,
          canvas: _this.canvas
        }, data.axis == 'y' ? deltaInput.x : deltaInput.y, index);
      });

      _this.canvas.addEventListener('LineDrawer.dragEnd', function (data) {
        var deltaInput = {
          x: data.session.current.x,
          y: data.session.current.y
        };
        var target = data.originalEvent.originalEvent.target;
        var index = findIndex(_this.lines, function (o) {
          return o.dom == target;
        });

        _this.setPosition({
          layer: target,
          canvas: _this.canvas
        }, data.axis == 'y' ? deltaInput.x : deltaInput.y, index, true);
      });

      return _this.lines.length - 1;
    };

    this.removeLine = function (context, index) {
      var dom = _this.lines[index].dom;

      if (dom && dom.parentNode) {
        dom.parentNode.removeChild(dom);

        _this.canvas.removeDomFromWorld(dom);

        _this.lines.splice(index, 1);

        _this.canvas.dispatchEvent('RulerLines.remove', new RulerLinesRemoveEvent('RulerLines.remove', _this.canvas, index));
      }
    };

    this.setPosition = function (context, axisCoordinate, index, dragEnd) {
      var indexOfLayer;

      if (isNil(index)) {
        indexOfLayer = _this.lines.length - 1;
      } else {
        indexOfLayer = index;
      }

      var line = _this.lines[indexOfLayer];

      if (line) {
        var dom = line.dom,
            axis = line.axis;

        if (axis == 'y') {
          dom.style.left = axisCoordinate + 'px';
        } else {
          dom.style.top = axisCoordinate + 'px';
        }

        _this.lines[indexOfLayer] = {
          axis: axis,
          axisCoordinate: axisCoordinate,
          dom: dom
        };

        _this.canvas.dispatchEvent('RulerLines.setPosition', new RulerLinesSetPositionEvent('RulerLines.setPosition', _this.canvas, axis, axisCoordinate, indexOfLayer));

        if (dragEnd) {
          var axisPoint = {
            x: axis == 'y' ? axisCoordinate : 0,
            y: axis == 'x' ? axisCoordinate : 0
          };

          var viewportPoint = _this.canvas.convertPoint(axisPoint, 'world', 'viewport');

          var viewportAxisCoordinate = axis === 'y' ? viewportPoint.x : viewportPoint.y;

          if (viewportAxisCoordinate < 18) {
            _this.removeLine({
              layer: _this.canvas,
              canvas: _this.canvas
            }, indexOfLayer);
          }
        }
      }
    };

    this.removeAll = function (context) {
      _this.lines.forEach(function (line) {
        var dom = line.dom;

        if (dom) {
          dom.remove();

          _this.canvas.removeDomFromWorld(dom);
        }
      });

      _this.lines = [];
    };

    this.addAll = function (context, data, emit) {
      if (emit === void 0) {
        emit = true;
      }

      data.forEach(function (line) {
        _this.addLine({
          layer: _this.canvas,
          canvas: _this.canvas
        }, line.axis, line.axisCoordinate, emit);
      });
    };

    this.show = function (context) {
      _this.lines.forEach(function (line) {
        var dom = line.dom;

        if (dom) {
          dom.style.display = '';
        }
      });
    };

    this.hide = function (context) {
      _this.lines.forEach(function (line) {
        var dom = line.dom;

        if (dom) {
          dom.style.display = 'none';
        }
      });
    };

    this.getLineCoordinates = function (context) {
      var coordinates = {
        x: [],
        y: []
      };

      if (_this.lines && _this.lines.length > 0) {
        if (_this.lines[0].dom.style.display !== 'none') {
          for (var _iterator = _createForOfIteratorHelperLoose(_this.lines), _step; !(_step = _iterator()).done;) {
            var line = _step.value;

            if (line.axis === 'x') {
              coordinates.x.push(line.axisCoordinate);
            } else {
              coordinates.y.push(line.axisCoordinate);
            }
          }
        }
      }

      return coordinates;
    };
  }

  var _proto = RulerLinesPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
    this.lines = [];
  };

  _proto.activate = function activate() {
    this.canvas.addFunction('RulerLines.addLine', this.addLine);
    this.canvas.addFunction('RulerLines.removeLine', this.removeLine);
    this.canvas.addFunction('RulerLines.setPosition', this.setPosition);
    this.canvas.addFunction('RulerLines.removeAll', this.removeAll);
    this.canvas.addFunction('RulerLines.addAll', this.addAll);
    this.canvas.addFunction('RulerLines.show', this.show);
    this.canvas.addFunction('RulerLines.hide', this.hide);
    this.canvas.addFunction('RulerLines.getLineCoordinates', this.getLineCoordinates);
  };

  _proto.deactivate = function deactivate() {
    this.canvas.removeFunction('RulerLines.addLine');
    this.canvas.removeFunction('RulerLines.removeLine');
    this.canvas.removeFunction('RulerLines.setPosition');
    this.canvas.removeFunction('RulerLines.removeAll');
    this.canvas.removeFunction('RulerLines.addAll');
    this.canvas.removeFunction('RulerLines.show');
    this.canvas.removeFunction('RulerLines.hide');
    this.canvas.removeFunction('RulerLines.getLineCoordinates');
  };

  return RulerLinesPlugin;
}();

function drawLinesForSnap(canvas, layer, boundingBox, meta, className) {
  if (!className) {
    className = 'snap-lines';
  }

  var parent = layer.parent ? layer.parent : meta && meta.parent;

  if (!parent) {
    return;
  } // // @ts-ignore


  var snapLinesX = document.querySelectorAll('.' + className + '-x');
  var snapLinesY = document.querySelectorAll('.' + className + '-y'); // @ts-ignore

  for (var _iterator = _createForOfIteratorHelperLoose(snapLinesX), _step; !(_step = _iterator()).done;) {
    var _snapLine2 = _step.value;
    _snapLine2.style.visibility = 'hidden';
  } // @ts-ignore


  for (var _iterator2 = _createForOfIteratorHelperLoose(snapLinesY), _step2; !(_step2 = _iterator2()).done;) {
    var _snapLine3 = _step2.value;
    _snapLine3.style.visibility = 'hidden';
  }

  if (!isNaN(get(meta, 'snappedSide.x.snappedSide.snappedPoint.rootValue', NaN))) {
    var point = meta.snappedSide.x.snappedSide.snappedPoint.rootValue;

    if (ModelUtils.pointsOverlap(point, boundingBox.x) || ModelUtils.pointsOverlap(point, boundingBox.width / 2 + boundingBox.x) || ModelUtils.pointsOverlap(point, boundingBox.width + boundingBox.x)) {
      // TODO: remove using architecture instead of DOM
      var snapLines = document.querySelectorAll('.' + className + '-y'); // @ts-ignore

      for (var _iterator3 = _createForOfIteratorHelperLoose(snapLines), _step3; !(_step3 = _iterator3()).done;) {
        var snapLine = _step3.value;
        snapLine.style.visibility = 'visible';
        snapLine.style.left = point + 'px';
        var parentAbsoluteRotation = parent.getAbsoluteRotation();
        var parentDims = parent.getRotatedPolygon();
        var offset = Math.max(boundingBox.width, boundingBox.height);
        snapLine.style.transform = "rotate(" + parentAbsoluteRotation + "deg)";
        snapLine.style.transformOrigin = parentDims.centroid[0] - point + "px " + (parentDims.centroid[1] + offset) + "px";
      }
    }
  }

  if (!isNaN(get(meta, 'snappedSide.y.snappedSide.snappedPoint.rootValue', NaN))) {
    var _point = meta.snappedSide.y.snappedSide.snappedPoint.rootValue; // jugaad: cheking if bounding box is touches snap line

    if (ModelUtils.pointsOverlap(_point, boundingBox.y) || ModelUtils.pointsOverlap(_point, boundingBox.height / 2 + boundingBox.y) || ModelUtils.pointsOverlap(_point, boundingBox.height + boundingBox.y)) {
      var _snapLines = document.querySelectorAll('.' + className + '-x'); // @ts-ignore


      for (var _iterator4 = _createForOfIteratorHelperLoose(_snapLines), _step4; !(_step4 = _iterator4()).done;) {
        var _snapLine = _step4.value;
        _snapLine.style.visibility = 'visible';
        _snapLine.style.top = _point + 'px'; // transform changes

        var _parentAbsoluteRotation = parent.getAbsoluteRotation();

        var _parentDims = parent.getRotatedPolygon();

        var _offset = Math.max(boundingBox.width, boundingBox.height);

        _snapLine.style.transform = "rotate(" + _parentAbsoluteRotation + "deg)";
        _snapLine.style.transformOrigin = _parentDims.centroid[0] + _offset + "px " + (_parentDims.centroid[1] - _point) + "px";
      }
    }
  }
}

function drawLine(canvas, layer, point, boundingBox, axis, meta, className) {
  var parent = layer.parent ? layer.parent : meta && meta.parent;

  if (!parent) {
    return;
  }

  var parentAbsoluteRotation = parent.getAbsoluteRotation();
  var parentDims = parent.getRotatedPolygon();
  var offset = Math.max(boundingBox.width, boundingBox.height);
  var value = point;
  var extraStyle = {// visibility: 'hidden',
  };

  if (axis === 'y') {
    extraStyle = _extends({}, extraStyle, {
      transform: "rotate(" + parentAbsoluteRotation + "deg)",
      transformOrigin: parentDims.centroid[0] - value + "px " + (parentDims.centroid[1] + offset) + "px"
    });
  } else {
    extraStyle = _extends({}, extraStyle, {
      transform: "rotate(" + parentAbsoluteRotation + "deg)",
      transformOrigin: parentDims.centroid[0] + offset + "px " + (parentDims.centroid[1] - value) + "px"
    });
  }

  canvas.executeFunction('drawLine', axis, value, className + '-' + axis, -offset, undefined, undefined, undefined, extraStyle);
}

function drawAllLinesForSnap(canvas, layer, boundingBox, snapLines, className, meta) {
  if (className === void 0) {
    className = 'snap-lines';
  }

  drawLine(canvas, layer, -100, boundingBox, 'y', meta, className);
  drawLine(canvas, layer, -100, boundingBox, 'x', meta, className);
}

var SnapLines = /*#__PURE__*/function () {
  function SnapLines() {
    this.name = 'SnapLines';
  }

  var _proto = SnapLines.prototype;

  _proto.removeElementsWithClass = function removeElementsWithClass(name) {
    var snapLinesX = document.querySelectorAll('.' + name + '-x'); // TODO: remove using architecture instead of DOM
    // @ts-ignore

    for (var _iterator = _createForOfIteratorHelperLoose(snapLinesX), _step; !(_step = _iterator()).done;) {
      var snapLine = _step.value;
      snapLine.remove();
      this.canvas.removeDomFromWorld(snapLine);
    }

    var snapLinesY = document.querySelectorAll('.' + name + '-y'); // TODO: remove using architecture instead of DOM
    // @ts-ignore

    for (var _iterator2 = _createForOfIteratorHelperLoose(snapLinesY), _step2; !(_step2 = _iterator2()).done;) {
      var _snapLine = _step2.value;

      _snapLine.remove();

      this.canvas.removeDomFromWorld(_snapLine);
    }
  };

  _proto.init = function init(canvas) {
    this.canvas = canvas;
  };

  _proto.dragStartListener = function dragStartListener(data, className) {
    if (className === void 0) {
      className = 'snap-lines';
    }

    this.removeElementsWithClass(className);
    var boundingBox = this.canvas.getContainerBoundingBoxWRTParent([data.target]);
    drawAllLinesForSnap(this.canvas, data.target, boundingBox, data.snapPoints, className, data.meta);
  };

  _proto.dragListener = function dragListener(data, className) {
    if (className === void 0) {
      className = 'snap-lines';
    }

    // this.removeElementsWithClass(className);
    var boundingBox = this.canvas.getContainerBoundingBoxWRTParent([data.target]);

    if (data.target.parent) {
      boundingBox = _extends({}, boundingBox, {
        x: boundingBox.x + data.target.parent.rootX,
        y: boundingBox.y + data.target.parent.rootY
      });
    }

    if (data.target) {
      drawLinesForSnap(this.canvas, data.target, boundingBox, data.meta, className);
    }
  };

  _proto.dragListenerDraw = function dragListenerDraw(data, className) {
    if (className === void 0) {
      className = 'snap-lines';
    }

    // this.removeElementsWithClass(className);
    var boundingBox = {
      x: data.worldX,
      y: data.worldY,
      width: data.dimensions.width,
      height: data.dimensions.height
    };

    if (data.target) {
      drawLinesForSnap(this.canvas, data.target, boundingBox, data.meta, className);
    }
  };

  _proto.dragListenerResizer = function dragListenerResizer(data, className) {
    if (className === void 0) {
      className = 'snap-lines';
    }

    // this.removeElementsWithClass(className);
    var boundingBox = this.canvas.getContainerBoundingBoxWRTParent(this.canvas.selectedLayers);

    if (this.canvas.selectedLayers[0].parent) {
      boundingBox = _extends({}, boundingBox, {
        x: boundingBox.x + this.canvas.selectedLayers[0].parent.rootX,
        y: boundingBox.y + this.canvas.selectedLayers[0].parent.rootY
      });
    }

    if (data.target) {
      drawLinesForSnap(this.canvas, data.target, boundingBox, data.meta, className);
    }
  };

  _proto.drawComponentMouseMoveListener = function drawComponentMouseMoveListener(data, className) {
    if (className === void 0) {
      className = 'snap-lines';
    }

    // this.removeElementsWithClass(className);
    var boundingBox = {
      x: data.worldX,
      y: data.worldY,
      width: 0,
      height: 0
    };

    if (data.target) {
      drawLinesForSnap(this.canvas, data.target, boundingBox, data.meta, className);
    }
  };

  _proto.activate = function activate() {
    var _this = this;

    // layer drag listener
    this.canvas.addEventListener('layerDragStart', function (data) {
      _this.dragStartListener(data);
    });
    this.canvas.addEventListener('layerDrag', function (data) {
      _this.dragListener(data);
    });
    this.canvas.addEventListener('layerDragEnd', function (data) {
      _this.removeElementsWithClass('snap-lines');
    }); // resizer listener

    this.canvas.addEventListener('LayerResizer.dragStart', function (data) {
      _this.dragStartListener(data);
    });
    this.canvas.addEventListener('LayerResizer.drag', function (data) {
      _this.dragListenerResizer(data);
    });
    this.canvas.addEventListener('LayerResizer.dragEnd', function (data) {
      _this.removeElementsWithClass('snap-lines');
    }); // resizer handle drag listener

    this.canvas.addEventListener('LayerResizer.handleDragStart', function (data) {
      _this.dragStartListener(data);
    });
    this.canvas.addEventListener('LayerResizer.handleDrag', function (data) {
      _this.dragListenerResizer(data);
    });
    this.canvas.addEventListener('LayerResizer.handleDragEnd', function (data) {
      _this.removeElementsWithClass('snap-lines');
    }); /// draw component listener

    this.canvas.addEventListener('StageDesignerDrawComponent.drawShape', function (data) {
      _this.dragStartListener(data, 'snap-lines-draw');
    });
    this.canvas.addEventListener('StageDesignerDrawComponent.mousemove', function (data) {
      _this.drawComponentMouseMoveListener(data, 'snap-lines-draw');
    }); // resizer listener

    this.canvas.addEventListener('StageDesignerDrawComponent.drawStart', function (data) {
      _this.dragStartListener(data);
    });
    this.canvas.addEventListener('StageDesignerDrawComponent.draw', function (data) {
      _this.dragListenerDraw(data);
    });
    this.canvas.addEventListener('StageDesignerDrawComponent.drawEnd', function (data) {
      _this.removeElementsWithClass('snap-lines');

      _this.removeElementsWithClass('snap-lines-draw');
    });
  };

  _proto.deactivate = function deactivate() {};

  return SnapLines;
}();

var LineDrawerDragEvent = /*#__PURE__*/function (_MouseEvent) {
  _inheritsLoose(LineDrawerDragEvent, _MouseEvent);

  function LineDrawerDragEvent(name, startValues, session, originalEvent, target, currentTarget, axis) {
    var _this;

    _this = _MouseEvent.call(this, name, target, originalEvent, currentTarget) || this;
    _this.session = session;
    _this.startValues = startValues;
    _this.axis = axis;
    return _this;
  }

  return LineDrawerDragEvent;
}(DesignerMouseEvent);

var LineDrawer = /*#__PURE__*/function () {
  function LineDrawer() {
    this.name = 'LineDrawer';
    this.namespace = 'LineDrawer';
  }

  var _proto = LineDrawer.prototype;

  _proto.handleGhostImage = function handleGhostImage(e) {
    var crt = e.target.cloneNode(true);
    crt.style.backgroundColor = 'red';
    crt.style.opacity = 0;
    crt.style.pointerEvents = 'none';
    document.body.appendChild(crt);
    this.ghostImageDOM = crt;
    e.dataTransfer.setDragImage(crt, 0, 0);
  };

  _proto.disposeGhostImage = function disposeGhostImage() {
    if (this.ghostImageDOM) this.ghostImageDOM.remove();
  };

  _proto.drawLine = function drawLine(context, axis, axisCoordinate, className, startCoordinate, endCoordinate, draggable, label, style) {
    var _this = this;

    if (style === void 0) {
      style = {};
    }

    var lineWrappedLayer = document.createElement('div');
    this.dispose = this.canvas.addDomToWorld(lineWrappedLayer, true, 103);
    var zoom = this.canvas.getZoom();
    var lineWidth = 1 / zoom;
    var lineWrapperDim = 8 / zoom;
    var line = document.createElement('div');
    this.canvas.on('zoom', function (e) {
      zoom = _this.canvas.getZoom();
      lineWidth = 1 / zoom;
      lineWrapperDim = 8 / zoom;

      if (line && lineWrappedLayer) {
        if (axis === 'x') {
          line.style.height = lineWidth + 'px';
          lineWrappedLayer.style.height = lineWrapperDim + "px";
        } else {
          lineWrappedLayer.style.width = lineWrapperDim + "px";
          line.style.width = lineWidth + 'px';
        }
      }
    });

    if (className) {
      lineWrappedLayer.className = className;
    }

    var labelBox;
    var boxWidth = 30;
    var boxHeight = 15;
    var fontSize = 10;
    var labelSpacing = 10;
    var length;
    startCoordinate = startCoordinate ? startCoordinate : 0;
    line.style.position = 'absolute';
    lineWrappedLayer.style.position = 'absolute';
    line.style.backgroundColor = '#22b9d1';
    lineWrappedLayer.style.pointerEvents = 'none';
    lineWrappedLayer.style.transform = style.transform;
    lineWrappedLayer.style.transformOrigin = style.transformOrigin;
    lineWrappedLayer.style.visibility = style.visibility;
    var lineLength = Math.max(this.canvas.getBoundingClientRect().width, this.canvas.getBoundingClientRect().height);

    if (draggable) {
      lineWrappedLayer.style.pointerEvents = 'auto';
      lineWrappedLayer.draggable = true;
      var x, y;

      if (axis == 'x') {
        endCoordinate = endCoordinate ? endCoordinate : lineLength;
        x = Math.min(startCoordinate, endCoordinate);
        y = axisCoordinate;

        lineWrappedLayer.onmouseover = function (e) {
          if (!_this.canvas.executeFunction('LayerDrag.isDragging')) _this.canvas.setMouseCursor('row-resize');
        };
      } else {
        endCoordinate = endCoordinate ? endCoordinate : lineLength;
        y = Math.min(startCoordinate, endCoordinate);
        x = axisCoordinate;

        lineWrappedLayer.onmouseover = function (e) {
          if (!_this.canvas.executeFunction('LayerDrag.isDragging')) _this.canvas.setMouseCursor('col-resize');
        };
      }

      lineWrappedLayer.onmouseleave = function (e) {
        _this.canvas.setMouseCursor('default');
      };

      var dims = {
        x: x,
        y: y,
        height: lineWidth,
        width: Math.abs(startCoordinate - endCoordinate),
        rotation: 0
      };

      lineWrappedLayer.ondragstart = function (e) {
        _this.handleGhostImage(e);

        var dragVal = _this.canvas.executeFunction('HtmlDragToWorld.dragStart', e, dims);

        _this.canvas.dispatchEvent(_this.namespace + ".dragStart", new LineDrawerDragEvent(_this.namespace + ".dragStart", dragVal.startValues, dragVal.session, dragVal.event, _this.canvas, undefined, axis));
      };

      lineWrappedLayer.ondrag = function (e) {
        if (e.pageX && e.pageY) {
          var dragVal = _this.canvas.executeFunction('HtmlDragToWorld.drag', e);

          if (dragVal.session.current.deltaX !== 0 || dragVal.session.current.deltaY !== 0) {
            _this.canvas.dispatchEvent(_this.namespace + ".onDrag", new LineDrawerDragEvent(_this.namespace + ".onDrag", dragVal.startValues, dragVal.session, dragVal.event, _this.canvas, undefined, axis));
          }
        }
      };

      lineWrappedLayer.ondragend = function (e) {
        _this.disposeGhostImage();

        e.preventDefault();

        var dragVal = _this.canvas.executeFunction('HtmlDragToWorld.dragEnd', e);

        _this.canvas.dispatchEvent(_this.namespace + ".dragEnd", new LineDrawerDragEvent(_this.namespace + ".dragEnd", dragVal.startValues, dragVal.session, dragVal.event, _this.canvas, undefined, axis));
      };
    }

    switch (axis) {
      case 'x':
        endCoordinate = endCoordinate ? endCoordinate : lineLength;
        length = Math.abs(startCoordinate - endCoordinate);
        line.style.height = lineWidth + 'px';
        line.style.width = length + 'px';
        lineWrappedLayer.style.width = length + 'px';
        lineWrappedLayer.style.height = lineWrapperDim + "px";
        lineWrappedLayer.style.left = Math.min(startCoordinate, endCoordinate) + 'px';
        lineWrappedLayer.style.top = axisCoordinate + 'px';
        lineWrappedLayer.appendChild(line);
        labelBox = this.createLabelBox(label, 'x', axisCoordinate, length / 2 - boxWidth / 2, boxHeight, boxWidth, labelSpacing, fontSize);

        if (labelBox) {
          lineWrappedLayer.appendChild(labelBox);
        }

        break;

      case 'y':
        endCoordinate = endCoordinate ? endCoordinate : lineLength;
        length = Math.abs(startCoordinate - endCoordinate);
        line.style.width = lineWidth + 'px';
        line.style.height = length + 'px';
        lineWrappedLayer.style.height = length + 'px';
        lineWrappedLayer.style.width = lineWrapperDim + "px";
        lineWrappedLayer.style.top = Math.min(startCoordinate, endCoordinate) + 'px';
        lineWrappedLayer.style.left = axisCoordinate + 'px';
        lineWrappedLayer.appendChild(line);
        labelBox = this.createLabelBox(label, 'y', axisCoordinate, length / 2 - boxHeight / 2, boxHeight, boxWidth, labelSpacing, fontSize);

        if (labelBox) {
          lineWrappedLayer.appendChild(labelBox);
        }

        break;
    }

    return lineWrappedLayer;
  };

  _proto.setLabelBoxStyle = function setLabelBoxStyle(labelBox, height, width, axis, labelSpacing, pointOnAxis, text, fontSize) {
    var zoom = this.canvas.getZoom();
    height = height / zoom;
    width = width / zoom;
    labelSpacing = labelSpacing / zoom;
    labelBox.style.width = width + 'px';
    labelBox.style.height = height + 'px';
    labelBox.style.borderRadius = 2 / zoom + "px";

    if (axis === 'x') {
      if (height - labelSpacing <= 0) {
        labelBox.style.top = labelSpacing + 'px';
      } else {
        labelBox.style.top = -(labelSpacing + height) + 'px';
      }

      labelBox.style.left = pointOnAxis + 'px';
    } else {
      if (width - labelSpacing <= 0) {
        labelBox.style.left = -(labelSpacing + width) + 'px';
      } else {
        labelBox.style.left = labelSpacing + 'px';
      }

      labelBox.style.top = pointOnAxis + 'px';
    }

    text.style.fontSize = fontSize / zoom + 'px';
  };

  _proto.createLabelBox = function createLabelBox(label, axis, coordinate, pointOnAxis, boxHeight, boxWidth, labelSpacing, fontSize) {
    var _this2 = this;

    if (!label) return;
    var labelBox = document.createElement('div');
    labelBox.style.position = 'absolute';
    labelBox.style.backgroundColor = '#22b9d1';
    var text = document.createElement('span');
    text.style.backgroundColor = 'transparent';
    text.style.color = 'white';
    text.style.left = 0 + 'px';
    text.style.right = 0 + 'px';
    text.style.top = 0 + 'px';
    text.style.bottom = 0 + 'px';
    text.style.position = 'absolute';
    text.style.display = 'flex';
    text.style.textAlign = 'center';
    text.style.justifyContent = 'center';
    text.style.alignItems = 'center';
    this.setLabelBoxStyle(labelBox, boxHeight, boxWidth, axis, labelSpacing, pointOnAxis, text, fontSize);
    text.innerHTML = label;
    labelBox.appendChild(text);
    this.canvas.on('zoom', function () {
      _this2.setLabelBoxStyle(labelBox, boxHeight, boxWidth, axis, labelSpacing, pointOnAxis, text, fontSize);
    });
    return labelBox;
  };

  _proto.init = function init(canvas) {
    this.canvas = canvas;
  };

  _proto.activate = function activate() {
    this.canvas.addFunction('drawLine', this.drawLine.bind(this));
  };

  _proto.deactivate = function deactivate() {
    this.canvas.removeFunction('drawLine');
    this.dispose();
  };

  return LineDrawer;
}();

var iconRight = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNTEycHgiIGhlaWdodD0iNTEycHgiIHZpZXdCb3g9IjAgMCA1MTIgNTEyIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0OS4zICg1MTE2NykgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+aWNvbl9yaWdodDwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJpY29uX3JpZ2h0IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0icmlnaHRfYXJyb3ciIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEwMi4wMDAwMDAsIDAuMDAwMDAwKSIgZmlsbD0iIzZGNzI3RCIgZmlsbC1ydWxlPSJub256ZXJvIj4KICAgICAgICAgICAgPHBvbHlnb24gaWQ9Iu+PkiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTUzLjU1Mzk4NiwgMjU1LjkyMzMwOSkgc2NhbGUoLTEsIDEpIHRyYW5zbGF0ZSgtMTUzLjU1Mzk4NiwgLTI1NS45MjMzMDkpICIgcG9pbnRzPSIzMDcuMTA3OTcxIDMwLjM5MDg5MyA2Ny4xNzk4Njk4IDI1NS45MjMzMDkgMzA3LjEwNzk3MSA0ODEuNDU1NzI0IDI3My41MTgwMzcgNTExLjg0NjYxNyAxLjE0OTgxMjhlLTA2IDI1NS45MjMzMDkgMjczLjUxODAzNyAwIj48L3BvbHlnb24+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4=';
var iconLeft = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNTEycHgiIGhlaWdodD0iNTEycHgiIHZpZXdCb3g9IjAgMCA1MTIgNTEyIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0OS4zICg1MTE2NykgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+aWNvbl9sZWZ0PC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGRlZnM+PC9kZWZzPgogICAgPGcgaWQ9Imljb25fbGVmdCIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9InJpZ2h0X2Fycm93IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNTYuMDAwMDAwLCAyNTYuMDAwMDAwKSBzY2FsZSgtMSwgMSkgdHJhbnNsYXRlKC0yNTYuMDAwMDAwLCAtMjU2LjAwMDAwMCkgdHJhbnNsYXRlKDEwMi4wMDAwMDAsIDAuMDAwMDAwKSIgZmlsbD0iIzZGNzI3RCIgZmlsbC1ydWxlPSJub256ZXJvIj4KICAgICAgICAgICAgPHBvbHlnb24gaWQ9Iu+PkiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTUzLjU1Mzk4NiwgMjU1LjkyMzMwOSkgc2NhbGUoLTEsIDEpIHRyYW5zbGF0ZSgtMTUzLjU1Mzk4NiwgLTI1NS45MjMzMDkpICIgcG9pbnRzPSIzMDcuMTA3OTcxIDMwLjM5MDg5MyA2Ny4xNzk4Njk4IDI1NS45MjMzMDkgMzA3LjEwNzk3MSA0ODEuNDU1NzI0IDI3My41MTgwMzcgNTExLjg0NjYxNyAxLjE0OTgxMjhlLTA2IDI1NS45MjMzMDkgMjczLjUxODAzNyAwIj48L3BvbHlnb24+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4=';

function getButtonCss(zoom) {
  return "\nbackground: transparent;\nwidth: auto;\ncolor: rgb(251,251,251);\nheight: 80px;\npadding-left: " + 6 / zoom + "px;\npadding-right: " + 6 / zoom + "px;\nmargin-top: 0px;\nborder:none;\nmin-width: " + 100 / zoom + "px;\n";
}

function getImgCss(zoom) {
  return "\n  border: none;\n  margin-right: 0px;\n  margin-left: 0px;\n  opacity: 1;\n  width: " + 32 / zoom + "px;\n  height: " + 32 / zoom + "px;\n  ";
}

var containerCss = "\nposition: absolute;\npointer-events: auto;\nz-index: 4;\ntransform-origin: 0px 0px;\n";

var StageDesignerPreviewModePlugin = /*#__PURE__*/function () {
  function StageDesignerPreviewModePlugin() {
    this.name = 'StageDesignerPreviewMode';
    this.artboards = [];
  }

  var _proto = StageDesignerPreviewModePlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
    this.disposeNextBtn = null;
    this.disposePreviousBtn = null;
    this.currentMode = 'stage';
  };

  _proto.activate = function activate() {
    var _this = this;

    this.canvas.addFunction('switchToPreviewMode', this.previewMode.bind(this));
    this.canvas.addFunction('switchToStageMode', this.stageMode.bind(this));
    this.disposeNextBtn = this.renderNextButton();
    this.disposePreviousBtn = this.renderPreviousButton();
    this.previousBtnContainerNode.style.display = 'none';
    this.nextBtnContainerNode.style.display = 'none';
    this.canvas.on('zoom', function () {
      if (_this.currentMode === 'preview' && _this.artboards.length > 1) {
        _this.prevImgElement.style.cssText = getImgCss(_this.canvas.getZoom());
        _this.prevBtnElement.style.cssText = getButtonCss(_this.canvas.getZoom());
        _this.nextBtnElement.style.cssText = getButtonCss(_this.canvas.getZoom());
        _this.nextImgElement.style.cssText = getImgCss(_this.canvas.getZoom());

        _this.setPreviousButtonContainerLayout();

        _this.setNextButtonContainerLayout();

        _this.setDisplayForButtons();
      }
    });
  };

  _proto.previewMode = function previewMode(context) {
    this.currentMode = 'preview';
    var artboards = this.canvas.executeFunction('getAllArtboards');
    this.artboards = Array.from(artboards.values());
    this.canvas.executeFunction('hidePlusButton');

    if (this.artboards.length > 1) {
      this.handleSelectedArtboardChange();
    }
  };

  _proto.stageMode = function stageMode(context) {
    var _this2 = this;

    this.currentMode = 'stage';
    var artboards = this.canvas.executeFunction('getAllArtboards');
    this.artboards = Array.from(artboards.values());
    this.previousBtnContainerNode.style.display = 'none';
    this.nextBtnContainerNode.style.display = 'none';
    this.canvas.executeFunction('showPlusButton');
    map$1(this.artboards, function (artboard) {
      artboard.show();
      artboard.executeFunction('LayerLabel.show');
      artboard.executeFunction('showGrid', _this2.canvas.executeFunction('getGridSize'));
    });
  };

  _proto.nextArtboard = function nextArtboard() {
    var selectedArtboard = this.canvas.executeFunction('getSelectedArtboard');
    selectedArtboard.hide();
    var selectedArtboardIndex = 0;
    if (selectedArtboard) selectedArtboardIndex = indexOf(this.artboards, selectedArtboard);
    selectedArtboardIndex += 1;
    this.artboards[selectedArtboardIndex].show();
    this.canvas.dispatchEvent('StageDesignerPreviewMode.selectArtboard', new Event('StageDesignerPreviewMode.selectArtboard', this.artboards[selectedArtboardIndex]));
    this.handleSelectedArtboardChange();
  };

  _proto.previousArtboard = function previousArtboard() {
    var selectedArtboard = this.canvas.executeFunction('getSelectedArtboard');
    selectedArtboard.hide();
    var selectedArtboardIndex = 0;
    if (selectedArtboard) selectedArtboardIndex = indexOf(this.artboards, selectedArtboard);
    selectedArtboardIndex -= 1;
    this.artboards[selectedArtboardIndex].show();
    this.canvas.dispatchEvent('StageDesignerPreviewMode.selectArtboard', new Event('StageDesignerPreviewMode.selectArtboard', this.artboards[selectedArtboardIndex]));
    this.handleSelectedArtboardChange();
  };

  _proto.setDisplayForButtons = function setDisplayForButtons() {
    var selectedArtboard = this.canvas.executeFunction('getSelectedArtboard');

    if (selectedArtboard) {
      var selectedArtboardIndex = indexOf(this.artboards, selectedArtboard);

      if (selectedArtboardIndex === 0) {
        this.previousBtnContainerNode.style.display = 'none';
        this.nextBtnContainerNode.style.display = '';
      } else if (selectedArtboardIndex === this.artboards.length - 1) {
        this.nextBtnContainerNode.style.display = 'none';
        this.previousBtnContainerNode.style.display = '';
      } else {
        this.previousBtnContainerNode.style.display = '';
        this.nextBtnContainerNode.style.display = '';
      }
    } else {
      this.nextBtnContainerNode.style.display = 'none';
      this.previousBtnContainerNode.style.display = 'none';
    }
  };

  _proto.handleSelectedArtboardChange = function handleSelectedArtboardChange() {
    var _this3 = this;

    this.setPreviousButtonContainerLayout();
    this.setNextButtonContainerLayout();
    var selectedArtboard = this.canvas.executeFunction('getSelectedArtboard');

    if (selectedArtboard) {
      this.setDisplayForButtons();
    } else {
      selectedArtboard = this.artboards[0];

      if (selectedArtboard) {
        this.canvas.dispatchEvent('StageDesignerPreviewMode.selectArtboard', new Event('StageDesignerPreviewMode.selectArtboard', selectedArtboard));
      }

      this.previousBtnContainerNode.style.display = 'none';
      this.nextBtnContainerNode.style.display = '';
    }

    map$1(this.artboards, function (artboard) {
      if (!isEqual(artboard, selectedArtboard)) {
        artboard.hide();
        artboard.executeFunction('LayerLabel.hide');
        artboard.executeFunction('hideGrid');
      } else {
        artboard.show();
        artboard.executeFunction('LayerLabel.show');
        artboard.executeFunction('showGrid', _this3.canvas.executeFunction('getGridSize'));

        if (artboard) {
          _this3.canvas.dispatchEvent('StageDesignerPreviewMode.selectArtboard', new Event('StageDesignerPreviewMode.selectArtboard', artboard));
        }
      }
    });
    selectedArtboard.executeFunction('focusArtboard');
  };

  _proto.renderNextButton = function renderNextButton() {
    var _this4 = this;

    this.nextBtnContainerNode = document.createElement('div');
    this.nextBtnElement = document.createElement('button');
    this.nextBtnElement.style.cssText = getButtonCss(this.canvas.getZoom());

    this.nextBtnElement.onclick = function () {
      return _this4.nextArtboard();
    };

    this.nextImgElement = document.createElement('img');
    this.nextImgElement.src = iconRight;
    this.nextImgElement.style.cssText = getImgCss(this.canvas.getZoom());
    this.nextBtnElement.append(this.nextImgElement);
    this.nextBtnContainerNode.appendChild(this.nextBtnElement);
    return this.canvas.addDomToWorld(this.nextBtnContainerNode);
  };

  _proto.renderPreviousButton = function renderPreviousButton() {
    var _this5 = this;

    this.previousBtnContainerNode = document.createElement('div');
    this.prevBtnElement = document.createElement('button');
    this.prevBtnElement.style.cssText = getButtonCss(this.canvas.getZoom());

    this.prevBtnElement.onclick = function () {
      return _this5.previousArtboard();
    };

    this.prevImgElement = document.createElement('img');
    this.prevImgElement.src = iconLeft;
    this.prevImgElement.style.cssText = getImgCss(this.canvas.getZoom());
    this.prevBtnElement.append(this.prevImgElement);
    this.previousBtnContainerNode.appendChild(this.prevBtnElement);
    return this.canvas.addDomToWorld(this.previousBtnContainerNode);
  };

  _proto.setPreviousButtonContainerLayout = function setPreviousButtonContainerLayout() {
    var selectedArtboard = this.canvas.executeFunction('getSelectedArtboard');
    if (!selectedArtboard) selectedArtboard = this.artboards[0];
    var containerLayout = {
      left: selectedArtboard.layout.data.left - 150 / this.canvas.getZoom(),
      top: selectedArtboard.layout.data.height / 2 + selectedArtboard.layout.data.top - 40 / this.canvas.getZoom()
    };
    this.previousBtnContainerNode.style.cssText = containerCss + ("left:" + containerLayout.left + "px;top:" + containerLayout.top + "px");
  };

  _proto.setNextButtonContainerLayout = function setNextButtonContainerLayout() {
    var selectedArtboard = this.canvas.executeFunction('getSelectedArtboard');
    if (!selectedArtboard) selectedArtboard = this.artboards[0];
    var containerLayout = {
      left: selectedArtboard.layout.data.left + selectedArtboard.layout.data.width + 50 / this.canvas.getZoom(),
      top: selectedArtboard.layout.data.height / 2 + selectedArtboard.layout.data.top - 40 / this.canvas.getZoom()
    };
    this.nextBtnContainerNode.style.cssText = containerCss + ("left:" + containerLayout.left + "px;top:" + containerLayout.top + "px");
  };

  _proto.deactivate = function deactivate() {
    this.canvas.removeFunction('switchToPreviewMode');
    this.canvas.removeFunction('switchToStageMode');
    this.disposeNextBtn();
    this.disposePreviousBtn();
  };

  return StageDesignerPreviewModePlugin;
}();

var StageDesignerDropEvent = /*#__PURE__*/function (_DesignerDropEvent) {
  _inheritsLoose(StageDesignerDropEvent, _DesignerDropEvent);

  function StageDesignerDropEvent(name, target, originalEvent, artboard, currentTarget) {
    var _this;

    _this = _DesignerDropEvent.call(this, name, target, originalEvent, currentTarget) || this;
    _this.artboard = artboard;
    return _this;
  }

  return StageDesignerDropEvent;
}(DesignerDropEvent);

var StageDesignerDropPlugin = /*#__PURE__*/function () {
  function StageDesignerDropPlugin() {
    this.name = 'StageDesignerDrop';
  }

  var _proto = StageDesignerDropPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
  };

  _proto.activate = function activate() {
    var _this = this;

    this.canvas.addEventListener('drop', function (e) {
      var draggedLayerStyles = JSON.parse(e.originalEvent.dataTransfer.getData('text'));

      var hitResult = _this.canvas.getHitRectResult(e.worldX - draggedLayerStyles.offsetX, e.worldY - draggedLayerStyles.offsetY, parseInt(draggedLayerStyles.width.replace('px', '')), parseInt(draggedLayerStyles.height.replace('px', '')));

      var canvas = hitResult.pop();
      var artboard = null;
      map$1(hitResult, function (hitLayer) {
        if (canvas.children.indexOf(hitLayer) >= 0) {
          artboard = hitLayer;
        }
      });

      if (!artboard) {
        artboard = _this.canvas.executeFunction('getSelectedArtboard');
      }

      _this.canvas.dispatchEvent('StageDesigner.drop', new StageDesignerDropEvent('StageDesigner.drop', _this.canvas, e.originalEvent, artboard, _this.canvas));
    });
  };

  _proto.deactivate = function deactivate() {// TODO: call remove event listener with callback
    // this.canvas.removeEventListener('drop');
  };

  return StageDesignerDropPlugin;
}();

var StageDesignerDrawEvent = /*#__PURE__*/function (_Event) {
  _inheritsLoose(StageDesignerDrawEvent, _Event);

  function StageDesignerDrawEvent(name, target, payload, currentTarget, meta, snapPoints) {
    var _this;

    _this = _Event.call(this, name, target, currentTarget) || this;
    _this.dimensions = {
      x: payload.x,
      y: payload.y,
      height: payload.height,
      width: payload.width
    };
    _this.worldX = payload.worldX;
    _this.worldY = payload.worldY;
    _this.meta = meta;
    _this.snapPoints = snapPoints;
    return _this;
  }

  return StageDesignerDrawEvent;
}(Event);

var StageDesignerDrawComponent = /*#__PURE__*/function () {
  function StageDesignerDrawComponent() {
    var _this = this;

    this.name = 'StageDesignerDrawComponent';
    this.firstTime = true;

    this.setSelectedArtboard = function (data) {
      var _data$dimensions = data.dimensions,
          worldX = _data$dimensions.worldX,
          worldY = _data$dimensions.worldY;

      var artboard = _this.canvas.executeFunction('getHitArtboard', worldX, worldY);

      var selectedArtboard = _this.canvas.executeFunction('getSelectedArtboard');

      if (artboard) {
        if (selectedArtboard !== artboard) {
          _this.canvas.dispatchEvent('selectArtboard', new Event('selectArtboard', artboard));
        }

        _this.selectedArtboard = artboard;
      } else if (selectedArtboard) {
        _this.selectedArtboard = selectedArtboard;
      } else {
        throw new Error('No artboard is selected');
      }
    };

    this.drawShape = function (data) {
      var _data$dimensions2 = data.dimensions,
          worldX = _data$dimensions2.worldX,
          worldY = _data$dimensions2.worldY;

      var relativeDims = _this.getDimsFromArtboard(data.dimensions);

      data.meta.parent = _this.selectedArtboard.children[0];
      _this.snapPoints = _this.canvas.executeFunction('getSnapPoints', [], _this.selectedArtboard.children[0]);

      _this.canvas.executeFunction('DrawComponent.setSnapPoints', _this.snapPoints);

      var stageDesignerDrawEvent = new StageDesignerDrawEvent(_this.name + ".drawShape", _this.canvas, _extends({}, relativeDims, {
        worldX: worldX,
        worldY: worldY
      }), undefined, data.meta, _this.snapPoints);

      _this.canvas.dispatchEvent(_this.name + ".drawShape", stageDesignerDrawEvent);
    };

    this.addListeners = function () {
      _this.canvas.addEventListener('DrawComponent.drawShape', function (data) {
        if (_this.selectedArtboard) {
          data.meta.parent = _this.selectedArtboard.children[0];

          _this.drawShape(data);
        }
      });

      _this.canvas.addEventListener('DrawComponent.mousemove', function (data) {
        //
        var _data$dimensions3 = data.dimensions,
            worldX = _data$dimensions3.worldX,
            worldY = _data$dimensions3.worldY;
        var oldSelectedArtboard = _this.selectedArtboard;

        _this.setSelectedArtboard(data);

        var relativeDims = _this.getDimsFromArtboard(data.dimensions);

        data.meta.parent = _this.selectedArtboard.children[0];

        if (oldSelectedArtboard !== _this.selectedArtboard) {
          _this.drawShape(data);
        }

        var stageDesignerDrawEvent = new StageDesignerDrawEvent(_this.name + ".mousemove", _this.canvas, _extends({}, relativeDims, {
          worldX: worldX,
          worldY: worldY
        }), undefined, data.meta);

        _this.canvas.dispatchEvent(_this.name + ".mousemove", stageDesignerDrawEvent);
      });

      _this.canvas.addEventListener('DrawComponent.drawStart', function (data) {
        _this.setSelectedArtboard(data);

        var _data$dimensions4 = data.dimensions,
            worldX = _data$dimensions4.worldX,
            worldY = _data$dimensions4.worldY;

        var relativeDims = _this.getDimsFromArtboard(data.dimensions);

        var parent = _this.selectedArtboard.children[0];
        var stageDesignerDrawStartEvent = new StageDesignerDrawEvent(_this.name + ".drawStart", _this.canvas, _extends({}, relativeDims, {
          worldX: worldX,
          worldY: worldY
        }), undefined, {
          parent: parent
        }, _this.snapPoints);

        _this.canvas.dispatchEvent(_this.name + ".drawStart", stageDesignerDrawStartEvent);

        _this.canvas.executeFunction('DrawComponent.setSnapPoints', _this.snapPoints);
      });

      _this.canvas.addEventListener('DrawComponent.draw', function (data) {
        var _data$dimensions5 = data.dimensions,
            worldX = _data$dimensions5.worldX,
            worldY = _data$dimensions5.worldY; // data.target.setParent(this.selectedArtboard.children[0]);
        // (data.target as any).parent = this.selectedArtboard.children[0];

        data.meta.parent = _this.selectedArtboard.children[0];

        var relativeDims = _this.getDimsFromArtboard(data.dimensions);

        var stageDesignerDrawEvent = new StageDesignerDrawEvent(_this.name + ".draw", _this.canvas, _extends({}, relativeDims, {
          worldX: data.dimensions.worldX,
          worldY: data.dimensions.worldY
        }), undefined, data.meta);

        _this.canvas.dispatchEvent(_this.name + ".draw", stageDesignerDrawEvent);
      });

      _this.canvas.addEventListener('DrawComponent.drawEnd', function (data) {
        var _data$dimensions6 = data.dimensions,
            worldX = _data$dimensions6.worldX,
            worldY = _data$dimensions6.worldY;

        var relativeDims = _this.getDimsFromArtboard(data.dimensions);

        var stageDesignerDrawEndEvent = new StageDesignerDrawEvent(_this.name + ".drawEnd", _this.canvas, _extends({}, relativeDims, {
          worldX: worldX,
          worldY: worldY
        }));

        _this.canvas.dispatchEvent(_this.name + ".drawEnd", stageDesignerDrawEndEvent);
      });

      _this.canvas.addEventListener('DrawComponent.click', function (data) {
        var _data$dimensions7 = data.dimensions,
            worldX = _data$dimensions7.worldX,
            worldY = _data$dimensions7.worldY;

        var relativeDims = _this.getDimsFromArtboard(data.dimensions);

        var stageDesignerClickEvent = new StageDesignerDrawEvent(_this.name + ".click", _this.canvas, _extends({}, relativeDims, {
          worldX: worldX,
          worldY: worldY,
          height: undefined,
          width: undefined
        }));

        _this.canvas.dispatchEvent(_this.name + ".click", stageDesignerClickEvent);
      });
    };

    this.getDimsFromArtboard = function (layerPoints) {
      var relativeX = 0;
      var relativeY = 0;
      var layerX = get(layerPoints, 'worldX', undefined);
      var layerY = get(layerPoints, 'worldY', undefined);
      var height = get(layerPoints, 'height', undefined);
      var width = get(layerPoints, 'width', undefined);

      if (layerX && _this.selectedArtboard) {
        relativeX = layerX - _this.selectedArtboard.rootX;
      }

      if (layerY && _this.selectedArtboard) {
        relativeY = layerY - _this.selectedArtboard.rootY;
      }

      return {
        x: relativeX,
        y: relativeY,
        height: height,
        width: width
      };
    };
  }

  var _proto = StageDesignerDrawComponent.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
  };

  _proto.activate = function activate() {
    this.addListeners();
  };

  _proto.deactivate = function deactivate() {};

  return StageDesignerDrawComponent;
}();

var StageDesignerRulerPlugin = /*#__PURE__*/function () {
  function StageDesignerRulerPlugin() {
    var _this = this;

    this.name = 'StageDesignerRuler';
    this.rulerVisibility = true;
    this.artboardLinesMap = new Map();

    this.showRuler = function (context) {
      _this.rulerVisibility = true;

      _this.canvas.executeFunction('RulerScale.show');

      _this.canvas.executeFunction('RulerLines.show');
    };

    this.hideRuler = function (context) {
      _this.rulerVisibility = false;

      _this.canvas.executeFunction('RulerScale.hide');

      _this.canvas.executeFunction('RulerLines.hide');
    };

    this.artboardSelected = function (event) {
      var selectedArtboard = event.artboard;
      var artboardDims = selectedArtboard.getBoundingClientRect();

      if (selectedArtboard) {
        var _this$canvas$convertP = _this.canvas.convertPoint({
          x: selectedArtboard.rootX,
          y: selectedArtboard.rootY
        }, 'world', 'viewport'),
            x = _this$canvas$convertP.x,
            y = _this$canvas$convertP.y;

        _this.canvas.executeFunction('RulerScale.setInitialPoint', {
          x: x,
          y: y
        });
      }

      _this.canvas.executeFunction('RulerLines.removeAll');

      var artboardLines = _this.artboardLinesMap.get(selectedArtboard) || [];

      if (artboardLines.length !== 0) {
        artboardLines = artboardLines.map(function (ruler) {
          if (ruler.axis === 'x') {
            return {
              axis: 'x',
              axisCoordinate: artboardDims.rootY + ruler.axisCoordinate
            };
          } else {
            return {
              axis: 'y',
              axisCoordinate: artboardDims.rootX + ruler.axisCoordinate
            };
          }
        });
      }

      _this.canvas.executeFunction('RulerLines.addAll', artboardLines);

      if (!_this.rulerVisibility) {
        _this.canvas.executeFunction('RulerLines.hide', artboardLines);
      }
    };

    this.getAllLines = function (context, selectedArtboard) {
      if (!selectedArtboard) {
        selectedArtboard = _this.canvas.executeFunction('getSelectedArtboard');
      }

      return _this.artboardLinesMap.get(selectedArtboard);
    };

    this.getLineCoordinates = function () {
      var selectedArtboard = _this.canvas.executeFunction('getSelectedArtboard');

      var coordinates = {
        x: [],
        y: []
      };

      if (!selectedArtboard) {
        return coordinates;
      }

      var rulerLines = _this.artboardLinesMap.get(selectedArtboard);

      if (!rulerLines) {
        return coordinates;
      }

      forEach(rulerLines, function (line) {
        if (line.axis === 'y') {
          coordinates.y.push(line.axisCoordinate);
        } else {
          coordinates.x.push(line.axisCoordinate);
        }
      });
      return coordinates;
    };

    this.addLine = function (event) {
      var selectedArtboard = _this.canvas.executeFunction('getSelectedArtboard');

      if (!selectedArtboard) return;
      var artboardDims = selectedArtboard.getBoundingClientRect();

      var artboardLines = _this.artboardLinesMap.get(selectedArtboard);

      if (!artboardLines) {
        artboardLines = [];
      }

      var artboardAxisCoordinate = event.axis === 'x' ? artboardDims.rootY : artboardDims.rootX;
      artboardLines.push({
        axis: event.axis,
        axisCoordinate: event.axisCoordinate - artboardAxisCoordinate
      });

      _this.artboardLinesMap.set(selectedArtboard, artboardLines);
    };

    this.setPosition = function (event) {
      var selectedArtboard = _this.canvas.executeFunction('getSelectedArtboard');

      if (!selectedArtboard) return;
      var artboardDims = selectedArtboard.getBoundingClientRect();

      var artboardLines = _this.artboardLinesMap.get(selectedArtboard);

      var artboardAxisCoordinate = event.axis === 'x' ? artboardDims.rootY : artboardDims.rootX;
      var line = {
        axis: event.axis,
        axisCoordinate: event.axisCoordinate - artboardAxisCoordinate
      };

      if (artboardLines) {
        if (event.index || event.index === 0) {
          artboardLines[event.index] = line;
        } else {
          artboardLines[artboardLines.length - 1] = line;
        }
      } else {
        artboardLines = [];
        artboardLines.push(line);
      }

      _this.artboardLinesMap.set(selectedArtboard, artboardLines);
    };

    this.removeLine = function (event) {
      var selectedArtboard = _this.canvas.executeFunction('getSelectedArtboard');

      if (!selectedArtboard) return;

      var artboardLines = _this.artboardLinesMap.get(selectedArtboard);

      artboardLines == null ? void 0 : artboardLines.splice(event.index, 1);

      _this.artboardLinesMap.set(selectedArtboard, artboardLines || []);
    };
  }

  var _proto = StageDesignerRulerPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
  };

  _proto.activate = function activate() {
    var _this2 = this;

    this.canvas.addEventListener('artboardSelected', this.artboardSelected);
    this.canvas.addEventListener('RulerLines.add', this.addLine);
    this.canvas.addEventListener('RulerLines.setPosition', this.setPosition);
    this.canvas.addEventListener('RulerLines.remove', this.removeLine);
    this.canvas.addFunction(this.name + ".getAllLines", this.getAllLines);
    this.canvas.addFunction(this.name + ".getLineCoordinates", this.getLineCoordinates);
    this.canvas.addFunction(this.name + ".show", this.showRuler);
    this.canvas.addFunction(this.name + ".hide", this.hideRuler);
    this.canvas.on('scroll', function (e) {
      var selectedArtboard = _this2.canvas.executeFunction('getSelectedArtboard');

      if (selectedArtboard) {
        var _this2$canvas$convert = _this2.canvas.convertPoint({
          x: selectedArtboard.rootX,
          y: selectedArtboard.rootY
        }, 'world', 'viewport'),
            x = _this2$canvas$convert.x,
            y = _this2$canvas$convert.y;

        _this2.canvas.executeFunction('RulerScale.setInitialPoint', {
          x: x,
          y: y
        });
      }
    });
  };

  _proto.deactivate = function deactivate() {
    this.canvas.removeEventListener('artboardSelected', this.artboardSelected);
    this.canvas.removeEventListener('RulerLines.add', this.addLine);
    this.canvas.removeEventListener('RulerLines.setPosition', this.setPosition);
    this.canvas.removeEventListener('RulerLines.remove', this.removeLine);
    this.canvas.removeFunction(this.name + ".getAllLines");
    this.canvas.removeFunction(this.name + ".getLineCoordinates");
    this.canvas.removeFunction(this.name + ".show");
    this.canvas.removeFunction(this.name + ".hide");
  };

  return StageDesignerRulerPlugin;
}();

var DrawEvent = /*#__PURE__*/function (_Event) {
  _inheritsLoose(DrawEvent, _Event);

  function DrawEvent(name, target, payload, currentTarget, meta) {
    var _this;

    _this = _Event.call(this, name, target, currentTarget) || this;
    _this.dimensions = {
      worldX: payload.x,
      worldY: payload.y,
      height: payload.height,
      width: payload.width
    };
    _this.meta = meta;
    return _this;
  }

  return DrawEvent;
}(Event);

var DrawComponent = /*#__PURE__*/function () {
  function DrawComponent() {
    var _this = this;

    this.name = 'DrawComponent';
    this.dragStart = {
      x: 0,
      y: 0
    };
    this.isShiftPressed = false;
    this.isAltPressed = false;
    this.dims = {
      x: 0,
      y: 0,
      height: 0,
      width: 0
    };
    this.dragSession = {
      start: {
        x: 0,
        y: 0,
        deltaX: 0,
        deltaY: 0
      },
      current: {
        x: 0,
        y: 0,
        deltaX: 0,
        deltaY: 0
      },
      end: {
        x: 0,
        y: 0,
        deltaX: 0,
        deltaY: 0
      }
    };
    this.initialDimensions = {
      x: 0,
      y: 0,
      height: 0,
      width: 0,
      rotation: 0
    };
    this.newDimensions = {
      x: 0,
      y: 0,
      height: 0,
      width: 0,
      rotation: 0
    };

    this.getQuad = function (start, current) {
      if (current.x < start.x && current.y > start.y) return 2;else if (current.x < start.x && current.y <= start.y) return 3;else if (current.x >= start.x && current.y < start.y) return 4;else return 1; // DOC:  quad as  3|4
      //                2|1
    };

    this.onMouseMove = function (shapeType, e) {
      var startX = 0;
      var startY = 0; // let initialDimensions = {
      //   x: startX,
      //   y: startY,
      //   height: 0,
      //   width: 0,
      //   rotation: 0,
      // };

      if (_this.mouseDown && !_this.dragStarted) {
        if (e.pageX && e.pageY) {
          // let val = this.canvas.executeFunction('HtmlDragToWorld.drag', e);
          startX = _this.dims.x;
          startY = _this.dims.y;
          _this.initialDimensions.x = startX;
          _this.initialDimensions.y = startY;
          _this.initialDimensions.width = 0;
          _this.initialDimensions.height = 0;

          var snappedData = _this.canvas.executeFunction('snapToPoints', _this.snapPoints, [_this.initialDimensions.x, _this.initialDimensions.y], [0, 0], _extends({}, _this.initialDimensions), [0, 0], [_this.initialDimensions.x, _this.initialDimensions.y], 0, _this.initialDimensions);

          _this.initialDelta = snappedData.delta;
          _this.newDimensions = computeOrientation(_this.initialDimensions, snappedData.delta, 'C', false, false);
          _this.dims.x = _this.newDimensions.x;
          _this.dims.y = _this.newDimensions.y;
          _this.initialDimensions.x = _this.dims.x;
          _this.initialDimensions.y = _this.dims.y;
          _this.dragStarted = true;
          var drawEvent = new DrawEvent(_this.name + ".draw", _this.canvas, _extends({}, _this.initialDimensions), undefined, snappedData.meta);

          _this.canvas.dispatchEvent(_this.name + ".draw", drawEvent);
        }
      } else if (_this.dragStarted) {
        var zoom = _this.canvas.getZoom();

        var canvasDims = _this.canvas.getBoundingClientRect(); // console.log(this.dims, 'dims here @@@@');


        if (e.pageX && e.pageY) {
          var val = _this.canvas.executeFunction('HtmlDragToWorld.drag', e);

          _this.dragSession.current = val.session.current; // this.dims.x =
          //   this.dragSession.current.x <= this.dragSession.start.x
          //     ? this.dragSession.current.x
          //     : this.dragSession.start.x;
          // this.dims.y =
          //   this.dragSession.current.y <= this.dragSession.start.y
          //     ? this.dragSession.current.y
          //     : this.dragSession.start.y;
          // this.dims.height = Math.abs(
          //   this.dragSession.current.y - this.dragSession.start.y
          // );
          // this.dims.width = Math.abs(
          //   this.dragSession.current.x - this.dragSession.start.x
          // );

          var left = _this.dims.x;
          var top = _this.dims.y; // console.log(this.dims, 'dims here @@@@');
          var totalDx = val.session.current.x - val.session.start.x + _this.initialDelta.x;
          var totalDy = val.session.current.y - val.session.start.y + _this.initialDelta.y;

          var _snappedData = _this.canvas.executeFunction('snapToPoints', _this.snapPoints, [_this.initialDimensions.x, _this.initialDimensions.y], [totalDx, totalDy], _extends({}, _this.initialDimensions), [totalDx, totalDy], [_this.initialDimensions.x, _this.initialDimensions.y], 0, _this.initialDimensions);

          var delta = _snappedData.delta;
          var handle = '';

          if (delta.x >= 0) {
            handle += 'R';
          }

          if (delta.x < 0) {
            handle += 'L';
          }

          if (delta.y >= 0) {
            handle += 'B';
          }

          if (delta.y < 0) {
            handle += 'T';
          }

          _this.newDimensions = computeOrientation(_this.initialDimensions, delta, handle, _this.isShiftPressed, _this.isAltPressed);
          _this.renderer.style.backgroundColor = 'transparent';

          if (shapeType === 'rect') {
            _this.renderer.style.position = 'absolute';
            _this.renderer.style.left = _this.newDimensions.x ? _this.newDimensions.x + 'px' : '';
            _this.renderer.style.top = _this.newDimensions.y ? _this.newDimensions.y + 'px' : ''; // this.renderer.style.right = right ? right + 'px' : '';
            // this.renderer.style.bottom = bottom ? bottom + 'px' : '';

            _this.renderer.style.height = _this.newDimensions.height + 'px';
            _this.renderer.style.width = _this.newDimensions.width + 'px';
            _this.renderer.style.border = 1 / zoom + "px solid black";
          } else if (shapeType === 'ellipse') {
            _this.overlayLayer.style.display = 'block';
            _this.renderer.style.position = 'absolute';
            _this.renderer.style.left = _this.newDimensions.x;
            _this.renderer.style.top = _this.newDimensions.y;

            _this.renderer.setAttribute('height', _this.newDimensions.height + 'px');

            _this.renderer.setAttribute('width', _this.newDimensions.width + 'px');

            _this.ellipseRenderer.setAttribute('cx', _this.newDimensions.width / 2 + 'px');

            _this.ellipseRenderer.setAttribute('cy', _this.newDimensions.height / 2 + 'px');

            var strokeZoomAdjustment = 1 / (2 * zoom);

            _this.ellipseRenderer.setAttribute('rx', _this.newDimensions.width !== 0 ? _this.newDimensions.width / 2 - strokeZoomAdjustment + 'px' : 0);

            _this.ellipseRenderer.setAttribute('ry', _this.newDimensions.height !== 0 ? _this.newDimensions.height / 2 - strokeZoomAdjustment + 'px' : 0);

            _this.ellipseRenderer.style.strokeWidth = 1 / zoom + "px";
          }

          _this.overlayLayer.appendChild(_this.renderer); // snap logic


          var _drawEvent = new DrawEvent(_this.name + ".draw", _this.canvas, _extends({}, _this.newDimensions), undefined, _snappedData.meta);

          var viewportDims = _this.canvas.convertPoint(_this.newDimensions, 'world', 'viewport');

          _this.canvas.executeFunction('Tooltip.show', {
            x: viewportDims.x + _this.newDimensions.width * zoom,
            y: viewportDims.y + _this.newDimensions.height * zoom
          }, Math.round(_this.newDimensions.width) + " \u2715 " + Math.round(_this.newDimensions.height));

          _this.canvas.dispatchEvent(_this.name + ".draw", _drawEvent);
        }
      }
    };

    this.onMouseUp = function (e) {
      _this.dragStarted = false;
      _this.mouseDown = false;
      var drawEndEvent = new DrawEvent(_this.name + ".drawEnd", _this.canvas, {
        x: _this.newDimensions.x,
        y: _this.newDimensions.y,
        height: _this.newDimensions.height,
        width: _this.newDimensions.width
      });

      _this.canvas.executeFunction('Tooltip.hide');

      _this.newDimensions.height = 0;
      _this.newDimensions.width = 0;
      _this.renderer.style.width = '0px';
      _this.renderer.style.height = '0px';
      _this.renderer.style.display = 'none';

      _this.overlayDispose();

      _this.canvas.setMouseCursor('default');

      _this.canvas.dispatchEvent(_this.name + ".drawEnd", drawEndEvent);

      if (_this.overlayLayer) {
        _this.overlayLayer.ownerDocument.removeEventListener('mousemove', _this.boundMouseMove);

        _this.overlayLayer.ownerDocument.removeEventListener('mouseup', _this.boundMouseUp);

        _this.overlayLayer.ownerDocument.removeEventListener('contextmenu', _this.boundMouseUp);
      }

      _this.renderer = undefined;
      _this.overlayLayer = undefined;
      _this.shapeType = undefined;
    };

    this.clickEvent = function (data) {
      var clickEvent = new DrawEvent(_this.name + ".click", _this.canvas, {
        x: data.worldX,
        y: data.worldY,
        height: undefined,
        width: undefined
      });

      _this.canvas.dispatchEvent(_this.name + ".click", clickEvent);
    };

    this.abortDraw = function () {
      _this.dragStarted = false;
      _this.mouseDown = false;
      _this.dims.height = 0;
      _this.dims.width = 0;

      if (_this.renderer && _this.renderer.style) {
        _this.renderer.style.width = '0px';
        _this.renderer.style.height = '0px';
        _this.renderer.style.display = 'none';
      }

      _this.canvas.executeFunction('Tooltip.hide');

      if (_this.overlayDispose) {
        _this.overlayDispose();
      }

      _this.canvas.setMouseCursor('default');

      _this.canvas.removeEventListener('click', _this.clickEvent);

      if (_this.overlayLayer) {
        _this.overlayLayer.ownerDocument.removeEventListener('mousemove', _this.boundMouseMove);

        _this.overlayLayer.ownerDocument.removeEventListener('mouseup', _this.boundMouseUp);

        _this.overlayLayer.ownerDocument.removeEventListener('contextmenu', _this.boundMouseUp);

        _this.renderer = undefined;
        _this.overlayLayer = undefined;
      }

      _this.shapeType = undefined;
    };

    this.setSnapPoints = function (context, snapPoints) {
      _this.snapPoints = snapPoints;

      if (_this.snapPoints) {
        _this.snapPoints.parentSnapPoints.x.forEach(function (point) {
          point.value = point.rootValue;
        });

        _this.snapPoints.parentSnapPoints.y.forEach(function (point) {
          point.value = point.rootValue;
        });

        _this.snapPoints.siblingSnapPoints.x.forEach(function (point) {
          point.value = point.rootValue;
        });

        _this.snapPoints.siblingSnapPoints.y.forEach(function (point) {
          point.value = point.rootValue;
        });

        _this.snapPoints.rulerSnapPoints.x.forEach(function (point) {
          point.value = point.rootValue;
        });

        _this.snapPoints.rulerSnapPoints.y.forEach(function (point) {
          point.value = point.rootValue;
        });
      }
    };
  }

  var _proto = DrawComponent.prototype;

  _proto.drawShape = function drawShape(context, shapeType, cursor) {
    var _this2 = this;

    if (shapeType === void 0) {
      shapeType = 'rect';
    }

    if (cursor === void 0) {
      cursor = 'crosshair';
    }

    if (this.shapeType && this.shapeType !== shapeType) {
      this.abortDraw();
    }

    if (!this.mouseDown && !this.overlayLayer) {
      var left = 0;
      var top = 0;
      var drawShape = new DrawEvent(this.name + ".drawShape", this.canvas, {
        x: left,
        y: top,
        height: 0,
        width: 0
      }, undefined, {});
      this.canvas.dispatchEvent(this.name + ".drawShape", drawShape);
      this.canvas.setMouseCursor(cursor);
      this.shapeType = shapeType;

      if (shapeType === 'rect') {
        this.renderer = document.createElement('div');
      } else if (shapeType === 'ellipse') {
        var svgns = 'http://www.w3.org/2000/svg';
        this.renderer = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        this.ellipseRenderer = document.createElementNS(svgns, 'ellipse');
        this.ellipseRenderer.style.fill = 'transparent';
        this.ellipseRenderer.style.stroke = 'black';
        this.renderer.appendChild(this.ellipseRenderer);
      }

      this.renderer.style.position = 'absolute';
      var canvasDims = this.canvas.getBoundingClientRect();
      this.overlayLayer = document.createElement('div');
      this.overlayLayer.style.background = 'transparent';
      this.overlayLayer.style.height = canvasDims.height + 'px';
      this.overlayLayer.style.width = canvasDims.width + 'px';
      this.overlayLayer.style.top = canvasDims.y + 'px';
      this.overlayLayer.style.left = canvasDims.x + 'px';
      this.overlayLayer.style.pointerEvents = 'none';
      this.overlayLayer.style.position = 'absolute';
      this.overlayLayer.style.zIndex = 1;
      this.overlayDispose = this.canvas.addDomToWorld(this.overlayLayer, true, 105);
      this.overlayLayer.addEventListener("mousemove", function (e) {
        //
        if (!_this2.mouseDown) {
          var dragStartVal = _this2.canvas.executeFunction('HtmlDragToWorld.dragStart', e, {
            x: 0,
            y: 0,
            height: 0,
            width: 0,
            rotation: 0
          });

          left = dragStartVal.session.start.x;
          top = dragStartVal.session.start.y;
          var dimension = {
            x: left,
            y: top,
            width: 0,
            height: 0
          };

          var snappedData = _this2.canvas.executeFunction('snapToPoints', _this2.snapPoints, [left, top], [0, 0], _extends({}, dimension), [0, 0], [left, top], 0, _this2.initialDimensions);

          dimension = _extends({}, dimension, {
            x: dimension.x + snappedData.delta.x,
            y: dimension.y + snappedData.delta.y
          });
          var drawEvent = new DrawEvent(_this2.name + ".mousemove", _this2.canvas, _extends({}, dimension), undefined, snappedData.meta);

          _this2.canvas.dispatchEvent(_this2.name + ".mousemove", drawEvent);
        } //   let dragStartVal = this.canvas.executeFunction(
        //     'HtmlDragToWorld.dragStart',
        //     e,
        //     { x: 0, y: 0, height: 0, width: 0, rotation: 0 }
        //   );
        //   left = dragStartVal.session.start.x;
        //   top = dragStartVal.session.start.y;
        // }
        // const snappedData = this.canvas.executeFunction(
        //   'snapToPoints',
        //   this.snapPoints,
        //   [left, top],
        //   [0, 0],
        //   {
        //     x: left,
        //     y: top,
        //     width: 0,
        //     height: 0,
        //     rotation: 0,
        //   },
        //   [0, 0],
        //   [top, left],
        //   0
        // );

      });
      this.overlayLayer.addEventListener("mousedown", function (e) {
        var dragStartVal = _this2.canvas.executeFunction('HtmlDragToWorld.dragStart', e, {
          x: 0,
          y: 0,
          height: 0,
          width: 0,
          rotation: 0
        });

        left = dragStartVal.session.start.x;
        top = dragStartVal.session.start.y;
        _this2.dragSession.start = dragStartVal.session.start;
        _this2.mouseDown = true;
        _this2.dragStarted = false;
        _this2.dims = {
          x: left,
          y: top,
          height: 0,
          width: 0
        };
        _this2.newDimensions = {
          x: left,
          y: top,
          height: 0,
          width: 0
        };
        _this2.boundMouseMove = _this2.onMouseMove.bind(_this2, shapeType);
        _this2.boundMouseUp = _this2.onMouseUp;

        _this2.overlayLayer.ownerDocument.addEventListener('mousemove', _this2.boundMouseMove);

        _this2.overlayLayer.ownerDocument.addEventListener('mouseup', _this2.boundMouseUp);

        _this2.overlayLayer.ownerDocument.addEventListener('contextmenu', _this2.boundMouseUp);

        var drawStartEvent = new DrawEvent(_this2.name + ".drawStart", _this2.canvas, {
          x: left,
          y: top,
          height: 0,
          width: 0
        });

        _this2.canvas.dispatchEvent(_this2.name + ".drawStart", drawStartEvent);
      });
      this.canvas.addEventListener('click', this.clickEvent);
    }
  };

  _proto.init = function init(canvas) {
    this.canvas = canvas;
  };

  _proto.activate = function activate() {
    var _this3 = this;

    this.canvas.addFunction('drawShape', this.drawShape.bind(this));
    this.canvas.addFunction('abortDraw', this.abortDraw.bind(this));
    this.canvas.addFunction('DrawComponent.setSnapPoints', this.setSnapPoints.bind(this));
    this.canvas.addEventListener('blur', function () {
      if (_this3.isAltPressed) _this3.isAltPressed = false;
      if (_this3.isShiftPressed) _this3.isShiftPressed = false;
    });
    this.canvas.addEventListener('keyUp', function (data) {
      var event = data.originalEvent ? data.originalEvent : data;

      if (event.keyCode === 16) {
        _this3.isShiftPressed = false;
      }

      if (event.keyCode === 18) {
        _this3.isAltPressed = false;
      }
    });
    this.canvas.addEventListener('keyDown', function (data) {
      var event = data.originalEvent ? data.originalEvent : data;

      if (event.keyCode === 16) {
        _this3.isShiftPressed = true;
      }

      if (event.keyCode === 18) {
        _this3.isAltPressed = true;
      }
    });
  };

  _proto.deactivate = function deactivate() {
    this.canvas.removeFunction('drawShape');
    this.canvas.removeFunction('abortDraw');
    this.canvas.removeFunction('DrawComponent.setSnapPoints');
    this.overlayDispose();
  };

  return DrawComponent;
}();

var LayerLabelEvent = /*#__PURE__*/function (_DesignerMouseEvent) {
  _inheritsLoose(LayerLabelEvent, _DesignerMouseEvent);

  function LayerLabelEvent(name, target, originalEvent, payload, currentTarget) {
    var _this;

    _this = _DesignerMouseEvent.call(this, name, target, originalEvent, currentTarget) || this;
    var canvas = target.getCanvas();
    _this.worldDx = payload.worldDx;
    _this.worldDy = payload.worldDy;
    var pagePoints = canvas.convertPoint({
      x: payload.worldDx,
      y: payload.worldDy
    }, 'world', 'page');
    _this.pageDx = pagePoints.x;
    _this.pageDy = pagePoints.y;
    var viewportPoints = canvas.convertPoint({
      x: _this.pageDx,
      y: _this.pageDy
    }, 'page', 'viewport');
    _this.viewportDx = viewportPoints.x;
    _this.viewportDy = viewportPoints.y;
    return _this;
  }

  return LayerLabelEvent;
}(DesignerMouseEvent);

var LayerLabel = /*#__PURE__*/function () {
  function LayerLabel() {
    var _this = this;

    this.name = 'LayerLabel';
    this.lastPageX = 0;
    this.lastPageY = 0;
    this.dragStart = {
      x: 0,
      y: 0
    };
    this.dims = {
      x: 0,
      y: 0,
      height: 0,
      width: 0
    };
    this.layerLabelMap = new Map([]);

    this.selectedArtboardChanged = function (event) {
      var selectedArtboard = event.artboard;

      if (selectedArtboard) {
        _this.layerLabelMap.forEach(function (label, artboard) {
          if (label.labeltextNode.parentElement) {
            if (artboard === selectedArtboard) {
              label.labeltextNode.parentElement.style.color = 'rgb(26, 170, 198)';
            } else {
              label.labeltextNode.parentElement.style.color = 'rgb(186, 189, 198)';
            }
          }
        });
      }
    };
  }

  var _proto = LayerLabel.prototype;

  _proto.handleGhostImage = function handleGhostImage(e) {
    var crt = e.target.cloneNode(true);
    crt.style.backgroundColor = 'red';
    crt.style.opacity = 0;
    crt.style.pointerEvents = 'none';
    document.body.appendChild(crt);
    this.ghostImageDOM = crt;
    e.dataTransfer.setDragImage(crt, 0, 0);
  };

  _proto.updateLabelLayout = function updateLabelLayout(label, layer) {
    label.style.top = layer.rootY - 20 / this.canvas.getZoom() + 'px';
    label.style.left = layer.rootX + 'px';
    label.style.height = 20 / this.canvas.getZoom() + "px";
    label.style.fontSize = 12 / this.canvas.getZoom() + "px";
  };

  _proto.setLabel = function setLabel(context, layerLabel) {
    var layer = this.layerLabelMap.get(context.layer);
    var layertextNode = layer.labeltextNode;
    layertextNode.nodeValue = layerLabel;
  };

  _proto.removeLabel = function removeLabel(context) {
    var layerCallback = this.layerLabelMap.get(context.layer).removeCallback;
    layerCallback();
  };

  _proto.hideLabel = function hideLabel(context) {
    var label = this.layerLabelMap.get(context.layer);

    if (label && label.labelNode) {
      label.labelNode.style.display = 'none';
    }
  };

  _proto.showLabel = function showLabel(context) {
    var label = this.layerLabelMap.get(context.layer);

    if (label && label.labelNode) {
      label.labelNode.style.display = '';
    }
  };

  _proto.addLabel = function addLabel(context, layerLabel) {
    var _this2 = this;

    var layer = context.layer;
    var label = document.createElement('span');
    var labeltext = document.createTextNode(layerLabel);
    label.appendChild(labeltext);
    label.style.position = 'absolute';
    label.style.top = layer.rootY - 20 / this.canvas.getZoom() + 'px';
    label.style.left = layer.rootX + 'px'; // label.style.width = layer.getBoundingClientRect().width + 'px';
    // label.style.letterSpacing = '1px';

    label.style.height = 20 / this.canvas.getZoom() + "px";
    label.style.fontSize = 12 / this.canvas.getZoom() + "px"; //label.style.lineHeight = '0.7px';

    label.style.fontFamily = 'Roboto, -apple-system, BlinkMacSystemFont, sans-serif';
    label.style.textOverflow = 'ellipsis';
    label.style.color = 'rgb(186, 189, 198)';
    label.style.overflow = 'hidden';
    label.style.fontWeight = '300px';
    label.style.letterSpacing = '0.6px';
    this.canvas.on('zoom', function () {
      _this2.updateLabelLayout(label, context.layer);
    });

    if (layer.parent) {
      layer.parent.addEventListener('removeChild', function (event) {
        if (layer === event.layer) layer.executeFunction('LayerLabel.remove');
      });
    }

    var dispose = this.canvas.addDomToWorld(label, true, 101);
    label.setAttribute('class', 'file-header ' + label.className);
    label.setAttribute('data-cypress-id', 'file-header');
    this.layerLabelMap.set(layer, {
      removeCallback: dispose,
      labelNode: label,
      labeltextNode: labeltext
    });
    label.style.pointerEvents = 'all';
    context.layer.on('layout', function () {
      _this2.updateLabelLayout(label, context.layer);
    });
    context.layer.on('updateDom', function () {
      _this2.updateLabelLayout(label, context.layer);
    });
    this.canvas.executeFunction('handleHtmlDrag', label);
    label.addEventListener('htmlDragStart', function (e) {
      var dragVal = _this2.canvas.executeFunction('HtmlDragToWorld.dragStart', e, {
        x: 0,
        y: 0,
        height: 0,
        width: 0,
        rotation: 0
      });

      _this2.lastPageX = dragVal.event.worldX;
      _this2.lastPageY = dragVal.event.worldY;
      var labelDragStartEvent = new LayerLabelEvent("dragStart", context.layer, e, {
        worldX: dragVal.event.worldX,
        worldY: dragVal.event.worldY
      }, context.layer);
      layer.dispatchEvent("dragStart", labelDragStartEvent);
    });
    label.addEventListener('htmlDrag', function (e) {
      if (e.pageX && e.pageY) {
        var dragVal = _this2.canvas.executeFunction('HtmlDragToWorld.drag', e);

        if (dragVal.session.current.deltaX || dragVal.session.current.deltaY) {
          var relPos = {
            x: dragVal.event.worldX - _this2.lastPageX,
            y: dragVal.event.worldY - _this2.lastPageY
          };
          var labelDragEvent = new LayerLabelEvent("drag", context.layer, e, {
            worldDx: relPos.x,
            worldDy: relPos.y
          });
          layer.dispatchEvent("drag", labelDragEvent);
          _this2.lastPageX = dragVal.event.worldX;
          _this2.lastPageY = dragVal.event.worldY;
        }
      }
    });
    label.addEventListener('contextmenu', function (e) {
      _this2.canvas.dispatchEventOnHitLayer(e.type, new DesignerMouseEvent(e.type, _this2.canvas, e, _this2.canvas), e);
    });
    label.addEventListener('htmlDragEnd', function (e) {
      var dragVal = layer.executeFunction('HtmlDragToWorld.dragEnd', e); // let relPos = {
      //   x: dragVal.event.worldX - this.lastPageX,
      //   y: dragVal.event.worldY - this.lastPageY,
      // };

      var labelDragEndEvent = new LayerLabelEvent("dragEnd", context.layer, e, {
        worldX: dragVal.event.worldX,
        worldY: dragVal.event.worldY
      }, context.layer);
      layer.dispatchEvent("dragEnd", labelDragEndEvent);
      _this2.lastPageX = 0;
      _this2.lastPageY = 0;
    });
    label.addEventListener('click', function (e) {
      var labelClickEvent = new LayerLabelEvent(_this2.name + ".click", layer, e, {});
      layer.dispatchEvent(_this2.name + ".click", labelClickEvent);
    });
    label.addEventListener('dblclick', function (e) {
      var layerDoubleClickEvent = new LayerLabelEvent(_this2.name + ".doubleClick", layer, e, {});
      layer.dispatchEvent(_this2.name + ".doubleClick", layerDoubleClickEvent);
    });
  };

  _proto.init = function init(canvas) {
    this.canvas = canvas;
  };

  _proto.activate = function activate() {
    this.canvas.addFunction(this.name + ".add", this.addLabel.bind(this));
    this.canvas.addFunction(this.name + ".set", this.setLabel.bind(this));
    this.canvas.addFunction(this.name + ".remove", this.removeLabel.bind(this));
    this.canvas.addFunction(this.name + ".show", this.showLabel.bind(this));
    this.canvas.addFunction(this.name + ".hide", this.hideLabel.bind(this));
    this.canvas.addEventListener('artboardSelected', this.selectedArtboardChanged);
  };

  _proto.deactivate = function deactivate() {};

  return LayerLabel;
}();

var IPhoneXFrame = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(IPhoneXFrame, _React$Component);

  function IPhoneXFrame() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = IPhoneXFrame.prototype;

  _proto.render = function render() {
    var _this$props = this.props,
        deviceOrientation = _this$props.deviceOrientation,
        left = _this$props.left,
        top = _this$props.top;
    var computedLeft = deviceOrientation === 'landscape' ? left + 211 : left - 8;
    var computedTop = deviceOrientation === 'landscape' ? top - 225 : top - 8;
    var computedTransform = deviceOrientation === 'landscape' ? "rotate(270deg)" : 'none';
    var styleObject = {
      position: 'absolute',
      pointerEvents: 'none',
      // zIndex: 1,
      left: computedLeft,
      top: computedTop,
      transform: computedTransform
    };
    return createElement("div", {
      style: styleObject
    }, createElement("svg", {
      width: "388px",
      height: "824px",
      viewBox: "-2 -2 388 824",
      version: "1.1",
      xmlnsXlink: "http://www.w3.org/1999/xlink"
    }, createElement("path", {
      d: "M46,6 C23.909,6 6,23.909 6,46 L6,778 C6,800.091 23.909,818 46,818 L341,818 C363.091,818 381,800.091 381,\n            778 L381,46 C381,23.909 363.091,6 341,6 L46,6 Z M112.04,37 C99.337,37 89.04,26.703 89.04,13.961\n            L89.046,10.037 C89.0345531,9.99058934 89.0205314,9.94485191 89.004,9.9 C88.334,8.086 86.78,6.674\n            84.892,6.216 L84,6 L303,6 L302.108,6.216 C300.210771,6.68271966 298.67094,8.06429185 298.002,9.9\n            C297.970221,9.98647005 297.953971,10.0778752 297.954,10.17 L297.961,14 C297.961,26.703 287.663,37\n            274.961,37 L112.039,37 L112.04,37 Z M0,0 L388,0 L388,824 L0,824 L0,0 Z M128.5,800 C127.119288,800\n            126,801.119288 126,802.5 C126,803.880712 127.119288,805 128.5,805 L258.5,805 C259.880712,805 261,803.880712\n            261,802.5 C261,801.119288 259.880712,800 258.5,800 L128.5,800 Z",
      fill: "#171A21",
      fillRule: "evenodd",
      id: "Shape"
    })));
  };

  return IPhoneXFrame;
}(Component);

var IPhoneXsMaxFrame = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(IPhoneXsMaxFrame, _React$Component);

  function IPhoneXsMaxFrame() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = IPhoneXsMaxFrame.prototype;

  _proto.render = function render() {
    var _this$props = this.props,
        deviceOrientation = _this$props.deviceOrientation,
        left = _this$props.left,
        top = _this$props.top;
    var computedLeft = deviceOrientation === 'landscape' ? left + 235 : left - 8;
    var computedTop = deviceOrientation === 'landscape' ? top - 248 : top - 8;
    var computedTransform = deviceOrientation === 'landscape' ? "rotate(270deg)" : 'none';
    var styleObject = {
      position: 'absolute',
      pointerEvents: 'none',
      zIndex: 1,
      left: computedLeft,
      top: computedTop,
      transform: computedTransform
    };
    return createElement("div", {
      style: styleObject
    }, createElement("svg", {
      // this width, height too
      width: "427px",
      height: "908px",
      // after 15 years of efforts, I have written this specific viewBox, dare not touch it ever
      viewBox: "0 -2 384 825",
      version: "1.1",
      xmlnsXlink: "http://www.w3.org/1999/xlink"
    }, createElement("path", {
      d: "M46,6 C23.909,6 6,23.909 6,46 L6,778 C6,800.091 23.909,818 46,818 L341,818 C363.091,818 381,800.091 381,\n            778 L381,46 C381,23.909 363.091,6 341,6 L46,6 Z M112.04,37 C99.337,37 89.04,26.703 89.04,13.961\n            L89.046,10.037 C89.0345531,9.99058934 89.0205314,9.94485191 89.004,9.9 C88.334,8.086 86.78,6.674\n            84.892,6.216 L84,6 L303,6 L302.108,6.216 C300.210771,6.68271966 298.67094,8.06429185 298.002,9.9\n            C297.970221,9.98647005 297.953971,10.0778752 297.954,10.17 L297.961,14 C297.961,26.703 287.663,37\n            274.961,37 L112.039,37 L112.04,37 Z M0,0 L388,0 L388,824 L0,824 L0,0 Z M128.5,800 C127.119288,800\n            126,801.119288 126,802.5 C126,803.880712 127.119288,805 128.5,805 L258.5,805 C259.880712,805 261,803.880712\n            261,802.5 C261,801.119288 259.880712,800 258.5,800 L128.5,800 Z",
      fill: "#171A21",
      fillRule: "evenodd",
      id: "Shape"
    })));
  };

  return IPhoneXsMaxFrame;
}(Component);

var DeviceFrame = /*#__PURE__*/function () {
  function DeviceFrame() {
    var _this = this;

    this.name = 'DeviceFrame';
    this.deviceFrameMap = new Map([]);
    this.lastPageX = 0;
    this.lastPageY = 0;
    this.dragStart = {
      x: 0,
      y: 0
    };
    this.dims = {
      x: 0,
      y: 0,
      height: 0,
      width: 0
    };
    this.DeviceFrameMap = new Map([]); // updateFrameLayout(layer: any) {
    //   this.render();
    // }

    this.selectedArtboardChanged = function (event) {
      var selectedArtboard = event.artboard;

      if (selectedArtboard) {
        _this.DeviceFrameMap.forEach(function (label, artboard) {
          if (artboard === selectedArtboard) {
            var layerTextNode = label.labeltextNode;
            layerTextNode.parentElement.style.color = 'rgb(26, 170, 198)';
          } else {
            label.labeltextNode.parentElement.style.color = 'rgb(186, 189, 198)';
          }
        });
      }
    };

    this.render = function (layer) {
      var FrameComponent;

      var deviceFrame = _this.deviceFrameMap.get(layer);

      if (!deviceFrame) {
        return;
      }

      deviceFrame.frameNode.style.top = layer.getBoundingClientRect().rootY + 'px';
      deviceFrame.frameNode.style.left = layer.getBoundingClientRect().rootX + 'px';

      if (deviceFrame.deviceName) {
        switch (deviceFrame.deviceName.toLowerCase()) {
          case 'iphone x':
          case 'iphone xs':
          case 'iphone 11 pro':
            FrameComponent = createElement(IPhoneXFrame, {
              deviceOrientation: deviceFrame.deviceOrientation,
              left: 0,
              top: 0
            });
            break;

          case 'iphone xs max':
          case 'iphone xr':
          case 'iphone 11 pro max':
          case 'iphone 11':
            FrameComponent = createElement(IPhoneXsMaxFrame, {
              deviceOrientation: deviceFrame.deviceOrientation,
              left: 0,
              top: 0
            });
            break;
        }
      }

      if (!FrameComponent) {
        return;
      }

      ReactDOM__default.render(FrameComponent, deviceFrame.frameNode);
    };
  }

  var _proto = DeviceFrame.prototype;

  _proto.removeFrame = function removeFrame(context) {
    var deviceFrame = this.deviceFrameMap.get(context.layer);

    if (deviceFrame) {
      deviceFrame.removeCallback();
    }
  };

  _proto.addFrame = function addFrame(context, deviceName, deviceOrientation) {
    var _this2 = this;

    var layer = context.layer;
    var deviceFrame = this.deviceFrameMap.get(layer);

    if (deviceFrame) {
      deviceFrame.removeCallback();
    }

    var wrapperDiv = document.createElement('div');
    wrapperDiv.className = 'frame-wrappers';
    wrapperDiv.style.pointerEvents = 'none';
    wrapperDiv.style.position = 'absolute';
    var dispose = this.canvas.addDomToWorld(wrapperDiv, true, 100);
    this.deviceFrameMap.set(layer, {
      removeCallback: dispose,
      frameNode: wrapperDiv,
      deviceName: deviceName,
      deviceOrientation: deviceOrientation
    });
    this.render(layer);

    if (layer.parent) {
      layer.parent.addEventListener('removeChild', function (event) {
        if (layer === event.layer) layer.executeFunction('DeviceFrame.remove');
      });
    }

    context.layer.on('layout', function () {
      _this2.render(context.layer);
    });
    context.layer.on('updateDom', function () {
      _this2.render(context.layer);
    });
  };

  _proto.init = function init(canvas) {
    this.canvas = canvas;
  };

  _proto.activate = function activate() {
    this.canvas.addFunction(this.name + ".add", this.addFrame.bind(this));
    this.canvas.addFunction(this.name + ".remove", this.removeFrame.bind(this));
    this.canvas.addEventListener('artboardSelected', this.selectedArtboardChanged);
  };

  _proto.deactivate = function deactivate() {};

  return DeviceFrame;
}();

var BatterySection = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(BatterySection, _React$Component);

  function BatterySection() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = BatterySection.prototype;

  _proto.render = function render() {
    return createElement("div", {
      style: {
        position: 'absolute',
        top: 0,
        left: this.props.left
      }
    }, createElement("svg", {
      width: "150px",
      height: "24px",
      viewBox: "0 0 150 24",
      version: "1.1",
      xmlnsXlink: "http://www.w3.org/1999/xlink"
    }, createElement("g", {
      stroke: "none",
      strokeWidth: 1,
      fill: "none",
      fillRule: "evenodd"
    }, createElement("rect", {
      // fill={this.props.backgroundColor}
      x: 0,
      y: 0,
      width: 150,
      height: 24
    }))));
  };

  return BatterySection;
}(Component);
var NetworkSection = /*#__PURE__*/function (_React$Component2) {
  _inheritsLoose(NetworkSection, _React$Component2);

  function NetworkSection() {
    return _React$Component2.apply(this, arguments) || this;
  }

  var _proto2 = NetworkSection.prototype;

  _proto2.render = function render() {
    // //console.log("NetworkSection", this.props.left, this.props.width);
    return createElement("div", {
      style: {
        position: 'absolute',
        top: 0,
        left: this.props.left
      }
    }, createElement("svg", {
      width: "116px",
      height: "24px",
      viewBox: "0 0 116 24",
      version: "1.1",
      xmlnsXlink: "http://www.w3.org/1999/xlink"
    }, createElement("g", {
      // transform="translate(242.000000, 0.000000)"
      strokeWidth: 1
    }, createElement("text", {
      opacity: "0.9",
      transform: "translate(74.000000, 4.000000)",
      fill: this.props.color,
      fontFamily: "Roboto-Medium, Roboto",
      fontSize: 14,
      fontWeight: 400
    }, createElement("tspan", {
      x: "0.459960938",
      y: 13
    }, "12:30")), createElement("g", {
      transform: "translate(55.000000, 4.000000)",
      fill: "transparent"
    }, createElement("polygon", {
      points: "0 0 16 0 16 16 0 16"
    }), createElement("polygon", {
      fill: this.props.color,
      points: "9 1.875 9 1 6 1 6 1.875 3 1.875 3 15 12 15 12 1.875"
    })), createElement("g", {
      transform: "translate(35.000000, 4.000000)",
      fill: "transparent"
    }, createElement("polygon", {
      points: "0 0 16 0 16 16 0 16"
    }), createElement("polygon", {
      fill: this.props.color,
      points: "0 15 14 15 14 1"
    })), createElement("g", {
      transform: "translate(14.000000, 4.000000)",
      fill: "transparent"
    }, createElement("polygon", {
      points: "2 0 18 0 18 16 2 16"
    }), createElement("path", {
      d: "M.977 4.016A14.934 14.934 0 0 1 10 1c3.387 0 6.512 1.123 9.023 3.016L10 15 .977 4.016z",
      fill: this.props.color
    })))));
  };

  return NetworkSection;
}(Component);
var AndroidStatusBar = (function (props) {
  var backgroundColor = props.backgroundColor ? props.backgroundColor : '#000';
  var color = props.color ? props.color : '#FFF';
  return createElement("div", {
    style: {
      position: 'relative',
      width: props.width,
      height: 24,
      zIndex: 1,
      backgroundColor: backgroundColor
    }
  }, createElement(BatterySection, {
    width: props.width,
    // backgroundColor={backgroundColor}
    left: 0
  }), createElement(NetworkSection, {
    width: props.width,
    color: color,
    left: props.width - 115
  }));
});

var RightSection = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(RightSection, _React$Component);

  function RightSection() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = RightSection.prototype;

  _proto.render = function render() {
    return createElement("div", {
      style: {
        position: 'absolute',
        top: 13,
        left: this.props.left
      }
    }, createElement("svg", {
      width: "97px",
      height: "18px",
      viewBox: "0 0 145 27",
      version: "1.1",
      xmlnsXlink: "http://www.w3.org/1999/xlink"
    }, createElement("g", {
      transform: "translate(-461.000000, -204.000000) translate(88.000000, 201.000000)\n            translate(373.000000, 3.000000)",
      stroke: "none",
      strokeWidth: 1,
      fill: "none",
      fillRule: "evenodd"
    }, createElement("path", {
      d: "M0 11.99c0-.546.444-.99 1-.99h3a1 1 0 0 1 1 .99v4.02c0 .546-.444.99-1 .99H1a1\n              1 0 0 1-1-.99v-4.02zm7-2.992C7 8.447 7.444 8 8 8h3c.552 0 1 .446 1 .998v7.004c0\n              .551-.444.998-1 .998H8c-.552 0-1-.446-1-.998V8.998zm7-4A.997.997 0 0 1 15 4h3a1 1 0 0\n              1 1 .999V16A.997.997 0 0 1 18 17h-3a1 1 0 0 1-1-.999V5zm7-2.997C21 1.448 21.444 1 22\n              1h3c.552 0 1 .445 1 1v14c0 .552-.444 1-1 1h-3c-.552 0-1-.445-1-1V2z",
      fill: this.props.color
    }), createElement("path", {
      d: "M32.348 5.634C38.603-.621 48.745-.621 55 5.634l-2.35\n              2.35c-4.957-4.957-12.994-4.957-17.951 0l-2.35-2.35zm3.858 3.857c4.125-4.124 10.812-4.124\n              14.936 0l-2.028 2.03a7.692 7.692 0 0 0-10.88 0l-2.028-2.03zm3.33 3.33a5.853 5.853 0 0\n              1 8.277 0l-4.139 4.139-4.138-4.139z",
      fill: this.props.color
    }), createElement("g", {
      transform: "translate(61.000000, 0.000000)"
    }, createElement("rect", {
      stroke: this.props.color,
      // stroke="none"
      opacity: "0.300000012",
      x: "0.5",
      y: "0.5",
      width: 31,
      height: 17,
      rx: 6
    }), createElement("rect", {
      fill: this.props.color,
      x: 3,
      y: 3,
      width: 26,
      height: 12,
      rx: 3
    }), createElement("path", {
      d: "M34 7a2 2 0 1 1 0 4V7z",
      fill: this.props.color
    })))));
  };

  return RightSection;
}(Component);
var LeftSection = /*#__PURE__*/function (_React$Component2) {
  _inheritsLoose(LeftSection, _React$Component2);

  function LeftSection() {
    return _React$Component2.apply(this, arguments) || this;
  }

  var _proto2 = LeftSection.prototype;

  _proto2.render = function render() {
    return createElement("div", {
      style: {
        position: 'absolute',
        top: 13,
        left: this.props.left
      }
    }, createElement("svg", {
      version: "1.1",
      xmlnsXlink: "http://www.w3.org/1999/xlink"
    }, createElement("g", {
      fill: this.props.color,
      stroke: "none",
      strokeWidth: 1,
      fillRule: "evenodd"
    }, createElement("g", {
      fill: this.props.color
    }, createElement("text", {
      fontFamily: ".AppleSystemUIFont",
      fontSize: "11.9931181",
      fontWeight: "normal"
    }, createElement("tspan", {
      x: 0,
      y: 13
    }, "9:41 AM")), createElement("path", {
      d: "M61.797 2.5a2.163 2.163 0 0 0-.763.134l-.339.133 2.764 2.763.242.221.12-.312a2.186 2.186 0 0\n                0-.495-2.304 2.18 2.18 0 0 0-1.529-.636zm-5.535.002a2.185 2.185 0 0 0-1.656.633 2.18 2.18 0 0 0-.502\n                2.292l.133.34L57 3.002l.22-.241-.31-.122-.046-.019a2.153 2.153 0 0 0-.602-.119zm2.704.866a4.568 4.568\n                0 0 0-4.562 4.562 4.568 4.568 0 0 0 4.562 4.563A4.568 4.568 0 0 0 63.53 7.93a4.568 4.568 0 0\n                0-4.563-4.562zm0 1.303c.12 0 .217.098.217.217V7.93c0 .12-.097.217-.217.217h-1.738a.217.217 0\n                0 1 0-.434h1.52V4.888c0-.12.098-.217.218-.217z",
      fillRule: "nonzero"
    })))));
  };

  return LeftSection;
}(Component);
var IPhoneXStatusBar = (function (props) {
  return createElement("div", {
    style: {
      position: 'relative',
      width: '100%',
      height: 44,
      zIndex: 1
    }
  }, createElement(LeftSection, {
    left: 14,
    width: 83,
    color: props.color
  }), createElement(RightSection, {
    left: props.width - 80,
    width: 83,
    color: props.color
  }));
});

var BatterySection$1 = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(BatterySection, _React$Component);

  function BatterySection() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = BatterySection.prototype;

  _proto.render = function render() {
    return createElement("div", {
      style: {
        position: 'absolute',
        top: 2.5,
        left: this.props.left
      }
    }, createElement("svg", {
      version: "1.1",
      xmlnsXlink: "http://www.w3.org/1999/xlink"
    }, createElement("g", {
      fill: this.props.color,
      stroke: "none",
      strokeWidth: 1,
      fillRule: "evenodd"
    }, createElement("g", {
      strokeWidth: 1,
      fillRule: "evenodd"
    }, createElement("path", {
      d: "M37.494 2.5h19.512c.82 0 1.494.674 1.494 1.505v6.49c0 .837-.669\n              1.505-1.494 1.505H37.494c-.82 0-1.494-.674-1.494-1.505v-6.49c0-.837.669-1.505\n              1.494-1.505zM59 5.5h.75c.417 0 .75.332.75.742v2.016a.748.748 0 0 1-.75.742H59V5.5zM37.508\n              3c-.557 0-1.008.457-1.008 1.008v6.484c0 .557.45 1.008 1.008 1.008h19.484c.557 0 1.008-.457\n              1.008-1.008V4.008C58 3.451 57.55 3 56.992 3H37.508zm-.001.5h19.486c.277\n              0 .507.22.507.492v6.516a.497.497 0 0 1-.507.492H37.507a.502.502 0 0\n              1-.507-.492V3.992c0-.276.227-.492.507-.492z"
    }), createElement("text", {
      fontFamily: ".AppleSystemUIFont",
      fontSize: 12,
      fontWeight: "normal"
    }, createElement("tspan", {
      x: "2.85351562",
      y: "11.5"
    }, "100%"))))));
  };

  return BatterySection;
}(Component);
var NetworkSection$1 = /*#__PURE__*/function (_React$Component2) {
  _inheritsLoose(NetworkSection, _React$Component2);

  function NetworkSection() {
    return _React$Component2.apply(this, arguments) || this;
  }

  var _proto2 = NetworkSection.prototype;

  _proto2.render = function render() {
    return createElement("div", {
      style: {
        position: 'absolute',
        top: 2.5,
        left: this.props.left
      }
    }, createElement("svg", {
      version: "1.1",
      xmlnsXlink: "http://www.w3.org/1999/xlink",
      fill: "red"
    }, createElement("g", {
      fill: this.props.color,
      stroke: "none",
      strokeWidth: 1,
      fillRule: "evenodd"
    }, createElement("g", {
      strokeWidth: 1,
      fillRule: "evenodd"
    }, createElement("path", {
      d: "M90.144 9.439L88.023 11.5 85.86 9.405a2.857 2.857 0 0 1 2.128-.936c.864 0\n              1.638.376 2.156.97zm2.18-2.118l-1.09 1.058a4.417 4.417 0 0 0-3.246-1.402c-1.274 0-2.42.528-3.219\n              1.372l-1.09-1.056a5.979 5.979 0 0 1 4.309-1.809c1.713 0 3.257.708 4.335 1.837zM94.5 5.207l-1.088\n              1.057a7.539 7.539 0 0 0-5.424-2.272 7.54 7.54 0 0 0-5.398 2.245L81.5 5.182A9.1 9.1 0 0 1 87.988 2.5\n              9.1 9.1 0 0 1 94.5 5.207z"
    }), createElement("text", {
      fontFamily: ".AppleSystemUIFont",
      fontSize: 12,
      fontWeight: "normal"
    }, createElement("tspan", {
      x: 38,
      y: "11.5"
    }, "Carrier")), createElement("path", {
      d: "M3.25 10a2.75 2.75 0 1 1 0-5.5 2.75 2.75 0 0 1 0 5.5zm7 0a2.75 2.75 0 1\n              1 0-5.5 2.75 2.75 0 0 1 0 5.5zm7 0a2.75 2.75 0 1 1 0-5.5 2.75 2.75 0 0 1 0 5.5zm7 0a2.75 2.75\n              0 1 1 0-5.5 2.75 2.75 0 0 1 0 5.5zm7 0a2.75 2.75 0 1 1 0-5.5 2.75 2.75 0 0 1 0 5.5z"
    })))));
  };

  return NetworkSection;
}(Component);
var TimeSection = /*#__PURE__*/function (_React$Component3) {
  _inheritsLoose(TimeSection, _React$Component3);

  function TimeSection() {
    return _React$Component3.apply(this, arguments) || this;
  }

  var _proto3 = TimeSection.prototype;

  _proto3.render = function render() {
    return createElement("div", {
      style: {
        position: 'absolute',
        top: 2.5,
        left: this.props.left
      }
    }, createElement("svg", {
      version: "1.1",
      xmlnsXlink: "http://www.w3.org/1999/xlink"
    }, createElement("g", {
      fill: this.props.color,
      stroke: "none",
      strokeWidth: 1,
      fillRule: "evenodd"
    }, createElement("text", {
      fontFamily: ".AppleSystemUIFont",
      fontSize: 12,
      fontWeight: "normal"
    }, createElement("tspan", {
      x: "0",
      y: "11.5"
    }, "9:41 AM")))));
  };

  return TimeSection;
}(Component);
var BackgroundRect = /*#__PURE__*/function (_React$Component4) {
  _inheritsLoose(BackgroundRect, _React$Component4);

  function BackgroundRect() {
    return _React$Component4.apply(this, arguments) || this;
  }

  var _proto4 = BackgroundRect.prototype;

  _proto4.render = function render() {
    return createElement("div", {
      style: {
        position: 'absolute',
        top: 0,
        left: 0,
        width: this.props.width
      }
    }, createElement("svg", {
      width: this.props.width + "px",
      height: "20px",
      viewBox: "0 0 " + this.props.width + " 20",
      version: "1.1",
      xmlnsXlink: "http://www.w3.org/1999/xlink"
    }, createElement("g", {
      stroke: "none",
      strokeWidth: 1,
      fill: "none",
      fillRule: "evenodd"
    }, createElement("rect", {
      fill: this.props.backgroundColor,
      x: 0,
      y: 0,
      width: this.props.width,
      height: 20
    }))));
  };

  return BackgroundRect;
}(Component);
var IOSStatusBar = (function (props) {
  return createElement("div", {
    style: {
      position: 'relative',
      width: props.width,
      height: 20,
      zIndex: 1
    }
  }, createElement(BackgroundRect, {
    backgroundColor: props.backgroundColor,
    width: props.width
  }), createElement(NetworkSection$1, {
    left: 3,
    color: props.color
  }), createElement(TimeSection, {
    color: props.color,
    left: props.width / 2 - 20
  }), createElement(BatterySection$1, {
    color: props.color,
    left: props.width - 65
  }));
});

var StatusBarComponent = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(StatusBarComponent, _React$Component);

  function StatusBarComponent(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;

    _this.onUpdate = function () {// this.forceUpdate();
    };

    _this.attachStatusBarListeners = function () {// const statusBarRenderLayer = this.props.layer;
      // const statusBarLayer = statusBarRenderLayer.domainCompiledRef.domainRef;
      // if (statusBarLayer) {
      //   statusBarLayer.props.on('hidden', this.onUpdate);
      //   statusBarLayer.props.on('backgroundColor', this.onUpdate);
      //   statusBarLayer.props.on('barStyle', this.onUpdate);
      //   statusBarLayer.props.on('animated', this.onUpdate);
      // }
      // if (this.props.layer.getFile()) {
      //   this.props.layer.getFile().on('height', this.onUpdate);
      //   this.props.layer.getFile().on('width', this.onUpdate);
      // }
    };

    _this.removeStatusBarListeners = function () {// const statusBarRenderLayer = this.props.layer;
      // const statusBarLayer = statusBarRenderLayer.domainCompiledRef.domainRef;
      // if (statusBarLayer) {
      //   statusBarLayer.props.off('hidden', this.onUpdate);
      //   statusBarLayer.props.off('backgroundColor', this.onUpdate);
      //   statusBarLayer.props.off('barStyle', this.onUpdate);
      //   statusBarLayer.props.off('animated', this.onUpdate);
      // }
      // if (this.props.layer.getFile()) {
      //   this.props.layer.getFile().off('height', this.onUpdate);
      //   this.props.layer.getFile().off('width', this.onUpdate);
      // }
      // // if (this.props.layer.parent) {
      // //   this.props.layer.parent.off("height", this.onUpdate);
      // //   this.props.layer.parent.off("width", this.onUpdate);
      // // }
    };

    return _this;
  }

  var _proto = StatusBarComponent.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.props.layer.on(['layout', 'updateDom'], this.onUpdate);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var _this2 = this;

    prevProps.layer.off(['layout', 'updateDom'], this.onUpdate);
    this.props.layer.on(['layout', 'updateDom'], function () {
      _this2.onUpdate();
    });
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.layer.off(['layout', 'updateDom'], this.onUpdate);
  };

  _proto.getElement = function getElement() {
    if (!this.props.layer) {
      return null;
    }

    var deviceName = this.props.deviceName;
    var deviceOS = this.props.deviceOS;
    var deviceOrientation = this.props.deviceOrientation;
    var barColor = '#000';
    var deviceWidth = this.props.width;
    var deviceHeight = this.props.height; // if (deviceOrientation === 'portrait') {
    //   deviceWidth = device.resolution.width / device.pixelRatio;
    //   deviceHeight = device.resolution.height / device.pixelRatio;
    // } else {
    //   deviceWidth = device.resolution.height / device.pixelRatio;
    //   deviceHeight = device.resolution.width / device.pixelRatio;
    // }

    var style = {// display: statusBarRenderLayer.props.style.display,
    }; // if (statusBarRenderLayer.props.hidden) {
    //   return null;
    // }
    // const height = renderFile ? renderFile.height : 0;
    // const width = renderFile ? renderFile.width : 0;

    var IPHONEX_OR_IPHONEXS = false;
    var IPHONEXR_OR_IPHONEXSMAX = false;

    if (deviceOS && deviceName) {
      IPHONEX_OR_IPHONEXS = deviceOS.toLowerCase() === 'ios' && (deviceName.toLowerCase() === 'iphone x' || deviceName.toLowerCase() === 'iphone xs' || deviceName.toLowerCase() === 'iphone 11 pro');
      IPHONEXR_OR_IPHONEXSMAX = deviceOS.toLowerCase() === 'ios' && (deviceName.toLowerCase() === 'iphone xr' || deviceName.toLowerCase() === 'iphone xs max' || deviceName.toLowerCase() === 'iphone 11' || deviceName.toLowerCase() === 'iphone 11 pro max');
    } //    &&
    // ((deviceWidth === height && deviceHeight === width) ||
    //   (deviceWidth === width && deviceHeight === height));


    var IOS = deviceOS === 'iOS';
    var WEB = deviceOS === 'Web';

    if (WEB) {
      return null;
    }

    if (IOS && !IPHONEX_OR_IPHONEXS && !IPHONEXR_OR_IPHONEXSMAX) {
      if (this.props.barStyle === 'light-content') {
        barColor = '#ffffff';
      } else if (this.props.barStyle === 'dark-content') {
        barColor = '#000000';
      }

      return createElement("div", {
        style: {
          position: 'absolute',
          top: 0,
          left: 0
        }
      }, createElement(IOSStatusBar, {
        width: deviceWidth,
        color: barColor,
        style: style
      }));
    } else if (IPHONEX_OR_IPHONEXS || IPHONEXR_OR_IPHONEXSMAX) {
      if (this.props.barStyle === 'light-content') {
        barColor = '#ffffff';
      } else if (this.props.barStyle === 'dark-content') {
        barColor = '#000000';
      }

      return createElement("div", {
        style: {
          position: 'absolute',
          top: 0,
          left: 0
        }
      }, createElement(IPhoneXStatusBar, {
        width: deviceWidth,
        deviceOrientation: deviceOrientation,
        backgroundColor: "rgba(255,255,255,0.2)",
        color: barColor,
        style: style
      }));
    } else {
      if (this.props.barStyle === 'light-content') {
        barColor = '#ffffff';
      } else if (this.props.barStyle === 'dark-content') {
        barColor = '#404040';
      }

      return createElement("div", {
        style: {
          position: 'absolute',
          top: 0,
          left: 0
        }
      }, createElement(AndroidStatusBar, {
        width: deviceWidth,
        height: deviceHeight,
        backgroundColor: this.props.backgroundColor || '#999999',
        color: barColor,
        style: style
      }));
    }
  };

  _proto.render = function render() {
    return this.getElement();
  };

  return StatusBarComponent;
}(Component);

var StatusBar = /*#__PURE__*/function () {
  function StatusBar() {
    var _this = this;

    this.name = 'StatusBar';
    this.statusBarMap = new Map([]);
    this.lastPageX = 0;
    this.lastPageY = 0;
    this.dragStart = {
      x: 0,
      y: 0
    };
    this.dims = {
      x: 0,
      y: 0,
      height: 0,
      width: 0
    }; // updateFrameLayout(layer: any) {
    //   this.render();
    // }

    this.selectedArtboardChanged = function (event) {// const selectedArtboard = event.artboard;
      // if (selectedArtboard) {
      //   this.statusBarMap.forEach((label: any, artboard: any) => {
      //     if (artboard === selectedArtboard) {
      //       let layerTextNode = label.labeltextNode;
      //       layerTextNode.parentElement.style.color = 'rgb(26, 170, 198)';
      //     } else {
      //       label.labeltextNode.parentElement.style.color = 'rgb(186, 189, 198)';
      //     }
      //   });
      // }
    };

    this.render = function (layer) {
      var deviceFrame = _this.statusBarMap.get(layer);

      if (!deviceFrame) {
        return;
      }

      deviceFrame.frameNode.style.top = layer.getBoundingClientRect().rootY + 'px';
      deviceFrame.frameNode.style.left = layer.getBoundingClientRect().rootX + 'px'; // const statusBarConfig = layer.executeFunction('getData', 'statusBarConfig');

      ReactDOM__default.render(createElement(StatusBarComponent, {
        layer: layer,
        width: layer.getBoundingClientRect().width,
        height: layer.getBoundingClientRect().height,
        deviceName: deviceFrame.deviceName,
        deviceOS: deviceFrame.deviceOS,
        deviceOrientation: deviceFrame.deviceOrientation,
        barStyle: deviceFrame.barStyle,
        backgroundColor: deviceFrame.backgroundColor
      }), deviceFrame.frameNode);
    };
  }

  var _proto = StatusBar.prototype;

  _proto.removeStatusBar = function removeStatusBar(context) {
    var deviceFrame = this.statusBarMap.get(context.layer);

    if (deviceFrame) {
      deviceFrame.removeCallback();
    }
  };

  _proto.addStatusBar = function addStatusBar(context, config) {
    var _this2 = this;

    var layer = context.layer;
    var deviceFrame = this.statusBarMap.get(layer);

    if (deviceFrame) {
      deviceFrame.removeCallback();
    }

    var wrapperDiv = document.createElement('div');
    wrapperDiv.className = 'status-bar-wrappers';
    wrapperDiv.style.position = 'absolute';
    var dispose = this.canvas.addDomToWorld(wrapperDiv, true, 100);
    wrapperDiv.style.pointerEvents = 'none';
    this.statusBarMap.set(layer, {
      removeCallback: dispose,
      frameNode: wrapperDiv,
      deviceName: config.deviceName,
      deviceOS: config.deviceOS,
      deviceOrientation: config.deviceOrientation,
      barStyle: config.barStyle,
      backgroundColor: config.backgroundColor
    });
    this.render(layer);

    if (layer.parent) {
      layer.parent.addEventListener('removeChild', function (event) {
        if (layer === event.layer) layer.executeFunction('StatusBar.remove');
      });
    }

    context.layer.on('layout', function () {
      _this2.render(context.layer);
    });
    context.layer.on('updateDom', function () {
      _this2.render(context.layer);
    });
  };

  _proto.init = function init(canvas) {
    this.canvas = canvas;
  };

  _proto.activate = function activate() {
    this.canvas.addFunction(this.name + ".add", this.addStatusBar.bind(this));
    this.canvas.addFunction(this.name + ".remove", this.removeStatusBar.bind(this)); // this.canvas.addEventListener(
    //   'artboardSelected',
    //   this.selectedArtboardChanged
    // );
  };

  _proto.deactivate = function deactivate() {};

  return StatusBar;
}();

var ResizerRendererDragEvent = /*#__PURE__*/function (_MouseEvent) {
  _inheritsLoose(ResizerRendererDragEvent, _MouseEvent);

  function ResizerRendererDragEvent(name, targetHandle, startValues, session, originalEvent, target, currentTarget) {
    var _this;

    _this = _MouseEvent.call(this, name, target, originalEvent, currentTarget) || this;
    _this.targetHandle = targetHandle;
    _this.session = session;
    _this.startValues = startValues;
    return _this;
  }

  return ResizerRendererDragEvent;
}(DesignerMouseEvent);

function getInitialRotation(handleName) {
  switch (handleName) {
    case 'TL':
      return 0;

    case 'T':
      return 45;

    case 'TR':
      return 90;

    case 'R':
      return 135;

    case 'BR':
      return 180;

    case 'B':
      return 225;

    case 'BL':
      return 270;

    case 'L':
      return 315;

    default:
      return 0;
  }
}
function getRotationResizerIcon(rotation) {
  return "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <svg width=\"20px\" height=\"20px\" viewBox=\"0 0 564 581\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n      <defs>\n          <path d=\"M477.685,171.292105 L371.8863,39.25 L263.608591,171.292105 L335.318307,171.23947 C335.404758,201.878069 335.447983,217.197368 335.447983,217.197368 C335.447983,240.945561 331.697189,285.753289 307.961066,309.007895 C286.086784,330.438429 244.930829,340.175619 223.588558,340.175619 L167.014783,340.175619 L166.896133,269.807895 L35.685,375.028947 L166.896133,480.25 L166.896133,410.453368 L223.42583,410.453368 C276.561146,410.453368 325.08715,391.950329 360.415853,357.229972 C395.744556,322.509615 406.110126,270.927723 406.110126,217.334067 C406.110126,217.334067 406.066901,201.986747 405.98045,171.292105 L477.685,171.292105 Z\" id=\"path-1\"></path>\n          <filter x=\"-22.4%\" y=\"-22.4%\" width=\"147.3%\" height=\"147.4%\" filterUnits=\"objectBoundingBox\" id=\"filter-2\">\n              <feMorphology radius=\"14\" operator=\"dilate\" in=\"SourceAlpha\" result=\"shadowSpreadOuter1\"></feMorphology>\n              <feOffset dx=\"2\" dy=\"2\" in=\"shadowSpreadOuter1\" result=\"shadowOffsetOuter1\"></feOffset>\n              <feGaussianBlur stdDeviation=\"25\" in=\"shadowOffsetOuter1\" result=\"shadowBlurOuter1\"></feGaussianBlur>\n              <feComposite in=\"shadowBlurOuter1\" in2=\"SourceAlpha\" operator=\"out\" result=\"shadowBlurOuter1\"></feComposite>\n              <feColorMatrix values=\"0 0 0 0 0.0487149004   0 0 0 0 0.0471071601   0 0 0 0 0.0471071601  0 0 0 1 0\" type=\"matrix\" in=\"shadowBlurOuter1\"></feColorMatrix>\n          </filter>\n      </defs>\n      <g id=\"Page-1\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n          <g id=\"iPhone-8\" transform=\"translate(0.000000, -95.000000)\">\n              <g id=\"curve-arrow\" transform=\"translate(21.000000, 131.000000)\">\n                  <g id=\"Path\" fill-rule=\"nonzero\" transform=\"translate(256.685000, 259.750000) rotate(" + (180 + rotation) + ") translate(-256.685000, -259.750000) \">\n                      <use fill=\"black\" fill-opacity=\"1\" filter=\"url(#filter-2)\" xlink:href=\"#path-1\"></use>\n                      <use stroke=\"#FCF7F7\" stroke-width=\"26\" fill=\"#000000\" xlink:href=\"#path-1\"></use>\n                  </g>\n              </g>\n          </g>\n      </g>\n  </svg>";
}
function getHorizontalResizerIcon(rotation) {
  return "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <svg width=\"20px\" height=\"20px\" viewBox=\"0 0 512 512\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n      <defs>\n          <path d=\"M30,256.450973 L156.560656,361 L156.597461,295.437849 C156.852233,295.437849 157.086901,295.480695 157.343864,295.480695 L343.414557,295.480695 C343.671649,295.480695 343.955674,295.444441 344.210833,295.437849 L344.053652,361 L482,256.343185 L344.053652,151 L344.210833,217.464668 C343.955932,217.464668 343.67152,217.421822 343.414557,217.421822 L157.343864,217.421822 C157.086772,217.421822 156.85249,217.458076 156.597461,217.464668 L156.560656,151 L30,256.450973 Z\" id=\"path-1\"></path>\n          <filter x=\"-21.8%\" y=\"-51.0%\" width=\"144.7%\" height=\"203.6%\" filterUnits=\"objectBoundingBox\" id=\"filter-2\">\n              <feMorphology radius=\"14\" operator=\"dilate\" in=\"SourceAlpha\" result=\"shadowSpreadOuter1\"></feMorphology>\n              <feOffset dx=\"2\" dy=\"2\" in=\"shadowSpreadOuter1\" result=\"shadowOffsetOuter1\"></feOffset>\n              <feGaussianBlur stdDeviation=\"25\" in=\"shadowOffsetOuter1\" result=\"shadowBlurOuter1\"></feGaussianBlur>\n              <feComposite in=\"shadowBlurOuter1\" in2=\"SourceAlpha\" operator=\"out\" result=\"shadowBlurOuter1\"></feComposite>\n              <feColorMatrix values=\"0 0 0 0 0.0448086504   0 0 0 0 0.0442135355   0 0 0 0 0.0442135355  0 0 0 1 0\" type=\"matrix\" in=\"shadowBlurOuter1\"></feColorMatrix>\n          </filter>\n      </defs>\n      <g id=\"Page-1\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n          <g id=\"iPhone-8-Copy\">\n              <g id=\"rect3044-174-4-7-5-8-7-1-1-3-2\">\n                  <g id=\"rect3044-174-4-7-5-8-7-1-1-3\" fill-rule=\"nonzero\" transform=\"translate(256.000000, 256.000000) rotate(" + (45 + rotation) + ") translate(-256.000000, -256.000000) \">\n                      <use fill=\"black\" fill-opacity=\"1\" filter=\"url(#filter-2)\" xlink:href=\"#path-1\"></use>\n                      <use stroke=\"#FCF9F9\" stroke-width=\"26\" fill=\"#000000\" xlink:href=\"#path-1\"></use>\n                  </g>\n              </g>\n          </g>\n      </g>\n  </svg>";
}

var ResizerRendererPlugin = /*#__PURE__*/function () {
  function ResizerRendererPlugin() {
    var _this = this;

    this.name = 'ResizerRenderer';
    this.namespace = 'ResizerRenderer';
    this.allowClickEvents = false;
    this.passedEvent = ['mousedown', 'mouseup', 'mousemove', 'dblclick', 'contextmenu', 'click', 'drop'];
    this.show = true;
    this.mouseDown = false;
    this.dragStarted = false;
    this.handleDragStarted = false;

    this.passEvent = function (e) {
      // FIXME: If we include this, drag events get fired and mouse rect starts showing but we need this in case sibling overlaps and the bottom one is already selected and we are trying to drag the top one.
      if (e.type !== 'mousedown') {
        if (e.type === 'mousemove') {
          if (_this.mouseDown) {
            _this.dragStarted = true;
          }
        }

        if (_this.dragStarted && _this.mouseDown) ; else {
          _this.canvas.dispatchEventOnHitLayer(e.type, new DesignerMouseEvent(e.type, _this.canvas, e, _this.canvas), e);
        }

        if (e.type === 'mouseup') {
          _this.dragStarted = false;
          _this.mouseDown = false;

          _this.canvas.dispatchEventOnHitLayer(e.type, new DesignerMouseEvent(e.type, _this.canvas, e, _this.canvas), e);
        }
      } else {
        if (e.button !== 2 && e.which !== 3) {
          _this.mouseDown = true;
        }
      }
    };

    this.renderDragLayer = function () {
      var dragLayer = document.createElement('div');
      dragLayer.style.pointerEvents = 'auto';
      dragLayer.style.position = 'absolute';
      dragLayer.style.top = '0';
      dragLayer.style.left = '0';
      dragLayer.style.right = '0';
      dragLayer.style.bottom = '0';
      dragLayer.setAttribute('class', 'resizer move ' + dragLayer.className);

      _this.wrapperLayer.appendChild(dragLayer);

      _this.handleLayerListeners(dragLayer);

      _this.canvas.executeFunction('handleHtmlDrag', dragLayer);

      dragLayer.addEventListener('htmlDragStart', function (e) {
        var dragVal = _this.canvas.executeFunction('HtmlDragToWorld.dragStart', e, _this.resizerData.dims);

        _this.canvas.blockMouseEvents();

        _this.canvas.dispatchEvent(_this.namespace + ".dragStart", new ResizerRendererDragEvent(_this.namespace + ".handleDragStart", 'C', dragVal.startValues, dragVal.session, dragVal.event, _this.canvas));

        return false;
      });
      dragLayer.addEventListener('htmlDrag', function (e) {
        if (e.pageX && e.pageY) {
          var dragVal = _this.canvas.executeFunction('HtmlDragToWorld.drag', e);

          if (dragVal.session.current.deltaX !== 0 || dragVal.session.current.deltaY !== 0) {
            _this.canvas.dispatchEvent(_this.namespace + ".drag", new ResizerRendererDragEvent(_this.namespace + ".drag", 'C', dragVal.startValues, dragVal.session, dragVal.event, _this.canvas));
          }
        }
      });
      dragLayer.addEventListener('htmlDragEnd', function (e) {
        var dragVal = _this.canvas.executeFunction('HtmlDragToWorld.drag', e);

        _this.canvas.unblockMouseEvents();

        _this.canvas.dispatchEvent(_this.namespace + ".dragEnd", new ResizerRendererDragEvent(_this.namespace + ".dragEnd", 'C', dragVal.startValues, dragVal.session, dragVal.event, _this.canvas));
      });
    };
  }

  var _proto = ResizerRendererPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
    this.dispose = null;
    this.resizerData = {
      dims: {
        x: 0,
        y: 0,
        height: 0,
        width: 0,
        rotation: 0
      },
      handles: []
    };
    this.resizerHandleLayersRef = new Map();
  };

  _proto.setHandleStyle = function setHandleStyle(handleInstance, handleName) {
    var zoom = this.canvas.getZoom();
    var rotationHandleSize = 20;
    var handleSize = 10;

    if (handleName === 'ROTATE') {
      return;
    }

    var propsWithoutPx = {
      position: 'absolute',
      display: '',
      'background-color': 'rgba(255, 255, 255, 1)',
      border: 1 / zoom + "px solid #1FB2CC",
      'pointer-events': 'auto',
      'z-index': '1'
    };
    var fixedLayoutProps = {
      height: handleSize / zoom,
      width: handleSize / zoom,
      'margin-left': -1 / zoom - handleSize / (2 * zoom),
      'margin-top': -1 / zoom - handleSize / (2 * zoom),
      'margin-right': -1 / zoom - handleSize / (2 * zoom),
      'margin-bottom': -1 / zoom - handleSize / (2 * zoom),
      'border-radius': 20 / zoom
    };
    var pos = {};
    var rotatorPos = {};
    var dims = this.resizerData.dims;

    switch (handleName) {
      case 'T':
        // pos = {
        //   left: handleSize + 2,
        //   top: 0,
        //   width: dims.width - handleSize - 2,
        // };
        pos = {
          left: dims.width / 2,
          top: 0
        };
        rotatorPos = {
          left: dims.width / 2 - rotationHandleSize / (2 * zoom),
          top: -rotationHandleSize / zoom
        };
        break;

      case 'L':
        // pos = {
        //   left: 0,
        //   top: handleSize + 2,
        //   height: dims.height - handleSize - 2,
        // };
        pos = {
          left: 0,
          top: dims.height / 2
        };
        rotatorPos = {
          left: -rotationHandleSize / zoom,
          top: dims.height / 2 - rotationHandleSize / (2 * zoom)
        };
        break;

      case 'R':
        // pos = {
        //   left: dims.width,
        //   top: handleSize + 2,
        //   height: dims.height - handleSize - 2,
        // };
        pos = {
          left: dims.width,
          top: dims.height / 2
        };
        rotatorPos = {
          left: dims.width,
          top: dims.height / 2 - rotationHandleSize / (2 * zoom)
        };
        break;

      case 'B':
        // pos = {
        //   left: handleSize + 2,
        //   top: dims.height,
        //   width: dims.width - handleSize - 2,
        // };
        pos = {
          left: dims.width / 2,
          top: dims.height
        };
        rotatorPos = {
          left: dims.width / 2 - rotationHandleSize / (2 * zoom),
          top: dims.height
        };
        break;

      case 'TR':
        rotatorPos = {
          left: dims.width,
          top: -rotationHandleSize / zoom
        };
        pos = {
          left: dims.width,
          top: 0
        };
        break;

      case 'BL':
        rotatorPos = {
          left: -rotationHandleSize / zoom,
          top: dims.height
        };
        pos = {
          left: 0,
          top: dims.height
        };
        break;

      case 'BR':
        rotatorPos = {
          left: dims.width,
          top: dims.height
        };
        pos = {
          left: dims.width,
          top: dims.height
        };
        break;

      default:
        rotatorPos = {
          left: -rotationHandleSize / zoom,
          top: -rotationHandleSize / zoom
        };
        pos = {
          left: 0,
          top: 0
        };
        break;
    }

    forEach(propsWithoutPx, function (val, key) {
      handleInstance.handleLayer.style[key] = val;
    });
    forEach(_extends({}, fixedLayoutProps, pos), function (val, key) {
      handleInstance.handleLayer.style[key] = val.toString() + 'px';
    });

    if (handleName !== 'ROTATE') {
      var rotatorPropsWithoutPx = {
        position: 'absolute',
        display: '',
        'pointer-events': 'auto'
      };
      fixedLayoutProps = {
        height: rotationHandleSize / zoom,
        width: rotationHandleSize / zoom
      };
      pos = rotatorPos;
      forEach(rotatorPropsWithoutPx, function (val, key) {
        handleInstance.handleRotator.style[key] = val;
      });
      forEach(_extends({}, fixedLayoutProps, pos), function (val, key) {
        handleInstance.handleRotator.style[key] = val.toString() + 'px';
      });
    }
  };

  _proto.addEventListeners = function addEventListeners(handleLayer, handleName, rotationType) {
    var _this2 = this;

    var dragData;

    if (rotationType) {
      this.resizerData.dims = _extends({}, this.resizerData.dims, {
        rotation: this.resizerData.dims.rotation + getInitialRotation(rotationType)
      });
    }

    this.canvas.executeFunction('handleHtmlDrag', handleLayer);
    handleLayer.addEventListener('htmlDragStart', function (e) {
      if (rotationType && !_this2.resizerData.handles.includes('ROTATE') || _this2.canvas.moveWithGrabHandle) {
        return;
      }

      _this2.canvas.blockMouseEvents();

      var dragVal = _this2.canvas.executeFunction('HtmlDragToWorld.dragStart', e, _this2.resizerData.dims);

      _this2.handleDragStarted = true;

      if (rotationType) {
        _this2.canvas.setMouseCursor("url(\"data:image/svg+xml," + escape(getRotationResizerIcon(getInitialRotation(rotationType) + _this2.resizerData.dims.rotation)) + "\") 10 10, auto");
      }

      dragData = dragVal;

      _this2.canvas.dispatchEvent(_this2.namespace + ".handleDragStart", new ResizerRendererDragEvent(_this2.namespace + ".handleDragStart", handleName + (rotationType ? rotationType : ''), dragVal.startValues, dragVal.session, dragVal.event, _this2.canvas));
    });
    handleLayer.addEventListener('htmlDrag', function (e) {
      if (rotationType && !_this2.resizerData.handles.includes('ROTATE') || _this2.canvas.moveWithGrabHandle) {
        return;
      }

      if (e.pageX && e.pageY) {
        var dragVal = _this2.canvas.executeFunction('HtmlDragToWorld.drag', e);

        if (dragVal.session.current.deltaX !== 0 || dragVal.session.current.deltaY !== 0) {
          dragData = dragVal;

          if (rotationType) {
            _this2.canvas.setMouseCursor("url(\"data:image/svg+xml," + escape(getRotationResizerIcon(getInitialRotation(rotationType) + _this2.resizerData.dims.rotation)) + "\") 10 10, auto");
          }

          _this2.canvas.dispatchEvent(_this2.namespace + ".handleDrag", new ResizerRendererDragEvent(_this2.namespace + ".handleDrag", handleName + (rotationType ? rotationType : ''), dragVal.startValues, dragVal.session, dragVal.event, _this2.canvas));
        }
      }
    });
    handleLayer.addEventListener('htmlDragEnd', function (e) {
      e.preventDefault();

      _this2.canvas.setMouseCursor('default');

      _this2.canvas.unblockMouseEvents();

      if (rotationType && !_this2.resizerData.handles.includes('ROTATE') || _this2.canvas.moveWithGrabHandle) {
        return;
      }

      _this2.handleDragStarted = false;

      _this2.canvas.dispatchEvent(_this2.namespace + ".handleDragEnd", new ResizerRendererDragEvent(_this2.namespace + ".handleDragEnd", handleName + (rotationType ? rotationType : ''), dragData.startValues, dragData.session, dragData.event, _this2.canvas));
    });
  };

  _proto.renderCursor = function renderCursor(handleInstance, handleName) {
    var _this3 = this;

    handleInstance.handleLayer.addEventListener('mousemove', function (event) {
      if (!_this3.handleDragStarted && !_this3.canvas.mouseEventsBlocked) {
        _this3.canvas.setMouseCursor("url(\"data:image/svg+xml," + escape(getHorizontalResizerIcon(getInitialRotation(handleName) + _this3.resizerData.dims.rotation)) + "\") 10 10, auto");
      }
    });
    handleInstance.handleLayer.addEventListener('mouseenter', function (event) {
      if (!_this3.handleDragStarted && !_this3.canvas.mouseEventsBlocked) {
        _this3.canvas.setMouseCursor("url(\"data:image/svg+xml," + escape(getHorizontalResizerIcon(getInitialRotation(handleName) + _this3.resizerData.dims.rotation)) + "\") 10 10, auto");
      }
    });
    handleInstance.handleLayer.addEventListener('mouseleave', function () {
      if (!_this3.handleDragStarted && !_this3.canvas.mouseEventsBlocked && _this3.canvas.mouseCursorType && _this3.canvas.mouseCursorType.includes('url')) {
        _this3.canvas.setMouseCursor('default');
      }
    });
    handleInstance.handleLayer.addEventListener('contextmenu', function (e) {
      e.preventDefault();
    });
    handleInstance.handleRotator.addEventListener('contextmenu', function (e) {
      e.preventDefault();
    });
    handleInstance.handleRotator.addEventListener('mouseenter', function (event) {
      if (_this3.resizerData.handles.includes('ROTATE') && !_this3.handleDragStarted && !_this3.canvas.mouseEventsBlocked) {
        _this3.canvas.setMouseCursor("url(\"data:image/svg+xml," + escape(getRotationResizerIcon(getInitialRotation(handleName) + _this3.resizerData.dims.rotation)) + "\") 10 10, auto");
      }
    });
    handleInstance.handleRotator.addEventListener('mouseleave', function () {
      if (!_this3.handleDragStarted && _this3.canvas.mouseCursorType && _this3.canvas.mouseCursorType.includes('url') && !_this3.canvas.mouseEventsBlocked) {
        _this3.canvas.setMouseCursor('default');
      }
    });
  };

  _proto.renderHandles = function renderHandles() {
    var _this4 = this;

    var handles = this.resizerData.handles;
    return handles.map(function (handleName, i) {
      var handle = _this4.resizerHandleLayersRef.get(handleName);

      if (!handle) {
        var handleLayer = document.createElement('div');
        var handleRotator = document.createElement('div');

        _this4.wrapperLayer.appendChild(handleLayer);

        _this4.wrapperLayer.appendChild(handleRotator);

        _this4.resizerHandleLayersRef.set(handleName, {
          handleLayer: handleLayer,
          handleRotator: handleRotator
        });

        handle = {
          handleLayer: handleLayer,
          handleRotator: handleRotator
        };

        _this4.addEventListeners(handle.handleLayer, handleName);

        _this4.addEventListeners(handle.handleRotator, 'ROTATE', handleName);

        _this4.renderCursor(handle, handleName);
      }

      _this4.setHandleStyle(handle, handleName);
    });
  };

  _proto.isVisible = function isVisible() {
    return this.show && this.resizerData.dims.x && this.resizerData.dims.y && this.resizerData.dims.width && this.resizerData.dims.height;
  };

  _proto.renderResizer = function renderResizer() {
    if (this.isVisible()) {
      var zoom = this.canvas.getZoom();
      this.wrapperLayer.style.border = 1 / zoom + "px solid #1FB2CC";
      this.wrapperLayer.style.top = this.resizerData.dims.y + 'px';
      this.wrapperLayer.style.left = this.resizerData.dims.x + 'px';
      this.wrapperLayer.style.height = this.resizerData.dims.height + 'px';
      this.wrapperLayer.style.width = this.resizerData.dims.width + 'px';

      if (this.resizerData.dims.rotation) {
        this.wrapperLayer.style.transform = "rotate(" + this.resizerData.dims.rotation + "deg";
      } else {
        this.wrapperLayer.style.transform = "";
      }

      this.wrapperLayer.style.display = '';
      this.renderHandles();
    } else {
      this.wrapperLayer.style.display = 'none';
    }
  };

  _proto.toggleResizer = function toggleResizer(show) {
    this.show = show;
    this.renderResizer();
  };

  _proto.showHandle = function showHandle(context, name) {
    if (!this.resizerData.handles.includes(name.toUpperCase())) {
      this.resizerData.handles.push(name.toUpperCase());
      this.renderHandles();
    }
  };

  _proto.hideHandle = function hideHandle(context, name) {
    if (this.resizerData.handles.includes(name.toUpperCase())) {
      this.resizerData.handles.splice(this.resizerData.handles.indexOf(name.toUpperCase()), 1);
      var handle = this.resizerHandleLayersRef.get(name);

      if (handle) {
        var handleLayer = handle.handleLayer,
            handleRotator = handle.handleRotator;
        handleLayer.style.display = 'none';
        handleRotator.style.display = 'none';
      }
    }
  };

  _proto.isValidKey = function isValidKey(key) {
    return key === 'x' || key === 'y' || key === 'height' || key === 'width' || key === 'rotation';
  };

  _proto.setResizerOrientation = function setResizerOrientation(context, key, value) {
    if (typeof key == 'object') {
      for (var prop in key) {
        if (this.isValidKey(prop)) {
          // @ts-ignore
          this.resizerData.dims[prop] = key[prop];
        } else {
          throw new Error("Resizer Orientation Error: Invalid key '" + prop + "'");
        }
      }
    } else {
      if (this.isValidKey(key)) {
        this.resizerData.dims[key] = value;
      } else {
        throw new Error("Resizer Orientation Error: Invalid key '" + key + "'");
      }
    }

    this.renderResizer();
  };

  _proto.handleLayerListeners = function handleLayerListeners(handle) {
    var _this5 = this;

    this.passedEvent.map(function (event) {
      handle.addEventListener(event, function (e1) {
        _this5.passEvent(e1);
      });
    });
  };

  _proto.hideAllHandles = function hideAllHandles(context) {
    var _this6 = this;

    this.resizerData.handles.forEach(function (handleName) {
      var handle = _this6.resizerHandleLayersRef.get(handleName);

      if (handle) {
        var handleLayer = handle.handleLayer,
            handleRotator = handle.handleRotator;
        handleLayer.style.display = 'none';
        handleRotator.style.display = 'none';
      }
    });
    this.resizerData.handles = [];
  };

  _proto.activate = function activate() {
    var _this7 = this;

    this.canvas.addFunction(this.namespace + ".show", this.toggleResizer.bind(this, true));
    this.canvas.addFunction(this.namespace + ".hide", this.toggleResizer.bind(this, false));
    this.canvas.addFunction(this.namespace + ".showHandle", this.showHandle.bind(this));
    this.canvas.addFunction(this.namespace + ".hideHandle", this.hideHandle.bind(this));
    this.canvas.addFunction(this.namespace + ".setOrientation", this.setResizerOrientation.bind(this));
    this.canvas.addFunction(this.namespace + ".hideAllHandles", this.hideAllHandles.bind(this));
    this.canvas.addEventListener('resetResizer', function (e) {
      _this7.canvas.executeFunction('HtmlDragToWorld.dragEnd', e.originalEvent);

      _this7.canvas.executeFunction('HtmlDragToWorld.dragStart', e.originalEvent, _this7.resizerData.dims);
    });
    this.wrapperLayer = document.createElement('div');
    this.wrapperLayer.style.pointerEvents = 'none';
    this.wrapperLayer.style.position = 'absolute';
    this.wrapperLayer.style.zIndex = 200;
    this.renderDragLayer();
    this.dispose = this.canvas.addDomToWorld(this.wrapperLayer, true, 101);
    this.renderResizer();
    ['zoom', 'scroll'].map(function (event) {
      _this7.canvas.on(event, function (e) {
        _this7.renderResizer();
      });
    });
  };

  _proto.deactivate = function deactivate() {
    this.canvas.removeFunction(this.namespace + ".show");
    this.canvas.removeFunction(this.namespace + ".hide");
    this.canvas.removeFunction(this.namespace + ".showHandle");
    this.canvas.removeFunction(this.namespace + ".hideHandle");
    this.canvas.removeFunction(this.namespace + ".setOrientation");
    this.canvas.removeFunction(this.namespace + ".hideAllHandles");
    this.dispose();
  };

  return ResizerRendererPlugin;
}();

var UndoRedoPlugin = /*#__PURE__*/function () {
  function UndoRedoPlugin() {
    this.name = 'UndoRedoPlugin';
    this.store = [];
  }

  var _proto = UndoRedoPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas; // //@ts-ignore
    // window['undoRedoStore'] = this.store;
  };

  _proto.activate = function activate() {
    var _this = this;

    this.canvas.addMiddleware('Layer.setStyle', function (next, data) {
      next(data);

      _this.store.push({
        type: 'Layer.setStyle',
        payload: data
      });
    });
  };

  _proto.deactivate = function deactivate() {};

  return UndoRedoPlugin;
}();

var LayerResizerEvent = /*#__PURE__*/function (_Event) {
  _inheritsLoose(LayerResizerEvent, _Event);

  function LayerResizerEvent(name, target, payload, originalEvent, currentTarget, meta, snapPoints) {
    var _this;

    _this = _Event.call(this, name, target, currentTarget) || this;
    _this.payload = payload;
    _this.meta = meta;
    _this.originalEvent = originalEvent;
    _this.snapPoints = snapPoints;
    return _this;
  }

  return LayerResizerEvent;
}(Event);

var LayerResizerPlugin = /*#__PURE__*/function () {
  function LayerResizerPlugin() {
    var _this = this;

    this.name = 'LayerResizerPlugin';
    this.namespace = 'LayerResizer';
    this.forbiddenLayers = [];
    this.draggingHandles = false;
    this.selectedLayers = [];
    this.selectedLayerDims = new Map();
    this.boundQueueUpdates = new Map();
    this.rerenderHandles = true;
    this.isAltPressed = false;
    this.isShiftPressed = false;
    this.layoutElementArray = [];
    this.shiftDirection = '';
    this.startX = 0;
    this.startY = 0;
    this.startAbsoluteX = 0;
    this.startAbsoluteY = 0;
    this.totalDx = 0;
    this.totalDy = 0;

    this.getHandlesForFill = function (layer) {
      var handlesForFill = [];
      var isFillWidth = layer.isFillWidth();
      var isFillHeight = layer.isFillHeight();
      var flexSiblings = [];

      if (layer.type !== 'root') {
        flexSiblings = layer.getSiblingsWithFlex();
      }

      if (flexSiblings.length === 0) {
        handlesForFill = _this.getHandlesForFlexLayer(isFillHeight, isFillWidth);
      } else if (layer.parent) {
        var layerParent = layer.parent;
        var parentFlexDirection = layerParent.layout.get('flexDirection');
        handlesForFill = _this.getHandlesForFlexLayerWithSiblings(layer, parentFlexDirection, isFillHeight, isFillWidth);
      }

      return handlesForFill;
    };

    this.getHandlesForAutoOrAbsoluteLayer = function (isAutoHeight, isAutoWidth) {
      if (isAutoHeight && isAutoWidth) {
        return ['ROTATE'];
      } else if (isAutoHeight) {
        return ['ROTATE', 'L', 'R'];
      } else if (isAutoWidth) {
        return ['ROTATE', 'T', 'B'];
      } else {
        return ['ROTATE', 'T', 'B', 'R', 'L', 'BL', 'BR', 'TR', 'TL'];
      }
    };

    this.getHandlesForFlexLayer = function (isFillHeight, isFillWidth) {
      if (isFillHeight && isFillWidth) {
        return [];
      } else if (isFillHeight) {
        return ['L', 'R'];
      } else if (isFillWidth) {
        return ['T', 'B'];
      } else {
        return ['T', 'B', 'R', 'L', 'BL', 'BR', 'TR', 'TL', 'ROTATE'];
      }
    };

    this.getHandlesForFlexLayerWithSiblings = function (layer, parentFlexDirection, isFillHeight, isFillWidth) {
      if (parentFlexDirection === 'row') {
        if (isFillHeight) {
          // if fill Width and fill Height or only fill Height
          return _this.getResizerHandlesLayout(layer, parentFlexDirection);
        } else if (isFillWidth) {
          var resizer = _this.getResizerHandlesLayout(layer, parentFlexDirection);

          return resizer.concat(['T', 'B']);
        } else {
          return ['T', 'B', 'R', 'L', 'BL', 'BR', 'TR', 'TL', 'ROTATE'];
        }
      } else {
        // column
        if (isFillWidth) {
          // if fill Width and fill Height or only fill Height
          return _this.getResizerHandlesLayout(layer, parentFlexDirection);
        } else if (isFillHeight) {
          var _resizer = _this.getResizerHandlesLayout(layer, parentFlexDirection);

          return _resizer.concat(['L', 'R']);
        } else {
          return ['T', 'B', 'R', 'L', 'BL', 'BR', 'TR', 'TL', 'ROTATE'];
        }
      }
    };

    this.getResizerHandlesLayout = function (layer, parentFlexDirection) {
      var parentLayer = layer.parent;
      var handles = [];
      var childrenLength = parentLayer.children.length;
      parentLayer.children.forEach(function (childLayer, index) {
        if (childLayer === layer) {
          // first
          if (index === 0) {
            if (parentFlexDirection === 'row') {
              handles.push('R');
            } else {
              handles.push('B');
            }
          } else if (index === childrenLength - 1) {
            // last
            if (parentFlexDirection === 'row') {
              handles.push('L');
            } else {
              handles.push('T');
            }
          } else {
            // middle
            if (parentFlexDirection === 'row') {
              handles.push('R');
              handles.push('L');
            } else {
              handles.push('B');
              handles.push('T');
            }
          }
        }
      });
      return handles;
    }; // getResizerHandlesForLayers = (layers: any) => {
    //   // add all handles except ROTATE handle when icon is selected
    //   let handles: any = ['T', 'B', 'R', 'L', 'BL', 'BR', 'TR', 'TL', 'ROTATE'];
    //   if (layers.length === 0) {
    //     return [];
    //   }
    //   layers.forEach((layer: Layer) => {
    //     if (layer.type === 'icon' || layer.type === 'switch') {
    //       handles = intersection(handles, ['ROTATE']);
    //     }
    //     const isLayerAbsolute = !isNil(layer.layout.get('position'));
    //     const isAutoHeight = layer.isAutoHeight();
    //     const isAutoWidth = layer.isAutoWidth();
    //     let handlesForAutoOrAbs = this.getHandlesForAutoOrAbsoluteLayer(
    //       isAutoHeight,
    //       isAutoWidth
    //     );
    //     if (isLayerAbsolute) {
    //       handles = intersection(handles, handlesForAutoOrAbs);
    //     } else {
    //       const handlesForFill = this.getHandlesForFill(layer);
    //       let handlesHere = intersection(handlesForAutoOrAbs, handlesForFill);
    //       handles = intersection(handles, handlesHere);
    //     }
    //   });
    //   return handles;
    // };


    this.getHandles = function (layers) {
      return _this.canvas.executeMiddleware('LayerResizer.getHandles', layers, function (layers) {
        var handles = ['T', 'B', 'R', 'L', 'BL', 'BR', 'TR', 'TL', 'ROTATE'];

        if (layers.length === 0 || layers.length === 1 && layers[0].type === 'canvas') {
          return [];
        }

        layers.forEach(function (layer) {
          var isLayerAbsolute = !isNil(layer.layout.get('position'));
          var isAutoHeight = layer.isAutoHeight();
          var isAutoWidth = layer.isAutoWidth();

          if (layer.type === 'icon' || layer.type === 'switch' || layer.type === 'activityIndicator' || isAutoHeight && isAutoWidth) {
            handles = intersection(handles, ['ROTATE']);
          }

          var handlesForAutoOrAbs = _this.getHandlesForAutoOrAbsoluteLayer(isAutoHeight, isAutoWidth);

          if (isLayerAbsolute) {
            handles = intersection(handles, handlesForAutoOrAbs);
          } else {
            var handlesForFill = _this.getHandlesForFill(layer);

            var handlesHere = intersection(handlesForAutoOrAbs, handlesForFill);
            handles = intersection(handles, handlesHere);
          }
        });
        return handles;
      });
    };

    this.layersQueuedForUpdate = [];

    this.onUpdate = function () {
      _this.rerender();
    };

    this.queueUpdate = function (layer) {
      _this.layersQueuedForUpdate.push(layer); // render when all the layers have finised emiiting layout updates


      if (_this.layersQueuedForUpdate.length === _this.selectedLayers.length) {
        _this.rerender();

        _this.layersQueuedForUpdate = [];
      }
    };
  }

  var _proto = LayerResizerPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
    this.dispose = null;
    this.selectedLayers = [];
  };

  _proto.hideLayerResizer = function hideLayerResizer(context) {
    if (!this.forbiddenLayers.includes(context.layer)) {
      this.forbiddenLayers.push(context.layer);
      this.setSelectedLayers();
      this.rerender();
    }
  };

  _proto.showLayerResizer = function showLayerResizer(context) {
    if (this.forbiddenLayers.includes(context.layer)) {
      this.forbiddenLayers.splice(this.forbiddenLayers.indexOf(context.layer), 1);
      this.setSelectedLayers();
      this.rerender();
    }
  };

  _proto.rerender = function rerender() {
    var _this2 = this;

    var dims = this.canvas.getBoundingBox(this.selectedLayers);

    if (this.rerenderHandles) {
      this.canvas.executeFunction('ResizerRenderer.hideAllHandles');
      this.getHandles(this.canvas.selectedLayers).map(function (handle) {
        _this2.canvas.executeFunction('ResizerRenderer.showHandle', handle);
      });
    }

    this.canvas.executeFunction('ResizerRenderer.setOrientation', dims);
  };

  _proto.setSelectedLayers = function setSelectedLayers() {
    var _this3 = this;

    this.layersQueuedForUpdate = [];
    this.boundQueueUpdates.forEach(function (cb, layer) {
      layer.off('yoga', cb);
    });
    this.boundQueueUpdates.clear();
    this.selectedLayers = this.canvas.selectedLayers.filter(function (layer) {
      return !_this3.forbiddenLayers.includes(layer);
    });
    this.selectedLayers.forEach(function (layer) {
      var cb = _this3.queueUpdate.bind(_this3, layer);

      layer.on('yoga', cb);

      _this3.boundQueueUpdates.set(layer, cb);
    });
  };

  _proto.getParentRelativeDims = function getParentRelativeDims(dims, layer) {
    var parentDims = layer.parent ? layer.parent.getBoundingClientRect() : {
      rootX: 0,
      rootY: 0
    };
    return _extends({}, dims, {
      x: dims.x - parentDims.rootX,
      y: dims.y - parentDims.rootY
    });
  };

  _proto.applyDimensions = function applyDimensions(eventType) {
    var _this$boundingBox, _this$boundingBox2;

    var data = this.dragEventData;
    var deltaX = data.session.current.x - data.session.start.x;
    var deltaY = data.session.current.y - data.session.start.y;

    if (!this.isShiftPressed) {
      this.shiftDirection = '';
    }

    if (data.targetHandle.indexOf('C') > -1 && this.isShiftPressed) {
      if (!this.shiftDirection) {
        if (Math.abs(data.session.current.deltaX) > Math.abs(data.session.current.deltaY)) {
          this.shiftDirection = 'horizontal';
        } else {
          this.shiftDirection = 'vertical';
        }
      }

      if (this.shiftDirection === 'horizontal') {
        this.totalDx = deltaX; // this.totalDy = 0;
      } else {
        this.totalDy = deltaY; // this.totalDx = 0;
      } // if (this.shiftDirection === "horizontal") {}

    } else {
      this.totalDy = deltaY;
      this.totalDx = deltaX;
    } // console.log(this.totalDx, this.totalDy, 'drag data here');


    if (!this.selectedLayers.length || this.selectedLayers.length && !this.selectedLayers[0].parent) {
      return;
    }

    var parentAbsoluteRotation = this.selectedLayers.length && this.selectedLayers[0].parent ? this.selectedLayers[0].parent.getAbsoluteRotation() : 0;
    var rotateDelta = ModelUtils.rotatePoint([this.totalDx, this.totalDy], 360 - parentAbsoluteRotation, [0, 0]);
    var snappedData = this.canvas.executeFunction('snapToPoints', this.snapPoints, [this.startX, this.startY], [rotateDelta[0], rotateDelta[1]], _extends({}, this.boundingBox), [this.totalDx, this.totalDy], [this.startAbsoluteX, this.startAbsoluteY], parentAbsoluteRotation, this.boundingBoxWRTWorld);
    this.boundingBox = _extends({}, this.boundingBox, {
      x: ((_this$boundingBox = this.boundingBox) == null ? void 0 : _this$boundingBox.x) + snappedData.delta.x,
      y: ((_this$boundingBox2 = this.boundingBox) == null ? void 0 : _this$boundingBox2.y) + snappedData.delta.y
    });
    var delta = snappedData.delta;
    this.setNewLayout(this.selectedLayers, this.boundingBox, data.session, data.targetHandle, eventType, data, delta, snappedData.meta // { x: rotateDelta[0], y: rotateDelta[1] }
    );
  };

  _proto.normalizeChildrenFlex = function normalizeChildrenFlex() {
    var parent = this.selectedLayers.length ? this.selectedLayers[0].parent : undefined;

    if (parent) {
      var totalChildrenFlex = parent.getTotalFlexOfFlexChildren();
      parent.children.forEach(function (child, index) {
        var layerFlex = child.getFlexValue();

        if (!isNil(layerFlex) && !isNil(totalChildrenFlex)) {
          // this.commandManager.execute(
          //   new RemoveStyleAttribute(this.session, child, 'flexGrow')
          // );
          child.removeLayout('flexGrow');
          var newFlex = layerFlex * (1 / totalChildrenFlex); // this.commandManager.execute(
          //   new SetStyleAttribute(this.session, child, 'flex', newFlex)
          // );

          child.setLayout('flex', newFlex);
        }
      });
    }
  };

  _proto.setLayoutChildren = function setLayoutChildren() {
    var _this4 = this;

    var normalizeForFlex = false;
    normalizeForFlex = this.selectedLayers.some(function (layer) {
      return (layer.isFillHeight() || layer.isFillWidth()) && layer.type !== 'root';
    });

    if (normalizeForFlex) {
      this.normalizeChildrenFlex();
    }

    this.layoutElementArray.length = 0;
    var selectedLayers = this.selectedLayers;

    if (selectedLayers.length === 0) {
      return;
    }

    var parentLayer = this.selectedLayers[0].parent;

    if (parentLayer) {
      parentLayer.children.forEach(function (child, index) {
        var layoutChild = {
          layer: child,
          startFlex: child.layout.get('flex') ? child.layout.get('flex') : 0
        };

        _this4.layoutElementArray.push(layoutChild);
      });
    }
  } // flex drag here
  ;

  _proto.setLayoutChildSize = function setLayoutChildSize(layer, deltaFactor) {
    var parentFlexDirection = layer.getParentLayerFlexDirection();
    var startDims = layer.executeFunction('getData', 'initialDims');
    var width = startDims.width;
    var height = startDims.height;

    if (startDims) {
      width = startDims.width + startDims.width * deltaFactor;
      height = startDims.height + startDims.height * deltaFactor;
    }

    if (parentFlexDirection === 'row') {
      layer.setLayout('width', width); // this.commandManager.execute(
      //   new SetStyleAttribute(this.session, layer, 'width', width)
      // );
    } else {
      layer.setLayout('height', height); // this.commandManager.execute(
      //   new SetStyleAttribute(this.session, layer, 'height', height)
      // );
    }
  };

  _proto.getDeltaFactor = function getDeltaFactor(layer, delta, handle) {
    var parent = layer.parent;

    if (!parent) {
      return 0;
    }

    var flexDirection = layer.getParentLayerFlexDirection();
    var width = parent.getBoundingClientRect().width;
    var height = parent.getBoundingClientRect().height;
    var deltaX = delta.x / width;
    var deltaY = delta.y / height;
    var deltaFactor = 0;

    if (handle.indexOf('C') === -1) {
      if (flexDirection === 'row') {
        if (handle.indexOf('L') > -1) {
          deltaX = -deltaX;
        }

        deltaFactor = deltaX;
      } else {
        if (handle.indexOf('T') > -1) {
          deltaY = -deltaY;
        }

        deltaFactor = deltaY;
      }
    }

    return +deltaFactor.toFixed(2);
  };

  _proto.dragLayout = function dragLayout(layer, delta, handle, eventName) {
    var _this5 = this;

    var deltaX = delta.x;
    var deltaY = delta.y;
    var startDims = layer.executeFunction('getData', 'initialDims');
    var originalDelta = {
      x: deltaX,
      y: deltaY
    };
    var deltaFactor = this.getDeltaFactor(layer, originalDelta, handle);
    var selectedLayerFlex = startDims.flex;

    if (!selectedLayerFlex) {
      this.setLayoutChildSize(layer, deltaFactor);
    } else {
      var childrenLength = this.layoutElementArray.length;
      this.layoutElementArray.forEach(function (child, index) {
        var expectedFlex;

        if (child.layer === layer) {
          expectedFlex = selectedLayerFlex + deltaFactor;
        } else {
          expectedFlex = child.startFlex - deltaFactor / (childrenLength - 1);
        }

        expectedFlex = +expectedFlex;

        if (!isNil(expectedFlex)) {
          child.layer.dispatchEvent(_this5.namespace + "." + eventName, new LayerResizerEvent(_this5.namespace + "." + eventName, child.layer, {
            flex: expectedFlex
          }, null));
        }
      });
    }
  };

  _proto.dragLayoutIsDoable = function dragLayoutIsDoable(handle, layer) {
    var position = layer.layout.get('position'); // TODO: implement this condition after symbols are done
    // workspace.persist.domain.isSymbolRootLayer(this.selectedLayers[0]

    return (handle.indexOf('B') > -1 || handle.indexOf('T') > -1) && position !== 'absolute' && layer.isFillHeight() || (handle.indexOf('L') > -1 || handle.indexOf('R') > -1) && position !== 'absolute' && layer.isFillWidth();
  };

  _proto.applyDimensionsForHandle = function applyDimensionsForHandle(eventType) {
    var data = this.dragEventData;
    this.totalDx = data.session.current.x - data.session.start.x;
    this.totalDy = data.session.current.y - data.session.start.y;

    if (!this.selectedLayers.length || this.selectedLayers.length && !this.selectedLayers[0].parent) {
      return;
    }

    var parentAbsoluteRotation = this.selectedLayers.length && this.selectedLayers[0].parent ? this.selectedLayers[0].parent.getAbsoluteRotation() : 0;
    var rotateDelta = ModelUtils.rotatePoint([this.totalDx, this.totalDy], 360 - parentAbsoluteRotation, [0, 0]);

    if (this.dragLayoutIsDoable(data.targetHandle, this.selectedLayers[0])) {
      this.dragLayout(this.selectedLayers[0], {
        x: rotateDelta[0],
        y: rotateDelta[1]
      }, data.targetHandle, eventType + 'Layout');
      return;
    }

    var snappedData = this.canvas.executeFunction('snapToPoints', this.snapPoints, [this.startX, this.startY], [rotateDelta[0], rotateDelta[1]], _extends({}, this.boundingBox), [this.totalDx, this.totalDy], [this.startAbsoluteX, this.startAbsoluteY], parentAbsoluteRotation, this.boundingBoxWRTWorld, data.targetHandle);
    var delta = snappedData.delta;
    var boundingBox = this.boundingBox;

    if (this.selectedLayers.length === 1) {
      var rotateDelta1 = ModelUtils.rotatePoint([snappedData.delta.x, snappedData.delta.y], 360 - this.selectedLayers[0].getBoundingClientRect().rotation, [0, 0]);
      delta = {
        x: rotateDelta1[0],
        y: rotateDelta1[1]
      };
    } else {
      boundingBox = this.boundingBoxWRTWorld;
      boundingBox = _extends({}, this.boundingBoxWRTWorld, {
        x: this.boundingBoxWRTWorld.x,
        y: this.boundingBoxWRTWorld.y
      });
    }

    this.setNewLayout(this.selectedLayers, boundingBox, data.session, data.targetHandle, eventType, data, delta, snappedData.meta);
  };

  _proto.activate = function activate() {
    var _this6 = this;

    this.setSelectedLayers();
    this.startX = 0;
    this.startY = 0;
    this.startAbsoluteX = 0;
    this.startAbsoluteY = 0;
    this.totalDx = 0;
    this.totalDy = 0;
    this.canvas.on('selectedLayers', function (event) {
      _this6.setSelectedLayers();

      if (isEmpty(_this6.canvas.selectedLayers)) {
        _this6.canvas.executeFunction('ResizerRenderer.hide');
      } else {
        _this6.canvas.executeFunction('ResizerRenderer.show');

        _this6.rerender();
      }
    });
    this.canvas.addFunction(this.namespace + ".stopHandleRerender", function () {
      _this6.rerenderHandles = false;
    });
    this.canvas.addFunction(this.namespace + ".startHandleRerender", function () {
      _this6.rerenderHandles = true;

      _this6.rerender();
    });
    this.canvas.addEventListener('ResizerRenderer.dragStart', function (data) {
      _this6.canvas.executeMiddleware('LayerResizer.dragStart', {
        data: data,
        selectedLayers: _this6.selectedLayers
      }, function (event) {
        var data = event.data;
        _this6.boundingBox = _this6.canvas.getContainerBoundingBoxWRTParent(_this6.selectedLayers);
        _this6.boundingBoxWRTWorld = _this6.canvas.getContainerBoundingBox(_this6.selectedLayers);
        forEach(_this6.selectedLayers, function (selectedLayer) {
          selectedLayer.setDragging(true);
        });
        var parentLayer = _this6.selectedLayers.length ? _this6.selectedLayers[0].parent : undefined;

        if (!parentLayer) {
          return;
        }

        _this6.startValues = _this6.getParentRelativeDims(data.startValues, _this6.selectedLayers[0]);
        _this6.startX = _this6.boundingBox.x;
        _this6.startY = _this6.boundingBox.y;
        _this6.startAbsoluteX = _this6.boundingBoxWRTWorld.x - _this6.canvas.getContainerBoundingBox([parentLayer]).x;
        _this6.startAbsoluteY = _this6.boundingBoxWRTWorld.y - _this6.canvas.getContainerBoundingBox([parentLayer]).y;
        _this6.snapPoints = _this6.canvas.executeFunction('getSnapPoints', _this6.selectedLayers, parentLayer);

        _this6.selectedLayers.forEach(function (selectedLayer) {
          var initialDims = selectedLayer.getBoundingClientRect(); // initialDims.x = initialDims.x - parentLayer.getBorderLeft();
          // initialDims.y = initialDims.y - parentLayer.getBorderTop();

          initialDims.rootX = initialDims.rootX - parentLayer.getBorderLeft();
          initialDims.rootY = initialDims.rootY - parentLayer.getBorderTop();
          selectedLayer.executeFunction('setData', 'initialDims', _extends({}, initialDims, {
            absoluteRotation: selectedLayer.getAbsoluteRotation(),
            flex: selectedLayer.layout.get('flex')
          }));
          selectedLayer.dispatchEvent(_this6.namespace + ".dragStart", new LayerResizerEvent(_this6.namespace + ".dragStart", selectedLayer, initialDims, data, undefined, undefined, _this6.snapPoints));

          _this6.selectedLayerDims.set(selectedLayer, initialDims);
        }); // this.snapPoints.gridSnap = this.config.gridSnap;

      });
    });
    this.canvas.addEventListener('ResizerRenderer.drag', function (data) {
      _this6.canvas.executeMiddleware('LayerResizer.drag', {
        data: data,
        selectedLayers: _this6.selectedLayers
      }, function (event) {
        _this6.dragEventData = event.data;

        _this6.applyDimensions('drag');
      });
    });
    this.canvas.addEventListener('ResizerRenderer.dragEnd', function (data) {
      _this6.canvas.executeMiddleware('LayerResizer.dragEnd', {
        data: data,
        selectedLayers: _this6.selectedLayers
      }, function (event) {
        forEach(_this6.selectedLayers, function (selectedLayer) {
          selectedLayer.setDragging(false);
        });
        _this6.dragEventData = event.data;

        _this6.applyDimensions('dragEnd');

        _this6.startValues = undefined;
        _this6.selectedLayerDims = new Map();
        _this6.shiftDirection = '';
        _this6.dragEventData = undefined;
        _this6.totalDx = 0;
        _this6.totalDy = 0;
      });
    });
    this.canvas.addEventListener('ResizerRenderer.handleDragStart', function (data) {
      return _this6.canvas.executeMiddleware('LayerResizer.handleDragStart', {
        data: data,
        selectedLayer: _this6.selectedLayers[0]
      }, function (event) {
        var data = event.data;
        _this6.boundingBox = _this6.canvas.getContainerBoundingBoxWRTParent(_this6.selectedLayers);
        _this6.boundingBoxWRTWorld = _this6.canvas.getContainerBoundingBox(_this6.selectedLayers);
        forEach(_this6.selectedLayers, function (selectedLayer) {
          selectedLayer.setDragging(true);
        });
        _this6.startValues = _this6.getParentRelativeDims(data.startValues, _this6.selectedLayers[0]);
        var parentLayer = _this6.selectedLayers.length ? _this6.selectedLayers[0].parent : undefined;

        if (!parentLayer) {
          return;
        }

        _this6.snapPoints = _this6.canvas.executeFunction('getSnapPoints', _this6.selectedLayers, parentLayer, data.targetHandle); // console.log(this.snapPoints, 'snap points here');

        _this6.setLayoutChildren();

        _this6.selectedLayers.forEach(function (selectedLayer) {
          var initialDims = selectedLayer.getBoundingClientRect();
          initialDims.rootX = initialDims.rootX - parentLayer.getBorderLeft();
          initialDims.rootY = initialDims.rootY - parentLayer.getBorderTop();
          selectedLayer.executeFunction('setData', 'initialDims', _extends({}, initialDims, {
            absoluteRotation: selectedLayer.getAbsoluteRotation(),
            flex: selectedLayer.layout.get('flex')
          }));
          selectedLayer.dispatchEvent(_this6.namespace + ".handleDragStart", new LayerResizerEvent(_this6.namespace + ".handleDragStart", selectedLayer, initialDims, data, undefined, undefined, _this6.snapPoints));

          _this6.selectedLayerDims.set(selectedLayer, initialDims);
        });

        _this6.startX = _this6.boundingBox.x;
        _this6.startY = _this6.boundingBox.y;
        _this6.startAbsoluteX = _this6.boundingBoxWRTWorld.x - _this6.canvas.getContainerBoundingBox([parentLayer]).x;
        _this6.startAbsoluteY = _this6.boundingBoxWRTWorld.y - _this6.canvas.getContainerBoundingBox([parentLayer]).y;
      });
    });
    this.canvas.addEventListener('ResizerRenderer.handleDrag', function (data) {
      return _this6.canvas.executeMiddleware('LayerResizer.handleDrag', {
        data: data,
        selectedLayer: _this6.selectedLayers[0]
      }, function (event) {
        _this6.dragEventData = event.data;

        _this6.applyDimensionsForHandle('handleDrag');
      });
    });
    this.canvas.addEventListener('ResizerRenderer.handleDragEnd', function (data) {
      return _this6.canvas.executeMiddleware('LayerResizer.handleDragEnd', {
        data: data,
        selectedLayer: _this6.selectedLayers[0]
      }, function (event) {
        forEach(_this6.selectedLayers, function (selectedLayer) {
          selectedLayer.setDragging(false);
        });
        _this6.dragEventData = event.data;

        _this6.applyDimensionsForHandle('handleDragEnd');

        _this6.startValues = undefined;
        _this6.dragEventData = undefined;
        _this6.totalDx = 0;
        _this6.totalDy = 0;
        _this6.selectedLayerDims = new Map();
      });
    });
    this.canvas.addFunction('LayerResizer.hideLayer', this.hideLayerResizer.bind(this));
    this.canvas.addFunction('LayerResizer.showLayer', this.showLayerResizer.bind(this));
    this.canvas.addEventListener('blur', function () {
      if (_this6.isAltPressed) _this6.isAltPressed = false;
      if (_this6.isShiftPressed) _this6.isShiftPressed = false;
    });
    this.canvas.addEventListener('keyUp', function (data) {
      var event = data.originalEvent ? data.originalEvent : data;

      if (event.keyCode === 16) {
        _this6.isShiftPressed = false;
      }

      if (event.keyCode === 18) {
        _this6.isAltPressed = false;
      }

      if (_this6.dragEventData) {
        if (_this6.dragEventData.targetHandle.indexOf('C') === -1) {
          _this6.applyDimensionsForHandle('handleDrag');
        } else {
          _this6.applyDimensions('drag');
        }
      }
    });
    this.canvas.addEventListener('keyDown', function (data) {
      var event = data.originalEvent ? data.originalEvent : data;

      if (event.keyCode === 16) {
        _this6.isShiftPressed = true;
      }

      if (event.keyCode === 18) {
        _this6.isAltPressed = true;
      }

      if (_this6.dragEventData) {
        if (_this6.dragEventData.targetHandle.indexOf('C') === -1) {
          _this6.applyDimensionsForHandle('handleDrag');
        } else {
          _this6.applyDimensions('drag');
        }
      }
    });
    this.canvas.addEventListener('resetResizer', function (e) {
      var event = e.originalEvent; // const newLayer = e.newTarget;

      _this6.startValues = undefined;
      _this6.selectedLayerDims = new Map();
      _this6.boundingBox = _this6.canvas.getContainerBoundingBox(_this6.selectedLayers);
      _this6.startValues = _this6.getParentRelativeDims(event.startValues, _this6.selectedLayers[0]);
      var parentLayer = _this6.selectedLayers.length ? _this6.selectedLayers[0].parent : undefined;
      _this6.startX = _this6.boundingBox.x - (parentLayer ? parentLayer.rootX : 0);
      _this6.startY = _this6.boundingBox.y - (parentLayer ? parentLayer.rootY : 0);

      _this6.selectedLayers.forEach(function (selectedLayer) {
        var initialDims = selectedLayer.getBoundingClientRect();
        selectedLayer.executeFunction('setData', 'initialDims', initialDims);

        _this6.selectedLayerDims.set(selectedLayer, initialDims);
      });

      _this6.snapPoints = _this6.canvas.executeFunction('getSnapPoints', _this6.selectedLayers, parentLayer);
    });
  };

  _proto.setNewLayout = function setNewLayout(layers, boundingBox, session, handle, eventName, originalEvent, delta, meta) {
    var _this7 = this;

    var deltaInput = {
      x: session.current.x - session.start.x,
      y: session.current.y - session.start.y
    };

    if (delta) {
      deltaInput = delta;
    }

    layers.forEach(function (selectedLayer, index) {
      var initialDims = selectedLayer.executeFunction('getData', 'initialDims');

      if (!initialDims) {
        return;
      }

      var initialDimensions = {
        x: initialDims.rootX,
        y: initialDims.rootY,
        height: initialDims.height,
        width: initialDims.width,
        rotation: initialDims.rotation
      };
      var dimensions;

      if (handle.indexOf('ROTATE') !== -1) {
        var rotationDelta = {
          x: session.current.x - session.start.x,
          y: session.current.y - session.start.y
        };

        if (layers.length === 1) {
          boundingBox = _extends({}, boundingBox, {
            x: selectedLayer.getBoundingClientRect().x,
            y: selectedLayer.getBoundingClientRect().y
          });
          var rotateDelta = ModelUtils.rotatePoint([rotationDelta.x, rotationDelta.y], 360 - initialDims.absoluteRotation, [0, 0]);
          rotationDelta = {
            x: rotateDelta[0],
            y: rotateDelta[1]
          };
        }

        var rotation = calculateRotation(_extends({}, boundingBox), session, initialDims.rotation, rotationDelta, handle);

        if (_this7.isShiftPressed) {
          var ROTATION_FACTOR = 15;
          var multiplicationFactor = Math.round(rotation / ROTATION_FACTOR);
          rotation = ROTATION_FACTOR * multiplicationFactor;
        }

        dimensions = _extends({}, initialDimensions, {
          rotation: rotation
        });
      } else {
        var isFlexChildren = false;
        var maintainAspectRatio = false;
        layers.forEach(function (layer) {
          if (layer.isFlexChild()) isFlexChildren = true;
          if (layer.aspectRatio) maintainAspectRatio = true;
        });

        if (layers.length === 1) {
          dimensions = computeOrientation(initialDimensions, deltaInput, handle, _this7.isShiftPressed || maintainAspectRatio, _this7.isAltPressed && !isFlexChildren);
        } else {
          dimensions = computeOrientationMultiple(initialDimensions, deltaInput, handle, boundingBox, ModelUtils.getPointsFromBoundingBox(initialDimensions, initialDims.rotation), _this7.isShiftPressed || maintainAspectRatio, _this7.isAltPressed && !isFlexChildren);
        }
      }

      var parentRootDims = {
        rootX: 0,
        rootY: 0
      };

      if (selectedLayer.parent) {
        parentRootDims = selectedLayer.parent.getBoundingClientRect();
      }

      var newDimension = _extends({}, dimensions); // if (handle.indexOf('C') !== -1 || handle.indexOf('ROTATE') !== -1) {


      newDimension = _extends({}, dimensions, {
        x: dimensions.x - parentRootDims.rootX,
        y: dimensions.y - parentRootDims.rootY
      }); // }

      selectedLayer.dispatchEvent(_this7.namespace + "." + eventName, new LayerResizerEvent(_this7.namespace + "." + eventName, selectedLayer, newDimension, originalEvent, undefined, meta));

      _this7.selectedLayerDims.set(selectedLayer, newDimension);
    });
  };

  _proto.deactivate = function deactivate() {
    this.dispose();
  };

  return LayerResizerPlugin;
}();

var FloatingButton = /*#__PURE__*/function () {
  function FloatingButton() {
    this.name = 'FloatingButton';
  }

  var _proto = FloatingButton.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
  };

  _proto.activate = function activate() {
    this.canvas.addFunction('addFloatingButton', this.addFloatingButton.bind(this));
    this.canvas.addFunction('removeFloatingButton', this.removeFloatingButton.bind(this));
  };

  _proto.removeFloatingButton = function removeFloatingButton() {
    if (this.dom) this.canvas.removeDomFromViewport(this.dom);
  };

  _proto.addFloatingButton = function addFloatingButton(context, caption, callback) {
    var button = document.createElement('button');
    this.dom = button;
    button.innerHTML = caption;
    button.addEventListener('click', callback);
    var styles = "text-size-adjust: 100%;\n    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n    box-sizing: border-box;\n    user-select: none;\n    -webkit-font-smoothing: antialiased;\n    outline: none;\n    font-size: 11px;\n    align-items: center;\n    display: inline-flex;\n    position: relative;\n    border: none;\n    transition: all 0.3s ease 0s;\n    cursor: pointer;\n    border-right: none;\n    border-left: none;\n    padding: 3px 6px;\n    justify-content: center;\n    margin-right: 0px;\n    margin-left: 0px;\n    min-width: 0px;\n    -webkit-app-region: no-drag;\n    border-radius: 2px;\n    background: rgb(37, 41, 49);\n    width: auto;\n    color: rgb(251, 251, 251);\n    height: 30px;\n    padding-left: 6px;\n    padding-right: 6px;\n    margin-top: 30px;\n    margin-left: 30px;\n\n    text-size-adjust: 100%;\n    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n    cursor: pointer;\n    vertical-align: baseline;\n    border-width: 0px;\n    border-style: initial;\n    border-color: initial;\n    border-image: initial;\n    font: inherit;\n    box-sizing: border-box;\n    user-select: none;\n    -webkit-font-smoothing: antialiased;\n    font-family: Roboto, -apple-system, BlinkMacSystemFont, sans-serif;\n    font-weight: 400;\n    align-self: center;\n    text-overflow: ellipsis;\n    letter-spacing: -0.27px;\n    font-size: 14px;\n    color: rgb(241, 242, 244, 0.6);\n\n    ";
    button.setAttribute('style', styles);
    this.canvas.addDomToViewport(button);
  };

  _proto.deactivate = function deactivate() {
    this.canvas.removeFunction('addFloatingButton');
    this.canvas.removeFunction('removeFloatingButton');
  };

  return FloatingButton;
}();

var GradientEditorEvent = /*#__PURE__*/function (_Event) {
  _inheritsLoose(GradientEditorEvent, _Event);

  function GradientEditorEvent(name, target, task, currentTarget) {
    var _this;

    _this = _Event.call(this, name, target, currentTarget) || this;
    _this.task = task;
    return _this;
  }

  return GradientEditorEvent;
}(Event);

var PlusButton = /*#__PURE__*/function () {
  function PlusButton() {
    this.name = 'PlusButton';
    this.passedEvent = ['mouseup', 'mousemove', 'drop'];
  }

  var _proto = PlusButton.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
    this.dispose = null;
  };

  _proto.activate = function activate() {
    this.canvas.addFunction('addPlusButton', this.addPlusButton.bind(this));
    this.canvas.addFunction('showPlusButton', this.showPlusButton.bind(this));
    this.canvas.addFunction('hidePlusButton', this.hidePlusButton.bind(this));
    this.canvas.addFunction('removePlusButton', this.removePlusButton.bind(this));
    this.canvas.on('zoom', this.handleZoom.bind(this));
    this.canvas.addEventListener('artboardLayoutChanges', this.positionPlusButton.bind(this));
  };

  _proto.passEvent = function passEvent(e) {
    e.preventDefault();
    this.canvas.dispatchEventOnHitLayer(e.type, new DesignerMouseEvent(e.type, this.canvas, e, this.canvas), e);
  };

  _proto.handleLayerListeners = function handleLayerListeners(handle) {
    var _this = this;

    this.passedEvent.map(function (event) {
      handle.addEventListener(event, function (e1) {
        _this.passEvent(e1);
      });
    });
  };

  _proto.positionPlusButton = function positionPlusButton() {
    if (!this.dom) return;
    var zoom = 1;
    var artboards = this.canvas.executeFunction('getAllArtboards');
    var left = Number.MIN_VALUE;
    var artLeft = Number.MIN_VALUE;
    var artTop = Number.MIN_VALUE;
    var top = Number.MIN_VALUE;

    if (artboards.size === 0) {
      this.dom.style.display = 'none';
    } // else {
    //   this.dom.style.display = 'inline-block';
    // }


    if (artboards.size === 0) {
      position = {
        left: 300,
        top: 50,
        artTop: 50,
        artLeft: 300
      };
    }

    artboards.forEach(function (artboard) {
      var artboardClientRect = artboard.getBoundingClientRect();
      var artMaxX = artboardClientRect.x + artboardClientRect.width;
      var artMidY = artboardClientRect.y + artboardClientRect.height / 2;

      if (left < artMaxX) {
        left = artMaxX;
        top = artMidY;
        artTop = artboardClientRect.y;
      }
    });
    artLeft = left + 50;
    left = left * zoom + 50;
    top = top * zoom - 40;
    var position = {
      left: left,
      top: top,
      artTop: artTop,
      artLeft: artLeft
    };
    this.dom.style.top = position.top + 'px';
    this.dom.style.left = position.left + 'px';
  };

  _proto.handleZoom = function handleZoom() {
    if (this.dom) {
      var zoom = this.canvas.getZoom();

      if (zoom > 0.5) {
        this.dom.style.transform = 'scale(' + 1 / zoom + ')';
      }
    }
  };

  _proto.removePlusButton = function removePlusButton() {
    if (this.dom) this.canvas.removeDomFromWorld(this.dom);
  };

  _proto.hidePlusButton = function hidePlusButton() {
    if (this.dom) this.dom.style.display = 'none';
  };

  _proto.showPlusButton = function showPlusButton() {
    if (this.dom) {
      this.dom.style.display = '';
    }
  };

  _proto.addPlusButton = function addPlusButton(context, caption, callback) {
    var _this2 = this;

    var button = document.createElement('button');
    this.dom = button;
    button.innerHTML = '<span style="font-size: 36px">+</span>';
    button.addEventListener('click', function (event) {
      if (!_this2.canvas.mouseEventsBlocked && event.sourceCapabilities) {
        callback();
      }
    });
    this.handleLayerListeners(button);
    var styles = "text-size-adjust: 100%;\n    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n    box-sizing: border-box;\n    user-select: none;\n    -webkit-font-smoothing: antialiased;\n    outline: none;\n    font-size: 11px;\n    align-items: center;\n    display: inline-flex;\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100px;\n    height: 80px;\n    border: none;\n    cursor: inherit;\n    border-right: none;\n    border-left: none;\n    padding: 3px 6px;\n    justify-content: center;\n    margin-right: 0px;\n    margin-left: 0px;\n    min-width: 0px;\n    -webkit-app-region: no-drag;\n    border-radius: 2px;\n    background: rgb(37, 41, 49);\n    color: rgb(251, 251, 251);\n    padding-left: 6px;\n    padding-right: 6px;\n    margin-top: 2px;\n    margin-left: 2px;\n\n    text-size-adjust: 100%;\n    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n    vertical-align: baseline;\n    border-width: 0px;\n    border-style: initial;\n    border-color: initial;\n    border-image: initial;\n    font: inherit;\n    box-sizing: border-box;\n    user-select: none;\n    -webkit-font-smoothing: antialiased;\n    font-family: Roboto, -apple-system, BlinkMacSystemFont, sans-serif;\n    font-weight: 400;\n    align-self: center;\n    text-overflow: ellipsis;\n    letter-spacing: -0.27px;\n    font-size: 14px;\n    color: rgb(241, 242, 244, 0.6);\n    transform-origin: 0 0;\n    ";
    button.setAttribute('style', styles);
    button.setAttribute('name', 'add-artboard');
    button.addEventListener('mouseenter', function (event) {
      if (!_this2.canvas.mouseEventsBlocked) {
        _this2.canvas.setMouseCursor('pointer');
      }
    });
    button.addEventListener('mouseleave', function (event) {
      if (!_this2.canvas.mouseEventsBlocked) {
        _this2.canvas.setMouseCursor('default');
      }
    });
    this.dispose = this.canvas.addDomToWorld(button);
    this.positionPlusButton();
  };

  _proto.deactivate = function deactivate() {
    this.canvas.removeFunction('addPlusButton');
    this.canvas.removeFunction('removePlusButton');
    this.dispose();
  };

  return PlusButton;
}();

var HtmlDragToWorldPlugin = /*#__PURE__*/function () {
  function HtmlDragToWorldPlugin() {
    var _this = this;

    this.name = 'HtmlDragToWorldPlugin';
    this.namespace = 'HtmlDragToWorld';
    this.initPos = {
      x: 0,
      y: 0
    };
    this.relPos = {
      x: 0,
      y: 0
    };
    this.lastPos = {
      x: 0,
      y: 0
    };
    this.startValues = {
      x: 0,
      y: 0,
      height: 0,
      width: 0,
      rotation: 0
    };
    this.dragSession = {
      start: {
        x: 0,
        y: 0,
        deltaX: 0,
        deltaY: 0
      },
      current: {
        x: 0,
        y: 0,
        deltaX: 0,
        deltaY: 0
      },
      end: {
        x: 0,
        y: 0,
        deltaX: 0,
        deltaY: 0
      }
    };

    this.setStartValues = function (dims) {
      _this.startValues = dims;
    };

    this.startDragSession = function (x, y) {
      _this.dragSession.start = {
        x: x,
        y: y,
        deltaX: 0,
        deltaY: 0
      };
      _this.dragSession.current = {
        x: x,
        y: y,
        deltaX: 0,
        deltaY: 0
      };
      _this.dragSession.end = {
        x: x,
        y: y,
        deltaX: 0,
        deltaY: 0
      };
    };

    this.endDragSession = function () {
      _this.dragSession.end = {
        x: _this.dragSession.current.x,
        y: _this.dragSession.current.y,
        deltaX: _this.dragSession.current.x - _this.dragSession.start.x,
        deltaY: _this.dragSession.current.y - _this.dragSession.start.y
      };
    };

    this.updateDragSession = function (dx, dy) {
      _this.dragSession.current = {
        x: _this.dragSession.current.x + dx,
        y: _this.dragSession.current.y + dy,
        deltaX: dx,
        deltaY: dy
      };
    };
  }

  var _proto = HtmlDragToWorldPlugin.prototype;

  _proto.init = function init(canvas) {
    this.canvas = canvas;
  };

  _proto.dragStart = function dragStart(context, e, initialDims) {
    var event = new DesignerMouseEvent(this.namespace + ".dragStart", this.canvas, e);
    this.initPos = {
      x: event.worldX,
      y: event.worldY
    };
    this.setStartValues(initialDims);
    this.startDragSession(event.worldX, event.worldY);
    this.lastPos = {
      x: 0,
      y: 0
    };
    return {
      event: event,
      startValues: _extends({}, this.startValues),
      session: _extends({}, this.dragSession)
    };
  };

  _proto.drag = function drag(context, e) {
    e.preventDefault();
    var event = new DesignerMouseEvent(this.namespace + ".drag", this.canvas, e);
    this.relPos = {
      x: event.worldX - this.initPos.x,
      y: event.worldY - this.initPos.y
    };
    var deltaX = this.relPos.x - this.lastPos.x;
    var deltaY = this.relPos.y - this.lastPos.y; // let rotatedDelta = ModelUtils.rotatePoint(
    //   [deltaX, deltaY],
    //   360 - this.startValues.rotation,
    //   [0, 0]
    // );

    this.updateDragSession(deltaX, deltaY);
    this.lastPos = _extends({}, this.relPos);
    return {
      event: event,
      startValues: _extends({}, this.startValues),
      session: _extends({}, this.dragSession)
    };
  };

  _proto.dragEnd = function dragEnd(context, e) {
    e.preventDefault();
    var event = new DesignerMouseEvent(this.namespace + ".dragEnd", this.canvas, e);
    this.setStartValues({
      x: 0,
      y: 0,
      height: 0,
      width: 0,
      rotation: 0
    });
    this.endDragSession();
    this.initPos = {
      x: 0,
      y: 0
    };
    return {
      event: event,
      startValues: _extends({}, this.startValues),
      session: _extends({}, this.dragSession)
    };
  };

  _proto.activate = function activate() {
    this.canvas.addFunction(this.namespace + ".dragStart", this.dragStart.bind(this));
    this.canvas.addFunction(this.namespace + ".drag", this.drag.bind(this));
    this.canvas.addFunction(this.namespace + ".dragEnd", this.dragEnd.bind(this));
  };

  _proto.deactivate = function deactivate() {//
  };

  return HtmlDragToWorldPlugin;
}();

var DesignerKeyboardEvent = /*#__PURE__*/function (_DesignerEvent) {
  _inheritsLoose(DesignerKeyboardEvent, _DesignerEvent);

  function DesignerKeyboardEvent(name, target, originalEvent) {
    var _this;

    _this = _DesignerEvent.call(this, name, target) || this;
    _this.originalEvent = originalEvent;
    return _this;
  }

  return DesignerKeyboardEvent;
}(Event);

export { ActivityIndicatorRendererPlugin, ArtboardEvent, Canvas, ConstructionLinesPlugin, DataStore as DataStorePlugin, DesignerKeyboardEvent, DeviceFrame, Drag as DragPlugin, DrawComponent, EllipseRendererPlugin, Event, FlexDragPlugin, FloatingButton as FloatingButtonPlugin, FontResizerEvent, FontResizerPlugin, Gradient, GradientEditorEvent, GradientEditorPlugin, GridRenderer as GridRendererPlugin, HoverPlugin, HtmlDragToWorldPlugin, Fonts as IconFonts, IconRendererPlugin, ImageRendererPlugin, KeyValueContainer, Layer, LayerDrag as LayerDragPlugin, LayerLabel, LayerMouseCursorPlugin as LayerMouseCursor, LayerResizerEvent, LayerResizerPlugin, LineDrawer as LineDrawerPlugin, MapViewRendererPlugin, MeasurementLinesPlugin, ModelUtils, DesignerMouseEvent as MouseEvent, MouseRectPlugin, NativeHtmlDrag as NativeHtmlDragPlugin, OpacityShortcutPlugin, PathEditorPlugin, PathEvent, PathRendererPlugin, PlusButton as PlusButtonPlugin, PopoverMenuPlugin, ResizerRendererPlugin, RulerLinesPlugin, RulerScalePlugin, ScrollMousePositionPlugin, ScrollViewRendererPlugin, Event as SetScrollEvent, SliderRendererPlugin, SnapLines as SnapLinesPlugin, SnapPointsCalculator as SnapPointsCalculatorPlugin, StageDesignerDeviceData as StageDesignerDeviceDataPlugin, StageDesignerDrawComponent, StageDesignerDropPlugin, StageDesigner as StageDesignerPlugin, StageDesignerPreviewModePlugin, StageDesignerRulerPlugin, StatusBar, IOSSwitchRendererPlugin as SwitchRendererPlugin, TextEditorEvent, TextEditorPlugin, TextInputRendererPlugin, TextRendererPlugin, TooltipPlugin, TouchableOpacityRendererPlugin, UndoRedoPlugin, ViewRendererPlugin, computeDelta, computeOrientation, computeOrientationWithDelta, computeOrientationWithDeltaAR, computeOrientationWithDeltaARMultiple, computeOrientationWithDeltaAlt, computeOrientationWithDeltaAltMultiple, computeOrientationWithDeltaMultiple, computeOrientationWithDeltaShiftAlt, computeOrientationWithDeltaShiftAltMultiple, action as designerAction, getBoundingBoxFromOrientation, getCorrection, getNewLayout, getResizerQuad, resumeLayoutUpdates, startChildrenLayoutUpdates, startRerender, stopAndBatchLayoutUpdates, stopAndForgetLayoutUpdates, stopChildrenLayoutUpdates, stopRerender };
//# sourceMappingURL=designer.esm.js.map
