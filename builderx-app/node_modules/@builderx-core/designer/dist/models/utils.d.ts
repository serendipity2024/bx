import { IDimensionWithRotation, IPosition, Layer } from './../';
import { Gradient } from './Gradient';
export default class ModelUtils {
    static pointsOverlap(point1: number, point2: number): boolean;
    static getDimensionFromPolygon(points: any): {
        x: any;
        y: any;
        width: number;
        height: number;
    };
    static rotatePolygon(poly: any, angle: number, centroid?: any): any;
    static findAngle(A: any, B: any, C: any, range: 180 | 360): number;
    static getAbsoluteRotation(poly: Array<any>): number;
    static middlePoint(point1: any, point2: any): number[];
    static getCentroid(coord: Array<any>): any;
    static distance(point1: any, point2: any): number;
    static rotatePoint(point: any, angle: number, centroid: any): any[];
    static getPointsFromBoundingBox(box: any, rotation?: number): Array<any>;
    static getPointsFromDims(dims: any): any[][];
    static depthComparator(a: string | null, b: string | null): -1 | 0 | 1;
    private static getNextCharacter;
    private static getActiveDigit;
}
export declare function getCorrection(orientation: IDimensionWithRotation, finalOrientation: IDimensionWithRotation, handle: any): {
    x: number;
    y: number;
    height: number;
    width: number;
    rotation: number;
};
export declare function getResizerQuad(rotation: number): string;
export declare function computeOrientation(layout: IDimensionWithRotation, delta: IPosition, handle: string, shift: boolean, alt: boolean): IDimensionWithRotation;
export declare function computeOrientationMultiple(orientation: IDimensionWithRotation, delta: IPosition, handle: any, boundaryBox: any, points: Array<any>, shift?: boolean, alt?: boolean): IDimensionWithRotation;
export declare function computeOrientationWithDelta(layout: IDimensionWithRotation, delta: IPosition, handle: string): IDimensionWithRotation;
export declare function computeOrientationWithDeltaMultiple(orientation: IDimensionWithRotation, delta: IPosition, handle: any, boundaryBox: any, points: Array<any>): IDimensionWithRotation;
export declare function computeOrientationWithDeltaARMultiple(orientation: IDimensionWithRotation, deltaInp: IPosition, handle: any, boundaryBox: any, points: Array<any>): IDimensionWithRotation;
export declare function computeOrientationWithDeltaAltMultiple(orientation: IDimensionWithRotation, delta: IPosition, handle: any, boundaryBox: any, points: Array<any>): IDimensionWithRotation;
export declare function computeOrientationWithDeltaShiftAltMultiple(orientation: IDimensionWithRotation, deltaInp: IPosition, handle: any, boundaryBox: any, points: Array<any>): IDimensionWithRotation;
export declare function computeOrientationWithDeltaAR(orientation: IDimensionWithRotation, delta: IPosition, handle: any): IDimensionWithRotation;
export declare function computeOrientationWithDeltaAlt(orientation: IDimensionWithRotation, delta: IPosition, handle: any): IDimensionWithRotation;
export declare function computeOrientationWithDeltaShiftAlt(orientation: IDimensionWithRotation, delta: IPosition, handle: any): IDimensionWithRotation;
export declare function getBoundingBoxFromOrientation({ x, y, width, height, }: any): any;
export declare function computeDelta(oldOrientation: IDimensionWithRotation, newOrientation: IDimensionWithRotation): IPosition;
export declare function getGradientString(gradient: Gradient, palette?: any): string;
export declare function getHandles(layers: Array<Layer>): string[];
export declare function calculateRotation(startValues: any, session: any, oldRotation?: number, delta?: any, handle?: string): number;
export declare function getNewLayout(startValues: any, session: any, handle: any): any;
export declare function generateRandomString(length: number): string;
